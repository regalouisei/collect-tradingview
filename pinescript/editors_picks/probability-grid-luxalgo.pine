// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=6
indicator('Probability Grid [LuxAlgo]','LuxAlgo - Probability Grid', overlay = true, max_boxes_count = 100, max_labels_count = 500, max_lines_count = 20)
//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
GREEN                   = #089981
RED                     = #F23645
SILVER80                = color.new(color.silver,80)

HIGH                    = +1
LOW                     = -1

TOP_RIGHT               = 'Top Right'
BOTTOM_RIGHT            = 'Bottom Right'
BOTTOM_LEFT             = 'Bottom Left'

TINY                    = 'Tiny'
SMALL                   = 'Small'
NORMAL                  = 'Normal'
LARGE                   = 'Large'
HUGE                    = 'Huge'

BEYOND                  = 'Beyond each cell'
WITHIN                  = 'Within each cell'

DOTTED                  = 'Dotted'
DASHED                  = 'Dashed'
SOLID                   = 'Solid'

EM_SPACE                = ' '
SPACING5                = EM_SPACE+EM_SPACE+EM_SPACE+EM_SPACE+EM_SPACE
PERCENTILE_GROUP        = SPACING5+'PERCENTILE'+SPACING5+'STYLE'
DASHBOARD_GROUP         = 'DASHBOARD'
STYLE_GROUP             = 'STYLE'

lengthInput             = input.int(    20,         'Swing Length')
maxPivotsInput          = input.int(    1000,       'Maximum Reversals',minval = 5)
normalizeDataInput      = input.bool(   true,       'Normalize Data')
probabilityModeInput    = input.string( BEYOND,     'Probability',      options = [BEYOND,WITHIN])

percentile0Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '0')
percentile0DataInput    = input.int(    0,          '',                 group = PERCENTILE_GROUP, inline = '0', minval = 0, maxval = 95)
percentile0StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '0', options = [DOTTED,DASHED,SOLID])

percentile1Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '1')
percentile1DataInput    = input.int(    10,         '',                 group = PERCENTILE_GROUP, inline = '1', minval = 0, maxval = 95)
percentile1StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '1', options = [DOTTED,DASHED,SOLID])

percentile2Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '2')
percentile2DataInput    = input.int(    20,         '',                 group = PERCENTILE_GROUP, inline = '2', minval = 0, maxval = 95)
percentile2StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '2', options = [DOTTED,DASHED,SOLID])

percentile3Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '3')
percentile3DataInput    = input.int(    30,         '',                 group = PERCENTILE_GROUP, inline = '3', minval = 0, maxval = 95)
percentile3StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '3', options = [DOTTED,DASHED,SOLID])

percentile4Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '4')
percentile4DataInput    = input.int(    40,         '',                 group = PERCENTILE_GROUP, inline = '4', minval = 0, maxval = 95)
percentile4StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '4', options = [DOTTED,DASHED,SOLID])

percentile5Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '5')
percentile5DataInput    = input.int(    50,         '',                 group = PERCENTILE_GROUP, inline = '5', minval = 0, maxval = 95)
percentile5StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '5', options = [DOTTED,DASHED,SOLID])

percentile6Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '6')
percentile6DataInput    = input.int(    60,         '',                 group = PERCENTILE_GROUP, inline = '6', minval = 0, maxval = 95)
percentile6StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '6', options = [DOTTED,DASHED,SOLID])

percentile7Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '7')
percentile7DataInput    = input.int(    70,         '',                 group = PERCENTILE_GROUP, inline = '7', minval = 0, maxval = 95)
percentile7StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '7', options = [DOTTED,DASHED,SOLID])

percentile8Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '8')
percentile8DataInput    = input.int(    80,         '',                 group = PERCENTILE_GROUP, inline = '8', minval = 0, maxval = 95)
percentile8StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '8', options = [DOTTED,DASHED,SOLID])

percentile9Input        = input.bool(   true,       '',                 group = PERCENTILE_GROUP, inline = '9')
percentile9DataInput    = input.int(    90,         '',                 group = PERCENTILE_GROUP, inline = '9', minval = 0, maxval = 95)
percentile9StyleInput   = input.string( DOTTED,     '',                 group = PERCENTILE_GROUP, inline = '9', options = [DOTTED,DASHED,SOLID])

showDashboardInput      = input.bool(   false,      'Show Dashboard',   group = DASHBOARD_GROUP)
dashboardPositionInput  = input.string( TOP_RIGHT,  'Position',         group = DASHBOARD_GROUP, options = [TOP_RIGHT,BOTTOM_RIGHT,BOTTOM_LEFT])
dashboardSizeInput      = input.string( NORMAL,     'Size',             group = DASHBOARD_GROUP, options = [TINY,SMALL,NORMAL,LARGE,HUGE])

gridInput               = input.bool(   true,       'Show Grid',        group = STYLE_GROUP)
gridSizeInput           = input.string( NORMAL,     'Size',             group = STYLE_GROUP, options = [TINY,SMALL,NORMAL,LARGE,HUGE])
bullishColorInput       = input.color(  color.new(GREEN,80),'',         group = STYLE_GROUP, inline = 'colors')
bearishColorInput       = input.color(  color.new(RED,80),  '',         group = STYLE_GROUP, inline = 'colors')
marksInput              = input.bool(   true,        'Show Marks',      group = STYLE_GROUP)

//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
type pivot    
    float   price   = close
    int     bar     = bar_index
    int     bias    = 1

type pivots
    array<float>    prices  = na
    array<int>      bars    = na

type percentile
    int value
    string style

var pivot currentPivot              = pivot.new()
var pivots bullishPivots            = pivots.new(array.new<float>(),array.new<int>())
var pivots bearishPivots            = pivots.new(array.new<float>(),array.new<int>())
var array<percentile> percentiles   = array.new<percentile>()
var array<int> rawPercentiles       = array.new<int>()
var array<label> gridLabels         = array.new<label>()

if barstate.isfirst

    if percentile0Input
        percentiles.push(percentile.new(percentile0DataInput,percentile0StyleInput))
        rawPercentiles.push(percentile0DataInput)

    if percentile1Input
        percentiles.push(percentile.new(percentile1DataInput,percentile1StyleInput))
        rawPercentiles.push(percentile1DataInput)

    if percentile2Input
        percentiles.push(percentile.new(percentile2DataInput,percentile2StyleInput))
        rawPercentiles.push(percentile2DataInput)
        
    if percentile3Input
        percentiles.push(percentile.new(percentile3DataInput,percentile3StyleInput))
        rawPercentiles.push(percentile3DataInput)       

    if percentile4Input
        percentiles.push(percentile.new(percentile4DataInput,percentile4StyleInput))
        rawPercentiles.push(percentile4DataInput)

    if percentile5Input
        percentiles.push(percentile.new(percentile5DataInput,percentile5StyleInput))
        rawPercentiles.push(percentile5DataInput)        

    if percentile6Input
        percentiles.push(percentile.new(percentile6DataInput,percentile6StyleInput))
        rawPercentiles.push(percentile6DataInput)

    if percentile7Input
        percentiles.push(percentile.new(percentile7DataInput,percentile7StyleInput))
        rawPercentiles.push(percentile7DataInput)
        
    if percentile8Input
        percentiles.push(percentile.new(percentile8DataInput,percentile8StyleInput))
        rawPercentiles.push(percentile8DataInput)
        
    if percentile9Input
        percentiles.push(percentile.new(percentile9DataInput,percentile9StyleInput))
        rawPercentiles.push(percentile9DataInput)
        
    if percentiles.size() < 2
        runtime.error('Please enable two or more percentiles in the settings panel.')    
    
    percentilesTemp = percentiles.copy()
    percentiles.clear()
    for index in rawPercentiles.sort_indices()
        percentiles.push(percentilesTemp.get(index))
    percentilesTemp.clear()        
    rawPercentiles.sort()  
    
var parsedDashboardPosition = switch dashboardPositionInput
    TOP_RIGHT       => position.top_right
    BOTTOM_RIGHT    => position.bottom_right
    BOTTOM_LEFT     => position.bottom_left

var parsedDashboardSize = switch dashboardSizeInput
    TINY            => size.tiny
    SMALL           => size.small
    NORMAL          => size.normal
    LARGE           => size.large
    HUGE            => size.huge

var parsedGridSize = switch gridSizeInput
    TINY            => size.tiny
    SMALL           => size.small
    NORMAL          => size.normal
    LARGE           => size.large
    HUGE            => size.huge

//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
lineStyle(string style) =>
    switch style
        DOTTED  => line.style_dotted
        DASHED  => line.style_dashed
        SOLID   => line.style_solid

fetchPivot(int length) =>    

    var float   currentPrice    = close
    var int     currentBar      = bar_index
    var int     bias            = na
    bool        newPivot        = false

    max     = math.max(close, open)
    min     = math.min(close, open)
    upper   = ta.highest(max, length)
    lower   = ta.lowest(min, length)

    bias    := max == upper ? HIGH : min == lower ? LOW : bias
    
    if bias != bias[1]
        newPivot            := true
        currentPivot.price  := currentPrice
        currentPivot.bar    := currentBar
        currentPivot.bias   := bias == LOW ? HIGH : LOW
        currentPrice        := bias == HIGH ? upper : lower
        currentBar          := bar_index
    else
        currentPrice        := bias == HIGH ? math.max(upper, currentPrice) : math.min(lower, currentPrice)
        currentBar          := currentPrice != currentPrice[1] ? bar_index : currentBar

    newPivot

fetchData(bool newPivot) =>
    var float   lastPrice   = close
    var int     lastBar     = bar_index

    bullish     = currentPivot.price > lastPrice
    priceDelta  = math.abs(currentPivot.price - lastPrice) / (normalizeDataInput ? lastPrice : 1)
    barsDelta   = currentPivot.bar - lastBar
   
    pivots p_ivots = bullish ? bullishPivots : bearishPivots

    if newPivot and barsDelta != 0 and not na(priceDelta)
        p_ivots.prices.push(priceDelta)
        p_ivots.bars.push(barsDelta)
        lastPrice   := currentPivot.price
        lastBar     := currentPivot.bar

        if p_ivots.prices.size() > maxPivotsInput
            p_ivots.prices.shift()
            p_ivots.bars.shift()

backgroundColor(float value) => currentPivot.bias == HIGH ? color.from_gradient(value,0,80,GREEN,RED) :color.from_gradient(value,0,80,RED,GREEN)

dataCell(table t_able, int column, int row, float barPercentile, float pricePercentile, float nextBarPercentile, float nextPricePercentile) => 
    float probability = probabilityModeInput == BEYOND ? (1 - pricePercentile * 0.01) * (1 - barPercentile * 0.01) : ((1 - nextPricePercentile * 0.01) - (1 - pricePercentile * 0.01)) * ((1 - nextBarPercentile * 0.01) - (1 - barPercentile * 0.01))
    t_able.cell(column,row,str.tostring(probability,'#%'),text_color = chart.fg_color,text_halign = text.align_right,bgcolor = backgroundColor(probability*100), text_size = parsedDashboardSize)

plotTable() =>
    var table t_able = table.new(parsedDashboardPosition,percentiles.size() + 2, percentiles.size() + 2
     , bgcolor      = #1e222d
     , border_color = #373a46
     , border_width = 1
     , frame_color  = #373a46
     , frame_width  = 1)
        
    t_able.merge_cells(0,0,1,1)
    t_able.merge_cells(2,0,percentiles.size() + 1,0)
    t_able.merge_cells(0,2,0,percentiles.size() + 1)
    t_able.cell(0,0,'PROBABILITY\nGRID',text_color = chart.fg_color, text_size = parsedDashboardSize)
    t_able.cell(2,0,'BARS',             text_color = chart.fg_color, bgcolor = SILVER80, text_size = parsedDashboardSize)
    t_able.cell(0,2,'PRICES',           text_color = chart.fg_color, bgcolor = SILVER80, text_size = parsedDashboardSize)

    pivots p_ivots = currentPivot.bias == HIGH ? bearishPivots : bullishPivots
    p_ivots.prices.sort()
    p_ivots.bars.sort()

    for [index,eachPercentile] in percentiles
        parsedIndex = index + 2
        t_able.cell(parsedIndex,1,str.tostring(p_ivots.bars.percentile_nearest_rank(eachPercentile.value)),text_color = chart.fg_color, bgcolor = SILVER80, text_size = parsedDashboardSize)
        float currentPercentile = p_ivots.prices.percentile_nearest_rank(eachPercentile.value)
        float price = currentPivot.price + (currentPivot.bias == HIGH ? -1 : 1) * (normalizeDataInput ? currentPivot.price * currentPercentile : currentPercentile)
        t_able.cell(1,parsedIndex,str.tostring(math.round_to_mintick(price),format.mintick),text_color = chart.fg_color,text_halign = text.align_right, bgcolor = SILVER80, text_size = parsedDashboardSize)

        for [innerIndex,innerPercentile] in percentiles
            innerParsedIndex    = innerIndex + 2
            nextPercentile      = index         == percentiles.size() - 1 ? 100 : percentiles.get(index + 1).value
            nextInnerPercentile = innerIndex    == percentiles.size() - 1 ? 100 : percentiles.get(innerIndex + 1).value
            dataCell(t_able,parsedIndex,innerParsedIndex,eachPercentile.value,innerPercentile.value,nextPercentile,nextInnerPercentile)
        
percentileBar(int index) =>    
    pivots p_ivots  = currentPivot.bias == HIGH ? bearishPivots : bullishPivots
    currentPivot.bar + p_ivots.bars.percentile_nearest_rank(index)

percentilePrice(int index) =>    
    pivots p_ivots          = currentPivot.bias == HIGH ? bearishPivots : bullishPivots
    float currentPercentile = p_ivots.prices.percentile_nearest_rank(index)
    math.round_to_mintick(currentPivot.price + (currentPivot.bias == HIGH ? -1 : 1) * (normalizeDataInput ? currentPivot.price * currentPercentile : currentPercentile))

backgroundGridColor(float value) => currentPivot.bias == HIGH ? color.from_gradient(value,0,80,bullishColorInput,bearishColorInput) : color.from_gradient(value,0,80,bearishColorInput,bullishColorInput)

plotBox(int column, int row, int barPercentile, int pricePercentile, int nextBarPercentile, int nextPricePercentile, int previousBarPercentile, int previoustPricePercentile) =>
    float probability       = probabilityModeInput == BEYOND ? (1 - pricePercentile * 0.01) * (1 - barPercentile * 0.01) : ((1 - nextPricePercentile * 0.01) - (1 - pricePercentile * 0.01)) * ((1 - nextBarPercentile * 0.01) - (1 - barPercentile * 0.01))   
    chart.point topLeft     = chart.point.new(na, column == 0 ? currentPivot.bar : percentileBar(previousBarPercentile), row == 0 ? currentPivot.price : percentilePrice(previoustPricePercentile))
    chart.point bottomRight = chart.point.new(na, percentileBar(barPercentile), percentilePrice(pricePercentile))
    box.new(topLeft,bottomRight,color(na),1,text =  str.tostring(probability,'#%'),text_color = color.new(chart.fg_color,50), text_size = parsedGridSize, bgcolor = backgroundGridColor(probability*100))

plotLinesAndLabels(percentile p_ercentile) =>
    line.new(chart.point.new(na,currentPivot.bar,percentilePrice(p_ercentile.value)),chart.point.new(na,percentileBar(rawPercentiles.max()),percentilePrice(p_ercentile.value)),color = color.new(chart.fg_color,50), style = lineStyle(p_ercentile.style))
    line.new(chart.point.new(na,percentileBar(p_ercentile.value),currentPivot.price),chart.point.new(na,percentileBar(p_ercentile.value),percentilePrice(rawPercentiles.max())),color = color.new(chart.fg_color,50), style = lineStyle(p_ercentile.style))
    gridLabels.push(label.new(chart.point.new(na,percentileBar(rawPercentiles.max()),percentilePrice(p_ercentile.value)),str.tostring(p_ercentile.value,'#th'),color = color(na),style = label.style_label_left, textcolor = color.new(chart.fg_color,50), size = parsedGridSize))
    gridLabels.push(label.new(chart.point.new(na,percentileBar(p_ercentile.value),currentPivot.price),str.tostring(p_ercentile.value,'#th'),color = color(na),style = currentPivot.bias == HIGH ? label.style_label_down : label.style_label_up, textcolor = color.new(chart.fg_color,50), size = parsedGridSize))

plotBoxes() =>
    for eachBox in box.all
        eachBox.delete()

    for eachLine in line.all
        eachLine.delete()

    for eachLabel in gridLabels
        eachLabel.delete()
    gridLabels.clear()
    
    pivots p_ivots  = currentPivot.bias == HIGH ? bearishPivots : bullishPivots
    p_ivots.prices.sort()
    p_ivots.bars.sort()   

    for [index,eachPercentile] in percentiles
        plotLinesAndLabels(eachPercentile)

        for [innerIndex,innerPercentile] in percentiles            
            nextPercentile          = index         == percentiles.size() - 1 ? 100 : percentiles.get(index + 1).value
            nextInnerPercentile     = innerIndex    == percentiles.size() - 1 ? 100 : percentiles.get(innerIndex + 1).value
            previousPercentile      = index         == 0 ? na : percentiles.get(index - 1).value
            previousInnerPercentile = innerIndex    == 0 ? na : percentiles.get(innerIndex - 1).value
            plotBox(index,innerIndex,eachPercentile.value,innerPercentile.value,nextPercentile,nextInnerPercentile,previousPercentile,previousInnerPercentile)          

plotForecast() =>
    if showDashboardInput
        plotTable()

    if gridInput
        plotBoxes()

plotMarks(bool newPivot) =>
    if marksInput and newPivot
        label.new(chart.point.new(na,currentPivot.bar,currentPivot.price), '•', color = color(na), textcolor = color.new(chart.fg_color,80),style = currentPivot.bias == HIGH ? label.style_label_down : label.style_label_up, size = 18)        
 
//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
bool isNewPivot = false

if barstate.isconfirmed
    isNewPivot := fetchPivot(lengthInput)
    fetchData(isNewPivot)
    plotMarks(isNewPivot)

if barstate.islast
    plotForecast()
    
//---------------------------------------------------------------------------------------------------------------------}
