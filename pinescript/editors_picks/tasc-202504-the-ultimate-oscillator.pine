// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © PineCodersTASC

//  TASC Issue: April 2025
//     Article: Less Lag In Momentum Indicators
//              The Ultimate Oscillator
//  Article By: John F. Ehlers
//    Language: TradingView's Pine Script® v6
// Provided By: PineCoders, for tradingview.com

//@version=6
title ="TASC 2025.04 The Ultimate Oscillator"
stitle = "UO"
indicator(title, stitle, false)


import TradingView/ta/9 as ta // import library for RMS function


//#region --- Constants and inputs ---

// @variable The source series to analyze.
float src = input.source(close, "Source:")

// @variable The width of the critical period range in the UO"s high-pass filters.
float Bandwidth = input.float(2, "Bandwidth:", 1.4, step = 0.1)

// @variable Defines the base critical period in the UO calculation. 
//           The HPF with the shorter wavelength uses this value directly.
//           The HPF with the longer wavelength multiplies this value by `Bandwidth` for its period.
float BandEdge = input.float(20, "BandEdge:", 3)

// @variable Determines whether the script displays a "cloud" of 10 additional UO series with different settings.
string cloudType = input.string("None", "Cloud: ", options = ["Bandwidth", "BandEdge", "Bandwidth + BandEdge", "None"])

// @variable Color input for the first fill().
color upColor = input.color(#08998180, "Cloud colors  ", inline = "1") 
color dnColor = input.color(#ff525280, "", inline="1")
//#endregion


//#region --- Functions ---

// @function      Calculates a second-order highpass filter.
// @param src     Series of values to process.
// @param period  Length of the filter"s critical period.
// @returns       The filtered series value.
HP(float src, float period) =>
    var float sq2 = math.sqrt(2.0)
    float a1      =  math.exp(-sq2 * math.pi / period)
    float c2      =  2.0 * a1 * math.cos(sq2 * math.pi / period)
    float c3      = -math.pow(a1, 2)
    float c1      = (1 + c2 - c3) * 0.25
    float hp      = 0.0
    if bar_index >= 4
        hp := c1 * (src - 2 * src[1] + src[2]) + 
              c2 * hp[1] + c3 * hp[2]
    hp


// @function   Calculates the Ultimate Oscillator.
// @param src  Series of values to process.
// @param bw   Width of the UO"s critical period range.
// @param be   Shortest critical period. 
// @returns    The UO value. 
UO(float src, float bw, float be) =>
    float hp1    = HP(src, bw * be)
    float hp2    = HP(src,      be)
    float signal = hp1 - hp2
    float rms    = ta.rms(signal, 100)
    rms == 0 ? 0 : signal / rms


// @function  Calculates 10 UO series with varying Bandwidth and BandEdge values.
UOCloud(float src, float bw, float be, simple string cloudType) =>
    var array<float> result = array.new<float>(10)
    var bool modBW = str.contains(cloudType, "Bandwidth")
    var bool modBE = str.contains(cloudType, "BandEdge")
    if modBW or modBE
        float minBW  = modBW ? math.max(bw * 0.5, 1.4) : bw
        float minBE  = modBE ? math.max(be * 0.5, 3) : be
        float bwStep = (bw - minBW) / 5
        float beStep = (be - minBE) / 5
        result.set(0, UO(src, minBW,              minBE             ))
        result.set(1, UO(src, minBW +     bwStep, minBE +     beStep))
        result.set(2, UO(src, minBW + 2 * bwStep, minBE + 2 * beStep))
        result.set(3, UO(src, minBW + 3 * bwStep, minBE + 3 * beStep))
        result.set(4, UO(src, minBW + 4 * bwStep, minBE + 4 * beStep))
        result.set(5, UO(src, minBW + 5 * bwStep, minBE + 5 * beStep))
        result.set(6, UO(src, minBW + 6 * bwStep, minBE + 6 * beStep))
        result.set(7, UO(src, minBW + 7 * bwStep, minBE + 7 * beStep))
        result.set(8, UO(src, minBW + 8 * bwStep, minBE + 8 * beStep))
        result.set(9, UO(src, minBW + 9 * bwStep, minBE + 9 * beStep))
    result
//#endregion


//#region --- Calculations and display

// @variable The UO of the `src` series based on the input settings.
float UO = UO(src, Bandwidth, BandEdge)

// @variable An array of UO values for the cloud display.
array<float> cloudValues = UOCloud(src, Bandwidth, BandEdge, cloudType)

// @variable The sum of each oscillator's polarity.
float sgnCount = math.sign(UO)
for val in cloudValues
    sgnCount += math.sign(val)

// @variable A gradient color based on the `sgnCount`.
color fillColor = color.from_gradient(sgnCount, -11, 11, dnColor, upColor)

// Calculate the maximum and minimum UO values for the cloud display.
float cloudMax = math.max(cloudValues.max(), UO)
float cloudMin = math.min(cloudValues.min(), UO)

// Plot the `cloudMax` and `cloudMin` and fill their space with the `fillColor`.
p1 = plot(cloudMax, "Cloud max", color.gray)
p2 = plot(cloudMin, "Cloud min", color.gray)
fill(p1, p2, fillColor)
// Plot the `UO`.
plot(UO, "Ultimate Oscillator", chart.fg_color, 3)
// Plot a horizontal line at 0.
hline(0)
//#endregion
