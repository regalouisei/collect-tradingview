// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © KioseffTrading

//@version=5
indicator("Tick CVD [Kioseff Trading]", max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, 
             max_polylines_count = 100, overlay = false)

import RicardoSantos/MathOperator/2
import kaigouthro/hsvColor/16 as kai 

enum visual 

    aesthetic = "Aesthetic"
    efficient = "Efficient"

enum lineT 

    line   = "Line"
    candle = "Candle"

enum dLineT 

    line   = "Line"
    candle = "Candle"

enum avgType 

    wma  = "WMA"
    hma  = "HMA"
    sma  = "SMA"
    ema  = "EMA"
    none = "None"

enum avgTypeP 

    wma  = "WMA"
    hma  = "HMA"
    sma  = "SMA"
    ema  = "EMA"
    none = "None"


justCVDP      = input.enum(defval = visual.aesthetic, title = "Visual Type", options = [visual.aesthetic, visual.efficient])
lineType      = input.enum(defval = lineT.candle , options = [lineT.candle, lineT.line], title = "CVD and Price Line Type")
lineTypeD     = input.enum(defval = dLineT.line, options = [dLineT.candle, dLineT.line], title = "Delta Line Type")
showKeyDelta  = input.bool(defval = true , title = "Show Key CVD   Levels as Lines")
showKeyPrice  = input.bool(defval = true , title = "Show Key Price Levels as Lines")
showLevels    = input.bool(defval = true , title = "Show Scale Lines")
showDots      = input.bool(defval = true , title = "Show CVD + Price Dots")
valuepdot     = input.bool(defval = false, title = "Value Next To Dot")
avgT          = input.enum(defval = avgType.wma , title = "Average Type CVD", 
         
         options = [ avgType.wma, 
                     avgType.hma, 
                     avgType.sma, 
                     avgType.ema, 
                     avgType.none
                     ])

avgTP         = input.enum(defval = avgTypeP.wma , title = "Average Type Price", 
         
         options = [ avgTypeP.wma, 
                     avgTypeP.hma, 
                     avgTypeP.sma, 
                     avgTypeP.ema, 
                     avgTypeP.none
                     ])

type CVD 

    varip float delta
    varip float price
    varip float normed 
    varip color pCol
    varip int   tick
    varip float rDelta
    varip float normedDelta
    varip float sDelta
    varip int   isKeyDelta = 0
    varip int   isKeyPrice = 0

type drawings 

    label yAxisLabel
    line  yAxisLine

var timeArr       = array.new_int (), var historicalCVD = array.new<CVD>(),
                         timeArr.unshift(time)

method append(array<CVD> id, CVD value) =>

    if id.size() > 5000
        id.pop()

    id.unshift(value)

method append(matrix<float> id, array<float> id2) =>

    if id.columns() > 5000
        id.remove_col(id.columns())

    id.add_col(0, id2)


method polyDraw(array<chart.point> id, array<chart.point> id1, string direction, color ifPrice) => 

    switch direction 

        "Pos" => 

                 polyline.new(id , xloc = xloc.bar_time, line_color = #FC8083, fill_color = color.new(#FC8083, 99),
                                       line_style = line.style_solid, 
                                       curved     = false
                                       ),

                 polyline.new(id1, xloc = xloc.bar_time, line_color = ifPrice,   fill_color = color.new(#ADAEF4, 99),
                                       line_style = line.style_solid, 
                                       curved     = false
                                       )

        "Neg" => 

                 polyline.new(id1, xloc = xloc.bar_time, line_color = ifPrice,   fill_color = color.new(#ADAEF4, 99),
                                       line_style = line.style_solid,
                                       curved     = false
                                       ),

                 polyline.new(id , xloc = xloc.bar_time, line_color = #FC8083, fill_color = color.new(#FC8083, 99),
                                       line_style = line.style_solid, 
                                       curved     = false
                                       )
   
method maxMin(map <string, float> id, string key, float value, int dir) =>     

    switch dir 

        1  => id.put(key, math.max(nz(id.get(key)), value))
        -1 => id.put(key, math.min(nz(id.get(key), 1e8), value))

method normalize (float value, array<CVD> id, map<string,float> id2, float calc, float calc2) =>

    getHigh = id2.get("Price High")              , getLow = id2.get("Price Low")
    maxCVD  = math.max(calc, id2.get("CVD High")), minCVD = math.min(calc, id2.get("CVD Low"))

    adjustment = (maxCVD - minCVD) * .1, var oldNmax = -1e8, var oldNmin = 1e8 

    oldMin    = math.min(nz(getLow, 1e8), value), oldMax    = math.max(nz(getHigh), value), 
    newMin    = maxCVD + adjustment * 10,         newMax    = newMin + (maxCVD - minCVD)
    nDeltaMax = maxCVD + adjustment * 9,          nDeltaMin = maxCVD + adjustment

    oldNmax   := math.max(calc2, id2.get("Delta High"), oldNmax)
    oldNmin   := math.min(calc2, id2.get("Delta Low" ), oldNmin)

    maxTopMinBotS = math.avg(nDeltaMin, nDeltaMax), maxTopMinBot  = math.avg(nDeltaMin, maxTopMinBotS),
                             adjDelta = (maxTopMinBotS - nDeltaMin) * .1, 
    
    maxTopMinBotS -= adjDelta , nDeltaMin += adjDelta

    newRange = newMax - newMin, oldRange = oldMax - oldMin,
                 oldNrange = oldNmax - oldNmin

    if id.size() > 0 
        

        for [i, data] in id

            norm   = newMin + ((((data.price - oldMin) * (newRange)) / (oldRange)))

            nDelta = switch math.sign(data.sDelta) 

                1  => maxTopMinBot + ((((data.sDelta - oldNmin) * (maxTopMinBotS - maxTopMinBot)) / (oldNrange)))
                -1 => nDeltaMin    + ((((data.sDelta - oldNmin) * (maxTopMinBot - nDeltaMin)) / (oldNrange)))
                =>    maxTopMinBot


            id.set(i, 
                     CVD.new(
                        
                             delta       = data.delta, 
                             price       = data.price, 
                             normed      = norm, 
                             tick        = data.tick,
                             rDelta      = data.rDelta,
                             normedDelta = nDelta, 
                             sDelta      = data.sDelta, 
                             isKeyDelta  = data.isKeyDelta, 
                             isKeyPrice  = data.isKeyPrice

                             
                             ))

    
    nDelta = switch math.sign(calc2) 

        1  => maxTopMinBot + ((((calc2 - oldNmin) * (maxTopMinBotS - maxTopMinBot)) / (oldNrange)))
        -1 => nDeltaMin    + ((((calc2 - oldNmin) * (maxTopMinBot - nDeltaMin)) / (oldNrange)))
        =>    maxTopMinBot

    [newMin + (((value - oldMin) * (newRange)) / (oldRange)), nDelta]

method calcAvg(array<float> series, bool isCVD) =>

    varip avgCoords = array.new_float()

    [cond1, cond2, cond3, cond4] = switch isCVD 

        true => [avgT  == avgType.hma , avgT  == avgType.wma , avgT  == avgType.ema , avgT  == avgType.sma ]
        =>      [avgTP == avgTypeP.hma, avgTP == avgTypeP.wma, avgTP == avgTypeP.ema, avgTP == avgTypeP.sma]

    if cond1

        normalize  = 0.0
        tickPrice  = 0.0

        length = math.min(50, series.size() - 1)

        for i = 0 to length - 1

            normalize +=  (length - i) * length
            tickPrice +=  series.get(i) * ((length - i) * length)

        tick1 = tickPrice / normalize

        normalize := 0.0 
        tickPrice := 0.0

        for i = 0 to length / 2 - 1

            normalize += (length / 2 - i) * (length / 2)
            tickPrice += series.get(i) * ((length / 2 - i) * (length / 2))

        tick2 = tickPrice / normalize 

        finLen = math.floor(math.sqrt(length))

        normalize := 0.0 
        tickPrice := 0.0 

        for i = 0 to finLen - 1

            normalize += (finLen - i) * finLen 
            tickPrice += (2 * tick2 - tick1) * ((finLen - i) * finLen)

        avgCoords.unshift(tickPrice / normalize)

    if cond2 
    
        normalize = 0.0, tickPrice  = 0.0

        length = math.min(50, series.size() - 1)

        for i = 0 to length - 1

            normalize += (length - i)  *   length
            tickPrice += series.get(i) * ((length - i) * length)

        avgCoords.unshift(tickPrice / normalize)

    if cond3

        normalize = 0.0, tickPrice  = 0.0

        length = math.min(50, series.size() - 1)

        for i = 0 to length - 1

            normalize += (length - i) * length
            tickPrice += series.get(i) * ((length - i) * length)

        avgCoords.unshift(tickPrice / normalize)

    if cond4

        slice = series.slice(0, math.min(series.size(), 50))

        avgCoords.unshift(slice.avg())

    avgCoords



cpft(int xCoord, float yCoord) => 

    chart.point.from_time(xCoord, yCoord)

method coord6(float currDelta, int getTime, int getTime1, float maxTopMinBot) => 
                
    c0 = cpft(getTime , maxTopMinBot), c1 = cpft(getTime1, maxTopMinBot), c2 = cpft(getTime1, currDelta)
    c3 = cpft(getTime , currDelta)   , c4 = cpft(getTime , maxTopMinBot), c5 = cpft(getTime1, maxTopMinBot),
                                       c6 = cpft(getTime1, maxTopMinBot)

    [c0, c1, c2, c3, c4, c5, c6]


method coord5(float currDelta, int getTime, int getTime1, float delta1) => 
                
    c0 = cpft(getTime , delta1)    , c1 = cpft(getTime1, delta1), c2 = cpft(getTime1, currDelta)
    c3 = cpft(getTime , currDelta) , c4 = cpft(getTime , delta1), c5 = cpft(getTime , currDelta)

    [c0, c1, c2, c3, c4, c5]


method coord5o6Push(array<chart.point> id, c0, c1, c2, c3, c4, c5, chart.point c6, bool no6 = true) => 
                
    id.push(c0), id.push(c1)
    id.push(c2), id.push(c3)
    id.push(c4), id.push(c5),

    if not no6 
        id.push(c6)


drawCVD() => 

    if barstate.islast and not barstate.isrealtime 
        var tab = table.new(position.middle_center, 1, 1, bgcolor = #00000000)
        tab.cell(0, 0, "Market Is Closed", text_color = chart.fg_color, text_size = size.large)

    if barstate.isnew and barstate.isrealtime
        timeArr.pop()

    if barstate.isrealtime 

        for poly in polyline.all 
            poly.delete()

        for boxes in box.all 
            boxes.delete()        

        for lab in label.all 
            lab.delete()

        for LINE in line.all 
            LINE.delete()

        varip vol = 0., varip vol1 = 0., varip clo = 0., varip clo1 = 0.

        vol1 := vol, vol := volume, clo1 := clo, clo := close

        varip RTcvd       = array.new<CVD>()        , varip keyPoints = map.new<string, float>()
        varip gradientExt = map.new<string, float>(), varip avg       = matrix.new<float>(0, 2)

        if vol.over(vol1) and vol1.not_equal(0)

            varip tickCount = 0, tickCount += 1

            delta    = vol - vol1
            newDelta = (delta).multiply(math.sign(clo.subtract(clo1)))

            calc = switch RTcvd.size() > 0

                true => RTcvd.first().delta + newDelta
                =>      0

            move = clo.subtract(clo1)

            if move.over(0)

                gradientExt.put("Pos. Delta +", math.max(nz(gradientExt.get("Pos. Delta +"), 0), delta))
                gradientExt.put("Pos. Delta -", math.min(nz(gradientExt.get("Pos. Delta -"), 20e20), delta))
            
            if move.under(0)

                gradientExt.put("Neg. Delta +", math.max(nz(gradientExt.get("Neg. Delta +"), 0), delta))
                gradientExt.put("Neg. Delta -", math.min(nz(gradientExt.get("Neg. Delta -"), 20e20), delta))

            switch RTcvd.size() == 0

                false => 
                         
                         [normClo, normSdelta] = clo.normalize(RTcvd, keyPoints, calc, newDelta),

                         RTcvd.append(CVD.new(calc, clo, normClo, 
                         tick = tickCount, rDelta = delta, sDelta = newDelta, normedDelta = normSdelta)),

                         avg.add_row(0, array.from(calc, clo))


                =>       

                         [normClo, normSdelta] = clo.normalize(RTcvd, keyPoints, calc, newDelta),

                         RTcvd.append(CVD.new((vol - vol1).multiply(math.sign(clo.subtract(clo1))), clo, 
                         normClo, tick = tickCount, rDelta = delta, sDelta = newDelta, normedDelta = normSdelta)), 

                         avg.add_row(0, array.from(calc, clo))

                        
            keyPoints.maxMin("CVD High"    , calc,  1)
            keyPoints.maxMin("CVD Low"     , calc, -1)
    
            keyPoints.maxMin("Price High"  , clo ,  1)
            keyPoints.maxMin("Price Low"   , clo ,  -1)

            keyPoints.maxMin("Delta High", newDelta, 1)
            keyPoints.maxMin("Delta Low" , newDelta, -1)

            if RTcvd.size() > 2 and justCVDP == visual.aesthetic
            
                getMid = RTcvd.get(1), getFirst = RTcvd.first(), getLast = RTcvd.get(2)

                priceKey = switch 

                    not showKeyDelta                                               => 0
                    getMid.price > getFirst.price and getMid.price > getLast.price => -1 
                    getMid.price < getFirst.price and getMid.price < getLast.price => 1 
                    => 0

                deltaKey = switch 

                    not showKeyPrice                                               => 0
                    getMid.delta > getFirst.delta and getMid.delta > getLast.delta => -1 
                    getMid.delta < getFirst.delta and getMid.delta < getLast.delta => 1 
                    => 0

                if deltaKey != 0 or priceKey != 0 
                    
                    RTcvd.set(1, CVD.new(getMid.delta, getMid.price, getMid.normed, getMid.pCol, 
                                           getMid.tick, getMid.rDelta, getMid.normedDelta, getMid.sDelta, deltaKey, priceKey))


        upGrad  = array.new<chart.point>(), dnGrad  = array.new<chart.point>()
        upGradP = array.new<chart.point>(), dnGradP = array.new<chart.point>()

        rDeltaCoordsSz = switch lineTypeD 

            dLineT.line => RTcvd.size() + 1
            =>             RTcvd.size()

        rDeltaCoords = matrix.new<chart.point>(rDeltaCoordsSz, 3)

        getCVDhigh = keyPoints.get("CVD High"   ), getCVDlow = keyPoints.get("CVD Low"   )
        getPhigh   = keyPoints.get("Price High" ), getPlow   = keyPoints.get("Price Low" )

        adjustment = (getCVDhigh - getCVDlow) * .1, newMin    = getCVDhigh  + adjustment * 9
        nDeltaMax  = getCVDhigh + adjustment  * 9 , nDeltaMin = getCVDhigh  + adjustment

        maxTopMinBotS = math.avg(nDeltaMin, newMin)
        maxTopMinBot  = math.avg(nDeltaMin, maxTopMinBotS) 

        if lineTypeD == dLineT.line and justCVDP == visual.aesthetic

            rDeltaCoords.set(0, 0, cpft(time("", -1), maxTopMinBot))
            rDeltaCoords.set(0, 1, cpft(time("", -1), maxTopMinBot))
            rDeltaCoords.set(0, 2, cpft(timeArr.first(), maxTopMinBot))

        minTime = time , exp = 0

        if RTcvd.size() > 2 

            if justCVDP == visual.aesthetic

                if lineTypeD == dLineT.line 
                    for [i, data] in RTcvd 
                    
                        getTime = timeArr.get(i)
                    
                        switch math.sign(data.sDelta) 
                        
                            1  =>
    
                                 rDeltaCoords.set(i + 1, 0, cpft(getTime, data.normedDelta)),
                                 rDeltaCoords.set(i + 1, 1, cpft(getTime, maxTopMinBot)),
    
                            -1 =>
    
                                 rDeltaCoords.set(i + 1, 1, cpft(getTime, data.normedDelta)),
                                 rDeltaCoords.set(i + 1, 0, cpft(getTime, maxTopMinBot)),
    
                            => 
                                 neutralPoint = cpft(getTime, maxTopMinBot),
                                 rDeltaCoords.set(i + 1, 1, neutralPoint),
                                 rDeltaCoords.set(i + 1, 0, neutralPoint),
    
                        exp := timeArr.get(i)
    
                        rDeltaCoords.set(i + 1, 2, cpft(timeArr.get(i), maxTopMinBot))
    
                    rDeltaCoords.add_row(rDeltaCoords.rows()), getRows = rDeltaCoords.rows() - 1,
    
                    lastPoint = cpft(exp, maxTopMinBot)
    
                    rDeltaCoords.set(getRows, 0, lastPoint)
                    rDeltaCoords.set(getRows, 1, lastPoint)
                    rDeltaCoords.set(getRows, 2, lastPoint)
    
                    polyline.new(rDeltaCoords.col(0), xloc = xloc.bar_time, line_color = #74ffbc, curved = true, 
                                                 fill_color = color.new(#74ffbc, 90))
    
                    polyline.new(rDeltaCoords.col(1), xloc = xloc.bar_time, line_color = color.rgb(255, 116, 116), curved = true, 
                                                 fill_color = color.new(color.rgb(255, 116, 116), 90))
    
                    polyline.new(rDeltaCoords.col(2), xloc = xloc.bar_time, line_color = chart.fg_color)
    
                else 
                    
                    rDeltaUp = array.new<chart.point>()
                    rDeltaDn = array.new<chart.point>()
    
                    for i = 0 to RTcvd.size() - 2
    
                        data = RTcvd.get(i)
    
                        getTime   = timeArr.get(i)  , getTime1 = timeArr.get(i + 1)
                        currDelta = data.normedDelta, sign     = math.sign(data.sDelta)
    
                        [c0, c1, c2, c3, c4, c5, c6] = currDelta.coord6(getTime, getTime1, maxTopMinBot)
    
                        neutralPoint = cpft(getTime, maxTopMinBot)
    
                        switch sign
                        
                            1 => 
                                 rDeltaUp.coord5o6Push(c0, c1, c2, c3, c4, c5, c6, false),
                                 rDeltaDn.push(neutralPoint)
    
                            -1 => 
    
                                 rDeltaDn.coord5o6Push(c0, c1, c2, c3, c4, c5, c6, false),
                                 rDeltaUp.push(neutralPoint)
                            
                            => 
    
                                 rDeltaUp.push(neutralPoint),
                                 rDeltaDn.push(neutralPoint)
    
                    
                    polyline.new(rDeltaUp, xloc = xloc.bar_time, fill_color = color.new(#74ffbc, 75), 
                                                 line_color = color.new(#74ffbc, 25))
    
                    polyline.new(rDeltaDn, xloc = xloc.bar_time, fill_color = color.new(color.rgb(255, 116, 116), 75), 
                                                 line_color = color.new(color.rgb(255, 116, 116), 25))

            first = RTcvd.first()

            if lineType == lineT.line

                for [i, data] in RTcvd 

                    getTime = timeArr.get(i), getTime1 = timeArr.get(i + 1)

                    chartPoint  = cpft(getTime, data.delta)
                    chartPoint2 = cpft(getTime, data.normed)

                    upGradP.push(chartPoint2), dnGradP.push(chartPoint2)
                    upGrad .push(chartPoint ), dnGrad .push(chartPoint )
                
                    minTime := math.min(minTime, getTime)

                    if justCVDP == visual.aesthetic

                        if data.isKeyDelta == 1 

                            switch first.delta > data.delta


                                true =>  line.new(getTime, data.delta, last_bar_time, data.delta, xloc = xloc.bar_time, 
                                                              color = #ADAEF4, 
                                                              style = line.style_dotted )

                                =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                         data.normedDelta, data.sDelta, 0, data.isKeyPrice))


                        if data.isKeyDelta == -1 

                            switch first.delta < data.delta


                                true =>  line.new(getTime, data.delta, last_bar_time, data.delta, xloc = xloc.bar_time, 
                                                              color = #FC8083, 
                                                              style = line.style_dotted )

                                =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                         data.normedDelta, data.sDelta, 0, data.isKeyPrice))

                        if data.isKeyPrice == 1 

                            switch first.price > data.price


                                true =>  line.new(getTime, data.normed, last_bar_time, data.normed, xloc = xloc.bar_time, 
                                                              color = #74ffbc, 
                                                              style = line.style_dotted )

                                =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                         data.normedDelta, data.sDelta, data.isKeyDelta, 0))



                        if data.isKeyPrice == -1 

                            switch first.price < data.price


                                true =>  line.new(getTime, data.normed, last_bar_time, data.normed, xloc = xloc.bar_time, 
                                                              color = #FC8083, 
                                                              style = line.style_dotted )

                                =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                         data.normedDelta, data.sDelta, data.isKeyDelta, 0))

   

            if lineType == lineT.candle

                if RTcvd.size() > 1
                    for i = RTcvd.size() - 1 to 0

                        getTime = timeArr.get(i)

                        data = RTcvd.get(i)
                
                        minTime := math.min(minTime, getTime)

                        if i == RTcvd.size() - 1

                            deltaPoint = cpft(getTime, data.delta)
                            normdPoint = cpft(getTime, data.normed)

                            upGrad .push(deltaPoint) , dnGrad .push(deltaPoint)
                            upGradP.push(normdPoint) , dnGradP.push(normdPoint)


                        else 

                            getTime1 = timeArr.get(i + 1), delta1 = RTcvd.get(i + 1).delta

                            [cp0, cp1, cp2, cp3, cp4, cp5] = data.delta.coord5(getTime, getTime1, delta1)

                            upGrad.coord5o6Push(cp0, cp1, cp2, cp3, cp4, cp5, na)
                            dnGrad.coord5o6Push(cp0, cp1, cp2, cp3, cp4, cp5, na)

                            norm1 = RTcvd.get(i + 1).normed

                            [cpn0, cpn1, cpn2, cpn3, cpn4, cpn5] = data.normed.coord5(getTime, getTime1, norm1)

                            upGradP.coord5o6Push(cpn0, cpn1, cpn2, cpn3, cpn4, cpn5, na)
                            dnGradP.coord5o6Push(cpn0, cpn1, cpn2, cpn3, cpn4, cpn5, na)

                        if justCVDP == visual.aesthetic

                            if data.isKeyDelta == 1 

                                switch first.delta > data.delta


                                    true =>  line.new(getTime, data.delta, last_bar_time, data.delta, xloc = xloc.bar_time, 
                                                                  color = #ADAEF4, 
                                                                  style = line.style_dotted )

                                    =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                             data.normedDelta, data.sDelta, 0, data.isKeyPrice))


                            if data.isKeyDelta == -1 

                                switch first.delta < data.delta


                                    true =>  line.new(getTime, data.delta, last_bar_time, data.delta, xloc = xloc.bar_time, 
                                                                  color = #FC8083, 
                                                                  style = line.style_dotted )

                                    =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                             data.normedDelta, data.sDelta, 0, data.isKeyPrice))


                            if data.isKeyPrice == 1 

                                switch first.price > data.price


                                    true =>  line.new(getTime, data.normed, last_bar_time, data.normed, xloc = xloc.bar_time, 
                                                                  color = #74ffbc, 
                                                                  style = line.style_dotted )

                                    =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                             data.normedDelta, data.sDelta, data.isKeyDelta, 0))



                            if data.isKeyPrice == -1 

                                switch first.price < data.price


                                    true =>  line.new(getTime, data.normed, last_bar_time, data.normed, xloc = xloc.bar_time, 
                                                                  color = #FC8083, 
                                                                  style = line.style_dotted )

                                    =>       RTcvd.set(i, CVD.new(data.delta, data.price, data.normed, data.pCol, data.tick, data.rDelta,
                                                             data.normedDelta, data.sDelta, data.isKeyDelta, 0))



            if lineType == lineT.line

                for i = upGrad.size() - 1 to 0

                    getTime = timeArr.get(i)

                    upGradP.push(cpft(getTime, (newMin + ((getCVDhigh + adjustment) - (getCVDlow - adjustment)))))
                    dnGradP.push(cpft(getTime, newMin))

                    upGrad .push(cpft(getTime, getCVDhigh + adjustment))
                    dnGrad .push(cpft(getTime, getCVDlow  - adjustment))

            if lineType == lineT.candle

                upGrad.reverse(), dnGrad.reverse(), upGradP.reverse(), dnGradP.reverse()

                for i = RTcvd.size() - 1 to 0

                    getTime = timeArr.get(i)

                    upGradP.push(cpft(getTime, (newMin + ((getCVDhigh + adjustment) - (getCVDlow - adjustment)))))
                    dnGradP.push(cpft(getTime, newMin))

                    upGrad .push(cpft(getTime, getCVDhigh + adjustment))
                    dnGrad .push(cpft(getTime, getCVDlow  - adjustment))


            keyPoints.put("Normed High" , (newMin + ((getCVDhigh + adjustment) - (getCVDlow - adjustment))))
            keyPoints.put("Normed Low"  , newMin)

            getNhigh   = keyPoints.get("Normed High"), getNlow   = keyPoints.get("Normed Low")

            switch RTcvd.first().delta >= 0 

                true => upGrad.polyDraw(dnGrad, "Pos", #ADAEF4)
                =>      upGrad.polyDraw(dnGrad, "Neg", #ADAEF4)

            switch RTcvd.first().price >= RTcvd.last().price

                true => upGradP.polyDraw(dnGradP, "Pos", #74ffbc)
                =>      upGradP.polyDraw(dnGradP, "Neg", #74ffbc)


            getTick = RTcvd.first().tick

            if RTcvd.size() > 1 and justCVDP == visual.aesthetic

                maxPos = gradientExt.get("Pos. Delta +"), minPos = gradientExt.get("Pos. Delta -")
                maxNeg = gradientExt.get("Neg. Delta +"), minNeg = gradientExt.get("Neg. Delta -")

                for i = math.min(RTcvd.size() - 2, 500) to 0

                    delta = RTcvd.get(i).rDelta, col = color.new(color.gray, 80), sign = 0.

                    sign := math.sign(RTcvd.get(i).price - RTcvd.get(i + 1).price)

                    col := switch sign

                        1  => kai.hsv_gradient(delta, minPos, maxPos, color.new(#ADAEF4, 75), color.new(#ADAEF4, 25))
                        -1 => kai.hsv_gradient(delta, minNeg, maxNeg, color.new(color.rgb(255, 116, 116), 75), 
                              color.new(color.rgb(255, 116, 116), 25))

                    operator = ""
            
                    if sign == 1 

                        operator += "+"
                
                    box.new(timeArr.get(i + 1), math.avg(newMin, getCVDhigh + adjustment), timeArr.get(i), newMin,
                                                 text             = str.tostring(getTick - i - 1) + '\n' 
                                                                  + operator + str.tostring(delta * sign, "###,###.##"), 
                                                 bgcolor          = col, 
                                                 border_color     = #00000000, 
                                                 xloc             = xloc.bar_time, 
                                                 text_color       = chart.fg_color, 
                                                 text_size        = size.auto, 
                                                 text_font_family = font.family_monospace
                                                 )

                end = math.min(12, RTcvd.size() - 1)


                if avgT != avgType.none and justCVDP == visual.aesthetic

                    avgLineCVD = avg.col(0).calcAvg(true)

                    avgPoints = array.new<chart.point>(), var polyAvg = array.new<polyline>(1)
        
                    polyAvg.first().delete()

                    if avgLineCVD.size() > 0 

                        for i = 0 to avgLineCVD.size() - 1

                            getTime = timeArr.get(i)

                            if getTime >= minTime 

                                avgPoints.push(cpft(getTime, avgLineCVD.get(i)))


                        polyAvg.set(0, polyline.new(avgPoints, xloc = xloc.bar_time, line_style = line.style_dotted, 
                                                         line_color = chart.fg_color
                                                         ))



                if avgTP != avgTypeP.none and justCVDP == visual.aesthetic

                    avgLinePrice = avg.col(1).calcAvg(false)
                    avgPoints    = array.new<chart.point>(), var polyAvg = array.new<polyline>(1)
        
                    polyAvg.first().delete()

                    if avgLinePrice.size() > 0

                        normMin   = getCVDhigh + adjustment * 10
                        normMax   = normMin + (getCVDhigh - getCVDlow), normR = normMax - normMin

                        for i = 0 to avgLinePrice.size() - 1

                            getTime  = timeArr.get(i) 

                            if getTime >= minTime 

                                getPrice = avgLinePrice.get(i)

                                norm = newMin + adjustment + (((getPrice - getPlow) * (normR)) / (getPhigh - getPlow))

                                avgPoints.push(cpft(getTime, norm))


                        polyAvg.set(0, polyline.new(avgPoints, xloc = xloc.bar_time, line_style = line.style_dotted, 
                                                         line_color = chart.fg_color
                                                         ))



                if showDots and justCVDP == visual.aesthetic

                    for i = 1 to end

                        index = RTcvd.get(i), delta = index.delta, sign  = 0., price = index.price

                        if i < RTcvd.size() - 1
                            sign := math.sign(price - RTcvd.get(i + 1).price)

                        [sz, txt] = switch valuepdot 

                            true => [size.tiny , "• " + str.tostring(delta, "###,###.##")]
                            =>      [size.small, "• "]

                        col = switch sign 

                            1  => #ADAEF4
                            -1 => #FC8083 
                            =>    chart.fg_color


                        label.new(time("", (end - i + 1) * -1), delta, 
                                     text      = txt, 
                                     color     = #00000000, 
                                     style     = label.style_label_center, 
                                     textcolor = col, 
                                     xloc      = xloc.bar_time, 
                                     size      = sz
                                     )


                        [szP, txtP] = switch valuepdot 

                            true => [size.tiny, "• " + str.tostring(price, "###,###.##")]
                            =>      [size.small, "• "]

                        col := switch sign 

                            1  => #74ffbc
                            -1 => #FC8083 
                            =>    chart.fg_color


                        label.new(time("", (end - i + 1) * -1), index.normed, 
                                     text      = txt, 
                                     color     = #00000000, 
                                     style     = label.style_label_center, 
                                     textcolor = col, 
                                     xloc      = xloc.bar_time, 
                                     size      = sz
                                     )


            if justCVDP == visual.aesthetic
            

                Range = (getCVDhigh - getCVDlow) / 10
    
                cvdDrawings   = array.new<drawings>(11)
                priceDrawings = array.new<drawings>(11)

                for i = 0 to 10
                    
                    calc = getCVDlow + (i * Range)
    
                    col = switch math.sign(calc)
                    
                        1 => #ADAEF4 
                        0 => color.white 
                        =>   #FC8083
    
    
                    cvdDrawings.set(i,
    
                             drawings.new(
                            
                                 label.new(bar_index + 20, calc, str.tostring(calc, format.volume), 
                                                     style     = label.style_label_right, 
                                                     color     = #00000000, 
                                                     textcolor = col), 
    
                                 showLevels ? line.new(bar_index, calc, bar_index + 15, calc, color =  color.new(col, 75)) : 
                                              line(na)
    
                             ))
    
                nRange = (getNhigh - getNlow) / 10
                pRange = (getPhigh - getPlow) / 10
    
                var cvdLab = label(na), var pLab = label(na)
                var cvdDot = label(na), var pDot = label(na)
                
                signCVD = math.sign(RTcvd.first().delta)
    
                [colCVD, dirCVD] = switch signCVD
                
                    1 => [#ADAEF4 ,    "⏶ "]
                    0 => [color.white, "- " ]
                    =>   [#FC8083,     "⏷ "]
    
                signP = math.sign(RTcvd.first().normed - RTcvd.last().normed)
    
                [colP, dirP] = switch signP
                
                    1 => [#74ffbc,     "⏶"]
                    0 => [color.white, "-" ]
                    =>   [#FC8083,     "⏷"]
    
                priceCalc = RTcvd.first().price / RTcvd.last().price - 1

                switch na(cvdLab) 
                
                    true =>  cvdLab := label.new(time("", -30), math.avg(getCVDhigh, getCVDlow), 
                                      text      = "CVD (" + str.tostring(RTcvd.first().delta, "###,###.##") + ") " + dirCVD, 
                                      color     = #00000000, 
                                      textcolor = colCVD, 
                                      xloc      = xloc.bar_time),
    
                             pLab   := label.new(time("", -30), math.avg(getNhigh, getNlow), 
                                     text      = "Price (" + str.tostring(priceCalc * 100, format.percent) + ") " + dirP, 
                                     color     = #00000000, 
                                     textcolor = colP, 
                                     xloc      = xloc.bar_time),
    
                             cvdDot := label.new(time("", -13), RTcvd.first().delta, xloc = xloc.bar_time, 
                                     textcolor = colCVD, 
                                     color     = #00000000, 
                                     style     = label.style_label_center, 
                                     text      = "• " + str.tostring(RTcvd.first().delta, format.volume)),
    
                             pDot  := label.new(time("", -14), RTcvd.first().normed, xloc = xloc.bar_time, 
                                     textcolor = colP, 
                                     color     = #00000000, 
                                     style     = label.style_label_center, 
                                     text      = "• " + str.tostring(RTcvd.first().price, format.mintick))
    
                    => 
                         cvdLab.set_xy(time("", -30), math.avg(getCVDhigh, getCVDlow)),
                         pLab  .set_xy(time("", -30), math.avg(getNhigh, getNlow)),
    
                         cvdDot.set_xy(time("", -8), RTcvd.first().delta),
                         cvdDot.set_text("• " + str.tostring(RTcvd.first().delta, format.volume)),
                         cvdDot.set_textcolor(colCVD),
    
                         pDot.set_xy(time("", -8), RTcvd.first().price),
                         pDot.set_text("• " + str.tostring(RTcvd.first().price, format.mintick)),
                         pDot.set_textcolor(colP)
    
    
                for i = 0 to 10
                
                    xCalc  = getNlow + (i * nRange)
                    pCalc  = getPlow + (i * pRange)
    
                    firstClose = RTcvd.last().price

                    col = switch 

                        pCalc > firstClose => #74ffbc 
                        pCalc < firstClose => #FC8083
                        =>                   color.white
    
                    priceDrawings.set(i,
    
                         drawings.new(
                        
                             label.new(bar_index + 20, xCalc, str.tostring(pCalc, format.mintick), 
                                         style     = label.style_label_right, 
                                         color     = #00000000, 
                                         textcolor = col
                                         ), 
    
                             showLevels ? line.new(bar_index, xCalc, bar_index + 15, xCalc, color = color.new(col, 75)) : 
                             line(na)
    
                         ))
    
            if justCVDP == visual.efficient
    
                var cvdLab = label(na), var pLab = label(na)
                
                signCVD = math.sign(RTcvd.first().delta)
    
                [colCVD, dirCVD] = switch signCVD
                
                    1 => [#ADAEF4 ,    "⏶"]
                    0 => [color.white, "-" ]
                    =>   [#FC8083,     "⏷"]
    
                signP = math.sign(RTcvd.first().normed - RTcvd.last().normed)
    
                [colP, dirP] = switch signP
                
                    1 => [#74ffbc,     "⏶"]
                    0 => [color.white, "-" ]
                    =>   [#FC8083,     "⏷"]
    
                priceCalc = RTcvd.first().price / RTcvd.last().price - 1


                switch na(cvdLab) 
                
                    true =>  cvdLab := label.new(time("", -5), math.avg(getCVDhigh, getCVDlow), 
                                      text      = "CVD (" + str.tostring(RTcvd.first().delta, "###,###.##") + ") " + dirCVD, 
                                      color     = #00000000, 
                                      textcolor = colCVD, 
                                      xloc      = xloc.bar_time),
    
                             pLab   := label.new(time("", -5), math.avg(getNhigh, getNlow), 
                                     text      = "Price (" + str.tostring(priceCalc * 100, format.percent) + ") " + dirP,
                                     color     = #00000000, 
                                     textcolor = colP, 
                                     xloc      = xloc.bar_time),
    
                    => 
                         cvdLab.set_xy(time("", -30), math.avg(getCVDhigh, getCVDlow)),
                         pLab  .set_xy(time("", -30), math.avg(getNhigh, getNlow)),

    0
    
drawCVD()
