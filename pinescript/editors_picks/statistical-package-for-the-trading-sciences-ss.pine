//\__\         /\  \                     /\__\    
//    /:/ _/_       /::\  \       ___         /:/ _/_   
//   /:/ /\  \     /:/\:\__\     /\__\       /:/ /\  \  
//  /:/ /::\  \   /:/ /:/  /    /:/  /      /:/ /::\  \ 
//:/_/:/\:\__\ /:/_/:/  /    /:/__/      /:/_/:/\:\__\
// \:\/:/ /:/  / \:\/:/  /    /::\  \      \:\/:/ /:/  /
//  \::/ /:/  /   \::/__/    /:/\:\  \      \::/ /:/  / 
//   \/_/:/  /     \:\  \    \/__\:\  \      \/_/:/  /  
//     /:/  /       \:\__\        \:\__\       /:/  /   
//     \/__/         \/__/         \/__/       \/__/    
//
// Statistical Package for the Trading Sciences by Steversteves///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SPTS is an open source, statistical package aimed at providing quick and accurate statistical analyses to traders and investors through the use of Pinescript.                                   //
// It brings statistical functions that are pivotal for traders and investors to analyze economic and stock trends from a mathmatical perspective.                                                  //  
// The aim is to build on the functionality of Pinescript, to allow for more advance, mathmatical analyses so that math based traders no longer need to rely on secondary software such as          //
// SPSS, R, SAS and/or Excel.                                                                                                                                                                       //
// This package acts as a stand-alone indicator for analysis, as well as a repository and library for other coders to utilize, build upon and improve.                                              //
// If you would like to collaborate on this project in bringing more statistical functionality to Pinescript, feel free to reach out on Tradingview!                                                //
// Thanks for checking this out :-).                                                                                                                                                                //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Made for:                                                                                                                                                               
//                                        ((                                      
//                                      (((((                                     
//                                    (((((((((                                   
//                                  (((((((((((((                                 
//                                 ((((((((((((((((                               
//                               ((((((((((((((((((((                             
//                             (((((     (((((((((((((                            
//                            ((((        ((((((((((((((                          
//                               #########   ((   (((                             
//                           ################       ####                          
//                          ##################    #######                         
//                        #################################                       
//                      #####################################                                          
//                      _____ _                     _     _   
//                      |  _  |_|___ ___ ___ ___ ___|_|___| |_ 
//                      |   __| |   | -_|_ -|  _|  _| | . |  _|
//                      |__|  |_|_|_|___|___|___|_| |_|  _|_|  
//                                                    |_|   
// Â© Steversteves

//@version=5
indicator("Statistical Package for the Trading Sciences [SS]", shorttitle = "SPTS [SS]", max_bars_back = 5000)

import Steversteves/SPTS_StatsPakLib/4 as spts 
// Groups 
g0 = "Analysis Type"
g1 = "Correlation and T-Test Assessments"
g2 = "If Multiple Regression Assessments Add Second Ticker:"
g3 = "ARIMA Model Inputs"
g4 = "Forecasting"
g5 = "ANOVA" 

start_time =    input.time(timestamp("20 Jul 2022 00:00 +000"), title = "Start time", confirm = true)
end_time =      input.time(timestamp("20 Jul 2022 00:00 +000"), title = "End time", confirm = true)
typ =           input.string("One Tailed T-Test", "Select the type of Analysis you wish to Perform", ["One Tailed T-Test", "Paired Sample T-Test", "Two Tailed T-Test", "Pearson Correlation", "Curvlinear (Quadratic) Correlation", "R Squared", "Linear Regression", "Multiple Regression", "Quadratic Regression", "Test Normality (Y Variable)", "ARIMA", "Forecast", "3 Group ANOVA"], group = g0)


// Correlations 
t1_in =         input.symbol("", "Dependent Variable (Y)", group = g1)
t2_in =         input.symbol("AMEX:DIA", "Independent Variable 1 (X1)", group = g1)
//Regressions 
t3_in =         input.symbol("", "Independent Variable 2 (X2)", group = g2) 
// ARIMA 
arima_src =     input.source(close, "ARIMA Source", group=g3)
arima_typ =     input.string("EMA", "ARIMA Type", ["EMA", "SMA"], group=g3)
ema_len =       input.int(200, "EMA/SMA Length")
cbands =        input.bool(false, "Plot Confidence Bands")
// Forecast 
forecast_src =  input.source(close, "Forecast Source", group = g4)
fore_train =    input.int(500, "Forecasting Train Time", group = g4)
for_len =       input.int(14, "Forecast Period", tooltip = "How many time periods do you want to forecast ?", group = g4, maxval = 25)
// ANOVA 
an_len =        input.int(500, "ANOVA Length", group = g5)
arr() => 
    array.new_float() 
sr(ticker) => 
    request.security(ticker, "", close, lookahead = barmerge.lookahead_on)

t1_cl = sr(t1_in) 
t2_cl = sr(t2_in) 
t3_cl = sr(t3_in)
t1_arr = arr() 
t2_arr = arr() 
// Colours 
color black = color.rgb(0, 0, 0) 
color white = color.white 

for i = 0 to 5000 
    if time[i] >= start_time and time[i] <= end_time 
        array.push(t1_arr, t1_cl[i])
        array.push(t2_arr, t2_cl[i]) 
// Define Table Parameters 
var table result_table = table.new(position.middle_right, 3, 9, bgcolor = black, frame_color = white, frame_width = 2)
/////////////////////////////////////////////////////// T-Tests ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// One Tailed T-Test:                                                                                                                                                                                                                               //
// A one-tailed t-test is used when you have a specific directional hypothesis and you want to test whether a sample mean is signficiantly greater than or less than a hypothesized population mean, but not both.                                  //
// It is appropraite when you are interested in detecting an effect in one direction and you want to maximize the power of your test by focusing on that direction, thereby increasing the sensitivity to detect                                    //
// the effect of interest while potentially sacrificing the ability to detect effects in the opposite direction.                                                                                                                                    //
// The advantage of using a t-test for comparing stocks include its simplicity and ease of interpretation and providing an alternative to the Pearson Correlation, making it accessible for many investors.                                         //
// However, a significant disavantage is its  assumption of normality, which may not hold for stock returns, and it doesn't account for factors like volatility and non-stationarity, limiting its applicability in complex financial analyses.     //
// A significant t-test in relation to stocks and economic data can be interpreted to mean there is strong evidence supporting a directional hypothesis. For example, if you hypothesize that returns on NVDA consistently outperform returns on    //
// SPX and the T-test is significant, your hypothesis is validated. This is something that a Pearson correlation is not fully capable of assessing directly.                                                                                        //
//                                                                                                                                                                                                                                                  //      
// Two Tailed T-Test:                                                                                                                                                                                                                               //
// The two tailed t-test is identical to the one tailed, however it looks at both directions. Thus, if there is a significance in either direction, it will register on the two-tailed assessment.                                                  //
// When you do not have a general hypothesis, it is reccomended to use the two-tailed test to identify significance, and then use the one tailed test to identify where that signifiance lies (in which direction).                                 //                                                                                                                                                                                                                  //
// Paired Sample T-Test                                                                                                                                                                                                                             //
// A paired sample t-test is used to compare the means of two related or paired sets of observations. It is tpyically applied when you have measurements or observations collected from the same                                                    //
// groups or entities under two different conditions or time points. The test assesses whether there is a significant difference between the paired observations, taking into account the inherent correlation                                      //
// between them. In Epidemiology and other statistical fields, it is often used to see if a treatment is more or less effective on one group vs. another group without the treatment.                                                               //
// In stock trading terms, a paired sample t-test SHOULD ONLY be used on tickers or indicies that are identical and track the same thing. For example, IWM and TNA or SPX and SPY.                                                                  //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// One tailed t-test function Tip for Repurposing //  
//                                                                                                                                                                          
// To use this function in your own code, you will need to push the two variables of interesst into an array. From there, the function will do the rest and pull the required information from the arrays. 
// It will export two variables, the t_stat (T-Statistic) and the df (Degrees of Freedom). So be sure to account for the exportaiton of the two variables, as shown below 

t_test(float[] array1, float[] array2) => 
    df = 0.0 
    t_stat = 0.0 
    avg1 = array.avg(array1) 
    stdev1 = array.stdev(array1)
    avg2 = array.avg(array2) 
    stdev2 = array.stdev(array2)  
    // Pooled Stdev 
    s1 = (array.size(array1) - 1) * math.pow(stdev1, 2)
    s2 = (array.size(array2) - 1) * math.pow(stdev2, 2) 
    s3 = (array.size(array1) + array.size(array2)) - 2 
    s4 = (s1 + s2) / s3 
    pol_stdev = math.sqrt(s4) 
    // T-Statistic 
    t1 = (avg1 - avg2) 
    t2 = (1 / array.size(array1)) + (1 / array.size(array2))
    t3 = math.sqrt(t2) 
    t4 = pol_stdev * t3 
    t_stat := t1 / t4 
    // degrees of freedom 
    df := (array.size(array1) + array.size(array2)) - 2 
    [t_stat, df]
    // End of function 


[t_statistic, degrees_freedom] = t_test(t1_arr, t2_arr)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Paired Sample T-Test Function Tips for Repurposing //
//
// UNlike the One Tailed T-Test, the Paired Sample T-Test function does not require you to push data into an array. There is an array input, however, but this is simply to determine the referencing length. 
// If you want to repurpose this function, simply replace the "Array" input with a "Length" input and remove the len = array.size(array) all-together. Unless you are using both the paired and one tailed in tandem, then 
// you can simply have the paired sample reference the array length of the one-tailed t-test. 
// This will output the t_statistic (T-Statistic) and the dfs (Degress of Freedom), similar to the one tailed test. 

paired_sample_t(src1, src2, array) => 
    t_static = 0.0 
    dfs = 0.0 
    dif = array.new_float() 
    len = array.size(array) 
    for i = 0 to len
        array.push(dif, src1[i] - src2[i]) 
    avg_dif = array.avg(dif) 
    stdev_dif = array.stdev(dif) 
    t1 = stdev_dif / math.sqrt(array.size(dif))
    t_static := avg_dif / t1 
    dfs := array.size(dif) - 1 
    [t_static, dfs]
    // End of function 

[paired_stat, paired_df] = paired_sample_t(t1_cl, t2_cl, t1_arr)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Two Tailed T-Test
// Similar to the one-tailed. You need to push the two variables you wish to analyze into an array. The rest remains the same! It will export the degress of freedom and the t-statistic.

two_tail_t_test(array1, array2) =>
    tstat = 0.0 
    df6 = 0.0 
    avg1 = array.avg(array1) 
    avg2 = array.avg(array2) 
    sd1 = array.stdev(array1) 
    sd2 = array.stdev(array2) 
    d1 = (avg1 - avg2) 
    d2 = (math.pow(sd1,2) / array.size(array1)) + (math.pow(sd2,2) / array.size(array2))
    d3 = math.sqrt(d2) 
    tstat := (d1 / d3) 
    //
    df1 = (math.pow(sd1,2) / array.size(array1))
    df2 = (math.pow(sd2,2) / array.size(array2))
    df3 = (df1 + df2) 
    df4 = math.pow(d3, 2)
    df5 = ((1/ array.size(array1)) * math.pow(df1, 2)) + ((1 / array.size(array2)) * math.pow(df2,2))
    df6 := df4 / df5 
    [tstat, df6]
    // End of function 

[tt, ttdf] = two_tail_t_test(t1_arr, t2_arr)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The T-table // 
// 
// The t-table is an integral part to interpreting the results of a t-stat. I have operationalized the t-table for use with a 1 or 2 tail test. 
// However, this t-table will not work for the paired sample t-test, as this is slightly more complex. 
// The t-table can be paired with your one or two-tailed t-test. It will perform the statistical significance assessment for you. It requires you to input the t-statistic (t_stat) and the degrees of freedom (df). 
// It will then export the p_value in string format, the explained implication (whether it is significant or not) and it will export a plotting color of either red or green dependending on the significance. 
// If you repurpose this, you can omit whichever variable you feel you do not need. 

t_table_analysis(t_stat, df) => 
    string p_value = na 
    string p_imp = na 
    color col = na 
    if df <= 1 and t_stat < 3.3 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 1 and t_stat >= 3.3 
        p_value := "p = 0.05"
        p_imp := "The results are significant."
    else if df > 1 and df <= 2 and t_stat < 2.9 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <=2 and df > 1 and t_stat >= 2.9 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 3 and df > 2 and t_stat < 2.3 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 3 and df > 2 and t_stat >= 2.3 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 4 and df > 3 and t_stat < 2.1 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <=4 and df > 3 and t_stat >= 2.1 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 5 and df > 4 and t_stat < 2
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 5 and df > 4 and t_stat >= 2 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 6 and df > 5 and t_stat < 1.9 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 6 and df > 5 and t_stat >= 1.9 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 7 and df > 6 and t_stat < 1.8 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 7 and df > 6 and t_stat >= 1.8 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 8 and df > 7 and t_stat < 1.8 // ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 8 and df > 7 and t_stat >= 1.8 // signific
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 9 and df > 8 and t_stat <1.82 // ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 9 and df > 8 and t_stat >= 1.82// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 10 and df > 9 and t_stat < 1.81// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 10 and df > 9 and t_stat >= 1.81// sig
        p_value := "p <= 0.05"
        p_imp := "The results are significant." 
    else if df <= 11 and df > 10 and t_stat < 1.79// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 11 and df > 10 and t_stat >= 1.79// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 12 and df > 11 and t_stat < 1.78 // ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 12 and df > 11 and t_stat >= 1.78// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 13 and df > 12 and t_stat < 1.77// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 13 and df > 12 and t_stat >= 1.77// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 14 and df > 13 and t_stat < 1.76// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 14 and df > 13 and t_stat >= 1.76// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 15 and df > 14 and t_stat < 1.75// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 15 and df > 13 and t_stat >= 1.75// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 16 and df > 15 and t_stat < 1.746// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 16 and df > 15 and t_stat >= 1.746// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 17 and df > 16 and t_stat < 1.74// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 17 and df > 16 and t_stat > 1.74 // sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 18 and df > 17 and t_stat < 1.73// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 18 and df > 17 and t_stat >= 1.73// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 19 and df > 18 and t_stat < 1.729 // ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 19 and df > 18 and t_stat >= 1.729 // sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 20 and df > 19  and t_stat < 1.725// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 20 and df > 19 and t_stat >= 1.725// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 21 and df > 20 and t_stat < 1.721 // ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 21 and df > 20 and t_stat >= 1.721// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 22 and df > 21 and t_stat < 1.717// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 22 and df > 21 and t_stat >= 1.717 // sig
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 23 and df > 22 and t_stat < 1.714 // ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 23 and df > 22 and t_stat >= 1.714// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 24 and df > 23 and t_stat < 1.711// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 24 and df > 23 and t_stat >= 1.711// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 25 and df > 24 and t_stat < 1.708// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 25 and df > 24  and t_stat >= 1.708// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 26 and df > 25 and t_stat < 1.706// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 26 and df > 25 and t_stat >= 1.706 // sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 27 and df > 26 and t_stat < 1.703// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 27 and df > 26 and t_stat >= 1.703// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 28 and df > 27 and t_stat < 1.701// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 28 and df > 27 and t_stat >= 1.701// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 29 and df > 28 and t_stat < 1.699// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 29 and df > 28 and t_stat >= 1.699// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 30 and df > 29 and t_stat < 1.697// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 30 and df > 29 and t_stat >= 1.697// sig
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 40 and df > 30 and t_stat < 1.684// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 40 and df > 30 and t_stat >= 1.684// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 60 and df > 40 and t_stat < 1.671 // ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 60 and df > 40 and t_stat >= 1.671 // sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 80 and df > 60 and t_stat < 1.664// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 80 and df > 60 and t_stat >= 1.664// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df <= 100 and df > 80 and t_stat < 1.660// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df <= 100 and df > 80 and t_stat >= 1.660// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    else if df > 100 and t_stat < 1.646// ns 
        p_value := "p > 0.05"
        p_imp := "The results are not significant."
        col := color.red 
    else if df > 100 and t_stat >= 1.646// sig 
        p_value := "p <= 0.05"
        p_imp := "The results are significant."
    [p_value, p_imp, col]
    // End of function 

// One Tailed 
[p, exp, t_col] = t_table_analysis(t_statistic, degrees_freedom)
// Two Tailed 
[tt_descriptives, tt_imp, tt_col] = t_table_analysis(tt, ttdf)
if typ == "Two Tailed T-Test" 
    table.cell(result_table, 1, 1, text = "T Statistic (Two Tailed)", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "T Statistic: " + str.tostring(math.round(tt,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Degrees of Freedom:  " + str.tostring(math.round(ttdf,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Significance:  " + str.tostring(tt_descriptives), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Result:  " + str.tostring(tt_imp), bgcolor = black, text_color = white)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// T-Table P-Value
// This function will return the p value for your t-test as a float variable. 
// It has been programmed with the parameters of a t-est table so you can implement this in tandem with the t-est, so the user will not need to manually reference a t-test table. 

t_table_p_value(df, t_stat)=>  
    sig = 0.0
    a1 = array.from(0.000, 1.000, 1.376, 1.963, 3.078, 6.314, 12.71, 31.82, 63.66, 318.31, 636.62)
    a2 = array.from(0.000, 0.816, 1.061, 1.386, 1.886, 2.920, 4.303, 6.965, 9.925, 22.327, 31.599)
    a3 = array.from( 0.000, 0.765, 0.978, 1.250, 1.638, 2.353, 3.182, 4.541, 5.841, 10.215, 12.924)
    search_arr = array.from( 0.000, 0.741, 0.941, 1.190, 1.533, 2.132, 2.776, 3.747, 4.604, 7.173, 8.610)
    search_arr1 = array.from(0.000, 0.727, 0.920, 1.156, 1.476, 2.015, 2.571, 3.365, 4.032, 5.893, 6.869)
    search_arr2 = array.from( 0.000, 0.718, 0.906, 1.134, 1.440, 1.943, 2.447, 3.143, 3.707, 5.208, 5.959)
    search_arr3 = array.from( 0.000, 0.711, 0.896, 1.119, 1.415, 1.895, 2.365, 2.998, 3.499, 4.785, 5.408)
    search_arr4 = array.from(0.000, 0.706, 0.889, 1.108, 1.397, 1.860, 2.306, 2.896, 3.355, 4.501, 5.041)
    search_arr5 = array.from(0.000, 0.703, 0.883, 1.100, 1.383, 1.833, 2.262, 2.821, 3.250, 4.297, 4.781)
    search_arr6 = array.from(0.000, 0.700, 0.879, 1.093, 1.372, 1.812, 2.228, 2.764, 3.169, 4.144, 4.587)
    search_arr7 = array.from( 0.000, 0.687, 0.860, 1.064, 1.325, 1.725, 2.086, 2.528, 2.845, 3.552, 3.850)
    search_arr8 = array.from(0.000, 0.683, 0.854, 1.055, 1.310, 1.697, 2.042, 2.457, 2.750, 3.385, 3.646)
    search_arr9 = array.from(0.000, 0.681, 0.851, 1.050, 1.303, 1.684, 2.021, 2.423, 2.704, 3.307, 3.551)
    search_arr10 = array.from(0.000, 0.679, 0.848, 1.045, 1.296, 1.671, 2.000, 2.390, 2.660, 3.232, 3.460)
    search_arr11 = array.from(0.000, 0.678, 0.846, 1.043, 1.292, 1.664, 1.990, 2.374, 2.639, 3.195, 3.416)
    search_arr12 = array.from(0.000, 0.677, 0.845, 1.042, 1.290, 1.660, 1.984, 2.364, 2.626, 3.174, 3.390)
    search_arr13 = array.from( 0.000, 0.675, 0.842, 1.037, 1.282, 1.646, 1.962, 2.330, 2.581, 3.098, 3.300)
    if df <= 1 
        sig := t_stat <= array.get(a1, 0) ? 0.5 : t_stat <= array.get(a1, 1) ? 0.25 : t_stat <= array.get(a1, 2) ? 0.20 : t_stat <= array.get(a1, 3) ? 0.15 : t_stat <= array.get(a1, 4) ? 0.10 : t_stat <= array.get(a1, 5) ? 0.05 : t_stat <= array.get(a1, 6) ? 0.025 : t_stat <= array.get(a1, 7) ? 0.01 : t_stat <= array.get(a1, 8) ? 0.005 : t_stat <= array.get(a1, 9) ? 0.001 : t_stat >= array.get(a1, 10) ? 0.0005 : na
    else if df <= 2 and df > 1
        sig := t_stat <= array.get(a2, 0) ? 0.5 : t_stat <= array.get(a2, 1) ? 0.25 : t_stat <= array.get(a2, 2) ? 0.20 : t_stat <= array.get(a2, 3) ? 0.15 : t_stat <= array.get(a2, 4) ? 0.10 : t_stat <= array.get(a2, 5) ? 0.05 : t_stat <= array.get(a2, 6) ? 0.025 : t_stat <= array.get(a2, 7) ? 0.01 : t_stat <= array.get(a2, 8) ? 0.005 : t_stat <= array.get(a2, 9) ? 0.001 : t_stat >= array.get(a2, 10) ? 0.0005 : na
    else if df <= 3 and df > 2 
        sig := t_stat <= array.get(a3, 0) ? 0.5 : t_stat <= array.get(a3, 1) ? 0.25 : t_stat <= array.get(a3, 2) ? 0.20 : t_stat <= array.get(a3, 3) ? 0.15 : t_stat <= array.get(a3, 4) ? 0.10 : t_stat <= array.get(a3, 5) ? 0.05 : t_stat <= array.get(a3, 6) ? 0.025 : t_stat <= array.get(a3, 7) ? 0.01 : t_stat <= array.get(a3, 8) ? 0.005 : t_stat <= array.get(a3, 9) ? 0.001 : t_stat >= array.get(a3, 10) ? 0.0005 : na
    else if df <= 4 and df > 3 
        sig := t_stat <= array.get(search_arr, 0) ? 0.5 : t_stat <= array.get(search_arr, 1) ? 0.20 : t_stat <= array.get(search_arr, 2) ? 0.25 : t_stat <= array.get(search_arr, 3) ? 0.15 : t_stat <= array.get(search_arr, 4) ? 0.10 : t_stat <= array.get(search_arr, 5) ? 0.05 : t_stat <= array.get(search_arr, 6) ? 0.025 : t_stat <= array.get(search_arr, 7) ? 0.01 : t_stat <= array.get(search_arr, 8) ? 0.005 : t_stat <= array.get(search_arr, 9) ? 0.001 : t_stat >= array.get(search_arr, 10) ? 0.0005 : 1
    else if df <= 5 and df > 4 
        sig := t_stat <= array.get(search_arr1, 0) ? 0.5 : t_stat <= array.get(search_arr1, 1) ? 0.20 : t_stat <= array.get(search_arr1, 2) ? 0.25 : t_stat <= array.get(search_arr1, 3) ? 0.15 : t_stat <= array.get(search_arr1, 4) ? 0.10 : t_stat <= array.get(search_arr1, 5) ? 0.05 : t_stat <= array.get(search_arr1, 6) ? 0.025 : t_stat <= array.get(search_arr1, 7) ? 0.01 : t_stat <= array.get(search_arr1, 8) ? 0.005 : t_stat <= array.get(search_arr1, 9) ? 0.001 : t_stat >= array.get(search_arr1, 10) ? 0.0005 : 1
    else if df <= 6 and df > 5 
        sig := t_stat <= array.get(search_arr2, 0) ? 0.5 : t_stat <= array.get(search_arr2, 1) ? 0.20 : t_stat <= array.get(search_arr2, 2) ? 0.25 : t_stat <= array.get(search_arr2, 3) ? 0.15 : t_stat <= array.get(search_arr2, 4) ? 0.10 : t_stat <= array.get(search_arr2, 5) ? 0.05 : t_stat <= array.get(search_arr2, 6) ? 0.025 : t_stat <= array.get(search_arr2, 7) ? 0.01 : t_stat <= array.get(search_arr2, 8) ? 0.005 : t_stat <= array.get(search_arr2, 9) ? 0.001 : t_stat >= array.get(search_arr2, 10) ? 0.0005 : 1
    else if df <= 7 and df > 6 
        sig := t_stat <= array.get(search_arr3, 0) ? 0.5 : t_stat <= array.get(search_arr3, 1) ? 0.20 : t_stat <= array.get(search_arr3, 2) ? 0.25 : t_stat <= array.get(search_arr3, 3) ? 0.15 : t_stat <= array.get(search_arr3, 4) ? 0.10 : t_stat <= array.get(search_arr3, 5) ? 0.05 : t_stat <= array.get(search_arr3, 6) ? 0.025 : t_stat <= array.get(search_arr3, 7) ? 0.01 : t_stat <= array.get(search_arr3, 8) ? 0.005 : t_stat <= array.get(search_arr3, 9) ? 0.001 : t_stat >= array.get(search_arr3, 10) ? 0.0005 : 1
    else if df <= 8 and df > 7
        sig := t_stat <= array.get(search_arr4, 0) ? 0.5 : t_stat <= array.get(search_arr4, 1) ? 0.20 : t_stat <= array.get(search_arr4, 2) ? 0.25 : t_stat <= array.get(search_arr4, 3) ? 0.15 : t_stat <= array.get(search_arr4, 4) ? 0.10 : t_stat <= array.get(search_arr4, 5) ? 0.05 : t_stat <= array.get(search_arr4, 6) ? 0.025 : t_stat <= array.get(search_arr4, 7) ? 0.01 : t_stat <= array.get(search_arr4, 8) ? 0.005 : t_stat <= array.get(search_arr4, 9) ? 0.001 : t_stat >= array.get(search_arr4, 10) ? 0.0005 : 1
    else if df <= 9 and df > 8
        sig := t_stat <= array.get(search_arr5, 0) ? 0.5 : t_stat <= array.get(search_arr5, 1) ? 0.20 : t_stat <= array.get(search_arr5, 2) ? 0.25 : t_stat <= array.get(search_arr5, 3) ? 0.15 : t_stat <= array.get(search_arr5, 4) ? 0.10 : t_stat <= array.get(search_arr5, 5) ? 0.05 : t_stat <= array.get(search_arr5, 6) ? 0.025 : t_stat <= array.get(search_arr5, 7) ? 0.01 : t_stat <= array.get(search_arr5, 8) ? 0.005 : t_stat <= array.get(search_arr5, 9) ? 0.001 : t_stat >= array.get(search_arr5, 10) ? 0.0005 : 1
    else if df <= 10 and df > 9 
        sig := t_stat <= array.get(search_arr6, 0) ? 0.5 : t_stat <= array.get(search_arr6, 1) ? 0.20 : t_stat <= array.get(search_arr6, 2) ? 0.25 : t_stat <= array.get(search_arr6, 3) ? 0.15 : t_stat <= array.get(search_arr6, 4) ? 0.10 : t_stat <= array.get(search_arr6, 5) ? 0.05 : t_stat <= array.get(search_arr6, 6) ? 0.025 : t_stat <= array.get(search_arr6, 7) ? 0.01 : t_stat <= array.get(search_arr6, 8) ? 0.005 : t_stat <= array.get(search_arr6, 9) ? 0.001 : t_stat >= array.get(search_arr6, 10) ? 0.0005 : 1
    else if df <= 20 and df > 10 
        sig := t_stat <= array.get(search_arr7, 0) ? 0.5 : t_stat <= array.get(search_arr7, 1) ? 0.20 : t_stat <= array.get(search_arr7, 2) ? 0.25 : t_stat <= array.get(search_arr7, 3) ? 0.15 : t_stat <= array.get(search_arr7, 4) ? 0.10 : t_stat <= array.get(search_arr7, 5) ? 0.05 : t_stat <= array.get(search_arr7, 6) ? 0.025 : t_stat <= array.get(search_arr7, 7) ? 0.01 : t_stat <= array.get(search_arr7, 8) ? 0.005 : t_stat <= array.get(search_arr7, 9) ? 0.001 : t_stat >= array.get(search_arr7, 10) ? 0.0005 : 1
    else if df <= 30 and df > 20 
        sig := t_stat <= array.get(search_arr8, 0) ? 0.5 : t_stat <= array.get(search_arr8, 1) ? 0.20 : t_stat <= array.get(search_arr8, 2) ? 0.25 : t_stat <= array.get(search_arr8, 3) ? 0.15 : t_stat <= array.get(search_arr8, 4) ? 0.10 : t_stat <= array.get(search_arr8, 5) ? 0.05 : t_stat <= array.get(search_arr8, 6) ? 0.025 : t_stat <= array.get(search_arr8, 7) ? 0.01 : t_stat <= array.get(search_arr8, 8) ? 0.005 : t_stat <= array.get(search_arr8, 9) ? 0.001 : t_stat >= array.get(search_arr8, 10) ? 0.0005 : 1
    else if df <= 40 and df > 30 
        sig := t_stat <= array.get(search_arr9, 0) ? 0.5 : t_stat <= array.get(search_arr9, 1) ? 0.20 : t_stat <= array.get(search_arr9, 2) ? 0.25 : t_stat <= array.get(search_arr9, 3) ? 0.15 : t_stat <= array.get(search_arr9, 4) ? 0.10 : t_stat <= array.get(search_arr9, 5) ? 0.05 : t_stat <= array.get(search_arr9, 6) ? 0.025 : t_stat <= array.get(search_arr9, 7) ? 0.01 : t_stat <= array.get(search_arr9, 8) ? 0.005 : t_stat <= array.get(search_arr9, 9) ? 0.001 : t_stat >= array.get(search_arr9, 10) ? 0.0005 : 1
    else if df <= 60 and df > 40 
        sig := t_stat <= array.get(search_arr10, 0) ? 0.5 : t_stat <= array.get(search_arr10, 1) ? 0.20 : t_stat <= array.get(search_arr10, 2) ? 0.25 : t_stat <= array.get(search_arr10, 3) ? 0.15 : t_stat <= array.get(search_arr10, 4) ? 0.10 : t_stat <= array.get(search_arr10, 5) ? 0.05 : t_stat <= array.get(search_arr10, 6) ? 0.025 : t_stat <= array.get(search_arr10, 7) ? 0.01 : t_stat <= array.get(search_arr10, 8) ? 0.005 : t_stat <= array.get(search_arr10, 9) ? 0.001 : t_stat >= array.get(search_arr10, 10) ? 0.0005 : 1
    else if df <= 80 and df > 60 
        sig := t_stat <= array.get(search_arr11, 0) ? 0.5 : t_stat <= array.get(search_arr11, 1) ? 0.20 : t_stat <= array.get(search_arr11, 2) ? 0.25 : t_stat <= array.get(search_arr11, 3) ? 0.15 : t_stat <= array.get(search_arr11, 4) ? 0.10 : t_stat <= array.get(search_arr11, 5) ? 0.05 : t_stat <= array.get(search_arr11, 6) ? 0.025 : t_stat <= array.get(search_arr11, 7) ? 0.01 : t_stat <= array.get(search_arr11, 8) ? 0.005 : t_stat <= array.get(search_arr11, 9) ? 0.001 : t_stat >= array.get(search_arr11, 10) ? 0.0005 : 1
    else if df <= 100 and df > 80 
        sig := t_stat <= array.get(search_arr12, 0) ? 0.5 : t_stat <= array.get(search_arr12, 1) ? 0.20 : t_stat <= array.get(search_arr12, 2) ? 0.25 : t_stat <= array.get(search_arr12, 3) ? 0.15 : t_stat <= array.get(search_arr12, 4) ? 0.10 : t_stat <= array.get(search_arr12, 5) ? 0.05 : t_stat <= array.get(search_arr12, 6) ? 0.025 : t_stat <= array.get(search_arr12, 7) ? 0.01 : t_stat <= array.get(search_arr12, 8) ? 0.005 : t_stat <= array.get(search_arr12, 9) ? 0.001 : t_stat >= array.get(search_arr12, 10) ? 0.0005 : 1
    else if df > 100 
        sig := t_stat <= array.get(search_arr13, 0) ? 0.5 : t_stat <= array.get(search_arr13, 1) ? 0.25 : t_stat <= array.get(search_arr13, 2) ? 0.25 : t_stat <= array.get(search_arr13, 3) ? 0.15 : t_stat <= array.get(search_arr13, 4) ? 0.10 : t_stat <= array.get(search_arr13, 5) ? 0.05 : t_stat <= array.get(search_arr13, 6) ? 0.025 : t_stat <= array.get(search_arr13, 7) ? 0.01 : t_stat <= array.get(search_arr13, 8) ? 0.005 : t_stat <= array.get(search_arr13, 9) ? 0.001 : t_stat >= array.get(search_arr13, 10) ? 0.0005 : 1
    else 
        sig := 1
    // End of function 

one_tailed_p_value = t_table_p_value(degrees_freedom, t_statistic) 
two_tailed_p_value = t_table_p_value(ttdf, tt)

if typ == "One Tailed T-Test"
    table.cell(result_table, 1, 6, text = "P Value:  " + str.tostring(one_tailed_p_value), bgcolor = black, text_color = white)
if typ == "Two Tailed T-Test"
    table.cell(result_table, 1, 6, text = "P Value:  " + str.tostring(one_tailed_p_value), bgcolor = black, text_color = white)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// T-Table Bell Curve// 

// Colours 
grayfill = color.gray 
greenfill = color.lime 
redfill = color.new(color.red, 55)
purple = color.new(color.purple, 55)
blackfill = color.new(color.rgb(0, 0, 0), 85)
color transp = color.new(color.white, 100)

// Colour function for t-test table 
f_tcolor(sig, typ) =>
    color sigcolor = na 
    color generic = na 
    color sigcolor2 = na 
    color bordercol = na 

    if sig == "The results are significant." and typ == "Two Tailed T-Test"
        sigcolor:= purple  
        sigcolor2 := purple
        generic := grayfill
        bordercol := grayfill 
    else if sig == "The results are not significant." and typ == "Two Tailed T-Test"  
        sigcolor := grayfill 
        generic := purple  
        sigcolor2 := grayfill 
        bordercol := grayfill
    else if sig == "The results are significant." and typ == "One Tailed T-Test"
        sigcolor := purple 
        generic := grayfill
        sigcolor2 := grayfill
        bordercol := grayfill 
    else if sig == "The results are not significant." and typ == "One Tailed T-Test" 
        sigcolor := grayfill
        generic := purple 
        sigcolor2 := grayfill
        bordercol := grayfill 
    else
        sigcolor := purple 
        generic := grayfill 
        sigcolor2 := grayfill
        bordercol := grayfill  
    [sigcolor, generic, sigcolor2, bordercol]


string t_sign = na 
string t_type = na 

if typ == "One Tailed T-Test" 
    t_type := "One Tailed T-Test"  
    t_sign := exp 
if typ == "Two Tailed T-Test"
    t_type := "Two Tailed T-Test" 
    t_sign := tt_imp


[t_sig_col, t_generic, t_sig_col2, t_border] = f_tcolor(t_sign, t_type)

var box box1 = na 
var box box2 = na 
var box box3 = na 
var box box4 = na 
var box box5 = na 
var box box6 = na 
var box box7 = na 
var box box8 = na 
var box box9 = na 
var box box10 = na 
var box box11 = na
var box box12 = na 
var box box13 = na 

if typ == "One Tailed T-Test" or typ == "Two Tailed T-Test" and barstate.isconfirmed
    box.delete(box1) 
    box.delete(box2) 
    box.delete(box3) 
    box.delete(box4) 
    box.delete(box5) 
    box.delete(box6) 
    box.delete(box7) 
    box.delete(box8) 
    box.delete(box9) 
    box.delete(box10) 
    box.delete(box11) 
    box.delete(box12) 
    box.delete(box13) 
    box1 := box.new(bar_index[20], 1, bar_index[19], 0, bgcolor = t_sig_col, border_color = t_sig_col) 
    box2 := box.new(bar_index[19], 2, bar_index[18], 1, bgcolor = t_generic,  border_color = t_border)
    box3 := box.new(bar_index[18], 3, bar_index[17], 2, bgcolor = t_generic,  border_color = t_border)  
    box4 := box.new(bar_index[17], 4, bar_index[16], 3, bgcolor = t_generic,  border_color = t_border) 
    box5 := box.new(bar_index[16], 5, bar_index[15], 4, bgcolor = t_generic,  border_color = t_border) 
    box6 := box.new(bar_index[15], 6, bar_index[14], 5, bgcolor = t_generic,  border_color = t_border)
    box7 := box.new(bar_index[14], 5, bar_index[13], 4, bgcolor = t_generic, border_color = t_border)
    box8 := box.new(bar_index[13], 4, bar_index[12], 3, bgcolor = t_generic, border_color = t_border) 
    box9 := box.new(bar_index[12], 3, bar_index[11], 2, bgcolor = t_generic,  border_color = t_border) 
    box10 := box.new(bar_index[11], 2, bar_index[10], 1, bgcolor = t_generic, border_color = t_border)
    box11 := box.new(bar_index[10], 1, bar_index[9], 0, bgcolor = t_sig_col2, border_color = t_border)

    box12 := box.new(bar_index[14], 3, bar_index[15], 1, bgcolor = t_generic,  border_color = t_border)
    box13 := box.new(bar_index[17], 1, bar_index[12], 0,  bgcolor = t_generic,  border_color = t_border)

var label lbl1 = na 
var label lbl2 = na 
var label lbl3 = na 
var label lbl4 = na 
var label lbl5 = na 
if typ == "One Tailed T-Test" or typ == "Two Tailed T-Test" and barstate.isconfirmed
    label.delete(lbl1)
    label.delete(lbl2) 
    label.delete(lbl3) 
    label.delete(lbl4) 
    label.delete(lbl5) 
    if t_type == "One Tailed T-Test" and t_sign == "The results are significant." 
        lbl1 := label.new(bar_index[20], y = -1, text = "t-stat = " + str.tostring(math.round(t_statistic,2)), color = transp, style = label.style_label_down, textcolor = white)
    if t_type == "Two Tailed T-Test" and t_sign == "The results are significant." 
        lbl1 := label.new(bar_index[20], y = -1, text = "t-stat = " + str.tostring(math.round(tt,2)), color = transp, style = label.style_label_down, textcolor = white)
    if t_type == "One Tailed T-Test" and t_sign == "The results are not significant." 
        lbl3 := label.new(bar_index[15], y = -1, text = "t-stat = " + str.tostring(math.round(t_statistic,2)), color = transp, style = label.style_label_down, textcolor = white)
    if t_type == "Two Tailed T-Test" and t_sign == "The results are not significant." 
        lbl4 := label.new(bar_index[15], y = -1, text = "t-stat = " + str.tostring(math.round(tt,2)), color = transp, style = label.style_label_down, textcolor = white)
    if t_type == "Two Tailed T-Test" and t_sign == "The results are significant." 
        lbl5 := label.new(bar_index[10], y = -1, text = "t-stat = " + str.tostring(math.round(tt,2)), color = transp, style = label.style_label_down, textcolor = white)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Cor of Array Function // 
// 
// This function allows you to quickly calculate the Pearson Correlation Coefficient of 2 arrays. 
// Simply add this function to your script and input the 2 arrays you wish to obtain the correlation for. The function will return a p_cor value, which is your pearson correlation.
// Simple as 1, 2, 3 :-). 

cor_of_array(array1, array2) => 
    array1_stdev = array.stdev(array1) 
    array2_stdev = array.stdev(array2) 
    cov = array.covariance(array1, array2) 
    p_cor = cov / (array1_stdev * array2_stdev) 
    // end of function 
    

cor = cor_of_array(t1_arr, t2_arr) 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Quadratic Correlation // 
// 
// This function calculates a quadratic or curvlinear correlation. Essentially, all it is, is the correlation taken to the power of 2. 
// This does not require an array. Simply input the two sources you wish to correlate. However, again, I have used the input array here soly as to reference the length of the correlation assesmsnent. 
// If you are repurposing this in your own script, remove the array input and replace it with "len" input for length. 

quadratic_correlation(src1, src2, array) => 
    x = array.new_float() 
    y = array.new_float() 
    a3 = array.new_float() 
    a4 = array.new_float() 
    len = array.size(array) 
    for i = 0 to len 
        array.push(x, src2[i] * math.pow(src2[i], 2)) 
        array.push(y, src1[i])
    x_sd = array.stdev(x) 
    y_sd = array.stdev(y) 
    xy_cov = array.covariance(x, y)
    q_cor = xy_cov / (x_sd * y_sd) 
    // End of function 


curvlinear_correlation = quadratic_correlation(t1_cl, t2_cl, t1_arr) 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Pearson Correlation Table // 
//
// This function simply determines the qualitative significance of a pearson correlation. It will plot it out, qualitatively, as a string variable. 
// You can use this as a companion for your pearson or curvlinear correlations to give the user a qualitative explanation of the meaning of the correlation. 
// It will also return an explanation and a colour based on the strength of the correlation assessment. 

    
pearson_cor_table(cor_result) => 
    string xp = na 
    color cor_color = na 
    if cor_result < 0.5 and cor_result > -0.5 
        xp := "Results are not significant."
        cor_color := color.red 
    else if cor_result >= 0.5 and cor_result < 0.8 or cor_result <= -0.5 and cor_result > -0.8 
        xp := "Results are moderately signficiant."
        cor_color := color.orange 
    else if cor_result >= 0.8 or cor_result <= -0.8 
        xp := "Results are highly significant."
        cor_color:= color.lime 
    [xp, cor_color]
    // End of Function 


[p_linear_sig, lin_col] = pearson_cor_table(cor)
[p_quad_sig, quad_col] = pearson_cor_table(curvlinear_correlation)


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Plot Functions 
plot(typ == "Paired Sample T-Test" ? paired_stat : na, "Paired T-Test")
plot(typ == "Paired Sample T-Test" ? paired_df : na, "Paired T-Test DF")
plot(typ == "Pearson Correlation" ? cor : na, "Pearson Correlation", color=lin_col, linewidth=3)
plot(typ == "Curvlinear (Quadratic) Correlation" ? curvlinear_correlation : na, "Quadratic Correlation", color=quad_col, linewidth=3)

var string p_res = na 
var string exo_res = na 

if typ == "One Tailed T-Test"
    p_res := p
    exo_res := exp 

if typ == "Paired Sample T-Test"
    p_res := "No Results for Paired Sample."
    exo_res := "No Results for Paired Sample."


if typ == "One Tailed T-Test" 
    table.cell(result_table, 1, 1, text = "T-Test (One-Tailed)", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "T Statistic: " + str.tostring(math.round(t_statistic,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Degrees of Freedom:  " + str.tostring(math.round(degrees_freedom,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Significance:  " + str.tostring(p_res), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Result:  " + str.tostring(exo_res), bgcolor = black, text_color = white)
if typ == "Paired Sample T-Test" 
    table.cell(result_table, 1, 1, text = "T-Test (Paired Sample)", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "T Statistic: " + str.tostring(math.round(t_statistic,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Degrees of Freedom:  " + str.tostring(math.round(degrees_freedom,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Significance:  " + str.tostring(p_res), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Result:  " + str.tostring(exo_res), bgcolor = black, text_color = white)
if typ == "Pearson Correlation"
    table.cell(result_table, 1, 1, text = "Pearson Correlation (Linear)", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "Variable 1:  " + str.tostring(t1_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Variable 2:  " + str.tostring(t2_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Significance:  " + str.tostring(math.round(cor,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Result:  " + str.tostring(p_linear_sig), bgcolor = black, text_color = white)

if typ == "Curvlinear (Quadratic) Correlation"
    table.cell(result_table, 1, 1, text = "Pearson Correlation (Quadratic)", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "Variable 1:  " + str.tostring(t1_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Variable 2:  " + str.tostring(t2_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Significance:  " + str.tostring(math.round(curvlinear_correlation,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Result:  " + str.tostring(p_quad_sig), bgcolor = black, text_color = white)
    
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// R-Squared Function //////////////////////////////////////////////////////////////////////////////////////////
// The R-Squared, AKA the coefficient of determination, measures the proportion of the variance in the dependent variable       //
// that is explained by the independent variable in a regression model. It ranges from 0 to 1, with higher values indicating    //
// a better fit of the model to the data. Specifically, it represents the proportion of the total variation in the dependent    // 
// variable that is captured by the regression model, and its often used to assess the goodness of fit of the model.            // 
// It can be roughly calculated as is in the funciton below, which is simply taking the pearson correlation and putting it      // 
// to the power of 2. However, if you want to calculate the full regression model with R2, you can refer to the regression      //
// functions below.                                                                                                             //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

f_r_sqr(array1, array2) => 
    array1_stdev = array.stdev(array1) 
    array2_stdev = array.stdev(array2) 
    cov = array.covariance(array1, array2) 
    pp_cor = cov / (array1_stdev * array2_stdev) 
    res = math.pow(pp_cor, 2)
    // End of Function 

r_squared = f_r_sqr(t1_arr, t2_arr)

r_squared_color(rsqrd_input) => 
    color bad = color.red 
    color ok = color.orange 
    color good = color.lime 
    color rsqrd_color = na 
    if rsqrd_input < 0.5 
        rsqrd_color := bad 
    else if rsqrd_input > 0.5 and rsqrd_input < 0.8
        rsqrd_color := ok 
    else if rsqrd_input > 0.8 
        rsqrd_color := good 
r2_color = r_squared_color(r_squared)
plot(typ == "R Squared" ? r_squared : na, color = r2_color, linewidth=3)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////// Multiple Regression Function ////////////////////////////////////////////////////////////////////////////////////////
// Multiple regression analysis is a statistical technique used to analyze the relationship between a dependent variable and two        //
// or more independent variables. It helps identify how these independent variables collectively influence or predict the variations    //
// in the dependent variable.                                                                                                           //
// The function will return the result of the regression (result), as well as the R squared value (rsqrd), the pearson correlation      //
// (pear_cor) and the standard error of assessment (std_err) along with the coefficients and intercept. This does not require an array for input. It just requires 2 independent  //
// and 1 dependent source inputs to perform the analysis. The array value is used for length determination. If you are using sourced    //
// data from outside an array, you can replace the array argument with a "length" argument.                                             //
// Y = dependent.                                                                                                                       //
// x1 = Independent 1 & X2 = Independent 2                                                                                              //
// input1 = x1 input and input2 = x2 input for future regressions.                                                                      //
// array = length                                                                                                                       //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
f_multiple_regression(y, x1, x2, input1, input2, array) =>
    result = 0.0 
    rsqrd = 0.0 
    pear_cor = 0.0 
    std_err = 0.0 
    b1 = 0.0 
    b2 = 0.0 
    b0 = 0.0 

    x1_sq = array.new_float() 
    x2_sq = array.new_float() 
    x1_array = array.new_float() 
    x2_array = array.new_float() 
    x1_y = array.new_float() 
    x2_y = array.new_float() 
    x1_x2 = array.new_float() 
    y_array = array.new_float() 
    len = array.size(array)


    for i = 0 to len 
        array.push(x1_sq, (x1[i] * x1[i]))
        array.push(x2_sq, (x2[i] * x2[i]))
        array.push(x1_array, x1[i]) 
        array.push(x2_array, x2[i])
        array.push(x1_y, (x1[i] * y[i]))
        array.push(x2_y, (x2[i] * y[i]))
        array.push(x1_x2, (x1[i] * x2[i])) 
        array.push(y_array, y[i]) 
    
    x1_sq_sum = array.sum(x1_sq) 
    x2_sq_sum = array.sum(x2_sq)
    x1_sum = array.sum(x1_array)
    x2_sum = array.sum(x2_array)
    x1_y_sum = array.sum(x1_y)
    x2_y_sum = array.sum(x2_y) 
    x1_x2_sum = array.sum(x1_x2) 
    y_sum = array.sum(y_array) 

    i1_x = x1_sq_sum - (math.pow(x1_sum, 2) / len) 
    i2_x = x2_sq_sum - (math.pow(x2_sum, 2) / len)
    i1_y = x1_y_sum - ((x1_sum * y_sum) / len)
    i2_y = x2_y_sum - ((x2_sum * y_sum) / len)

    ix1x2 = x1_x2_sum - ((x1_sum * x2_sum) / len)

    b1 := ((i2_x * i1_y) - (ix1x2 * i2_y)) / ((i1_x * i2_x) - math.pow(ix1x2, 2))
    b2 := ((i1_x * i2_y) - (ix1x2 * i1_y)) / ((i1_x * i2_x) - math.pow(ix1x2, 2))
    b0 := (y_sum / len) - (b1 * (x1_sum / len)) - (b2 * (x2_sum / len)) 

    result := (input1 * b1) + (input2 * b2) + b0 
    // Correlation 
    stdev1 = array.stdev(x1_x2)
    stdev2 = array.stdev(y_array)
    xy_cov = array.covariance(y_array, x1_x2)
    pear_cor := xy_cov / (stdev1 * stdev2) 
    // R2 
    rsqrd := math.pow(pear_cor,2)
    // Standard Error
    se_residuals = array.new_float() 
    for i = 0 to len 
        array.push(se_residuals, (result[i] - y[i]) * (result[i] - y[i]))
    se_add = array.sum(se_residuals) 
    r1 = se_add / (len - 2) 
    std_err := math.sqrt(r1) 
    [result, pear_cor, rsqrd, std_err, b1, b2, b0]
    // End of Function 

[mr, mr_cor, mr_rsqrd, mr_std_err, mr_b1, mr_b2, mr_b0] =f_multiple_regression(t1_cl, t2_cl, t3_cl, t2_cl, t3_cl, t1_arr) 

plot(typ == "Multiple Regression" ? mr : na, "Multiple Regression", linewidth=3)

if typ == "Multiple Regression"
    table.cell(result_table, 1, 1, text = "Multiple Regression", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "Dependent (Y): " + str.tostring(t1_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Independent (X1): " + str.tostring(t2_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Independent (X2): " + str.tostring(t3_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Equation: y= " + str.tostring(math.round(mr_b1,4)) + "x + " + str.tostring(math.round(mr_b2,2)) + "x + " + str.tostring(math.round(mr_b0)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 6, text = "Significance:  " + str.tostring(math.round(mr_cor,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 7, text = "R Squared:  " + str.tostring(math.round(mr_rsqrd,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 8, text = "Error:  " + str.tostring(math.round(mr_std_err,2)), bgcolor = black, text_color = white)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Linear Regression// 
// Similar to multiple regression; however, it uses only 1 independent variable.
// It will return the same as the multiple regression, the result, the pearson correlation, the R2, the slope, the intercept and the standard error assessment. 
// Again, array is used as an input for this function as a length determination. You can remove the array and substitute with a "Length" argument. 
// Independent = Y variable, dependent = x, array = len, variable = input source to calculate future regressions 

f_linear_regression(float independent, float dependent, array, float variable) =>
    result = 0.0 
    rsqrd = 0.0 
    pear_cor = 0.0 
    std_err = 0.0 
    slope = 0.0 
    intercept = 0.0 

    y_array = array.new_float() 
    y_sq_array = array.new_float() 
    x_array = array.new_float() 
    x_sq_array = array.new_float() 
    xy_array = array.new_float() 
    len = array.size(array) 

    // Loop functions
    for i = 0 to len
        array.push(y_array, dependent[i])
        array.push(y_sq_array, dependent[i] * dependent[i]) 
        array.push(x_array, independent[i])
        array.push(x_sq_array, independent[i] * independent[i]) 
        array.push(xy_array, independent[i] * dependent[i])
    
    // Regression Calculations 
    y = array.sum(y_array)
    y2 = array.sum(y_sq_array) 
    x = array.sum(x_array) 
    x2 = array.sum(x_sq_array)
    xy = array.sum(xy_array) 

    b1 = xy - (x * y) / len 
    bbb2 = x2 - (math.pow(x, 2) / len) 
    slope := (b1 / bbb2) 

    abc = y - (slope * x) 
    intercept := abc / len 

    result := (variable * slope) + intercept
     // Correlation 
    stdev1 = array.stdev(x_array)
    stdev2 = array.stdev(y_array)
    xy_cov = array.covariance(y_array, x_array)
    pear_cor := xy_cov / (stdev1 * stdev2) 
    // R2 
    rsqrd := math.pow(pear_cor,2)
    // Standard Error
    se_residuals = array.new_float() 
    for i = 0 to len 
        array.push(se_residuals, (result[i] - dependent[i]) * (result[i] - dependent[i]))
    se_add = array.sum(se_residuals) 
    r1 = se_add / (len - 2) 
    std_err := math.sqrt(r1) 
    [result, pear_cor, rsqrd, std_err, slope, intercept]
    // End of function 

[lin_reg, lin_reg_cor, lin_reg_r, lin_reg_err, lin_reg_slope, lin_reg_intercept] = f_linear_regression(t2_cl, t1_cl, t1_arr, t2_cl)

plot(typ == "Linear Regression" ? lin_reg : na, "Linear Regression", linewidth=3)
if typ == "Linear Regression"
    table.cell(result_table, 1, 1, text = "Linear Regression", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "Dependent (Y): " + str.tostring(t1_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Independent (X1): " + str.tostring(t2_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Significance:  " + str.tostring(math.round(lin_reg_cor,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Equation: y = " + str.tostring(math.round(lin_reg_slope,4)) + "x + " + str.tostring(math.round(lin_reg_intercept,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 6, text = "R Squared:  " + str.tostring(math.round(lin_reg_r,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 7, text = "Error:  " + str.tostring(math.round(lin_reg_err,2)), bgcolor = black, text_color = white)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test of Normality//
// This function will assess a dataset for up to 7 different distribution types. It will determine whether it is normally distributed or not, and return the most likely distribution based on the skewness and kurtosis. 
// The function returns 4 variables: the kurtosis (float), skewness (float), distribution (string) and the qualitative implication (string) 

test_of_normality(array, src) =>
    // Skewedness 
    float skew = 0.0 
    float kurt = 0.0 
    avga = array.avg(array)
    stdv = array.stdev(array)
    sum = math.pow(src - avga, 3)
    for i = 0 to array.size(array)
        sum := sum + math.pow(src[i] - avga, 3)
    skew := ((sum / array.size(array)) / math.pow(stdv, 3))
    // Kurtosis 
    avgb = array.avg(array)
    stdvb = array.stdev(array)
    sq_df = array.new_float() 
    for i = 0 to array.size(array) 
        array.push(sq_df, math.pow(src[i] - avgb, 4))
    sumb = array.sum(sq_df) 
    c = array.size(array) * math.pow(stdvb, 4)
    kurt := (sumb / c ) - 3

    // Assessment of the normal distribution 
    bool normal_dist = kurt >= -2 and kurt <= 2 and skew >= -1 and skew <= 1 
    bool leptokurtic = kurt > 2 and skew >= -1 and skew <= 1 
    bool platykurtic = kurt < -2 and skew >= -1 and skew <= 1 
    bool right_tailed = kurt >= -2 and kurt <= 2 and skew > 1 
    bool left_tailed = kurt >= -2 and kurt <= 2 and skew < -1 
    bool leptokurtic_heavy_right = kurt > 2 and skew > 1 
    bool platykurtic_heavy_left = kurt <-2 and skew < -1 

    string dist = na 
    string implication = na 

    if normal_dist 
        dist := "Normally Distributed"
        implication := "The Data is normally distributed, with a kurtosis of \n " + str.tostring(math.round(kurt,2)) + " and a skewness of " + str.tostring(math.round(skew,2)) + ". \n The data will respond well to most statistical measures and is highly predictable." 
    else if leptokurtic 
        dist := "Leptokurtic"
        implication := "The Data shows signs of being leptokurtic, with a kurtosis of \n" + str.tostring(math.round(kurt,2)) + " and a skewness of " + str.tostring(math.round(skew,2)) + " \n The data has heavier tails than a normal distribution but is symmetric. \n Extreme deviations in variations are to be expected."
    else if platykurtic 
        dist := "Platykurtic"
        implication := "The Data shows signs of being platykurtic, with a kurtosis of \n" + str.tostring(math.round(kurt,2)) + " and a skewness of " + str.tostring(math.round(skew,2)) + ". \n The data has lighter tails than a normal distribution but is symmetric. \n The data is less prone to extreme variations over time." 
    else if right_tailed 
        dist := "Positive, Right-tailed Distribution"
        implication := "The Data shows signs of a positive, right-tailed distribution, with a kurtosis of \n" + str.tostring(math.round(kurt,2)) + " and a skewness of " + str.tostring(math.round(skew,2)) + ". \n The data is skewed to the right which suggests extreme outliars. \n There is an over-arching, positive bias in the data \n indicating a greater likelihood of extreme variations to the upside." 
    else if left_tailed 
        dist := "Negative, Left-tailed Distribution"
        implication :=  "The Data shows signs of a negative, left-tailed distribution, with a kurtosis of \n" + str.tostring(math.round(kurt,2)) + " and a skewness of " + str.tostring(math.round(skew,2)) + ". \n The data is skewed to the left which suggests extreme outliers, \n there is an over-arching negative bias in the data \n indicating a greater likelihood of extreme variations to the downside."
    else if leptokurtic_heavy_right 
        dist := "Leptokurtic, heavy right tailed"
        implication := "The Data shows signs of a laeptokurtic distribution with heavier tails to the right, with a kurtosis of \n " + str.tostring(math.round(kurt,2)) + " and a skewness of " + str.tostring(math.round(skew,2)) + ". \n The data is heavily skewed to the right which suggests extreme outliers, \n the data is prone to sudden dramatic spikes to the upside and downside."
    else if platykurtic_heavy_left 
        dist := "Platykurtic, heavy left tailed"
        implication := "The Data shows signs of a platykurtic distribution with heavier tails to the left, with a kurtosis of \n" + str.tostring(math.round(kurt,2)) + " and a skewness of " + str.tostring(math.round(skew,2)) + ". \n The data is heavily skewed to the left which suggests extreme outliers, \n the data is prone to drops to the downside, but not overly extreme."
    else  
        dist := "Unable to determine." 
        implication := "The distribution is not normally distributed. \n Unable to determine the distribution type."

    // Output 
    [skew, kurt, dist, implication]
    // End of function 


[y_skew, y_kurt, y_dist, y_implication] = test_of_normality(t1_arr, t1_cl) 

if typ == "Test Normality (Y Variable)"
    table.cell(result_table, 1, 1, text = "Test of Normality", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "Dependent (Y): " + str.tostring(syminfo.ticker), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Distribution Type:  " + str.tostring(y_dist), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Kurtosis: " + str.tostring(math.round(y_kurt,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Skewedness:  " + str.tostring(math.round(y_skew,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 6, text = "Implications", bgcolor = black, text_color = white, text_valign=text.align_center)
    table.cell(result_table, 1, 7, text = str.tostring(y_implication), bgcolor = black, text_color = white, text_valign = text.align_center)
// Distribution Diagram 
// Function that plots out a typical normal, skewed, platykurtic or leptokurtic distribution. Soly for demonstration purposes. 
// It will return a plotted image. 
distribution_diagram(dist_type, showtype) => 
    if showtype == "Test Normality (Y Variable)"
        color fill = color.gray 
        var box box100 = na 
        var box box20 = na 
        var box box30 = na 
        var box box40 = na 
        var box box50 = na 
        var box box60 = na 
        var box box70 = na 
        var box box80 = na 
        var box box90 = na 
        var box box15 = na 
        if dist_type == "Normally Distributed" and barstate.isconfirmed 
            box.delete(box100) 
            box.delete(box20) 
            box.delete(box30) 
            box.delete(box40)
            box.delete(box50) 
            box.delete(box60) 
            box.delete(box70) 
            box.delete(box80)
            box.delete(box90) 
            box100 := box.new(bar_index[30], 1, bar_index[29], 0, bgcolor = fill)
            box20 := box.new(bar_index[29], 2, bar_index[28], 1, bgcolor = fill)
            box30 := box.new(bar_index[28], 3, bar_index[27], 2, bgcolor = fill)
            box40 := box.new(bar_index[27], 4, bar_index[26], 3, bgcolor = fill)
            box50 := box.new(bar_index[26], 5, bar_index[25], 4, bgcolor = fill)
            box60 := box.new(bar_index[25], 4, bar_index[24], 3, bgcolor = fill)
            box70 := box.new(bar_index[24], 3, bar_index[23], 2, bgcolor = fill)
            box80 := box.new(bar_index[23], 2, bar_index[22], 1, bgcolor = fill)
            box90 := box.new(bar_index[22], 1, bar_index[21], 0, bgcolor = fill)
        if dist_type == "Platykurtic" and barstate.isconfirmed or dist_type == "Platykurtic, heavy left tailed" and barstate.isconfirmed
            box.delete(box100) 
            box.delete(box20) 
            box.delete(box30) 
            box.delete(box40)
            box.delete(box50) 
            box.delete(box60) 
            box.delete(box70) 
            box.delete(box80)
            box.delete(box90) 
            box.delete(box15) 
            box100 := box.new(bar_index[30], 1, bar_index[29], 0, bgcolor = fill, border_color = fill)
            box20 := box.new(bar_index[29], 1.5, bar_index[28], 1, bgcolor = fill, border_color = fill)
            box30 := box.new(bar_index[28], 2, bar_index[27], 1.5, bgcolor = fill,  border_color = fill)
            box40 := box.new(bar_index[27], 2.5, bar_index[26], 2, bgcolor = fill,  border_color = fill)
            box50 := box.new(bar_index[26], 3, bar_index[25], 2.5, bgcolor = fill,  border_color = fill)
            box60 := box.new(bar_index[25], 3, bar_index[24], 2.5, bgcolor = fill,  border_color = fill)
            box70 := box.new(bar_index[24], 2.5, bar_index[23], 2, bgcolor = fill, border_color = fill)
            box80 := box.new(bar_index[23], 2, bar_index[22], 1.5, bgcolor = fill, border_color = fill)
            box90 := box.new(bar_index[22], 1.5, bar_index[21], 1, bgcolor = fill, border_color = fill)
            box15 := box.new(bar_index[21], 1, bar_index[20], 0, bgcolor = fill, border_color = fill)
        if dist_type == "Leptokurtic" and barstate.isconfirmed or dist_type == "Leptokurtic, heavy right tailed" and barstate.isconfirmed 
            box.delete(box100) 
            box.delete(box20) 
            box.delete(box30) 
            box.delete(box40)
            box.delete(box50) 
            box.delete(box60) 
            box.delete(box70) 
            box.delete(box80)
            box.delete(box90) 
            box100 := box.new(bar_index[30], 1, bar_index[29], 0, bgcolor = fill)
            box20 := box.new(bar_index[29], 1, bar_index[28], 1, bgcolor = fill)
            box30 := box.new(bar_index[28], 2, bar_index[27], 1, bgcolor = fill)
            box40 := box.new(bar_index[27], 4, bar_index[26], 2, bgcolor = fill)
            box50 := box.new(bar_index[26], 5, bar_index[25], 3, bgcolor = fill)
            box60 := box.new(bar_index[25], 4, bar_index[24], 2, bgcolor = fill)
            box70 := box.new(bar_index[24], 2, bar_index[23], 1, bgcolor = fill)
            box80 := box.new(bar_index[23], 1, bar_index[22], 1, bgcolor = fill)
            box90 := box.new(bar_index[22], 1, bar_index[21], 0, bgcolor = fill)
        if dist_type == "Negative, Left-tailed Distributio" and barstate.isconfirmed
            box.delete(box100) 
            box.delete(box20) 
            box.delete(box30) 
            box.delete(box40)
            box.delete(box50) 
            box.delete(box60) 
            box.delete(box70) 
            box.delete(box80)
            box.delete(box90) 
            box100 := box.new(bar_index[30], 1, bar_index[29], 0, bgcolor = fill, border_color = fill)
            box20 := box.new(bar_index[29], 1, bar_index[28], 0, bgcolor = fill, border_color = fill)
            box30 := box.new(bar_index[28], 2, bar_index[27], 1, bgcolor = fill,  border_color = fill)
            box40 := box.new(bar_index[27], 2, bar_index[26], 1, bgcolor = fill,  border_color = fill)
            box50 := box.new(bar_index[26], 3, bar_index[25], 2, bgcolor = fill,  border_color = fill)
            box60 := box.new(bar_index[25], 4, bar_index[24], 3, bgcolor = fill,  border_color = fill)
            box70 := box.new(bar_index[24], 3, bar_index[23], 2, bgcolor = fill, border_color = fill)
            box80 := box.new(bar_index[23], 2, bar_index[22], 0, bgcolor = fill, border_color = fill)
        if dist_type == "Positive, Right-tailed Distribution" and barstate.isconfirmed 
            box.delete(box100) 
            box.delete(box20) 
            box.delete(box30) 
            box.delete(box40)
            box.delete(box50) 
            box.delete(box60) 
            box.delete(box70) 
            box.delete(box80)
            box.delete(box90) 
            box100 := box.new(bar_index[30], 2, bar_index[29], 0, bgcolor = fill, border_color = fill)
            box20 := box.new(bar_index[29], 3, bar_index[28], 2, bgcolor = fill, border_color = fill)
            box30 := box.new(bar_index[28], 4, bar_index[27], 3, bgcolor = fill,  border_color = fill)
            box40 := box.new(bar_index[27], 3, bar_index[26], 2, bgcolor = fill,  border_color = fill)
            box50 := box.new(bar_index[26], 2, bar_index[25], 1, bgcolor = fill,  border_color = fill)
            box60 := box.new(bar_index[25], 2, bar_index[24], 1, bgcolor = fill,  border_color = fill)
            box70 := box.new(bar_index[24], 1, bar_index[23], 0, bgcolor = fill, border_color = fill)
            box80 := box.new(bar_index[23], 1, bar_index[22], 0, bgcolor = fill, border_color = fill)


diagram = distribution_diagram(y_dist, typ)

// Autoregressive Moving Average 

ema = ta.ema(arima_src, ema_len)
sma = ta.sma(arima_src, ema_len) 
var float ema_input = 0.0 

if arima_typ == "EMA" 
    ema_input := ema 
else if arima_typ == "SMA"
    ema_input := sma 

[arima_model, arima_cor, arima_sqrd, arima_err, aa, bb]  = f_linear_regression(ema_input[ema_len], ema_input, t1_arr, ema_input)

plot(typ == "ARIMA" ? arima_model : na, "ARIMA Forecast", color = purple, offset = ema_len, linewidth=3)
plot(typ == "ARIMA" and cbands ? arima_model + arima_err : na, "ARIMA UCL", color = color.green, offset = ema_len, linewidth=3) 
plot(typ == "ARIMA" and cbands ? arima_model - arima_err : na, "ARIMA LCL", color = color.red, offset = ema_len, linewidth=3) 
if typ == "ARIMA"
    table.cell(result_table, 1, 1, text = "ARIMA Model " + str.tostring(arima_typ), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "Dependent (Y): " + str.tostring(syminfo.ticker), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Significance:  " + str.tostring(math.round(arima_cor,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 6, text = "R Squared:  " + str.tostring(math.round(arima_sqrd,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 7, text = "Error:  " + str.tostring(math.round(arima_err,2)), bgcolor = black, text_color = white)


// Quadratic Regression 
x1_sq = math.pow(t1_cl, 2) 

[qr_result, qr_rsqrd, qr_cor, qr_err, qr_b1, qr_b2, qr_b0] = f_multiple_regression(t1_cl, t2_cl, x1_sq, t2_cl, x1_sq, t1_arr)

plot(typ == "Quadratic Regression" ? qr_result : na, "Quadratic Regression", linewidth=3)

if typ == "Quadratic Regression"
    table.cell(result_table, 1, 1, text = "Quadratic Regression", bgcolor = black, text_color = white)
    table.cell(result_table, 1, 2, text = "Dependent (Y): " + str.tostring(t1_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 3, text = "Independent (X1): " + str.tostring(t2_in), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 4, text = "Equation: y = " + str.tostring(math.round(qr_b1,2)) + "x + " + str.tostring(math.round(qr_b2,2)) + "x +" + str.tostring(math.round(qr_b0,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 5, text = "Significance (R):  " + str.tostring(math.round(qr_cor,2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 6, text = "R Squared:  " + str.tostring(math.round(qr_rsqrd, 2)), bgcolor = black, text_color = white)
    table.cell(result_table, 1, 7, text = "Error:  " + str.tostring(math.round(qr_err,2)), bgcolor = black, text_color = white)


// Forecast 

if typ == "Forecast"
    forecast_results = arr() 
    forecast_ucl = arr() 
    forecast_lcl = arr() 
    [fore1, fore2, fore3] = spts.f_forecast(forecast_src, forecast_src[1], fore_train, for_len, forecast_results, forecast_ucl, forecast_lcl)
    var table fore_table = table.new(position.middle_center, 4, 30, bgcolor = black, frame_color = white)
    table.cell(fore_table, 0, 1, text = "Time", bgcolor = black, text_color = white)
    table.cell(fore_table, 1, 1, text = "Lower Confidence \n Result", bgcolor = black, text_color = white)
    table.cell(fore_table, 2, 1, text = "Forecast Result", bgcolor = black, text_color = white)
    table.cell(fore_table, 3, 1, text = "Upper Confidence \n Result", bgcolor = black, text_color = white)
    for i = 0 to array.size(forecast_results) - 1 
        table.cell(fore_table, 0, 2 + i, text = str.tostring(i + 1), bgcolor = black, text_color = white)
        table.cell(fore_table, 1, 2 + i, text = str.tostring(math.round(array.get(forecast_lcl, i),2)), bgcolor = black, text_color = white) 
        table.cell(fore_table, 2, 2 + i, text = str.tostring(math.round(array.get(forecast_results, i),2)), bgcolor = black, text_color = white) 
        table.cell(fore_table, 3, 2 + i, text = str.tostring(math.round(array.get(forecast_ucl, i),2)), bgcolor = black, text_color = white) 


if typ == "3 Group ANOVA" 
    [sig, f_stat] = spts.ANOVA(t1_cl, t2_cl, t3_cl, an_len) 
    var table fore_table = table.new(position.middle_center, 4, 30, bgcolor = black, frame_color = white, frame_width = 3)
    table.cell(fore_table, 1, 1, text = "ANOVA Analysis, 3 Group", bgcolor = color.gray, text_color = white) 
    table.cell(fore_table, 1, 2, text = "F-Statistic: " + str.tostring(math.round(f_stat, 2)), bgcolor = black, text_color = white)
    table.cell(fore_table, 1, 3, text = "p value (significance): " + str.tostring(sig), bgcolor = black, text_color = white)
    table.cell(fore_table, 1, 4, text = "Groups", bgcolor = color.gray, text_color = white)
    table.cell(fore_table, 1, 5, text = "Group 1: " + str.tostring(t1_in), bgcolor = black, text_color = white)
    table.cell(fore_table, 1, 6, text = "Group 2: " + str.tostring(t2_in), bgcolor = black, text_color = white)
    table.cell(fore_table, 1, 7, text = "Group 3: " + str.tostring(t3_in), bgcolor = black, text_color = white)
