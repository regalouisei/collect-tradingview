// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RicardoSantos

//@version=6
string LTITLE = 'Multi Asset Similarity Matrix'
string STITLE = 'MASM'
indicator(LTITLE, STITLE, false)


// Provides a unique and visually stunning way to analyze the similarity between various stock market indices. This script uses a range of mathematical measures to calculate the correlation between different assets, such as indices, forex, crypto, etc..
// Key Features:
// Similarity Measures: The script offers a range of similarity measures to choose from, including SSD (Sum of Squared Differences), Euclidean Distance, Manhattan Distance, Minkowski Distance, Chebyshev Distance, Correlation Coefficient, Cosine Similarity, Camberra Index, Mean Absolute Error (MAE), Mean Squared Error (MSE), Lorentzian Function, Intersection, and Penrose Shape.
// Asset Selection: Users can select the assets they want to analyze by entering a comma-separated list of tickers in the "Asset List" input field.
// Color Gradient: The script uses a color gradient to represent the similarity values between each pair of indices, with red indicating low similarity and blue indicating high similarity.
// How it Works:
// The script calculates the source method (Returns or Volume Modified Returns) for each index using the sec function.
// It then creates a matrix to hold the current values of each index over a specified window size (default is 10).
// For each pair of indices, it applies the selected similarity measure using the select function and stores the result in a separate matrix.
// The script calculates the maximum and minimum values of the similarity matrix to normalize the color gradient.
// Finally, it creates a table with the index names as rows and columns, displaying the similarity values for each pair of indices using the calculated colors.
// Visual Insights:
// The indicator provides an intuitive way to visualize the relationships between different assets. By analyzing the color-coded tables, traders can gain insights into:
// Which assets are highly correlated (blue) or uncorrelated (red)
// The strength and direction of these correlations
// Potential trading opportunities based on similarities and differences between assets
// Overall, MASM is a powerful tool for market analysis and visualization, offering a unique perspective on the relationships between various assets.
// ~llama3

//#region    Similarity functions
import RicardoSantos/SimilarityMeasures/2 as sm

enum M
    SSD
    Euclidean
    Manhattan
    Minkowski
    Chebyshev
    Correlation
    Cosine
    Camberra
    MAE
    MSE
    Lorentzian
    Intersection
    PenroseShape
    Meehl

// @function Select the method of measure.
select (M m, float[] a, float[] b) =>
    switch m
        M.SSD            => sm.ssd(a, b)
        M.Euclidean        => sm.euclidean(a, b)
        M.Manhattan        => sm.manhattan(a, b)
        M.Minkowski        => sm.minkowski(a, b)
        M.Chebyshev        => sm.chebyshev(a, b)
        M.Correlation    => sm.correlation(a, b)
        M.Cosine        => sm.cosine(a, b)
        M.Camberra        => sm.camberra(a, b)
        M.MAE            => sm.mae(a, b)
        M.MSE            => sm.mse(a, b)
        M.Lorentzian    => sm.lorentzian(a, b)
        M.Intersection    => sm.intersection(a, b)
        M.PenroseShape    => sm.penrose(a, b)
        M.Meehl            => sm.meehl(a, b)

//#endregion
//#region    Inputs:

enum MSRC
    R  = 'Returns'
    RV = 'Volume Modified Returns'

int window = input.int(10, 'Window:')
MSRC srcmethod = input.enum(MSRC.R, 'Source Method:')
M mmethod = input.enum(M.Cosine, 'Similarity Measure Method:')
string tickers = input.text_area('NAS100,SPX500,DJI, IBXX, N100, EU500, UKX, JP225USD, NIFTY, CN50USD, HSI, NZ50G, MOEX', 'Asset List:')
color grad1 = input.color(color.maroon, 'Gradient Colors:', inline='1')
color grad2 = input.color(color.blue, '', inline='1')
int ndigits = input.int(5, 'Number of Digits:')

var string fdigits = '0.'
if barstate.isfirst
    for _i = 1 to ndigits
        fdigits += '0'

sec (string t) => 
    float _src = na
    switch srcmethod
        MSRC.R => _src := close / close[1]
        MSRC.RV => float _v = nz(volume, 1.0) , _src := (close * _v) / (close[1] * _v[1])
    request.security(t, timeframe.period, _src, barmerge.gaps_off, barmerge.lookahead_on)


//#endregion
//#region    Import indices data:

var string[] tlist = str.split(str.replace_all(tickers, ' ', ''), ',')
int tsize = tlist.size()
// @variable Matrix to hold the indice values for the length of the window.
var matrix<float> tvalues = matrix.new<float>(window, tsize, float(na))
// @variable Temporary array to hold current indice values.
float[] lastvalues = array.new<float>(tsize, float(na))
for [_i, _t] in tlist
    lastvalues.set(_i, sec(_t))
tvalues.add_row(window, lastvalues)
if tvalues.rows() > window
    tvalues.remove_row(0)

//#endregion
//#region    Calculate the measure of the indices:

// @variable similarity measure values
matrix<float> cs = matrix.new<float>(tsize, tsize, float(na))
for _i = 0 to tsize - 1
    _ri = tvalues.col(_i)
    for _j = 0 to tsize - 1
        if _i == _j
            continue
        _rj = tvalues.col(_j)
        cs.set(_i, _j, select(mmethod, _ri, _rj))
// @variable matrice highest value.
float smax = cs.max()
// @variable matrice lowest value.
float smin = cs.min()

// @function Color the table values.
col (v) => 
    float _v = (v - smin) / (smax - smin)
    color.from_gradient(_v, 0, 1, grad1, grad2)

//#endregion
//#region
var table TB = table.new(position.bottom_right, tsize+1, tsize+1, #000000, #ffffff, 1)
for [_i, _t] in tlist
    TB.cell(0, 1+_i, _t, 0, 0, #ffffff, text.align_center, text.align_center, 14, #000000)
    TB.cell(1+_i, 0, _t, 0, 0, #ffffff, text.align_center, text.align_center, 14, #000000)
    for _j = 0 to tsize-1
        float _sv = cs.get(_i, _j)
        if _i == _j
            TB.cell(1+_i, 1+_j, str.format('{0}', _t), 0, 0, #ffffff, text.align_center, text.align_center, 14, #000000)
        else
            TB.cell(1+_i, 1+_j, str.format('{0}', str.tostring(_sv, fdigits)), 0, 0, #ffffff, text.align_center, text.align_center, 14, col(_sv))
