// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RicardoSantos

//@version=5
indicator(title='[RS]Bar Pattern Statistics Tool', shorttitle='bst', overlay=false)

// @function Calculate percentage
to_percent (float fraction, float total) => (fraction / total) * 100

string op_type_01 = 'inside bar'
string op_type_02 = 'outside bar'
string op_type_03 = 'up bar'
string op_type_04 = 'down bar'
string op_type_05 = 'up pin bar'
string op_type_06 = 'down pin bar'
string op_type_07 = 'any type of bar'

// @function Index bar type names.
// @param name  `string`    Name of the bar type.
// @returns `int` Bar type index.
enum_type (string name) => 
    switch name
        op_type_01 => 1
        op_type_02 => 2
        op_type_03 => 3
        op_type_04 => 4
        op_type_05 => 5
        op_type_06 => 6
        op_type_07 => 7
        =>            na

// @function Bar type name by index.
// @param idx   `int`   Index of the bar type name.
// @returns `string` Name of the bar type.
enum_type_by_idx (int idx) =>
    switch idx
        1 => op_type_01
        2 => op_type_02
        3 => op_type_03
        4 => op_type_04
        5 => op_type_05
        6 => op_type_06
        7 => op_type_07
        =>   op_type_07 // TODO add a new "na" type?

// bar properties
float body_range  = math.abs(close - open)
float hl_range    = high - low
float upperwick   = high - math.max(close, open)
float lowerwick   = math.min(close, open) - low
bool  risinghigh  = high > high[1]
bool  fallinghigh = high < high[1]
bool  risinglow   = low > low[1]
bool  fallinglow  = low < low[1]

// methods to check bar property at `bar_index - pos`
isHighUp      (int pos)   => risinghigh[pos]
isHighDown    (int pos)   => fallinghigh[pos]
isLowUp       (int pos)   => risinglow[pos]
isLowDown     (int pos)   => fallinglow[pos]

isInsideBar   (int pos)   => isHighDown(pos) and isLowUp(pos)
isOutsideBar  (int pos)   => isHighUp(pos)   and isLowDown(pos)
isUpBar       (int pos)   => isHighUp(pos)   and isLowUp(pos)
isDownBar     (int pos)   => isHighDown(pos) and isLowDown(pos)
isPinUp       (int pos)   => risinghigh[pos] and body_range[pos] < (hl_range[pos] * 0.33) and (upperwick[pos] * 0.66) > lowerwick[pos]
isPinDown     (int pos)   => fallinglow[pos] and body_range[pos] < (hl_range[pos] * 0.33) and (lowerwick[pos] * 0.66) > upperwick[pos]
isAny         (int pos)   => true

// @function Test if there is a bar of indexed type at position.
test_BarPattern (int idx, int pos) =>
    bool _isInsideBar    = isInsideBar(pos)
    bool _isOutsideBar   = isOutsideBar(pos)
    bool _isUpBar        = isUpBar(pos)
    bool _isDownBar      = isDownBar(pos)
    bool _isPinUp        = isPinUp(pos)
    bool _isPinDown      = isPinDown(pos)
    bool _isAny          = isAny(pos)
    switch idx
        1 => _isInsideBar
        2 => _isOutsideBar
        3 => _isUpBar
        4 => _isDownBar
        5 => _isPinUp
        6 => _isPinDown
        7 => _isAny
        => bool(na)

// @function Index the bar type at position.
ident_bar (int pos) =>
    bool _isInsideBar   = isInsideBar(pos)
    bool _isOutsideBar  = isOutsideBar(pos)
    bool _isUpBar       = isUpBar(pos)
    bool _isDownBar     = isDownBar(pos)
    bool _isPinUp       = isPinUp(pos)
    bool _isPinDown     = isPinDown(pos)
    bool _isAny         = isAny(pos)
    switch
        _isInsideBar    => 1
        _isOutsideBar   => 2
        _isUpBar        => 3
        _isDownBar      => 4
        _isPinUp        => 5
        _isPinDown      => 6
        _isAny          => 7
        => 7

//
bool show_all_stats = input.bool(false, 'Show All Stats?', 'Shows the stats for each bar type, not pattern dependent.')
int n_bars_in_pattern = input.int(defval=3, title='How many bars pattern:', minval=1, maxval=10, tooltip='The size of the base pattern')

string bar01_type = input.string(defval=op_type_01, title='#1 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar02_type = input.string(defval=op_type_01, title='#2 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar03_type = input.string(defval=op_type_01, title='#3 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar04_type = input.string(defval=op_type_01, title='#4 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar05_type = input.string(defval=op_type_01, title='#5 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar06_type = input.string(defval=op_type_01, title='#6 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar07_type = input.string(defval=op_type_01, title='#7 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar08_type = input.string(defval=op_type_01, title='#8 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar09_type = input.string(defval=op_type_01, title='#9 in pattern:' , options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
string bar10_type = input.string(defval=op_type_01, title='#10 in pattern:', options=[op_type_01, op_type_02, op_type_03, op_type_04, op_type_05, op_type_06, op_type_07])
 
all_stats_pre_eval_01 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-01)))
all_stats_pre_eval_02 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-02)))
all_stats_pre_eval_03 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-03)))
all_stats_pre_eval_04 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-04)))
all_stats_pre_eval_05 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-05)))
all_stats_pre_eval_06 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-06)))
all_stats_pre_eval_07 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-07)))
all_stats_pre_eval_08 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-08)))
all_stats_pre_eval_09 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-09)))
all_stats_pre_eval_10 = enum_type_by_idx(ident_bar(math.max(0, n_bars_in_pattern-10)))
if show_all_stats
    bar01_type := all_stats_pre_eval_01
    bar02_type := all_stats_pre_eval_02
    bar03_type := all_stats_pre_eval_03
    bar04_type := all_stats_pre_eval_04
    bar05_type := all_stats_pre_eval_05
    bar06_type := all_stats_pre_eval_06
    bar07_type := all_stats_pre_eval_07
    bar08_type := all_stats_pre_eval_08
    bar09_type := all_stats_pre_eval_09
    bar10_type := all_stats_pre_eval_10

// @function Bar type name of the input/autofill selection.
get_bar_type_from_input (int idx) =>
    switch idx
        01 => bar01_type
        02 => bar02_type
        03 => bar03_type
        04 => bar04_type
        05 => bar05_type
        06 => bar06_type
        07 => bar07_type
        08 => bar08_type
        09 => bar09_type
        10 => bar10_type
        => na

// @function Checks if the input bar type at position is active.
check_nbar (int idx, int pos) => test_BarPattern(enum_type(get_bar_type_from_input(idx)), pos)

// @function Convert the input pattern into a string.
input_pattern_to_text (string sep = ' > ') =>
    string _t = ''
    for _i = 1 to n_bars_in_pattern
        _t := _t + str.format('({0}: {1})', str.tostring(_i, '#'), get_bar_type_from_input(_i))
        if _i != n_bars_in_pattern
            _t := _t + sep
    _t

// @function Check if current bar has a valid pattern.
check_if_pattern (int length) =>
    int _count = 0
    bool _is_valid = false
    // check the number of bar types that match the input pattern.
    for _i = 1 to length
        int _pos = length - _i
        _count := _count + (check_nbar(_i, _pos) ? 1 : 0) // no quick fix for alert!
    // if counter is higher than the input pattern number of bars.
    if _count >= length
        _is_valid := true
    _is_valid

int is_pattern = check_if_pattern(n_bars_in_pattern) ? 1 : 0

// count the number of historic bars, same as `bar_index`.
var int total_bars = -1     , total_bars += 1  // last bar is not evaluated so no need to count it

//stats:
// counters:
var int n_detected = 0
var int n_bars_inside = 0
var int n_bars_outside = 0
var int n_bars_up = 0
var int n_bars_down = 0
var int n_bars_over_atr14x1 = 0
var int n_bars_over_atr14x2 = 0
var int n_bars_over_atr14x3 = 0

int   atr_length = input.int(14, 'ATR length:', 1)
float atr        = ta.atr(atr_length)

if is_pattern[1] > 0
    n_detected := n_detected + 1
    if isInsideBar(0) // no quick fix for alert!
        n_bars_inside := n_bars_inside + 1
    if isOutsideBar(0) // no quick fix for alert!
        n_bars_outside := n_bars_outside + 1
    if isUpBar(0) // no quick fix for alert!
        n_bars_up := n_bars_up + 1
    if isDownBar(0) // no quick fix for alert!
        n_bars_down := n_bars_down + 1
    if high-low > atr * 1
        n_bars_over_atr14x1 := n_bars_over_atr14x1 + 1
    if high-low > atr * 2
        n_bars_over_atr14x2 := n_bars_over_atr14x2 + 1
    if high-low > atr * 3
        n_bars_over_atr14x3 := n_bars_over_atr14x3 + 1

// Output:
string T_ititle = 'Table style:'
color  T_bg_col = input.color(color.rgb(37, 37, 50), T_ititle, '', T_ititle)
color  T_fg_col = input.color(color.rgb(65, 65, 70), '', '', T_ititle)
color  T_t_col  = input.color(color.rgb(170, 180, 190), '', '', T_ititle)
string T_tsize  = input.string(defval=size.normal, title='', options=[size.auto, size.tiny, size.small, size.normal, size.large, size.huge], inline=T_ititle)

var table T = table.new(position.bottom_right, 3, 14, T_bg_col, T_fg_col, 1, T_fg_col, 1)
T.cell(0, 0, 'Statistics:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.merge_cells(0, 0, 2, 0)
T.cell(0, 1, str.format('Pattern: {0}', input_pattern_to_text()), text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.merge_cells(0, 1, 2, 1)
if show_all_stats
    T.cell(0, 2, str.format('Statistics for all next bars in {0, number} bars.', total_bars), text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
    T.merge_cells(0, 2, 2, 2)
else
    T.cell(0, 2, str.format('Nº of patterns: {0,number} in {1,number} bars ({2,number,0.000}%)', n_detected, total_bars, to_percent(n_detected, total_bars)), text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
    T.merge_cells(0, 2, 2, 2)
T.cell(0, 3, 'Nº of next bars, that are:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.merge_cells(0, 3, 2, 3)
T.cell(0, 4, 'Bar Type:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 4, 'Counter:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(2, 4, 'Percent:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(0, 5, ' --- > Inside Bars:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 5, str.tostring(n_bars_inside, '#'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(2, 5, str.tostring(n_bars_inside / n_detected, '#.000%'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(0, 6, ' --- > Outside Bars:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 6, str.tostring(n_bars_outside, '#'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(2, 6, str.tostring(n_bars_outside / n_detected, '#.000%'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(0, 7, ' --- > Up Bars:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 7, str.tostring(n_bars_up, '#'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(2, 7, str.tostring(n_bars_up / n_detected, '#.000%'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(0, 8, ' --- > Down Bars:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 8, str.tostring(n_bars_down, '#'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(2, 8, str.tostring(n_bars_down / n_detected, '#.000%'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(0, 9, 'Volatility:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.merge_cells(0, 9, 2, 9)
T.cell(0, 10, ' --- > Over ATR(X):', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 10, str.tostring(n_bars_over_atr14x1, '#'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(2, 10, str.tostring(n_bars_over_atr14x1 / n_detected, '#.000%'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(0, 11, ' --- > Over ATR(X) x 2:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 11, str.tostring(n_bars_over_atr14x2, '#'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(2, 11, str.tostring(n_bars_over_atr14x2 / n_detected, '#.000%'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(0, 12, ' --- > Over ATR(X) x 3:', text_color=T_t_col, text_halign=text.align_left, text_size=T_tsize)
T.cell(1, 12, str.tostring(n_bars_over_atr14x3, '#'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)
T.cell(2, 12, str.tostring(n_bars_over_atr14x3 / n_detected, '#.000%'), text_color=T_t_col, text_halign=text.align_right, text_size=T_tsize)


plot(series=is_pattern, title='Event', color=color.black, style=plot.style_histogram)
hline(0)
hline(1)
