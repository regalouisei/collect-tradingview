// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// © Zeiierman {
//@version=6
indicator('Volume Cluster Profile [VCP] (Zeiierman)', overlay = true, max_boxes_count = 500, max_lines_count = 50, max_bars_back = 5000)
//}

// ~~ Tooltips {
var string t1  = "How many most-recent bars are used to build the CURRENT (right-side) volume profile."
var string t2  = "Number of price bins used to build the volume histogram. More bins = more detail but heavier CPU."
var string t3  = "Gaussian spread (sigma) used to ‘blur’ volumes around detected cluster peaks. Higher = smoother/wider clusters."
var string t4  = "Maximum number of cluster centers (peaks) to detect and use for the pseudo-AI enhancement."
var string t5  = "Show the CURRENT profile Point of Control (highest enhanced-volume bin) line."
var string t6  = "Show dotted lines for CURRENT detected cluster centers."
var string t7  = "Maximum width (in bars) of the CURRENT profile histogram drawn to the right."
var string t8  = "Fill color (with transparency) for the CURRENT profile histogram boxes."
var string t9  = "Border color for the CURRENT profile histogram boxes."
var string t10 = "Line color for the CURRENT POC."
var string t11 = "Line color for CURRENT cluster center lines."
var string t12 = "Enable/disable drawing of historical swing-segment profiles."
var string t13 = "Pivot length used to detect swing highs/lows. Larger = fewer, broader segments."
var string t14 = "Maximum number of historical swing profiles to keep on chart (older ones are removed)."
var string t15 = "Maximum width (in bars) of EACH historical profile histogram."
var string t16 = "Show the historical POC line inside each historical profile."
var string t17 = "Color of the historical POC line."
var string t18 = "Thickness (width) of the historical POC line."
var string t19 = "Fill color (with transparency) for historical profiles created from HIGH swing segments."
var string t20 = "Fill color (with transparency) for historical profiles created from LOW swing segments."
var string t21 = "Background transparency for the historical segment wrap box (the big rectangle around the segment)."
var string t22 = "Extend the LAST historical segment forward to the current bar with VA/LV boxes (top-bin and lowest-bin)."
var string t23 = "Fill color for the LAST segment Value Area (VA) extension box."
var string t24 = "Fill color for the LAST segment Low Value (LV) extension box."
var string t25 = "Transparency for the LAST segment VA/LV extension boxes."
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Inputs {
lookbackBars = input.int(250, 'Lookback Bars', minval = 50, maxval = 5000, group = 'Cluster Volume Profile', inline="a", tooltip=t1)
binsCount    = input.int(40,  'Price Bins',  minval = 10, maxval = 200,  group = 'Cluster Volume Profile', inline="a", tooltip=t1+ "\n\n" +t2)

clusterSigma = input.float(2.5, 'Cluster Spread',     minval = 0.5, maxval = 20.0, group = 'Cluster Volume Profile', inline="b", tooltip=t3)
maxClusters  = input.int(2,     'Max Cluster Centers', minval = 1,   maxval = 20,   group = 'Cluster Volume Profile', inline="b", tooltip=t3+ "\n\n" +t4)

showPOCLine  = input.bool(true, 'Current POC',             group = 'Cluster Volume Profile', inline="style", tooltip=t5)
showClusters = input.bool(true, 'Current Cluster Centers', group = 'Cluster Volume Profile', inline="style", tooltip=t5+ "\n\n" +t6)
profileWidth = input.int(50, 'Profile Width', minval = 5, maxval = 200, group = 'Cluster Volume Profile', inline="c", tooltip=t7)
profileColor = input.color(color.new(color.teal, 60), 'Profile Color', group = 'Cluster Volume Profile', inline="c", tooltip=t8)
borderColor  = input.color(color.new(color.teal, 0),  'Border Color',  group = 'Cluster Volume Profile', inline="c", tooltip=t9)
pocColor     = input.color(color.new(color.yellow, 0), "Current POC Color", group="Cluster Volume Profile", inline="c", tooltip=t10)
clusterColor = input.color(color.new(color.orange, 0), 'Cluster Line Color', group = 'Cluster Volume Profile', inline="c", tooltip=t7+ "\n\n" +t8+ "\n\n" +t9+ "\n\n" +t10+ "\n\n" +t11)

showHistorical  = input.bool(true, 'Show Historical Swing Profiles', group = 'Historical Swing Cluster Volume Profile', inline="Historical", tooltip=t12)
swingLen        = input.int(20,   '', minval = 2, maxval = 200, group = 'Historical Swing Cluster Volume Profile', inline="Historical", tooltip=t13)
maxHistProfiles = input.int(12, 'Max Profiles', minval = 1, maxval = 30, group = 'Historical Swing Cluster Volume Profile', inline="Historical_", tooltip=t14)
histWidth       = input.int(20, 'Profile Width', minval = 5, maxval = 200, group = 'Historical Swing Cluster Volume Profile', inline="Historical_", tooltip=t12+ "\n\n" +t13+ "\n\n" +t14+ "\n\n" +t15)

histShowPOC  = input.bool(true, 'Historical POC Line', group = 'Historical Swing Cluster Volume Profile', inline="h", tooltip=t16)
histHighPOC  = input.color(color.new(color.yellow, 0), 'POC', group='Historical Swing Cluster Volume Profile', inline="h", tooltip=t17)
histPOCWidth = input.int(2, '', minval = 1, maxval = 5, group = 'Historical Swing Cluster Volume Profile', inline="h", tooltip=t16+ "\n\n" +t17+ "\n\n" +t18)

histHighFill   = input.color(color.new(color.orange, 65), 'High Fill',     group='Historical Swing Cluster Volume Profile', inline="hs3", tooltip=t19)
histLowFill    = input.color(color.new(color.teal, 65),   'Low Fill',      group='Historical Swing Cluster Volume Profile', inline="hs3", tooltip=t20)
histWrapTransp = input.int(85, 'Transparency', minval = 0, maxval = 100,   group = 'Historical Swing Cluster Volume Profile', inline="hs3", tooltip=t19+ "\n\n" +t20+ "\n\n" +t21)

showLastExtBoxes = input.bool(true, "Profile VA/LV", group="High & Low Value Area", inline="extA", tooltip=t22)
vaFillCol        = input.color(color.new(color.orange, 80), "VA Fill", group="High & Low Value Area", inline="extA", tooltip=t23)
lvFillCol        = input.color(color.new(color.blue, 85),   "LV Fill", group="High & Low Value Area", inline="extA", tooltip=t24)
lastExtTransp    = input.int(70, "", minval=0, maxval=100, group="High & Low Value Area", inline="extA", tooltip=t22+ "\n\n" +t23+ "\n\n" +t24+ "\n\n" +t25)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Helpers {
f_clamp(int x, int minVal, int maxVal) =>
    x < minVal ? minVal : x > maxVal ? maxVal : x

f_gauss(float dist, float sigma) =>
    sigma > 0.0 ? math.exp(-(dist * dist) / (2.0 * sigma * sigma)) : 1.0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Storage (Current) {
var array<box> profileBoxes = array.new_box()
var array<line> clusterLines = array.new_line()

f_clear_current() =>
    int szB = array.size(profileBoxes)
    if szB > 0
        for i = 0 to szB - 1
            box.delete(array.get(profileBoxes, i))
        array.clear(profileBoxes)

    int szL = array.size(clusterLines)
    if szL > 0
        for i = 0 to szL - 1
            line.delete(array.get(clusterLines, i))
        array.clear(clusterLines)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Storage (Historical) {
var array<box> histBoxes = array.new_box()
var array<line> histLines = array.new_line()
var array<box> histWraps = array.new_box()
var array<box> histExtBoxes = array.new_box()

f_clear_historical() =>
    int szB = array.size(histBoxes)
    if szB > 0
        for i = 0 to szB - 1
            box.delete(array.get(histBoxes, i))
        array.clear(histBoxes)

    int szL = array.size(histLines)
    if szL > 0
        for i = 0 to szL - 1
            line.delete(array.get(histLines, i))
        array.clear(histLines)

    int szW = array.size(histWraps)
    if szW > 0
        for i = 0 to szW - 1
            box.delete(array.get(histWraps, i))
        array.clear(histWraps)

    int szE = array.size(histExtBoxes)
    if szE > 0
        for i = 0 to szE - 1
            box.delete(array.get(histExtBoxes, i))
        array.clear(histExtBoxes)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Historical segment storage {
var array<int> segStart = array.new_int()
var array<int> segEnd   = array.new_int()
var array<int> segType  = array.new_int()

var int lastPivotIndex = na
var int lastPivotType  = 0

ph = ta.pivothigh(high, swingLen, swingLen)
pl = ta.pivotlow(low, swingLen, swingLen)

int pivotIndex = na
int pivotType  = 0
if not na(ph)
    pivotIndex := bar_index - swingLen
    pivotType  := +1
if not na(pl)
    pivotIndex := bar_index - swingLen
    pivotType  := -1

if showHistorical and not na(pivotIndex)
    if na(lastPivotIndex)
        lastPivotIndex := pivotIndex
        lastPivotType  := pivotType
    else
        if pivotIndex > lastPivotIndex + 10 and pivotIndex != lastPivotIndex
            array.push(segStart, lastPivotIndex)
            array.push(segEnd,   pivotIndex)
            array.push(segType,  pivotType)

            while array.size(segStart) > maxHistProfiles
                array.shift(segStart)
                array.shift(segEnd)
                array.shift(segType)

        lastPivotIndex := pivotIndex
        lastPivotType  := pivotType
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Historical draw + LAST segment VA/LV extensions {
f_draw_hist_segment(
    int xBase, int segBarsLen, int widthBars, int endBack,
    color profCol, color bordCol, bool drawPOC, int pocWid, color pocCol,
    bool drawWrap, int segStartX, int segEndX, color wrapBorderCol, int wrapTransp,
    bool isLastSeg,
    bool drawLastExt, int extTransp,
    color vaFill, color vaBorder,
    color lvFill, color lvBorder
) =>
    int barsAvail = bar_index + 1
    if segBarsLen <= 10 or endBack < 0 or endBack >= barsAvail
        na
    else
        int safeLen = math.min(segBarsLen, barsAvail - endBack)
        if safeLen <= 10
            na
        else
            float minPrice = high[endBack]
            float maxPrice = low[endBack]

            for i = 0 to safeLen - 1
                int idx = endBack + i
                float c = close[idx]
                float h = high[idx]
                float l = low[idx]
                maxPrice := math.max(maxPrice, math.max(c, h))
                minPrice := math.min(minPrice, math.min(c, l))

            float rangee = maxPrice - minPrice
            if rangee <= syminfo.mintick
                na
            else
                float step = rangee / binsCount

                array<float> volBins   = array.new_float(binsCount, 0.0)
                array<float> volBinsAI = array.new_float(binsCount, 0.0)
                array<int>   clusterIdxs = array.new_int()

                for i = 0 to safeLen - 1
                    int idx = endBack + i
                    float price = close[idx]
                    float vol   = volume[idx]
                    int binIndex = int(math.floor((price - minPrice) / step))
                    binIndex := f_clamp(binIndex, 0, binsCount - 1)
                    array.set(volBins, binIndex, array.get(volBins, binIndex) + vol)

                float sumVol = 0.0
                for b = 0 to binsCount - 1
                    sumVol += array.get(volBins, b)
                float avgVol = sumVol / binsCount

                float varVol = 0.0
                for b = 0 to binsCount - 1
                    float v = array.get(volBins, b)
                    float diff = v - avgVol
                    varVol += diff * diff
                varVol := varVol / binsCount
                float stdVol = varVol > 0.0 ? math.sqrt(varVol) : 0.0
                bool isFlat = stdVol == 0.0

                for b = 0 to binsCount - 1
                    float v = array.get(volBins, b)
                    float left  = b > 0 ? array.get(volBins, b - 1) : v
                    float right = b < binsCount - 1 ? array.get(volBins, b + 1) : v
                    bool isPeak = v >= left and v >= right
                    float thresh = isFlat ? avgVol : avgVol + 0. * stdVol
                    if isPeak and v > thresh
                        array.push(clusterIdxs, b)

                while array.size(clusterIdxs) > maxClusters
                    int worstIdx = 0
                    float worstVol = array.get(volBins, array.get(clusterIdxs, 0))
                    for i = 1 to array.size(clusterIdxs) - 1
                        int ci = array.get(clusterIdxs, i)
                        float ciVol = array.get(volBins, ci)
                        if ciVol < worstVol
                            worstVol := ciVol
                            worstIdx := i
                    array.remove(clusterIdxs, worstIdx)

                float clusterWeight = 1.0 - 0.
                int szClFinal = array.size(clusterIdxs)

                for b = 0 to binsCount - 1
                    float baseV = array.get(volBins, b)
                    float finalV = baseV
                    if szClFinal > 0
                        float enhanced = 0.0
                        for i = 0 to szClFinal - 1
                            int centerBin = array.get(clusterIdxs, i)
                            float centerV = array.get(volBins, centerBin)
                            float dist = math.abs(b - centerBin)
                            float w = f_gauss(dist, clusterSigma)
                            enhanced += centerV * w
                        finalV := baseV * 0. + enhanced * clusterWeight / szClFinal
                    array.set(volBinsAI, b, finalV)

                float maxVol = 0.0
                int pocBin = 0
                for b = 0 to binsCount - 1
                    float v = array.get(volBinsAI, b)
                    if v > maxVol
                        maxVol := v
                        pocBin := b

                // Wrap box (border uses profCol)
                if drawWrap
                    color wrapBg = color.new(profCol, wrapTransp)
                    color wrapBd = color.new(profCol, 20)
                    box wbx = box.new(segStartX, maxPrice, segEndX, minPrice, bgcolor = wrapBg, border_color = wrapBd, border_width = 1)
                    array.push(histWraps, wbx)

                // Draw histogram boxes
                if maxVol > 0
                    int createdBoxes = 0
                    int maxRightX = xBase

                    for b = 0 to binsCount - 1
                        float v = array.get(volBinsAI, b)
                        if v > 0.0
                            float rel = v / maxVol
                            int wBars = math.max(1, int(math.round(rel * widthBars)))

                            float binLow  = minPrice + b * step
                            float binHigh = binLow + step

                            int leftX  = xBase
                            int rightX = math.min(xBase + wBars, segEndX)

                            if rightX > leftX
                                box bx = box.new(leftX, binHigh, rightX, binLow, bgcolor = profCol, border_color = bordCol)
                                array.push(histBoxes, bx)
                                createdBoxes += 1
                                maxRightX := math.max(maxRightX, rightX)

                    if drawPOC and createdBoxes > 0 and maxRightX > xBase
                        float pocPrice = minPrice + (pocBin + 0.5) * step
                        line ln = line.new(xBase, pocPrice, maxRightX, pocPrice, extend = extend.none, style = line.style_solid, width = pocWid, color = pocCol)
                        array.push(histLines, ln)

                // LAST segment extensions (VA/LV)
                if isLastSeg and drawLastExt and maxVol > 0 and segEndX < bar_index
                    // Biggest bin ONLY
                    int topBin = 0
                    float topV = -1.0
                    for bb = 0 to binsCount - 1
                        float vv = array.get(volBinsAI, bb)
                        if vv > topV
                            topV := vv
                            topBin := bb

                    float vaBot = minPrice + topBin * step
                    float vaTop = vaBot + step

                    color vaBg = color.new(vaFill, extTransp)
                    box vaBox = box.new(segEndX, vaTop, bar_index, vaBot, bgcolor=vaBg, border_color=vaBorder, border_width=1)
                    array.push(histExtBoxes, vaBox)

                    // Lowest bin ONLY
                    int lowBin = 0
                    float lowV = 1e100
                    for bb = 0 to binsCount - 1
                        float vv = array.get(volBinsAI, bb)
                        if vv < lowV
                            lowV := vv
                            lowBin := bb

                    float lvBot = minPrice + lowBin * step
                    float lvTop = lvBot + step

                    color lvBg = color.new(lvFill, extTransp)
                    box lvBox = box.new(segEndX, lvTop, bar_index, lvBot, bgcolor=lvBg, border_color=lvBorder, border_width=1)
                    array.push(histExtBoxes, lvBox)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Main logic {
if barstate.islast
    f_clear_current()
    f_clear_historical()

    // 1) Draw historical
    if showHistorical
        int nSeg = array.size(segStart)
        if nSeg > 0
            for s = 0 to nSeg - 1
                int a = array.get(segStart, s)
                int b = array.get(segEnd, s)
                int t = array.get(segType, s)

                int segLen = b - a
                int endBack = last_bar_index - b

                color hc = (t == 1 ? histHighFill : histLowFill)
                color hb = color.new(hc, 0)
                color pc = histHighPOC

                bool isLast = (s == nSeg - 1)

                f_draw_hist_segment(
                    a, segLen, histWidth, endBack,
                    hc, hb, histShowPOC, histPOCWidth, pc,
                    true, a, b, color.white, histWrapTransp,
                    isLast,
                    showLastExtBoxes, lastExtTransp,
                    vaFillCol, vaFillCol,
                    lvFillCol, lvFillCol
                )

    // 2) Current profile
    int barsAvailable = bar_index + 1
    int barsToUse = math.min(lookbackBars, barsAvailable)

    if barsToUse > 10
        float minPrice = high
        float maxPrice = low
        for i = 0 to barsToUse - 1
            float c = close[i]
            float h = high[i]
            float l = low[i]
            maxPrice := math.max(maxPrice, math.max(c, h))
            minPrice := math.min(minPrice, math.min(c, l))

        float rangee = maxPrice - minPrice
        if rangee > syminfo.mintick
            float step = rangee / binsCount

            array<float> volBins = array.new_float(binsCount, 0.0)
            array<float> volBinsAI = array.new_float(binsCount, 0.0)
            array<int> clusterIdxs = array.new_int()

            for i = 0 to barsToUse - 1
                float price = close[i]
                float vol = volume[i]
                int binIndex = int(math.floor((price - minPrice) / step))
                binIndex := f_clamp(binIndex, 0, binsCount - 1)
                array.set(volBins, binIndex, array.get(volBins, binIndex) + vol)

            float sumVol = 0.0
            for b = 0 to binsCount - 1
                sumVol += array.get(volBins, b)
            float avgVol = sumVol / binsCount

            float varVol = 0.0
            for b = 0 to binsCount - 1
                float v = array.get(volBins, b)
                float diff = v - avgVol
                varVol += diff * diff
            varVol := varVol / binsCount
            float stdVol = varVol > 0.0 ? math.sqrt(varVol) : 0.0
            bool isFlat = stdVol == 0.0

            for b = 0 to binsCount - 1
                float v = array.get(volBins, b)
                float left = b > 0 ? array.get(volBins, b - 1) : v
                float right = b < binsCount - 1 ? array.get(volBins, b + 1) : v
                bool isPeak = v >= left and v >= right
                float thresh = isFlat ? avgVol : avgVol + 0. * stdVol
                if isPeak and v > thresh
                    array.push(clusterIdxs, b)

            while array.size(clusterIdxs) > maxClusters
                int worstIdx = 0
                float worstVol = array.get(volBins, array.get(clusterIdxs, 0))
                for i = 1 to array.size(clusterIdxs) - 1
                    int ci = array.get(clusterIdxs, i)
                    float ciVol = array.get(volBins, ci)
                    if ciVol < worstVol
                        worstVol := ciVol
                        worstIdx := i
                array.remove(clusterIdxs, worstIdx)

            float clusterWeight = 1.0 - 0.
            int szClFinal = array.size(clusterIdxs)

            for b = 0 to binsCount - 1
                float baseV = array.get(volBins, b)
                float finalV = baseV
                if szClFinal > 0
                    float enhanced = 0.0
                    for i = 0 to szClFinal - 1
                        int centerBin = array.get(clusterIdxs, i)
                        float centerV = array.get(volBins, centerBin)
                        float dist = math.abs(b - centerBin)
                        float w = f_gauss(dist, clusterSigma)
                        enhanced += centerV * w
                    finalV := baseV * 0. + enhanced * clusterWeight / szClFinal
                array.set(volBinsAI, b, finalV)

            float maxVol = 0.0
            float pocPrice = na
            for b = 0 to binsCount - 1
                float v = array.get(volBinsAI, b)
                if v > maxVol
                    maxVol := v
                    pocPrice := minPrice + (b + 0.5) * step

            if maxVol > 0
                int xBase = bar_index + 1
                int createdCurBoxes = 0
                int curMaxRightX = xBase

                for b = 0 to binsCount - 1
                    float v = array.get(volBinsAI, b)
                    if v > 0.0
                        float rel = v / maxVol
                        int widthBars = math.max(1, int(math.round(rel * profileWidth)))

                        float binLow = minPrice + b * step
                        float binHigh = binLow + step

                        int rightX = xBase + widthBars
                        box newBox = box.new(xBase, binHigh, rightX, binLow, bgcolor = profileColor, border_color = borderColor)
                        array.push(profileBoxes, newBox)

                        createdCurBoxes += 1
                        curMaxRightX := math.max(curMaxRightX, rightX)

                if createdCurBoxes > 0 and showClusters and szClFinal > 0 and curMaxRightX > xBase
                    for i = 0 to szClFinal - 1
                        int centerBin = array.get(clusterIdxs, i)
                        float priceMid = minPrice + (centerBin + 0.5) * step
                        line cl = line.new(xBase, priceMid, curMaxRightX, priceMid, extend = extend.none, style = line.style_dotted, width = 2, color = clusterColor)
                        array.push(clusterLines, cl)

                if createdCurBoxes > 0 and showPOCLine and not na(pocPrice) and curMaxRightX > xBase
                    line pocLine = line.new(xBase, pocPrice, curMaxRightX, pocPrice, extend = extend.none, style = line.style_solid, width = 2, color = pocColor)
                    array.push(clusterLines, pocLine)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
