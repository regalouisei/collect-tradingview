// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © MUQWISHI

//@version=6
indicator("Time & Sales (Tape) [By MUQWISHI]", "Time & Sales [MUQWISHI]", overlay = true)
import n00btraders/Timezone/1 as tz

// |++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|
// |                                   INPUT                                    |
// |++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|
// +++++++++++++++ Table Settings
var G1 = "Table Settings" 

// Timezone
var timzon = input.enum(tz.TimezoneDST.NEW_YORK, "Timezone", group = G1, display = display.none).tostring()

// Location 
tblPos = input.string("Top Right", "Table Location", 
             ["Top Right" , "Middle Right"  , "Bottom Right" , 
              "Top Center", "Middle Center" , "Bottom Center", 
              "Top Left"  , "Middle Left"   , "Bottom Left" ], group = G1, display = display.none)

// Size
tblSiz = input.int(10, "Table Size", 0, group = G1, display = display.none)

// Volume Scale Bar
barChk = input.bool(true, "Show Dynamic Volume Scale Bar", group = G1)

// Title Colors
tiClC = input.color(#555580, "Title   ",  group = G1, inline = "2")
tiClX = input.color(#ffffff, "",          group = G1, inline = "2",
         tooltip = "Cell Color | Text Color")

// Cell Colors
upNCC = input.color(#BBD9FB, "Up       ", group = G1, inline = "4")
upXCC = input.color(#0C3299, "",          group = G1, inline = "4")
upClX = input.color(#089981, "",          group = G1, inline = "4",
         tooltip = "Min Color | Max Color | Text Color")

dnNCC = input.color(#FFE0B2, "Down ",     group = G1, inline = "5")
dnXCC = input.color(#E65100, "",          group = G1, inline = "5")
dnClX = input.color(#880E4F, "",          group = G1, inline = "5",
         tooltip = "Min Color | Max Color | Text Color")


// +++++++++++++++ Technical Settings
var G2  = "Technical Settings"
calMode = input.string("Lower Timeframe", "Implement By", ["Lower Timeframe", "Live Tick"], group = G2, 
          display = display.none,  tooltip = "➤ Lower Timeframe:\nFetch data from selected lower timeframe.\n\n" +
                                             "➤ Live Tick:\nFetch data in real-time on a tick-by-tick basis,"    +
                                             " capturing data as soon as it's observed by the system.")

ltFrm   = input.timeframe("1S", " ➤ Lower Timeframe",  group = G2, display = display.none,
         tooltip = "Note:\nIf the selected timeframe is invalid (higher than chart's timeframe), " + 
                   "the indicator will automatically switch to 1 second.")

rowLen  = input.int(60, "Length (№ of Rows)", 1, 100, group = G2, display = display.none) + 2

volTyp  = input.string("Volume", "Size Type", ["Volume", "Price Volume"], group = G2, display = display.none)


// |++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|
// |                                 CALCULATION                                |
// |++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|
type tape
    string tim  = na 
    string side = na
    float  last = na 
    float  vol  = na 
    color  clr  = na

// +++++++++++++++ Convert to Strings Functions 
varip strFormat = array.new<string>(3, "0")

// +++++ Max Digits 
maxDig(x1, x2) => 
    str.length(x1) > str.length(x2) ? x1 : x2

// +++++ Number of Digits Without "."
numDig(x, min) => 
    out = str.length(x) - (str.contains(x, ".") ? 1 : 0)
    out > min ? out : min

// +++++ Price Format 
strTick(x) => 
    str.tostring(x, str.replace(str.tostring(syminfo.mintick), "1", "0"))

// +++++ Volume Format
// Number of Digits 
rDigits(x1, x2) =>
    var lft = 0, var out = "" 
    if str.contains(x2, ".")
        out := "0." 
        nLft = str.length(str.split(x2, ".").get(1))
        if nLft > lft
            lft := nLft
            for i = 1 to lft
                out += "0"

    str.length(x1) < str.length(out) ? out : x1

// Volume Format 
strVol(x) =>
    if volTyp == "Volume" 
        if x > 999999 
            str.tostring(x, format.volume) 
        else 
            volFormat = strFormat.get(2)
            str.tostring(x, volFormat)
    else 
        str.tostring(x, "$#0.00")


// +++++++++++++++ Get RBG Color Function
rbgCol(x, xMin, xMax, chg) =>
    cMin = chg > 0 ? upNCC : dnNCC
    cMax = chg > 0 ? upXCC : dnXCC
    color.from_gradient(x, xMin, xMax, cMin, cMax)


// +++++++++++++++ Call Security For Lower Timeframe Data
dataLTF() =>
    vol = volTyp == "Volume" ? volume : hlc3 * volume
    tape values = na
    if calMode == "Lower Timeframe" 
        var side = float(na)

        var mx = 0.0, mx := ta.highest(vol, rowLen - 2)
        var mn = 0.0, mn := ta.lowest (vol, rowLen - 2)

        if close[1] != close
            side := (close - close[1])/close[1] > 0 ? 1 : -1

        [time, side > 0 ? "▲" : "▼", close, vol, rbgCol(vol, mn, mx, side)]

    else
        [timenow, na, close, vol, na]

var timeframe = calMode == "Live Tick" ? "" : timeframe.in_seconds(ltFrm) > timeframe.in_seconds() ? "1S" : ltFrm
[tim, side, cls, vol, clr] = request.security_lower_tf(syminfo.tickerid, timeframe, dataLTF(), true, 
                             ignore_invalid_timeframe = true, calc_bars_count = rowLen * 2)

// +++++++++++++++ Calculation Type 
// Lower Timeframe Function 
method processLTF(array<int> tim, array<string> sid, array<float> cls, array<float> vol, array<color> clr) =>
    var out = array.new<tape>(na)
    if vol.size() > 0 and  vol.size() == cls.size()

        // Slice Variables
        sIdx = cls.size() - rowLen < 0 ? 0 : cls.size() - rowLen
        eIdx = cls.size()

        tim0 = tim.slice(sIdx, eIdx) // Time
        sid0 = sid.slice(sIdx, eIdx) // Change Up or Down
        cls0 = cls.slice(sIdx, eIdx) // Last
        vol0 = vol.slice(sIdx, eIdx) // Volume
        clr0 = clr.slice(sIdx, eIdx) // Cell Color

        // Process LTF Data 
        for i = 0 to cls0.size() - 1
            cTim = str.format_time(int(tim0.get(i)), "HH:mm:ss", timzon)
            cSid = sid0.get(i)
            cCls = cls0.get(i)
            cVol = vol0.get(i)
            cClr = clr0.get(i)

            if not na(cVol) and cVol > 0
                out.unshift(tape.new(cTim, cSid, cCls, cVol, cClr))

                if barstate.islast
                    strFormat.set(2, rDigits(strFormat.get(2), str.tostring(cVol)))
                    strFormat.set(1, maxDig(strFormat.get(1) , strVol(cVol)))
                    strFormat.set(0, maxDig(strFormat.get(0) , strTick(cCls)))

                while out.size() > rowLen
                    out.pop()
    out 

// Live Tick Function
method processTick(array<int> tim, array<float> cls, array<float> vol) =>
    varip out    = array.new <tape>(1, tape.new(na, na, 0, 0, na))
    varip recVol = array.new<float>(1, 0)  // Record Volume

    if barstate.isrealtime
        cTim = int(tim.get(0))  // Time
        vol0 = vol.get(0)
        cCls = cls.get(0)       // Last

        // Tick Volume
        varip cVol = vol0
        varip pVol = 0.0
        if barstate.isnew 
            cVol := vol0
        else 
            cVol := vol0 - pVol

        // Change Up or Down
        varip cChg = 0          // Change 
        pCls  = out.get(0).last
        cChg := pCls < cCls ? 1 : pCls > cCls ? -1 : cChg
        
        // Color for Up/Down Volume
        mxVol = recVol.max()
        mnVol = recVol.min()
        cClr  = rbgCol(cVol, mnVol, mxVol, cChg)
        
        pVol := vol0, recVol.unshift(cVol)
        out.unshift(tape.new(str.format_time(cTim, "HH:mm:ss", timzon), cChg > 0 ? "▲" : "▼", cCls, cVol, cClr))

        if barstate.islast
            strFormat.set(2, rDigits(strFormat.get(2), str.tostring(cVol)))
            strFormat.set(1, maxDig(strFormat.get(1) , strVol(cVol)))
            strFormat.set(0, maxDig(strFormat.get(0) , strTick(cCls)))

        if out.size() > rowLen
            out.pop()
            recVol.pop()
    out

// Fill the Tape Array
tapeData = array.new<tape>(na)
if calMode == "Lower Timeframe"
    tapeData := processLTF(tim, side, cls, vol, clr)
else 
    tapeData := processTick(tim, cls, vol)


// |++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|
// |                                   TABLE                                    |
// |++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|
// Get Tbale Location & Size
locNsze(x) => 
    y   = str.split(str.lower(x), " ")
    out = ""
    for i = 0 to y.size() - 1
        out += y.get(i)
        if i != y.size() - 1
            out += "_"
    out

// Create Table
var nRow = rowLen
var nCol = 4
var table tbl = na

// Get Cell Function
cell(col, row, txt, hi, color, txtCol) =>
    tbl.cell(col, row, txt, 0, hi, txtCol, text.align_center, bgcolor = color, text_size = tblSiz)


// Scale Bar
scaleBar(x, prc, vol) =>
    // Sum Volume 
    upVol = .0
    dnVol = .0
    for i = 0 to x.size() - 3
        element = x.get(i)
        if element.side == "▲"
            upVol += element.vol
        else
            dnVol += element.vol
    smVol = upVol + dnVol

    // Estimate Number of Blocks for Scale Bar 
    stng  = 9 + numDig(prc, 4) + numDig(vol, 6) 
    upTxt = "", upStng = math.round(upVol/smVol * stng)
    dnTxt = "", dnStng = stng - upStng
    for i = 0 to math.max(upStng, dnStng)
        if i < upStng 
            upTxt += "█" 
        if i < dnStng
            dnTxt += "█"

    // Draw Scale Bar 
    tbl.merge_cells(0, 0, 3, 0)
    tbl.cell(0, 0, upTxt + dnTxt, 0, 0.0001, tiClC, text.align_center, text.align_center, tblSiz, tiClC), 

    tbl.merge_cells(0, 1, 3, 1)
    tbl.cell(0, 1, upTxt, 0, 0.8, upXCC, text.align_left, text.align_center, tblSiz, color.new(upNCC, 25)), 

    tbl.merge_cells(0, 2, 3, 2)
    tbl.cell(0, 2, dnTxt, 0, 0.8, dnXCC, text.align_right, text.align_center, tblSiz, color.new(dnNCC, 25)),

    // Scale Buy X Sell Info 
    tbl.merge_cells(0, 3, 3, 3)
    tCol = math.max(upVol, dnVol) == upVol ? upNCC : dnNCC
    cell(0, 3, "B  " + strVol(upVol) +"  ✖  " + strVol(dnVol) + "  S", 0, tiClC, tCol)


// Draw Table
if barstate.islast
    if tapeData.size() > 2
        tbl.delete()
        tbl := table.new(locNsze(tblPos), 4, nRow + 4, color(na), tiClC, 2, color(na), 0)

        // Header
        cell(0, 4,     "Time", 0, tiClC, tiClX)
        cell(1, 4,     "Side", 0, tiClC, tiClX)
        cell(2, 4, "  Last  ", 0, tiClC, tiClX)
        cell(3, 4, "Volume"+ (volTyp == "Volume" ? "":"\n(" + syminfo.currency + ")"), 0, tiClC, tiClX)

        // Content
        r = 5
        for i = 0 to tapeData.size() - 3
            element = tapeData.get(i)

            cTim = element.tim
            cSid = element.side
            cCls = strTick(element.last)
            cVol = strVol(element.vol)
            cClr = element.clr

            xCol = cSid == "▲" ? upClX : dnClX // Text Color

            cell(0, r, cTim, 0, cClr, xCol)
            cell(1, r, cSid, 0, cClr, xCol)
            cell(2, r, cCls, 0, cClr, xCol)
            cell(3, r, cVol, 0, cClr, xCol)

            r += 1

        // To Fixed The Width of Table
        cell(0, r, "",               0.01, tiClC, tiClC),
        cell(1, r, "",               0.01, tiClC, tiClC),
        cell(2, r, strFormat.get(0), 0.01, tiClC, tiClC),
        cell(3, r, strFormat.get(1), 0.01, tiClC, tiClC),

        // Scale Bar
        if barChk
            scaleBar(tapeData, strFormat.get(0), strFormat.get(1))
