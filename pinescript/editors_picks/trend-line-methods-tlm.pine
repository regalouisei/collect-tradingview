//@version=6
indicator(title="Trend Line Methods", shorttitle="TLM", overlay=true)

//══════════════
// Pivot Span Trendline — Method Switch & Group (Method 1)
//══════════════
string grpPivotSpan = "Pivot Span Trendline"

bool enable_pivot_span_trendline = input.bool(
     defval  = true,
     title   = "Enable Pivot Span Trendline",
     tooltip = "Toggle the Pivot Span Trendline method on or off.",
     group   = grpPivotSpan)

//══════════════
// Style Settings (Pivot Span Trendline)
//══════════════
color trend_high_color = input.color(
     defval  = #ff7b00,
     title   = "High trend line color",
     tooltip = "Color for high trend lines.",
     group   = grpPivotSpan)

color trend_low_color = input.color(
     defval  = #ff7b00,
     title   = "Low trend line color",
     tooltip = "Color for low trend lines.",
     group   = grpPivotSpan)

// رنگ ناحیه‌ی بین دو خط — پیش‌فرض همان رنگ خطوط، با شفافیت ۹۰ در کد
color pivot_span_fill_color = input.color(
     defval  = #ff7b00,
     title   = "Fill color between trend lines",
     tooltip = "Base color for the area between high and low trend lines (transparency = 90).",
     group   = grpPivotSpan)

int trend_line_width = input.int(
     defval  = 2,
     minval  = 1,
     maxval  = 5,
     title   = "Trend line thickness",
     tooltip = "Thickness of high/low trend lines.",
     group   = grpPivotSpan)

string trend_line_style = input.string(
     defval  = "dashed",
     options = ["solid", "dashed", "dotted"],
     title   = "Trend line style",
     tooltip = "Style of high/low trend lines.",
     group   = grpPivotSpan)

//══════════════
// Utils
//══════════════
get_line_style(string style) =>
    style == "solid"  ? line.style_solid  :
     style == "dashed" ? line.style_dashed :
     style == "dotted" ? line.style_dotted :
                         line.style_dashed

//══════════════
// Pivot Parameters
//══════════════
int pivot_left_input  = input.int(5,   minval=1,  title="Pivot Left",      tooltip="Left bars for pivot detection.",         group=grpPivotSpan)
int pivot_right_input = input.int(5,   minval=1,  title="Pivot Right",     tooltip="Right bars for pivot detection.",        group=grpPivotSpan)
int point_count_input = input.int(5,   minval=2,  title="Pivot Count",     tooltip="Number of pivots to track.",             group=grpPivotSpan)
int length_input      = input.int(150, minval=10, title="Lookback Length", tooltip="Bars used to keep pivots inside range.", group=grpPivotSpan)

//══════════════
// Pivot Storage
//══════════════
var int[]   high_idx_points = array.new_int()
var float[] high_val_points = array.new_float()
var int[]   low_idx_points  = array.new_int()
var float[] low_val_points  = array.new_float()

//══════════════
// Trend Lines & Fill IDs
//══════════════
var line     high_trend_line_id = na
var line     low_trend_line_id  = na
var linefill pivot_span_fill_id = na

//══════════════
// Pivot Span Trendline Logic (Method 1)
//══════════════
if enable_pivot_span_trendline
    // Pivot Detection
    float pivot_high_value = ta.pivothigh(high, pivot_left_input, pivot_right_input)
    float pivot_low_value  = ta.pivotlow(low,  pivot_left_input, pivot_right_input)

    // When a pivot high is detected, store its bar index and price.
    if not na(pivot_high_value)
        int   piv_hi_idx   = bar_index - pivot_right_input
        float piv_hi_price = high[pivot_right_input]
        array.push(high_idx_points, piv_hi_idx)
        array.push(high_val_points, piv_hi_price)
        // Remove oldest entries if exceeding the configured pivot count.
        while array.size(high_idx_points) > point_count_input
            array.shift(high_idx_points)
            array.shift(high_val_points)

    // When a pivot low is detected, store its bar index and price.
    if not na(pivot_low_value)
        int   piv_lo_idx   = bar_index - pivot_right_input
        float piv_lo_price = low[pivot_right_input]
        array.push(low_idx_points, piv_lo_idx)
        array.push(low_val_points, piv_lo_price)
        while array.size(low_idx_points) > point_count_input
            array.shift(low_idx_points)
            array.shift(low_val_points)

    // Draw or update the HIGH trend line; remove it if fewer than two high pivots exist.
    if array.size(high_idx_points) >= 2
        int   far_hi_idx   = array.get(high_idx_points, 0)
        float far_hi_val   = array.get(high_val_points, 0)
        int   near_hi_idx  = array.get(high_idx_points, array.size(high_idx_points) - 1)
        float near_hi_val  = array.get(high_val_points, array.size(high_val_points) - 1)
        int   hi_bar_diff  = near_hi_idx - far_hi_idx
        float hi_slope     = hi_bar_diff != 0 ? (near_hi_val - far_hi_val) / hi_bar_diff : 0.0
        float hi_intercept = far_hi_val - hi_slope * far_hi_idx
        int   x1_hi        = bar_index - (length_input - 1)
        int   x2_hi        = bar_index
        float y1_hi        = hi_intercept + hi_slope * x1_hi
        float y2_hi        = hi_intercept + hi_slope * x2_hi
        if na(high_trend_line_id)
            high_trend_line_id := line.new(
                 x1_hi, y1_hi, x2_hi, y2_hi,
                 xloc   = xloc.bar_index,
                 extend = extend.none,
                 color  = trend_high_color,
                 width  = trend_line_width,
                 style  = get_line_style(trend_line_style))
        else
            line.set_xy1(high_trend_line_id, x1_hi, y1_hi)
            line.set_xy2(high_trend_line_id, x2_hi, y2_hi)
            line.set_extend(high_trend_line_id, extend.none)
            line.set_color(high_trend_line_id, trend_high_color)
            line.set_width(high_trend_line_id, trend_line_width)
            line.set_style(high_trend_line_id, get_line_style(trend_line_style))
    else
        if not na(high_trend_line_id)
            line.delete(high_trend_line_id)
        high_trend_line_id := na

    // Draw or update the LOW trend line; remove it if fewer than two low pivots exist.
    if array.size(low_idx_points) >= 2
        int   far_lo_idx   = array.get(low_idx_points, 0)
        float far_lo_val   = array.get(low_val_points, 0)
        int   near_lo_idx  = array.get(low_idx_points, array.size(low_idx_points) - 1)
        float near_lo_val  = array.get(low_val_points, array.size(low_val_points) - 1)
        int   lo_bar_diff  = near_lo_idx - far_lo_idx
        float lo_slope     = lo_bar_diff != 0 ? (near_lo_val - far_lo_val) / lo_bar_diff : 0.0
        float lo_intercept = far_lo_val - lo_slope * far_lo_idx
        int   x1_lo        = bar_index - (length_input - 1)
        int   x2_lo        = bar_index
        float y1_lo        = lo_intercept + lo_slope * x1_lo
        float y2_lo        = lo_intercept + lo_slope * x2_lo
        if na(low_trend_line_id)
            low_trend_line_id := line.new(
                 x1_lo, y1_lo, x2_lo, y2_lo,
                 xloc   = xloc.bar_index,
                 extend = extend.none,
                 color  = trend_low_color,
                 width  = trend_line_width,
                 style  = get_line_style(trend_line_style))
        else
            line.set_xy1(low_trend_line_id, x1_lo, y1_lo)
            line.set_xy2(low_trend_line_id, x2_lo, y2_lo)
            line.set_extend(low_trend_line_id, extend.none)
            line.set_color(low_trend_line_id, trend_low_color)
            line.set_width(low_trend_line_id, trend_line_width)
            line.set_style(low_trend_line_id, get_line_style(trend_line_style))
    else
        if not na(low_trend_line_id)
            line.delete(low_trend_line_id)
        low_trend_line_id := na

    //══════════════
    // Pivot Span Fill Between High & Low Lines
    //══════════════
    if not na(high_trend_line_id) and not na(low_trend_line_id)
        color fill_col = color.new(pivot_span_fill_color, 90)
        if na(pivot_span_fill_id)
            pivot_span_fill_id := linefill.new(
                 high_trend_line_id,
                 low_trend_line_id,
                 fill_col)
        else
            linefill.set_color(pivot_span_fill_id, fill_col)
    else
        if not na(pivot_span_fill_id)
            linefill.delete(pivot_span_fill_id)
            pivot_span_fill_id := na
else
    // When method is disabled, make sure any existing lines and fills are removed.
    if not na(high_trend_line_id)
        line.delete(high_trend_line_id)
        high_trend_line_id := na
    if not na(low_trend_line_id)
        line.delete(low_trend_line_id)
        low_trend_line_id := na
    if not na(pivot_span_fill_id)
        linefill.delete(pivot_span_fill_id)
        pivot_span_fill_id := na

//══════════════
// 5-Point Straight Channel — Method 2
//══════════════
string grpFivePoint = "5-Point Straight Channel"

bool enable_five_point_channel = input.bool(
     defval  = false,
     title   = "Enable 5-Point Straight Channel",
     tooltip = "Toggle the 5-Point Straight Channel method on or off.",
     group   = grpFivePoint)

// Style for Method 2
color five_hi_color = input.color(
     defval  = #ff00d0,
     title   = "High channel line color",
     tooltip = "Color for the upper 5-point channel line.",
     group   = grpFivePoint)

color five_lo_color = input.color(
     defval  = #ff00d0,
     title   = "Low channel line color",
     tooltip = "Color for the lower 5-point channel line.",
     group   = grpFivePoint)

int five_line_width = input.int(
     defval  = 3,
     minval  = 1,
     maxval  = 5,
     title   = "Channel line thickness",
     tooltip = "Thickness of 5-point channel lines.",
     group   = grpFivePoint)

string five_line_style = input.string(
     defval  = "solid",
     options = ["solid", "dashed", "dotted"],
     title   = "Channel line style",
     tooltip = "Style of 5-point channel lines.",
     group   = grpFivePoint)

// Length (window) for Method 2
int len_channel_5pt = input.int(
     defval  = 100,
     minval  = 10,
     title   = "Channel Length (bars)",
     tooltip = "Lookback window used to build 5-point straight high/low channel lines.",
     group   = grpFivePoint)

//──────── Function: 5-Point Linear Channel Fit
calcFivePointChannel(int len_window) =>
    float slope_hi_5pt     = na
    float intercept_hi_5pt = na
    float slope_lo_5pt     = na
    float intercept_lo_5pt = na

    bool enough_bars_5pt = bar_index >= len_window

    if enough_bars_5pt
        float sum_x_hi  = 0.0
        float sum_y_hi  = 0.0
        float sum_xy_hi = 0.0
        float sum_x2_hi = 0.0
        int   n_hi      = 0

        float sum_x_lo  = 0.0
        float sum_y_lo  = 0.0
        float sum_xy_lo = 0.0
        float sum_x2_lo = 0.0
        int   n_lo      = 0

        int seg_len_base = math.max(1, math.floor(len_window / 5))

        for k = 0 to 4
            int seg_start = k * seg_len_base
            int remaining = len_window - seg_start
            if remaining <= 0
                break

            int seg_len_k = k < 4 ? math.min(seg_len_base, remaining) : remaining

            // High segment – take highest high in this segment
            float max_hi     = na
            int   barsAgo_hi = na
            for i = 0 to seg_len_k - 1
                int   sh = seg_start + i
                float v  = high[sh]
                if not na(v) and (na(max_hi) or v > max_hi)
                    max_hi     := v
                    barsAgo_hi := sh
            if not na(barsAgo_hi)
                int   x_hi_int = bar_index - barsAgo_hi
                float x_hi     = x_hi_int
                float y_hi     = high[barsAgo_hi]
                sum_x_hi  += x_hi
                sum_y_hi  += y_hi
                sum_xy_hi += x_hi * y_hi
                sum_x2_hi += x_hi * x_hi
                n_hi      += 1

            // Low segment – take lowest low in this segment
            float min_lo     = na
            int   barsAgo_lo = na
            for i = 0 to seg_len_k - 1
                int   sl = seg_start + i
                float v2 = low[sl]
                if not na(v2) and (na(min_lo) or v2 < min_lo)
                    min_lo     := v2
                    barsAgo_lo := sl
            if not na(barsAgo_lo)
                int   x_lo_int = bar_index - barsAgo_lo
                float x_lo     = x_lo_int
                float y_lo     = low[barsAgo_lo]
                sum_x_lo  += x_lo
                sum_y_lo  += y_lo
                sum_xy_lo += x_lo * y_lo
                sum_x2_lo += x_lo * x_lo
                n_lo      += 1

        // Linear regression for highs
        if n_hi >= 2
            float nf_hi    = n_hi
            float denom_hi = nf_hi * sum_x2_hi - sum_x_hi * sum_x_hi
            slope_hi_5pt     := denom_hi != 0.0 ? (nf_hi * sum_xy_hi - sum_x_hi * sum_y_hi) / denom_hi : 0.0
            intercept_hi_5pt := nf_hi  != 0.0 ? (sum_y_hi - slope_hi_5pt * sum_x_hi) / nf_hi : na

        // Linear regression for lows
        if n_lo >= 2
            float nf_lo    = n_lo
            float denom_lo = nf_lo * sum_x2_lo - sum_x_lo * sum_x_lo
            slope_lo_5pt     := denom_lo != 0.0 ? (nf_lo * sum_xy_lo - sum_x_lo * sum_y_lo) / denom_lo : 0.0
            intercept_lo_5pt := nf_lo  != 0.0 ? (sum_y_lo - slope_lo_5pt * sum_x_lo) / nf_lo : na

    [slope_hi_5pt, intercept_hi_5pt, slope_lo_5pt, intercept_lo_5pt]

//──────── Lines IDs for Method 2
var line hi_line_5pt = na
var line lo_line_5pt = na

//══════════════
// 5-Point Straight Channel Logic (Method 2)
//══════════════
if enable_five_point_channel
    [slope_hi_5pt, intercept_hi_5pt, slope_lo_5pt, intercept_lo_5pt] = calcFivePointChannel(len_channel_5pt)

    bool can_draw_hi_5pt = not na(slope_hi_5pt) and not na(intercept_hi_5pt)
    bool can_draw_lo_5pt = not na(slope_lo_5pt) and not na(intercept_lo_5pt)

    int   x1_5pt  = bar_index - len_channel_5pt + 1
    int   x2_5pt  = bar_index
    float x1f_5pt = x1_5pt
    float x2f_5pt = x2_5pt

    // Upper line
    if can_draw_hi_5pt
        float y1_hi_5pt = slope_hi_5pt * x1f_5pt + intercept_hi_5pt
        float y2_hi_5pt = slope_hi_5pt * x2f_5pt + intercept_hi_5pt
        if na(hi_line_5pt)
            hi_line_5pt := line.new(
                 x1_5pt, y1_hi_5pt,
                 x2_5pt, y2_hi_5pt,
                 xloc   = xloc.bar_index,
                 extend = extend.none,
                 color  = five_hi_color,
                 style  = get_line_style(five_line_style),
                 width  = five_line_width)
        else
            line.set_xy1(hi_line_5pt, x1_5pt, y1_hi_5pt)
            line.set_xy2(hi_line_5pt, x2_5pt, y2_hi_5pt)
            line.set_color(hi_line_5pt, five_hi_color)
            line.set_style(hi_line_5pt, get_line_style(five_line_style))
            line.set_width(hi_line_5pt, five_line_width)
    else
        if not na(hi_line_5pt)
            line.delete(hi_line_5pt)
            hi_line_5pt := na

    // Lower line
    if can_draw_lo_5pt
        float y1_lo_5pt = slope_lo_5pt * x1f_5pt + intercept_lo_5pt
        float y2_lo_5pt = slope_lo_5pt * x2f_5pt + intercept_lo_5pt
        if na(lo_line_5pt)
            lo_line_5pt := line.new(
                 x1_5pt, y1_lo_5pt,
                 x2_5pt, y2_lo_5pt,
                 xloc   = xloc.bar_index,
                 extend = extend.none,
                 color  = five_lo_color,
                 style  = get_line_style(five_line_style),
                 width  = five_line_width)
        else
            line.set_xy1(lo_line_5pt, x1_5pt, y1_lo_5pt)
            line.set_xy2(lo_line_5pt, x2_5pt, y2_lo_5pt)
            line.set_color(lo_line_5pt, five_lo_color)
            line.set_style(lo_line_5pt, get_line_style(five_line_style))
            line.set_width(lo_line_5pt, five_line_width)
    else
        if not na(lo_line_5pt)
            line.delete(lo_line_5pt)
            lo_line_5pt := na
else
    // Disable: clean up Method 2 lines
    if not na(hi_line_5pt)
        line.delete(hi_line_5pt)
        hi_line_5pt := na
    if not na(lo_line_5pt)
        line.delete(lo_line_5pt)
        lo_line_5pt := na
