// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© fikira
//@version=5
indicator("Average Lines", max_lines_count=500, overlay=true)

// -----------[ inputs ]-----------

var int     left  = input.int      (10  , 'leftbars'   , group='settings')
var int     right = input.int      ( 1  , 'rightbars'  , group='settings')
var bool    fill  = input.bool     (true, 'fill lines?', group='settings')
var string  choice= input.string   ('ph', 'choice'     , group='settings', options=['ph', 'pl', 'both', 'none'])
var int     max   = input.int      (500 , 'max pivot points for calculations'           )
var int     maxX  = input.int      (1000, 'max bars between concerning bar and last bar')

var color   c_pih = input.color    (color.new(color.red , 85), 'connecting line between (pivots)', group='colours pivot high')
var color   c_lh  = input.color    (color.new(color.red , 99), 'lines'                           , group='colours pivot high')
var color   c_avh = input.color    (color.new(#00bcd4   ,  0), 'average'                         , group='colours pivot high')
var color   c_fh  = input.color    (color.new(color.red , 93), 'linefill'                        , group='colours pivot high')

var color   c_pil = input.color    (color.new(color.lime, 85), 'connecting line between (pivots)', group='colours pivot low' )
var color   c_ll  = input.color    (color.new(color.blue, 99), 'lines'                           , group='colours pivot low' )
var color   c_avl = input.color    (color.new(#388e3c   ,  0), 'average'                         , group='colours pivot low' )
var color   c_fl  = input.color    (color.new(color.lime, 93), 'linefill'                        , group='colours pivot low' )

// -----------[ variables ]-----------

var float   avh   = 0.
var float   avl   = 0.

// no var

float       ph    = ta.pivothigh   (left, right)
float       pl    = ta.pivotlow    (left, right)
float[]     a_avh = array.new_float()
float[]     a_avl = array.new_float()

// -----------[ array's ]-----------

var float   [] a_php = array.new_float   ()
var float   [] a_plp = array.new_float   ()
var int     [] a_plb = array.new_int     ()
var int     [] a_phb = array.new_int     ()
var line    [] a_lh  = array.new_line    ()
var linefill[] a_lhF = array.new_linefill()
var line    [] a_ll  = array.new_line    ()
var linefill[] a_llF = array.new_linefill()


switch
    choice == 'both' =>
        if array.size(a_lh ) > 0 and array.size(a_ll ) > 0 
            if (array.size(a_lh )  + array.size(a_ll )) > 500
                if array.size(a_lh ) > array.size(a_ll )
                    line.delete(array.pop(a_lh ))
                else
                    line.delete(array.pop(a_ll ))
        if array.size(a_lhF) > 0 and array.size(a_llF) > 0 
            if (array.size(a_lhF)  + array.size(a_llF)) > 500
                if array.size(a_lhF) > array.size(a_llF)
                    lineF         = array.pop(a_lhF)
                    line.delete(linefill.get_line1(lineF))
                    line.delete(linefill.get_line2(lineF))
                    linefill.delete(lineF)
                else
                    lineF         = array.pop(a_llF)
                    line.delete(linefill.get_line1(lineF))
                    line.delete(linefill.get_line2(lineF))
                    linefill.delete(lineF)
    choice == 'ph' =>
        if array.size(a_lh) > 500
            line.delete(array.pop(a_lh))
        if array.size(a_lhF) > 500
            lineF         = array.pop(a_lhF)
            line.delete(linefill.get_line1(lineF))
            line.delete(linefill.get_line2(lineF))
            linefill.delete(lineF)
    choice == 'pl' =>
        if array.size(a_ll) > 500
            line.delete(array.pop(a_ll))  
        if array.size(a_llF) > 500
            lineF         = array.pop(a_llF)
            line.delete(linefill.get_line1(lineF))
            line.delete(linefill.get_line2(lineF))
            linefill.delete(lineF)
    
// -----------[ functions ]-----------

calc_avg(array_lines, array_average) =>
    var average = 0.
    if array.size(array_lines) > 0
        for i = 0 to array.size(array_lines) -1
            array.unshift(array_average, line.get_price(array.get(array_lines, i), bar_index))
            average := array.avg(array_average)
    [average]
 
draw_lines(piv, array_piv_price, array_piv_index, array_lines, array_fill, col_lines, col_fill) => 
    //
    //var linefill ln_fill = na
    max_bars_back(piv, 5000)
    if piv and last_bar_index - bar_index < maxX
        array.unshift(array_piv_price, piv              )
        array.unshift(array_piv_index, bar_index - right)
        //
        if array.size(array_piv_price) > 0
            for i = 0 to array.size(array_piv_price) -1
                x1 = array.get(array_piv_index, i)
                y1 = array.get(array_piv_price, i)
                x2 = array.get(array_piv_index, 0)
                y2 = array.get(array_piv_price, 0)
                //
                array.unshift (array_lines    , line.new(x1, y1, x2, y2, color=col_lines, extend=extend.right))
                if array.size(array_lines) > 500
                    line.delete(array.pop(array_lines))
                    line.delete(array.pop(array_lines))
                if fill and array.size(array_lines) > 1
                    array.unshift(array_fill, linefill.new(array.get(array_lines, i + 1), array.get(array_lines, i), col_fill))
                    //    


if choice == 'ph' or choice == 'both'
    draw_lines(ph, a_php, a_phb, a_lh, a_lhF, c_lh, c_fh)  
    [_avh]   = calc_avg(a_lh, a_avh), avh := _avh

if choice == 'pl' or choice == 'both'
    draw_lines(pl, a_plp, a_plb, a_ll, a_llF, c_ll, c_fl)  
    [_avl]   = calc_avg(a_ll, a_avl), avl := _avl
    
if array.size(a_php) > max 
    array.pop(a_php)
    array.pop(a_phb)
if array.size(a_plp) > max 
    array.pop(a_plp)
    array.pop(a_plb)

plot((choice == 'ph' or choice == 'both') and avh > 0 ? avh : na, color=c_avh)
plot((choice == 'pl' or choice == 'both') and avl > 0 ? avl : na, color=c_avl)
plot((choice == 'ph' or choice == 'both')             ? ph  : na, color=c_pih, offset=-right)
plot((choice == 'pl' or choice == 'both')             ? pl  : na, color=c_pil, offset=-right)
