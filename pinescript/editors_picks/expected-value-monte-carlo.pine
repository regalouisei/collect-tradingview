//@version=6
//Developed by Henrique Centieiro :) 
indicator("Expected Value Monte Carlo", shorttitle="EVMC", overlay=true, max_labels_count=10)

// --- DESCRIPTION ---
// This indicator overlays a statistical projection on the main chart, providing a sophisticated analytical edge.
// 1. Historical Backtesting: Calculates the actual results of a strategy over a long-term, user-defined period.
// 2. Monte Carlo Projection: Simulates thousands of future price paths based on the trend and volatility of a recent period.
// The script is fully timeframe-aware and asset-aware (stocks, crypto, etc.), ensuring mathematically sound, non-repainting analysis on any chart.

// --- USER INPUTS ---
// General Settings
i_trade_duration = input.int(defval=252, title="Max Trade Duration (bars)", minval=1, group="General Settings", tooltip="The maximum number of bars to hold a trade. On a Daily chart, 252 is ~1 year for stocks.")
i_position_size = input.float(defval=1000.0, title="Position Size ($)", minval=1.0, group="General Settings")

// Calculation Settings
i_momentum_lookback = input.int(defval=252, title="Projection Lookback (bars)", minval=10, group="Calculation Settings", tooltip="The lookback period for calculating the trend and volatility that the Monte Carlo projection is based on. A shorter period makes the projection more sensitive to recent price action, which can reveal recency bias.")
i_lookback_bars = input.int(defval=2500, title="Historical Lookback (bars)", minval=1, maxval=5000, group="Calculation Settings", tooltip="Defines the total historical data for the backtest. A longer period provides more statistically significant results.")
i_monte_carlo_sims = input.int(defval=1000, title="Monte Carlo Simulations", minval=100, maxval=5000, group="Calculation Settings")
i_risk_free_rate = input.float(defval=5.0, title="Annual Risk-Free Rate (%)", group="Calculation Settings", tooltip="Used for Sharpe Ratio calculation.")

// Historical TP/SL Settings
i_use_tp_sl = input.bool(defval=false, title="Use TP/SL for Historical EV", group="Historical Strategy Settings")
i_tp_pct = input.float(defval=10.0, title="Take Profit (%)", minval=0.1, group="Historical Strategy Settings")
i_sl_pct = input.float(defval=5.0, title="Stop Loss (%)", minval=0.1, maxval=99.9, group="Historical Strategy Settings", tooltip="Must be between 0.1 and 99.9.")

// Display Settings
i_font_size_option = input.string(defval="Normal", title="Table Font Size", options=["Small", "Normal", "Large"], group="Display Settings")

// --- SETUP ---
entry_price = close
table_font_size = switch i_font_size_option
    "Small"  => size.small
    "Normal" => size.normal
    "Large"  => size.large
    => size.normal

// --- DYNAMIC ANNUALIZATION FACTOR ---
var trading_days_in_year = 252.0 // Default for stocks, forex, etc.
switch syminfo.type
    "crypto" => trading_days_in_year := 365.0

ms_in_year = 1000.0 * 60 * 60 * 24 * trading_days_in_year
ms_in_bar = timeframe.in_seconds() * 1000
annualization_factor = ms_in_bar > 0 ? ms_in_year / ms_in_bar : trading_days_in_year

// --- STATISTICAL PROPERTY CALCULATIONS ---
returns = math.log(close / nz(close[1], close))
long_vol = ta.stdev(returns, i_momentum_lookback) * math.sqrt(annualization_factor) * 100
long_trend = ta.sma(returns, i_momentum_lookback) * annualization_factor * 100

// --- FUNCTION TO CALCULATE SHARPE RATIO ---
calculate_sharpe(avg_annual_return, ann_volatility) =>
    excess_return = avg_annual_return - i_risk_free_rate
    ann_volatility > 0 ? excess_return / ann_volatility : na

// --- HISTORICAL BACKTESTING ---
calculate_historical_stats() =>
    var float hist_ev = na, var float hist_ev_pct = na, var float hist_sigma = na, var float hist_win_rate = na, var float hist_sharpe = na, var int total_trades = 0
    if barstate.islast
        hist_ev := na, hist_ev_pct := na, hist_sigma := na, hist_win_rate := na, hist_sharpe := na
        min_required_lookback = i_trade_duration + 50
        if i_lookback_bars < min_required_lookback
            total_trades := -1
        else
            hist_returns = array.new<float>()
            step_size = math.max(3, int(i_trade_duration / 10))
            for entry_ago = i_trade_duration + step_size to i_lookback_bars by step_size
                if bar_index > entry_ago
                    entry_price_hist = close[entry_ago]
                    trade_return = 0.0
                    if not i_use_tp_sl
                        exit_price_hist = close[entry_ago - i_trade_duration]
                        trade_return := (exit_price_hist - entry_price_hist) / entry_price_hist
                    else
                        tp_level = entry_price_hist * (1 + i_tp_pct / 100)
                        sl_level = entry_price_hist * (1 - i_sl_pct / 100)
                        exit_found = false
                        exit_price_hist = 0.0
                        for i = 1 to i_trade_duration
                            bar_offset = entry_ago - i
                            if low[bar_offset] <= sl_level
                                exit_price_hist := sl_level, exit_found := true, break
                            if high[bar_offset] >= tp_level
                                exit_price_hist := tp_level, exit_found := true, break
                        if not exit_found
                            exit_price_hist := close[entry_ago - i_trade_duration]
                        trade_return := (exit_price_hist - entry_price_hist) / entry_price_hist
                    array.push(hist_returns, trade_return)
            trade_count = array.size(hist_returns)
            if trade_count > 0
                avg_period_return = array.sum(hist_returns) / trade_count
                annualized_return = math.pow(1 + avg_period_return, annualization_factor / i_trade_duration) - 1
                variance = 0.0
                for ret in hist_returns
                    variance += math.pow(ret - avg_period_return, 2)
                period_vol = math.sqrt(variance / trade_count)
                annualized_vol = period_vol * math.sqrt(annualization_factor / i_trade_duration)
                win_count = 0
                for ret in hist_returns
                    if ret > 0
                        win_count += 1
                hist_ev := avg_period_return * i_position_size, hist_ev_pct := avg_period_return * 100, hist_sigma := period_vol * i_position_size
                hist_win_rate := win_count / trade_count * 100, hist_sharpe := calculate_sharpe(annualized_return * 100, annualized_vol * 100)
                total_trades := trade_count
            else
                total_trades := 0
    [hist_ev, hist_ev_pct, hist_sigma, hist_win_rate, hist_sharpe, total_trades]

// --- MONTE CARLO SIMULATION (Buy and Hold) ---
calculate_monte_carlo_stats() =>
    var float mc_ev = na, var float mc_ev_pct = na, var float mc_sigma = na, var float mc_win_rate = na, var float mc_sharpe = na
    if barstate.islast
        mc_ev := na, mc_ev_pct := na, mc_sigma := na, mc_win_rate := na, mc_sharpe := na
        mc_returns = array.new<float>()
        annual_return_mc = long_trend, annual_vol_mc = long_vol
        per_bar_drift = annual_return_mc / annualization_factor / 100
        per_bar_vol = annual_vol_mc / 100 / math.sqrt(annualization_factor)
        total_drift = per_bar_drift * i_trade_duration
        total_vol = per_bar_vol * math.sqrt(i_trade_duration)
        for sim = 1 to i_monte_carlo_sims
            // FINAL POLISH: Non-repainting random number seeds for stable projections.
            seed1 = (sim * 31415 + bar_index) % 2147483647
            seed2 = (sim * 14142 + time_tradingday) % 2147483647 // time_tradingday provides a stable, non-repainting seed.
            random1 = (seed1 % 100000) / 100000.0
            random2 = (seed2 % 100000) / 100000.0
            if random1 > 0.0001 and random2 > 0.0001
                normal_random = math.sqrt(-2 * math.log(random1)) * math.cos(2 * math.pi * random2)
                log_return = total_drift + normal_random * total_vol
                array.push(mc_returns, math.exp(log_return) - 1)
        sim_count = array.size(mc_returns)
        if sim_count > 0
            avg_period_return = array.sum(mc_returns) / sim_count
            variance = 0.0
            for ret in mc_returns
                variance += math.pow(ret - avg_period_return, 2)
            period_vol = math.sqrt(variance / sim_count)
            win_count = 0
            for ret in mc_returns
                if ret > 0
                    win_count += 1
            mc_ev := avg_period_return * i_position_size, mc_ev_pct := avg_period_return * 100, mc_sigma := period_vol * i_position_size
            mc_win_rate := win_count / sim_count * 100, mc_sharpe := calculate_sharpe(annual_return_mc, annual_vol_mc)
    [mc_ev, mc_ev_pct, mc_sigma, mc_win_rate, mc_sharpe]

// --- GLOBAL DECLARATIONS ---
var table info_table = na
var line ev_line = na, var line upper_line = na, var line lower_line = na
var line hist_ev_line = na, var linefill projection_fill = na
var label hist_label = na, var label upper_sigma_label = na, var label lower_sigma_label = na

// --- CALCULATIONS & DISPLAY ---
[hist_ev, hist_ev_pct, hist_sigma, hist_win_rate, hist_sharpe, total_trades] = calculate_historical_stats()
[mc_ev, mc_ev_pct, mc_sigma, mc_win_rate, mc_sharpe] = calculate_monte_carlo_stats()

if barstate.islast
    // --- TABLE DISPLAY ---
    info_table := table.new(position.top_right, 5, 4, bgcolor=color.new(#1e293b, 85), border_width=1)
    // UPDATED: Changed table title.
    table.cell(info_table, 0, 0, "EV STATISTICAL VALUES", text_color=color.gray, text_size=table_font_size)
    table.merge_cells(info_table, 0, 0, 4, 0)
    table.cell(info_table, 0, 1, "Method", text_color=color.gray, text_size=table_font_size)
    table.cell(info_table, 1, 1, "$ Amount", text_color=color.gray, text_size=table_font_size)
    table.cell(info_table, 2, 1, "% Return", text_color=color.gray, text_size=table_font_size)
    table.cell(info_table, 3, 1, "Win Rate", text_color=color.gray, text_size=table_font_size)
    table.cell(info_table, 4, 1, "Sharpe", text_color=color.gray, text_size=table_font_size)
    
    if total_trades == -1
        table.cell(info_table, 0, 2, "Historical" + (i_use_tp_sl ? " (TP/SL)" : ""), text_color=color.silver, text_size=table_font_size)
        table.cell(info_table, 1, 2, "Increase Lookback", text_color=color.orange, text_size=size.small)
        table.merge_cells(info_table, 1, 2, 4, 2)
    else
        hist_color = na(hist_ev) ? color.gray : hist_ev >= 0 ? color.green : color.red
        table.cell(info_table, 0, 2, "Historical" + (i_use_tp_sl ? " (TP/SL)" : ""), text_color=color.silver, text_size=table_font_size)
        table.cell(info_table, 1, 2, "$" + str.tostring(hist_ev, "#.##"), text_color=hist_color, text_size=table_font_size)
        table.cell(info_table, 2, 2, str.tostring(hist_ev_pct, "#.##") + "%", text_color=hist_color, text_size=table_font_size)
        table.cell(info_table, 3, 2, str.tostring(hist_win_rate, "#.#") + "%", text_color=color.white, text_size=table_font_size)
        table.cell(info_table, 4, 2, str.tostring(hist_sharpe, "#.##"), text_color=color.white, text_size=table_font_size)
        
    mc_color = na(mc_ev) ? color.gray : mc_ev >= 0 ? color.green : color.red
    table.cell(info_table, 0, 3, "Monte Carlo (Hold)", text_color=color.silver, text_size=table_font_size)
    table.cell(info_table, 1, 3, "$" + str.tostring(mc_ev, "#.##"), text_color=mc_color, text_size=table_font_size)
    table.cell(info_table, 2, 3, str.tostring(mc_ev_pct, "#.##") + "%", text_color=mc_color, text_size=table_font_size)
    table.cell(info_table, 3, 3, str.tostring(mc_win_rate, "#.#") + "%", text_color=color.white, text_size=table_font_size)
    table.cell(info_table, 4, 3, str.tostring(mc_sharpe, "#.##"), text_color=color.white, text_size=table_font_size)
    
    // --- VISUALIZATION ---
    line.delete(ev_line[1]), line.delete(upper_line[1]), line.delete(lower_line[1]), line.delete(hist_ev_line[1]), linefill.delete(projection_fill[1]), label.delete(hist_label[1]), label.delete(upper_sigma_label[1]), label.delete(lower_sigma_label[1])
    if not na(mc_ev_pct)
        future_ev_price = entry_price * (1 + mc_ev_pct / 100)
        future_upper_price = entry_price * (1 + (mc_ev_pct + mc_sigma / i_position_size * 100) / 100)
        future_lower_price = entry_price * (1 + (mc_ev_pct - mc_sigma / i_position_size * 100) / 100)
        
        // UPDATED: Changed color from orange to purple.
        ev_line := line.new(bar_index, entry_price, bar_index + i_trade_duration, future_ev_price, color=color.purple, width=1)
        upper_line := line.new(bar_index, entry_price, bar_index + i_trade_duration, future_upper_price, color=color.new(color.white, 80), style=line.style_dashed)
        lower_line := line.new(bar_index, entry_price, bar_index + i_trade_duration, future_lower_price, color=color.new(color.white, 80), style=line.style_dashed)
        projection_fill := linefill.new(upper_line, lower_line, color=color.new(color.purple, 85))

        upper_sigma_label := label.new(bar_index + i_trade_duration, future_upper_price, text=str.tostring(future_upper_price, "#.##") + " (+1σ)", color=color.new(color.white, 100), textcolor=color.white, style=label.style_label_left, textalign=text.align_right)
        lower_sigma_label := label.new(bar_index + i_trade_duration, future_lower_price, text=str.tostring(future_lower_price, "#.##") + " (-1σ)", color=color.new(color.white, 100), textcolor=color.white, style=label.style_label_left, textalign=text.align_right)

    if not na(hist_ev)
        hist_ev_price = entry_price * (1 + hist_ev_pct/100)
        hist_ev_line := line.new(bar_index, hist_ev_price, bar_index + i_trade_duration, hist_ev_price, color=color.green, width=1, style=line.style_dotted)
        // UPDATED: Repositioned Hist. EV label to the start of the line for better clarity.
        hist_label := label.new(bar_index, hist_ev_price, text="Hist. EV: " + str.tostring(hist_ev_price, "#.##"), color=color.new(color.green, 100), textcolor=color.green, style=label.style_label_right, textalign=text.align_left)
