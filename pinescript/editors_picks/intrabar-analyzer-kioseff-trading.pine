// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © KioseffTrading

//@version=5
indicator("Intrabar Analyzer [Kioseff Trading]", max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 1)

import PineCoders/Time/3 as pct, import kaigouthro/hsvColor/15 as kai, import kaigouthro/EchoMorphicAverage/1 as wema, import TradingView/TechnicalRating/1 as rating


lowTFstr  = input.string (defval = "1", title = "Lower Timeframe Chart", inline = "24")
rolling   = input.bool   (defval = false, title = "Show Current LTF Data Only", inline = "24")
strin     = input.string (defval = "Scatter Plot", title = "Price x Vol Graph Characters", options = ["Numbers", "Scatter Plot"], group = "Rotation Graph")
scol      = input.color  (defval = color.blue, title = "Start Color (Early Data Color)",  group = "Rotation Graph")
ecol      = input.color  (defval = #7e57c2, title = "End Color (Late Data Color)",group = "Rotation Graph")
typ       = input.string (defval = "Traditional", title = "Price Data", options = ["Traditional", "Heikin-Ashi", "Kagi", "Point Figure", "Renko", "Line Break"], group = "Price Chart")
kRev      = input.float  (defval = 0.01, title = "Reversal Number", minval = 0.00000001, group = "Kagi")
pBox      = input.string (defval = "Traditional", title = "Box Assignment Method", options = ["ATR", "Traditional"], group = "Point Figure")
lb        = input.float  (defval = 1, title = "ATR Length / Box Size", minval = 0.00000001,  group = "Point Figure")
pRev      = input.int    (defval = 3, title = "Reversal Amount", minval = 1,  group = "Point Figure")
pfl       = input.string (defval = "Tiny", title = "Label Size", options = ["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], group = "Point Figure")
rStyle    = input.string (defval = "Traditional", title = "Box Assignment Menthod", options = ["ATR", "Traditional"], group = "Renko")
rba       = input.float  (defval = 0.1, title = "ATR Length / Box Size", minval = 0.00000001, group = "Renko")
rwick     = input.bool   (defval = false, title = "Wicks", group = "Renko")
linbr     = input.int    (defval = 1, title = "Number of Lines", minval = 1, group = "Line Break")


ind1       = input.string(defval = "Positive Volume Index", title = "Indicator 1", group = "Indicator Chart", options = ["RSI", "%k", "ROC", "MFI", "MFC", "OBV", "CCI", "BBW", "CMO" , "COG", "KCW", "MOM", "Negative Volume Index", "Positive Volume Index", "Price Volume Trend", "RANGE", "WPR"], inline = "30")
ind1Len    = input.int   (defval = 14, title = "Length", inline = "30", group = "Indicator Chart")
ind1Col    = input.color (defval = color.purple, title = "", inline = "30", group = "Indicator Chart")

ind2       = input.string(defval = "Negative Volume Index", title = "Indicator 2", inline = "31",group = "Indicator Chart", options = ["RSI", "%k", "ROC", "MFI", "MFC", "OBV", "CCI", "BBW", "CMO" , "COG", "KCW", "MOM", "Negative Volume Index", "Positive Volume Index", "Price Volume Trend", "RANGE", "WPR"])
ind2Len    = input.int   (defval = 14, title = "Length", inline = "31",group = "Indicator Chart")
ind2Col    = input.color (defval = color.lime, title = "", inline = "31",group = "Indicator Chart")


ind3       = input.string(defval = "Price Volume Trend", title = "Indicator 3", inline = "32" , group = "Indicator Chart", options = ["RSI", "%k", "ROC", "MFI", "MFC", "OBV", "CCI", "BBW", "CMO" , "COG", "KCW", "MOM", "Negative Volume Index", "Positive Volume Index", "Price Volume Trend", "RANGE", "WPR"])
ind3Len    = input.int   (defval = 14, title = "Length", inline = "32", group = "Indicator Chart")
ind3Col    = input.color (defval = color.red, title = "", inline = "32", group = "Indicator Chart")
hideInd    = input.bool  (defval = false, title = "Hide Indicator Names ?", group = "Indicator Chart", inline = "40")
hideInd2   = input.bool  (defval = false, title = "Hide Indicators ?", group = "Indicator Chart", inline = "40")

priceInd   = input.string(defval = "Lin Reg", title = "Price Indicator", inline = "33", group = "Price Indicator", options = ["Lin Reg", "SMA", "WEMA", "EMA" ,"ALMA","HMA" ,"RMA" ,"WMA" ,"VWMA","VWAP","SWMA", "SAR", "Supertrend"])
priceIndLen= input.int   (defval = 20, title = "Price Indicator Length", inline = "33", group = "Price Indicator")
priceIndCol= input.color (defval = color.rgb(255, 217, 0), title = "", inline = "33", group = "Price Indicator")


req() => 
    switch typ      
        "Traditional" => syminfo.tickerid
        "Heikin-Ashi" => ticker.heikinashi  (syminfo.tickerid)
        "Kagi"        => ticker.kagi        (syminfo.tickerid, kRev)
        "Line Break"  => ticker.linebreak   (syminfo.tickerid, linbr)
        "Renko"       => ticker.renko       (syminfo.tickerid, rStyle, rba, rwick)
        "Point Figure"=> ticker.pointfigure (syminfo.tickerid, "hl", pBox, lb, pRev)




var int [] timeArray = array.new_int(), array.push(timeArray, math.round(time))

indPull(simple string indString, simple int indLen) => 
    ad = close==high and close==low or high==low ? 0 : ((2*close-low-high)/(high-low))*volume
    switch indString
        "OBV"                     => ta.obv
        "Negative Volume Index"   => ta.nvi
        "Positive Volume Index"   => ta.pvi
        "Price Volume Trend"      => ta.pvt
        "WPR"                     => ta.wpr  (indLen)
        "RSI"                     => ta.rsi  (close, indLen)
        "ROC"                     => ta.roc  (close, indLen)
        "MFI"                     => ta.mfi  (close, indLen)
        "CCI"                     => ta.cci  (close, indLen)
        "CMO"                     => ta.cmo  (close, indLen)
        "COG"                     => ta.cog  (close, indLen)
        "MOM"                     => ta.mom  (close, indLen)
        "RANGE"                   => ta.range(close, indLen)
        "BBW"                     => ta.bbw  (close, indLen, 2)
        "KCW"                     => ta.kcw  (close, indLen, 2)
        "%k"                      => ta.stoch(close, high, low, indLen)
        "MFC"                     => math.sum(ad, indLen) / math.sum(volume, indLen)

indPullPrice(simple string indString, simple int indLen) => 
    switch indString    
        "VWAP" => ta.vwap
        "SWMA" => ta.swma  (close)
        "SAR"  => ta.sar   (0.02, 0.02, 0.2)
        "SMA"  => ta.sma   (close, priceIndLen)
        "EMA"  => ta.ema   (close, priceIndLen)
        "HMA"  => ta.hma   (close, priceIndLen)
        "RMA"  => ta.rma   (close, priceIndLen)
        "WMA"  => ta.wma   (close, priceIndLen)
        "VWMA" => ta.vwma  (close, priceIndLen)
        "WEMA" => wema.wema(close, 0.5, priceIndLen)
        "ALMA" => ta.alma  (close, priceIndLen, 0.85, 6)


[s, d] = ta.supertrend(3, 3), [r, r1, r2] = rating.calcRatingAll()

[lowTFc, lowTFv, lowTFo, lowTFh, lowTFl, lowTFind1, lowTFind2, lowTFind3, lowTFpriceInd, lowTFr, lowTFd] = 
     
     request.security_lower_tf(req(), lowTFstr, 
         [
         close, volume, open, high, low, 
         indPull(ind1, ind1Len), 
         indPull(ind2, ind2Len), 
         indPull(ind3, ind3Len), 
         priceInd == "Supertrend" ? s : indPullPrice(priceInd, priceIndLen), 
         r, str.tostring(hour) + ":" + str.tostring(minute)
         ])

type sequential

    array <float>  lowTFcopyC 
    array <float>  lowTFcopyO 
    array <float>  lowTFcopyV 
    array <float>  lowTFcopyH 
    array <float>  lowTFcopyL 
    array <float>  lowTFcopyI1
    array <float>  lowTFcopyI2
    array <float>  lowTFcopyI3
    array <float>  lowTFcopyPI
    array <float>  lowTFcopyR 
    array <string> lowTFcopyD 


var sequence = sequential.new(
                              
                              array.new_float (), array.new_float(), 
                              array.new_float (), array.new_float(), 
                              array.new_float (), array.new_float(),
                              array.new_float (), array.new_float(), 
                              array.new_float (), array.new_float(), 
                              array.new_string()
                              
                              )

insert(arr, arr2, i) => 
    array.unshift(arr, array.get(arr2, i))

popClear(bool booL) => 
    
    if booL == false
        
        array.pop(sequence.lowTFcopyC ), array.pop(sequence.lowTFcopyV )
        array.pop(sequence.lowTFcopyH ), array.pop(sequence.lowTFcopyL )
        array.pop(sequence.lowTFcopyI1), array.pop(sequence.lowTFcopyI2)
        array.pop(sequence.lowTFcopyI3), array.pop(sequence.lowTFcopyPI)
        array.pop(sequence.lowTFcopyR ), array.pop(sequence.lowTFcopyD )
        
    if booL == true 
        
        array.clear(sequence.lowTFcopyC ), array.clear(sequence.lowTFcopyV )
        array.clear(sequence.lowTFcopyH ), array.clear(sequence.lowTFcopyL )
        array.clear(sequence.lowTFcopyI1), array.clear(sequence.lowTFcopyI2)
        array.clear(sequence.lowTFcopyI3), array.clear(sequence.lowTFcopyPI)
        array.clear(sequence.lowTFcopyR ), array.clear(sequence.lowTFcopyD )


if rolling == true  
    if timeframe.change(timeframe.period)
        popClear(true)

if array.size(lowTFc) > 0 and last_bar_index - bar_index <= 10
    for i = 0 to array.size(lowTFc) - 1
        insert(sequence.lowTFcopyC,  lowTFc, i       ), insert(sequence.lowTFcopyO,  lowTFo, i       )
        insert(sequence.lowTFcopyV , lowTFv, i       ), insert(sequence.lowTFcopyH , lowTFh, i       )
        insert(sequence.lowTFcopyL , lowTFl, i       ), insert(sequence.lowTFcopyI1, lowTFind1, i    )
        insert(sequence.lowTFcopyI2, lowTFind2, i    ), insert(sequence.lowTFcopyI3, lowTFind3, i    )
        insert(sequence.lowTFcopyPI, lowTFpriceInd, i), insert(sequence.lowTFcopyR , lowTFr, i       )
        insert(sequence.lowTFcopyD , lowTFd, i       )




if rolling == false 
    if array.size(sequence.lowTFcopyC) > math.max(timeframe.multiplier, 30)
        for i = 0 to array.size(sequence.lowTFcopyC) - math.max(timeframe.multiplier, 30)
            popClear(false)


funcDraw(bx, draw, drawli, temp, len, str, y, i) => 
                
    x1 = math.min(bar_index + 30, bar_index + 10 + array.size(sequence.lowTFcopyC)), styl = label.style_label_left

    matrix.set(draw, i, 0, label.new(x1, y, text = str.tostring(array.min(temp), "##.00"), 
                                     size      = size.small, 
                                     color     = #ffffff00, 
                                     textcolor = color.white,  
                                     style     = styl, 
                                     textalign = text.align_left
                                     ))

    matrix.set(draw, i, 1, label.copy(matrix.get(draw, i, 0)))
    label.set_xy(matrix.get(draw, i, 1), x1, box.get_top(bx)), label.set_text(matrix.get(draw, i, 1), str.tostring(array.max(temp), "##.00"))

    matrix.set(draw, i, 2, label.new(math.round(math.avg(box.get_right(bx), box.get_left(bx))), box.get_top(bx), text = str , 
                                     size      = size.small, 
                                     color     = #ffffff00, 
                                     textcolor = hideInd == false ? color.white : #ffffff00, 
                                     style     = label.style_label_center
                                     ))

    matrix.set(drawli, 3, 0, line.new(x1, math.avg(y, box.get_top(bx)), box.get_left(bx), math.avg(y, box.get_top(bx)), 
                                     color = color.gray, 
                                     style = line.style_dashed
                                     ))

funcAppend(lowTF, temp, yx, bx, mat, str, row, col) => 
 
    if array.size(sequence.lowTFcopyC) > 2
        for i = 1 to math.min(19, array.size(lowTF) - 1)
            array.push(temp, array.get(lowTF, i))
        
        for i = 1 to array.size(temp) - 1
            if box.get_right(bx) - i  < box.get_left(bx)
                break
            calcY  = yx + (box.get_top(bx) * .9999 - yx) * (array.get(temp, i) - array.min(temp))     / (array.max(temp) - array.min(temp))
            calcY1 = yx + (box.get_top(bx) * .9999 - yx) * (array.get(temp, i - 1) - array.min(temp)) / (array.max(temp) - array.min(temp))
           
            matrix.set(mat, row, i, 
                 line.new(
                 box.get_right(bx) - i + 1, calcY1, 
                 box.get_right(bx) - i    , calcY , 
                 color = col
                 ))

setLeftRight(box boxObject, line lineObject, label labelObject, simple string borl, int x, bool Bool) => 

    subtract = Bool == false ? 15 : x
    switch borl
        "Box"   =>   box.set_left (boxObject  , array.get(timeArray, array.indexof(timeArray, box.get_left (boxObject  )) - subtract )), 
                     box.set_right(boxObject  , array.get(timeArray, array.indexof(timeArray, box.get_right(boxObject  )) - subtract ))
        "Line"  =>   line.set_x1  (lineObject , array.get(timeArray, array.indexof(timeArray, line.get_x1  (lineObject )) - subtract )),
                     line.set_x2  (lineObject , array.get(timeArray, array.indexof(timeArray, line.get_x2  (lineObject )) - subtract ))
        "Label" =>   label.set_x  (labelObject, array.get(timeArray, array.indexof(timeArray, label.get_x  (labelObject)) - subtract ))


sz = switch pfl
    
    "Auto"   => size.auto
    "Tiny"   => size.tiny
    "Small"  => size.small
    "Normal" => size.normal
    "Large"  => size.large
    "Huge"   => size.huge


type indDraw
   
    matrix <line>  indLi
    matrix <label> indLa
    matrix <box>   indBo
    matrix <line>  dynamicLine
    array  <box>   priceBox
    matrix <color> ratingColor 
    matrix <int>   Quadrant
    array  <label> numLa
    array <line>   numLi

if barstate.islastconfirmedhistory
    if array.size(sequence.lowTFcopyC) > bar_index    
        runtime.error("Not Enough Chart Space! Load An Asset With More Data.")
    if timeframe.isminutes and timeframe.multiplier < 5
        runtime.error("Try a Higher Timeframe!")


if barstate.islast

    if array.size(line.all) > 0 
        for i = 0 to array.size(line.all) - 1
            line.delete(array.shift(line.all))

    if array.size(label.all) > 0 
        for i = 0 to array.size(label.all) - 1
            label.delete(array.shift(label.all))

    if array.size(box.all) > 0 
        for i = 0 to array.size(box.all) - 1
            box.delete(array.shift(box.all))

    draw = indDraw.new(
                       
                       matrix.new<line>(8, 20), matrix.new<label>(8, 20), matrix.new<box>(8, 6), 
                       matrix.new<line>(8, 1), array.new_box(), matrix.new<color>(4, 3), matrix.new<int>(1, 8, 0), 
                       array.new_label(), array.new_line()), matx = matrix.new<float>(3, 0)
   
    for i = 0 to array.size(sequence.lowTFcopyC) - 1
        matrix.add_col(matx)
        matrix.set(matx, 0, matrix.columns(matx) - 1, array.get(sequence.lowTFcopyC, i))
        matrix.set(matx, 1, matrix.columns(matx) - 1, array.get(sequence.lowTFcopyV, i))
       
    subX = matrix.submatrix(matx, 1, 2, 0, matrix.columns(matx))
    subY = matrix.submatrix(matx, 0, 1, 0, matrix.columns(matx))
    tr   = matrix.transpose(subX)
    

    skip = -1
    matrix.sort(tr, order = order.descending)
    calcX = math.max(math.abs(matrix.median(subX) - matrix.max(subX)), matrix.median(subX) - matrix.min(subX)) / 200
    int [] calculation = array.new_int(), float [] calculation2 = array.new_float(), array.reverse(timeArray)
    
    for x = 0 to matrix.columns(matx) - 1
        for i = 0 to matrix.columns(matx) - 1
            if matrix.get(subX, 0, x) == matrix.get(tr, i, 0) and skip != x
                array.push(calculation, math.round(array.get(timeArray, i + math.round(array.size(sequence.lowTFcopyC) * 2.5))))
                skip := x
    
    array.reverse(timeArray)

    for x = 0 to 20
        yTop = math.max(math.abs(matrix.median(subY) - matrix.max(subY)), matrix.median(subY) - matrix.min(subY)) 
        calcY = yTop * 2 / 20 
        append = switch yTop == math.abs(matrix.median(subY) - matrix.max(subY)) 
            true => matrix.max(subY) - ((yTop * 2 / 20) * x)
            =>      matrix.min(subY) + ((yTop * 2 / 20) * x)
        array.push(calculation2, append)


     
    pricexvolGraph = box.new(
                 
                 array.get(timeArray, array.size(timeArray) - math.round(matrix.columns(matx) * 3.5) - 1),  
                 array.max(calculation2) * 1.0001, 
                 array.get(timeArray, array.size(timeArray) - math.round(matrix.columns(matx) * 2.433) - 1),  
                 array.min(calculation2) * .9999, 
                 border_color = #ffffff, 
                 bgcolor =na, 
                 xloc = xloc.bar_time
         )

     
    mid = array.get(timeArray, array.size(timeArray) - math.round(matrix.columns(matx) * math.avg(3.5, 2.433))), 


    matrix.set(draw.indBo, 0, 0, box.new(
                                                     box.get_left(pricexvolGraph), 
                                                     box.get_top(pricexvolGraph), 
                                                     mid, 
                                                     matrix.median(subY), 
                                                     border_color =  na, 
                                                     bgcolor =color.new(color.blue, 85), 
                                                     xloc = xloc.bar_time, 
                                                     text_color = color.blue,
                                                     text_size = size.small
                                                     ))
       

    matrix.set(draw.indBo, 0, 1, box.new(
                                                     box.get_left(pricexvolGraph), 
                                                     matrix.median(subY), 
                                                     mid, 
                                                     box.get_bottom(pricexvolGraph), 
                                                     border_color = na, 
                                                     bgcolor =color.new(color.yellow, 85),
                                                     xloc = xloc.bar_time,
                                                     text_color = color.yellow, 
                                                     text_size = size.small

                                                     ))
     
     
    matrix.set(draw.indBo, 0, 2, box.new(
                                                     mid, 
                                                     box.get_top(pricexvolGraph), 
                                                     box.get_right(pricexvolGraph), 
                                                     matrix.median(subY),   
                                                     border_color = na, 
                                                     bgcolor =color.new(color.green, 85),
                                                     xloc = xloc.bar_time,
                                                     text_color = color.green,
                                                     text_size = size.small

                                                     ))
    matrix.set(draw.indBo, 0, 3, box.new(                                       
                                                     mid, 
                                                     matrix.median(subY),
                                                     box.get_right(pricexvolGraph), 
                                                     box.get_bottom(pricexvolGraph),
                                                     border_color = na, 
                                                     bgcolor =color.new(color.red, 85),
                                                     xloc = xloc.bar_time,
                                                     text_color = color.red,
                                                     text_size = size.small

                                                     ))



    for i = 0 to array.size(timeArray) - 1
        if array.get(timeArray, i) == box.get_right(matrix.get(draw.indBo, 0, 1))
            matrix.set(draw.Quadrant, 0, 0, i)
        if array.get(timeArray, i) == box.get_left (matrix.get(draw.indBo, 0, 1))
            matrix.set(draw.Quadrant, 0, 1, i)
        if array.get(timeArray, i) == box.get_right(matrix.get(draw.indBo, 0, 3))
            matrix.set(draw.Quadrant, 0, 2, i)
        if array.get(timeArray, i) == box.get_left (matrix.get(draw.indBo, 0, 3))
            matrix.set(draw.Quadrant, 0, 3, i)
            

    condQ =  matrix.get(draw.Quadrant, 0, 0) - matrix.get(draw.Quadrant, 0, 1) > 
             matrix.get(draw.Quadrant, 0, 2) - matrix.get(draw.Quadrant, 0, 3)

    if condQ
        
        box.set_right(matrix.get(draw.indBo, 0, 0), array.get(timeArray, matrix.get(draw.Quadrant, 0, 0) - 1))
        box.set_right(matrix.get(draw.indBo, 0, 1), array.get(timeArray, matrix.get(draw.Quadrant, 0, 0) - 1))
        box.set_left (matrix.get(draw.indBo, 0, 2), array.get(timeArray, matrix.get(draw.Quadrant, 0, 3) - 1))
        box.set_left (matrix.get(draw.indBo, 0, 3), array.get(timeArray, matrix.get(draw.Quadrant, 0, 3) - 1))
        matrix.set(draw.Quadrant, 0, 0, matrix.get(draw.Quadrant, 0, 0) - 1)
        matrix.set(draw.Quadrant, 0, 3, matrix.get(draw.Quadrant, 0, 3) - 1) // condChange

    condQ := matrix.get(draw.Quadrant, 0, 0) - matrix.get(draw.Quadrant, 0, 1) > 
             matrix.get(draw.Quadrant, 0, 2) - matrix.get(draw.Quadrant, 0, 3)

    if condQ // is still true

        box.set_right (matrix.get(draw.indBo, 0, 2), array.get(timeArray, matrix.get(draw.Quadrant,  0, 2) + 1))
        box.set_right (matrix.get(draw.indBo, 0, 3), array.get(timeArray, matrix.get(draw.Quadrant,  0, 2)    ))
        box.set_right (pricexvolGraph,               array.get(timeArray, matrix.get(draw.Quadrant,  0, 2) + 1))
        box.set_right (matrix.get(draw.indBo, 0, 3), array.get(timeArray, matrix.get(draw.Quadrant,  0, 2) + 1))


    matrix.set(draw.indLi, 6, 1, 
         line.new(box.get_left(pricexvolGraph) , matrix.median(subY) , 
         box.get_right        (pricexvolGraph) , array.median(sequence.lowTFcopyC), 
         color =            color.gray       , xloc = xloc.bar_time
         ))

    for i = 0 to array.size(calculation) - 1
        col = kai.hsv_gradient(i, 0, array.size(calculation) - 1, scol, ecol)
        switch 
            array.get(sequence.lowTFcopyC, i) >= array.median(sequence.lowTFcopyC) and array.get(sequence.lowTFcopyV, i) >= array.median(sequence.lowTFcopyV) => 
                             matrix.set(draw.Quadrant, 0, 4, matrix.get(draw.Quadrant, 0, 4) + 1)
            array.get(sequence.lowTFcopyC, i) >= array.median(sequence.lowTFcopyC) and array.get(sequence.lowTFcopyV, i) <  array.median(sequence.lowTFcopyV) => 
                             matrix.set(draw.Quadrant, 0, 5, matrix.get(draw.Quadrant, 0, 5) + 1)
            array.get(sequence.lowTFcopyC, i) <  array.median(sequence.lowTFcopyC) and array.get(sequence.lowTFcopyV, i) >= array.median(sequence.lowTFcopyV) => 
                             matrix.set(draw.Quadrant, 0, 6, matrix.get(draw.Quadrant, 0, 6) + 1)
            array.get(sequence.lowTFcopyC, i) <  array.median(sequence.lowTFcopyC) and array.get(sequence.lowTFcopyV, i) <  array.median(sequence.lowTFcopyV) => 
                             matrix.set(draw.Quadrant, 0, 7, matrix.get(draw.Quadrant, 0, 7) + 1)


        array.push(draw.numLa, label.new(array.get(calculation, i), array.get(sequence.lowTFcopyC, i), 
                              color = #ffffff00, textcolor = col, 
                              text = strin == "Numbers" ? str.tostring(i) : "◉", 
                              style = label.style_label_center, 
                              xloc = xloc.bar_time, 
                              size = size.tiny, 
                              tooltip = array.get(sequence.lowTFcopyD, i) + "\n" + 
                              str.tostring(array.get(sequence.lowTFcopyC, i), format.mintick) 
                              + "\n" + str.tostring(array.get(sequence.lowTFcopyV, i), format.volume)
                              ))
       
       
    for i = 0 to array.size(calculation2) - 1
        
        array.push(draw.numLi, line.new( array.get(timeArray, array.size(timeArray) - math.round(matrix.columns(matx) * 3.51) - 2), 
                                         array.get(calculation2, i), box.get_left(pricexvolGraph), array.get(calculation2, i), 
                                         xloc  = xloc.bar_time, 
                                         color = color.gray
                                         ))

        array.push(draw.numLa, label.new(array.get(timeArray, array.size(timeArray) - math.round(matrix.columns(matx) * 3.51) - 2), 
                                         array.get(calculation2, i), str.tostring(array.get(calculation2, i), format.mintick), 
                                         color = #ffffff00, 
                                         style = label.style_label_right, 
                                         textcolor = color.white, 
                                         size = size.tiny, 
                                         xloc = xloc.bar_time
                                         ))
    for i = 0 to 7
        
        l  = box.get_left(pricexvolGraph),  t  = box.get_top(pricexvolGraph), b = box.get_bottom(pricexvolGraph)
        ri = box.get_right(pricexvolGraph), up = label.style_label_up, dn = label.style_label_down
        lf = label.style_label_left, tiny = size.tiny, small = size.small, maxVol = array.max(sequence.lowTFcopyV)
        form = format.volume, iTrack = -1

        
        [x, y, text, styl, tcol, siz] = switch i != iTrack

            true and i == 0 => [l,  t, str.tostring(t, format.mintick), dn, color.white   , tiny  ]
            true and i == 1 => [l,  b, str.tostring(b, format.mintick), up, color.white   , tiny  ]
            true and i == 2 => [ri, t, str.tostring(maxVol, form     ), lf, color.white , tiny  ]
            true and i == 3 => [l,  t * 1.0001, "High Price / Low Volume"      , dn, color.blue  , small ]
            true and i == 4 => [ri, t * 1.0001, "High Price / High Volume"     , dn, color.green , small ]
            true and i == 5 => [ri, b * .9999, "Low Price / High Volume"      , up, color.red   , small ]
            true and i == 6 => [l,  b * .9999, "Low Price / Low Volume"       , up, color.yellow, small ]
            true and i == 7 => [
                                     box.get_right(matrix.get(draw.indBo, 0, 1)), b, 
                                     str.tostring(array.median(sequence.lowTFcopyV), format.volume) + " (Median Volume)", up, 
                                     color.white, size.small
                               ]


        matrix.set(draw.indLa, 6, i, label.new(x, y, text, xloc = xloc.bar_time, color = #ffffff00, 
                                                 size      = siz, 
                                                 textcolor = tcol, 
                                                 style     = styl
                                                 ))
    
    box.set_text(matrix.get(draw.indBo, 0, 0), str.tostring(matrix.get(draw.Quadrant, 0, 5)))
    box.set_text(matrix.get(draw.indBo, 0, 2), str.tostring(matrix.get(draw.Quadrant, 0, 4)))
    box.set_text(matrix.get(draw.indBo, 0, 3), str.tostring(matrix.get(draw.Quadrant, 0, 6)))
    box.set_text(matrix.get(draw.indBo, 0, 1), str.tostring(matrix.get(draw.Quadrant, 0, 7)))





    kLine = array.new_line(), kLineConnect = array.new_line()
    if array.size(sequence.lowTFcopyC) > 0 
        
        // array.reverse(sequence.lowTFcopyC), array.reverse(sequence.lowTFcopyH)
        // array.reverse(sequence.lowTFcopyL), array.reverse(sequence.lowTFcopyO)

        colZ = switch array.get(sequence.lowTFcopyC, 0) >= array.get(sequence.lowTFcopyO, 0)
        
            true => color.green 
            =>      color.red
        
        if typ != "Kagi"
            array.push(draw.priceBox, box.new(
                                 left         = time[1], 
                                 top          = math.max(array.get(sequence.lowTFcopyC, 0), array.get(sequence.lowTFcopyO, 0)), 
                                 right        = pct.timeFrom("bar", 1, "chart") ,
                                 bottom       = math.min(array.get(sequence.lowTFcopyC, 0), array.get(sequence.lowTFcopyO, 0)),
                                 bgcolor      = color.new(colZ, 95),
                                 border_color = colZ, 
                                 xloc         = xloc.bar_time
                                 ))

            for i = 0 to 1
                iTrack = -1
                [y1, y2] = switch i != iTrack
                    
                    true and i == 0 => [array.get(sequence.lowTFcopyH, 0), box.get_top   (array.get(draw.priceBox, 0))]
                    =>                 [array.get(sequence.lowTFcopyL, 0), box.get_bottom(array.get(draw.priceBox, 0))]
                
                matrix.set(draw.dynamicLine, i , 0, line.new(
                                 x1           = time, 
                                 y1           = y1,
                                 x2           = time, 
                                 y2           = y2,
                                 color        = colZ,
                                 xloc         = xloc.bar_time
                                 ))

        else 
           
            array.push(kLine, line.new(
                     x1 = time, y1 = array.get(sequence.lowTFcopyC, 0), 
                     x2 = pct.timeFrom("bar", 1, "chart"), 
                     y2 = array.get(sequence.lowTFcopyC, 0), 
                     width = 2, xloc = xloc.bar_time
                     ))

        if array.size(sequence.lowTFcopyC) > 1
            X1 = 4, X2 = 2, X3 = 3
            if typ == "Kagi"
                array.reverse(timeArray)
            for i = 1 to array.size(sequence.lowTFcopyC) - 1


                matrix.add_col(draw.dynamicLine, matrix.columns(draw.dynamicLine))
                
                colA = switch array.get(sequence.lowTFcopyC, i) >= array.get(sequence.lowTFcopyO, i)
                    
                    true  => color.green
                    false => color.red
                
                if typ != "Kagi"
                    array.push(draw.priceBox, box.new(array.get(timeArray, array.size(timeArray) - X1), 

                                       math.max(array.get(sequence.lowTFcopyC, i), array.get(sequence.lowTFcopyO, i)), 
                                       array.get(timeArray, array.size(timeArray) - X2), 
                                       math.min(array.get(sequence.lowTFcopyC, i), array.get(sequence.lowTFcopyO, i)), 
                                       bgcolor = color.new(colA, 95), border_color = colA, 
                                       xloc = xloc.bar_time
                                       ))       
                    x1 = array.get(timeArray, array.size(timeArray) - X3)
                    matrix.set(draw.dynamicLine, 0, matrix.columns(draw.dynamicLine) - 1, line.new(x1,
                                                         array.get(sequence.lowTFcopyH, i), x1, box.get_top(array.get(draw.priceBox, i)),
                                                         color = colA, xloc = xloc.bar_time
                                                         )) 
                    matrix.set(draw.dynamicLine, 1, matrix.columns(draw.dynamicLine) - 1, line.new(x1,
                                                         array.get(sequence.lowTFcopyL, i), x1, box.get_bottom(array.get(draw.priceBox, i)),
                                                         color = colA, xloc = xloc.bar_time
                                                         ))
                    X1 += 2, X2 += 2, X3 += 2
                
                
                else 


                    array.push(kLine, line.new(array.get(timeArray, i), array.get(sequence.lowTFcopyC, i), 
                                      array.get(timeArray, i - 1), array.get(sequence.lowTFcopyC, i), 
                                      width = 2, xloc = xloc.bar_time
                                      ))
                    
                    array.push(kLineConnect, line.new(line.get_x1(array.get(kLine, i - 1)),
                                             line.get_y1(array.get(kLine, i - 1)), 
                                             line.get_x1(array.get(kLine, i - 1)), 
                                             line.get_y1(array.get(kLine, i)), 
                                             width = 2, xloc = xloc.bar_time
                                             ))
                    
                    if i == array.size(sequence.lowTFcopyC) - 1
                        array.reverse(timeArray)


        min = math.round(20e20)
        
        if array.size(draw.priceBox) > 0 and typ != "Kagi"
            for i = 0 to array.size(draw.priceBox) - 1
                min := math.min(box.get_left(array.get(draw.priceBox, i)), min)
        
        if array.size(kLine) > 0 and typ == "Kagi"
            for i = 0 to array.size(kLine) - 1
                min := math.min(line.get_x1(array.get(kLine, i)), min)
        
        min := array.get(timeArray, array.indexof(timeArray, min) - 1)
        
        matrix.set(draw.indBo, 3, 0, box.new(min, array.max(sequence.lowTFcopyH) , 
              pct.timeFrom("bar", 1, "chart"), array.min(sequence.lowTFcopyL) ,
              bgcolor = color.new(color.blue, 95),
              border_color = color.white, xloc = xloc.bar_time
              ))
        
        left  = box.get_left (matrix.get(draw.indBo, 3, 0)), top    = box.get_top   (matrix.get(draw.indBo, 3, 0))
        right = box.get_right(matrix.get(draw.indBo, 3, 0)), bottom = box.get_bottom(matrix.get(draw.indBo, 3, 0))


        if typ == "Kagi"
            if array.size(kLine) > 2
                array.reverse(kLine), array.reverse(kLineConnect)
                bool ixb = na, bool ixf = na

                if line.get_y1(array.get(kLine, 1)) >= line.get_y1(array.get(kLine, 0))
                    
                    line.set_color(array.get(kLine, 1), color.lime), line.set_color(array.get(kLine, 0), color.lime)
                    line.set_color(array.get(kLineConnect, 0), color.lime), ixb := true
                
                else 
                    
                    line.set_color(array.get(kLine, 1), color.red), line.set_color(array.get(kLine, 0), color.red)
                    line.set_color(array.get(kLineConnect, 0), color.red), ixb := false
                    
                for i = 2 to array.size(kLine) - 1
                    
                    if ixb == true
                        ixf := true
                    else 
                        ixf := false
                   
                    ix  = line.get_y1(array.get(kLine, i)) 
                    ix1 = line.get_y1(array.get(kLine, i - 1))
                    ix2 = line.get_y1(array.get(kLine, i - 2))
                    
                    if ix >= ix1 and ix >= ix2
                        ixb := true
                    if ix < ix1 and ix < ix2
                        ixb := false
                    
                    switch ixb
                        
                        true =>    line.set_color(array.get(kLine, i), color.lime),
                                   line.set_color(array.get(kLineConnect, i - 1), color.lime)
                        =>         line.set_color(array.get(kLine, i), color.red),
                                   line.set_color(array.get(kLineConnect, i - 1), color.red)
        
                    if ixb == true and ixf == false 
                        line.new(line.get_x1(array.get(kLine, i)), ix1, line.get_x1(array.get(kLine, i)), ix2, width = 2, xloc = xloc.bar_time, color = color.red)
                        line.new(line.get_x1(array.get(kLine, i)), ix2, line.get_x1(array.get(kLine, i)), ix , width = 2, xloc = xloc.bar_time, color = color.lime)
                        line.delete(array.get(kLineConnect, i - 1))
                    if ixb == false and ixf == true
                        line.new(line.get_x1(array.get(kLine, i)), ix1, line.get_x1(array.get(kLine, i)), ix2, width = 2, xloc = xloc.bar_time,  color = color.lime)
                        line.new(line.get_x1(array.get(kLine, i)), ix2, line.get_x1(array.get(kLine, i)), ix , width = 2, xloc = xloc.bar_time,  color = color.red)
                        line.delete(array.get(kLineConnect, i - 1))


        if array.size(sequence.lowTFcopyC) > 1
            
            if priceInd == "Lin Reg"
                
                finSlo = array.new_float()
                x = array.new_float() , y  = array.sum(sequence.lowTFcopyC)
                xy = array.new_float(), x2 = array.new_float()

                for i = 0 to array.size(sequence.lowTFcopyC) - 1
                    array.push(x, i + 1)

                for i = 0 to array.size(sequence.lowTFcopyC) - 1
                    array.push(xy, (i + 1) * array.get(sequence.lowTFcopyC, i))
                    array.push(x2, math.pow(i + 1, 2))
                
                mTop =  ((array.size(x) * array.sum(xy)) - (array.sum(x) * y))
                mBot =  array.size(x) * array.sum(x2) - math.pow(array.sum(x), 2)
                m    = mTop / mBot, bx = (y - m * array.sum(x)) / array.size(x)
                
                for i = 0 to array.size(sequence.lowTFcopyC) - 1
                    array.push(finSlo, (m * (i + 1)) + bx)
                array.reverse(finSlo)

                for i = 2 to 4
                    iTrack = -1, fin0 = array.get(finSlo, 0), finLast = array.get(finSlo, array.size(finSlo) - 1)
                    
                    [y1, y2, styl, col] = switch i != iTrack
                       
                        true and i == 2 => [fin0, finLast, line.style_dashed, fin0 >= finLast ? color.red : color.green]
                        true and i == 3 => [fin0 + (array.stdev(sequence.lowTFcopyC)), finLast + array.stdev(sequence.lowTFcopyC), line.style_solid, color.blue]
                        true and i == 4 => [fin0 - (array.stdev(sequence.lowTFcopyC)), finLast - array.stdev(sequence.lowTFcopyC), line.style_solid, color.blue]
                    
                    matrix.set(draw.dynamicLine, i, 0, line.new(min, y1, time, y2, 
                                                       color = col, 
                                                       style = styl, 
                                                       xloc = xloc.bar_time, 
                                                       width = i == 2 ? 2 : 1
                                                       ))


                linefill.new(matrix.get(draw.dynamicLine, 3, 0), matrix.get(draw.dynamicLine, 4, 0), 
                             array.get(finSlo, 0) >= array.get(finSlo, array.size(finSlo) - 1) ? 
                           color.new(color.red, 95) : color.new(color.green, 95)) 
                
                box.set_bottom(matrix.get(draw.indBo, 3, 0), 
                     math.min(
                     array.min(sequence.lowTFcopyL), box.get_bottom(matrix.get(draw.indBo, 3, 0)),
                     line.get_y1(matrix.get(draw.dynamicLine, 4, 0)), line.get_y2(matrix.get(draw.dynamicLine, 4, 0))
                     ))
                
                box.set_top(matrix.get(draw.indBo, 3, 0), 
                     math.max(
                     array.max(sequence.lowTFcopyH), box.get_top(matrix.get(draw.indBo, 3, 0)),    
                     line.get_y1(matrix.get(draw.dynamicLine, 3, 0)), line.get_y2(matrix.get(draw.dynamicLine, 3, 0))
                     ))

                top    := box.get_top   (matrix.get(draw.indBo, 3, 0))
                bottom := box.get_bottom(matrix.get(draw.indBo, 3, 0))

            else
                
                //array.reverse(sequence.lowTFcopyPI)
                line  [] priceIndLine = array.new_line()
                array.reverse(timeArray)    , float [] tineIndLine = array.new_float()
                
                array.push(priceIndLine, line.new(time[1], array.get(sequence.lowTFcopyPI, 1), 
                                             time, array.get(sequence.lowTFcopyPI, 0), 
                                             width = 2,color = priceIndCol,
                                             xloc = xloc.bar_time, 
                                             style = priceInd == "SAR" ? 
                                             line.style_dotted : 
                                             line.style_solid
                                             ))
               
                if array.size(sequence.lowTFcopyPI) > 2 
                    for i = 2 to array.size(sequence.lowTFcopyPI) - 1 
                       
                        array.push(priceIndLine, line.new(array.get(timeArray, i * 2), 
                             array.get(sequence.lowTFcopyPI, i), line.get_x1(array.get(priceIndLine, array.size(priceIndLine) - 1)), 
                             array.get(sequence.lowTFcopyPI, i - 1), width = 2, color=  priceIndCol, xloc = xloc.bar_time, 
                             style = priceInd == "SAR" ? line.style_dotted : line.style_solid
                             
                             ))
                       
                        if array.get(timeArray, i * 2) <= left
                            break
               
                if priceInd == "SAR" or priceInd == "Supertrend"
                    if array.size(priceIndLine) > 1
                        
                        for i = 0 to array.size(priceIndLine) - 1
                            switch line.get_y2(array.get(priceIndLine, i)) >= array.get(sequence.lowTFcopyC, i)
                                
                                true => line.set_color(array.get(priceIndLine, i), color.red)
                                =>      line.set_color(array.get(priceIndLine, i), color.lime)
                            
                            if i >= 1
                                if array.get(sequence.lowTFcopyC, i)  >= line.get_y2(array.get(priceIndLine, i)) and array.get(sequence.lowTFcopyC, i) <= line.get_y2(array.get(priceIndLine, i - 1))
                                 or array.get(sequence.lowTFcopyC, i) <= line.get_y2(array.get(priceIndLine, i)) and array.get(sequence.lowTFcopyC, i) >= line.get_y2(array.get(priceIndLine, i - 1))
                                    line.delete(array.get(priceIndLine, i - 1))  

                array.reverse(timeArray)
                box.set_bottom(matrix.get(draw.indBo, 3, 0), math.min(array.min(sequence.lowTFcopyL), box.get_bottom(matrix.get(draw.indBo, 3, 0)),
                     array.min(sequence.lowTFcopyPI)))
                box.set_top(matrix.get(draw.indBo, 3, 0),    math.max(array.max(sequence.lowTFcopyH), box.get_top(matrix.get(draw.indBo, 3, 0)),    
                     array.max(sequence.lowTFcopyPI)))
                
                top    := box.get_top   (matrix.get(draw.indBo, 3, 0))
                bottom := box.get_bottom(matrix.get(draw.indBo, 3, 0))




            if typ == "Point Figure"    
                tick = (top - bottom) / 30
                levels = array.new_float(), labels = array.new_label(), X1 = 1
                for i = 0 to 29
                    array.push(levels, bottom + (tick * i))
                
                for i = 0 to array.size(sequence.lowTFcopyC) - 1
                    for nxx = 0 to array.size(levels) - 1
                        if array.get(sequence.lowTFcopyC, i) >= array.get(sequence.lowTFcopyO, i)
                            if array.get(levels, nxx) >= array.get(sequence.lowTFcopyO, i) and array.get(levels, nxx) <= array.get(sequence.lowTFcopyC, i)
                                array.push(labels, label.new(
                                     array.get(timeArray, array.size(timeArray) - X1) , array.get(levels, nxx),
                                     color = color.lime, text = "X" , size = sz, textcolor = color.white, 
                                     xloc = xloc.bar_time, style = label.style_text_outline
                                     ))
                        else 
                            if array.get(levels, nxx) <= array.get(sequence.lowTFcopyO, i) and array.get(levels, nxx) >= array.get(sequence.lowTFcopyC, i)
                                array.push(labels, label.new(array.get(timeArray, array.size(timeArray) - X1), array.get(levels, nxx),
                                     color = color.red, text = "O" , size = sz, textcolor = color.white,
                                     xloc = xloc.bar_time, style = label.style_text_outline
                                     ))

                    X1 += 2

                for i = 0 to array.size(draw.priceBox) - 1
                    box.delete(array.shift(draw.priceBox))

            trueAvg = math.round((bar_index -  array.indexof(timeArray, left)) / 2)
            
            label.new(array.get(timeArray, array.size(timeArray) - trueAvg), top, 
                      
                      typ + " " + (((close / close[1] - 1) * 100) >= 0 ? "+" : "") + 
                      str.tostring((close / close[1] - 1) * 100, format.percent) + " " 
                      + str.tostring(volume, format.volume), color = #ffffff00, 
                      textcolor = color.white, xloc = xloc.bar_time
                      
                      )


            if hideInd2 == false
                
                calcB1 = (math.round(right - left) / 3), altY = (top - bottom) / 3, ind1Box = box.new(

                     bar_index + 10, top,
                     math.min(bar_index + 30, bar_index + 10 + array.size(sequence.lowTFcopyC)),
                     top - altY , bgcolor = color.new(color.blue, 95), border_color = na)

                //array.reverse(sequence.lowTFcopyI1),
                tempArray1 = array.new_float()
                funcAppend(sequence.lowTFcopyI1, tempArray1, box.get_bottom(ind1Box) * 1.0001, ind1Box, draw.indLi, ind1, 0, ind1Col)
                funcDraw(ind1Box, draw.indLa, draw.indLi, tempArray1, ind1Len, ind1, box.get_bottom(ind1Box), 0)

                label.set_y(matrix.get(draw.indLa, 0, 2), box.get_top(ind1Box) * 1.0001), ind2Box = box.new(

                     bar_index + 10, box.get_bottom(ind1Box), 
                     math.min(bar_index + 30, bar_index + 10 + array.size(sequence.lowTFcopyC)), 
                     top -  (altY * 2), bgcolor = color.new(color.blue, 95), border_color = na)

                //array.reverse(sequence.lowTFcopyI2), 
                tempArray2 = array.new_float()
                funcAppend(sequence.lowTFcopyI2, tempArray2, box.get_bottom(ind2Box) * 1.0001, ind2Box, draw.indLi, ind2 , 1, ind2Col)
                funcDraw(ind2Box, draw.indLa, draw.indLi, tempArray2, ind2Len, ind2, box.get_bottom(ind2Box), 1)

                label.set_text(matrix.get(draw.indLa, 0, 0), label.get_text(matrix.get(draw.indLa, 0, 0)) + "\n" + label.get_text(matrix.get(draw.indLa, 1, 1)))
                label.delete(matrix.get(draw.indLa, 1, 1)), ind3Box = box.new(

                     bar_index + 10, box.get_bottom(ind2Box), 
                     math.min(bar_index + 30, bar_index + 10 + array.size(sequence.lowTFcopyC)), 
                     bottom, bgcolor = color.new(color.blue, 95), border_color = na)

                // array.reverse(sequence.lowTFcopyI3), 
                tempArray3 = array.new_float()
                funcAppend(sequence.lowTFcopyI3, tempArray3, box.get_bottom(ind3Box) * 1.0001, ind3Box, draw.indLi, ind3, 2, ind3Col)
                funcDraw(ind3Box, draw.indLa, draw.indLi, tempArray3, ind3Len, ind3, box.get_bottom(ind3Box), 2)
                label.set_text(matrix.get(draw.indLa, 1, 0), label.get_text(matrix.get(draw.indLa, 1, 0)) + "\n" + label.get_text(matrix.get(draw.indLa, 2, 1)))
                label.delete(matrix.get(draw.indLa, 2, 1)), box.new(

                     box.get_left(ind1Box), box.get_top(ind1Box), 
                     box.get_right(ind1Box), box.get_bottom(ind3Box), 
                     border_color = color.white, bgcolor = na)

            matrix.set(draw.ratingColor, 0, 0, #801922), matrix.set(draw.ratingColor, 0, 1, #f7525f), matrix.set(draw.ratingColor, 0, 2, #faa1a4)
            matrix.set(draw.ratingColor, 1, 0, #b22833), matrix.set(draw.ratingColor, 1, 1, #f77c80), matrix.set(draw.ratingColor, 1, 2, #fccbcd)
            matrix.set(draw.ratingColor, 2, 0, #a5d6a7), matrix.set(draw.ratingColor, 2, 1, #66bb6a), matrix.set(draw.ratingColor, 2, 2, #58ff56)
            matrix.set(draw.ratingColor, 3, 0, #81c784), matrix.set(draw.ratingColor, 3, 1, #388e3c), matrix.set(draw.ratingColor, 3, 2, #58ff56)


            ratingi1 = -6, ratingi2 = -5
            ratingi3 =  1, ratingi4 =  2
            altY2    = (top - bottom) / 4

            for i = 0 to 2

                calcCond = math.round(array.get(sequence.lowTFcopyR, array.size(sequence.lowTFcopyR) - 1) * 10)
                cond  = calcCond == ratingi1, cond1 = calcCond == ratingi2, cond2 = calcCond == ratingi3, cond3 = calcCond == ratingi4

                matrix.set(draw.indBo, 4, i, box.new(array.get(timeArray, array.indexof(timeArray, left) - 2), 
                                         
                                         bottom + (altY2 * i), left, bottom + (altY2 * (i + 1)), 
                                         bgcolor = color.new(matrix.get(draw.ratingColor, 1, i), cond ? 25 : 60),
                                         xloc = xloc.bar_time, border_color = color.white, 
                                         text = str.tostring(ratingi2) + (cond1 ? "◉" : ""), 
                                         text_color = color.white, text_size = size.small
                                         ))

                matrix.set(draw.indBo, 5, i, box.new(array.get(timeArray, array.indexof(timeArray, left) - 4), 
                                         
                                         bottom + (altY2 * i),
                                         array.get(timeArray, array.indexof(timeArray, left) - 2), bottom + (altY2 * (i + 1)), 
                                         bgcolor = color.new(matrix.get(draw.ratingColor, 0, i), cond1 ? 25 : 60),
                                         xloc = xloc.bar_time, border_color = color.white, text = str.tostring(ratingi1) + (cond ? "◉" : ""), 
                                         text_color = color.white, text_size = size.small
                                         ))

                matrix.set(draw.indBo, 6, i, box.new(bar_index + 1, top - (altY2 * (i + 1)), bar_index + 3 , 
                                         
                                         top - (altY2 * (i + 2)), 
                                         bgcolor = color.new(matrix.get(draw.ratingColor, 2, i), cond ? 25 : 60) ,
                                         xloc = xloc.bar_index, border_color = color.white, text = str.tostring(ratingi3) + (cond2 ? "◉" : ""), 
                                         text_color = color.white, text_size = size.small
                                         ))

                matrix.set(draw.indBo, 7, i, box.new(bar_index + 3, top - (altY2 * (i + 1)), 
                                         
                                         bar_index + 5 , top - (altY2 * (i + 2)), 
                                         bgcolor = color.new(matrix.get(draw.ratingColor, 3, i), cond ? 25 : 60),
                                         xloc = xloc.bar_index, border_color = color.white, text = str.tostring(ratingi4) + (cond3 ? "◉" : ""), 
                                         text_color = color.white, text_size = size.small))

                ratingi1 += 2 , ratingi2 += 2, ratingi3 += 2, ratingi4 += 2
            
            matrix.set(draw.indLa, 7, 0, label.new(array.get(timeArray, array.indexof(timeArray, left) - 2), 
                 top - altY2, text = "−", textcolor = color.white, color = #ffffff00, xloc = xloc.bar_time, size = size.large))
            matrix.set(draw.indLa, 7, 1, label.new(bar_index + 3, 
                 top - altY2, text = "+", textcolor = color.white, color = #ffffff00, xloc = xloc.bar_index,size = size.large))

            r5 = 
             array.indexof(timeArray, box.get_left(matrix.get(draw.indBo, 5, 0))) - 
             array.indexof(timeArray, box.get_right(pricexvolGraph)), r6 = math.round(r5/2), bCond = false
            
            if r5 > 100
                bCond := true
            if box.get_right(pricexvolGraph) >= array.get(timeArray, array.indexof(timeArray, box.get_left(matrix.get(draw.indBo, 5, 0))) - 7) or bCond == true 
                setLeftRight(pricexvolGraph, line(na), label(na), "Box", -r6, bCond)
                setLeftRight(box(na), matrix.get(draw.indLi, 6, 1), label(na), "Line", -r6, bCond)
                for i = 0 to 7
                    setLeftRight(box(na), line(na), matrix.get(draw.indLa, 6, i), "Label", -r6, bCond)
                    if i <= 3
                        setLeftRight(matrix.get(draw.indBo, 0, i), line(na), label(na), "Box", -r6, bCond)
                for i = 0 to array.size(draw.numLi) - 1
                    setLeftRight(box(na), array.get(draw.numLi, i), label(na), "Line", -r6, bCond)
                for i = 0 to array.size(draw.numLa) - 1
                    setLeftRight(box(na), line(na), array.get(draw.numLa, i), "Label", -r6, bCond)
