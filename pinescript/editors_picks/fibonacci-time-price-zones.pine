//@version=6
indicator('Fibonacci Time-Price Zones',  shorttitle='Fib Time-Price [xxattaxx]', overlay=true)   

// ===========================  TOOLTIPS  ===========================

ttLev    = "Fibonacci Levels: Configures this Fibonacci level. \n" +
         " ■ Toggle visibility, set the level value, customize the color, and adjust line thickness."
ttPoint  = "A-B-C-D Points: Toggles the visibility of the labels for A, B, and C points on the chart. \n" +
         " ■ A and B are user-defined time and price points. \n" +" ■ C is the calculated end point of the Trend Extension. \n" +
         " ■ D is the calculated end point of the Trend Retracement."
ttRetr   = "Retrace: Visibility of the trend retracement line connecting B-D. \n"
ttFill   = "Fill %: Adjusts the transparency of the fill area. \n" + " ■ 0% is fully transparent \n ■ 100% is fully opaque.\n" 
ttTrend  = "Trendline: Toggles the visibility of the trend line connecting points A and B. \n" +
         " ■ Extension: Toggles the visibility of the trend extension line connecting B-C. \n" +
         " ■ Retracement: Toggles the visibility of the trend retracement line connecting B-D."
ttLabel  = "Labels: Toggles the visibility of the Fibonacci level labels."
ttZone   = "ZoneType: Toggles the visibility of the Upper, Lower, or Both Fibonacci segments. \n" 
ttShape  = "Shape: Selects the structure of Fibonacci plots. \n" +
         " ■ Circular: Represents Fibonacci levels as arcs that incorporate both time and price dimensions. \n" +
         " ■ Orthogonal: Displays L-shaped patterns combining horizontal and vertical components to reflect time and price relationships. \n" +
         " ■ Slope: Aligns Fibonacci levels along the trend line, emphasizing trend direction and momentum. \n" +
         " ■ Horizontal: Traditional horizontal lines for Fibonacci levels, focusing solely on price-based relationships. \n\n"
ttA      = 'Exact Start Time/Price Point' 
ttC      = 'Exact End Time/Price Point'

// ===========================  INPUTS  ===========================

gL              = 'Show            '  +  'Level                  '  + 'Color            '  +  'Linewidth'
isEnabled0      = input.bool    (true,                          '',           group=gL,         inline='Level0')
levelValue0     = input.float   (0.236,                         '',           group=gL,         inline='Level0')
levelColor0     = input.color   (color.new(#87CEEB, 30),        '',           group=gL,         inline='Level0')
levelThick0     = input.string  ('▬▬▬',        title =          '',           group=gL,         inline='Level0',
                                 options=['────', '▬▬▬', '▄▄▄▄'],                                                tooltip=ttLev)
isEnabled1      = input.bool    (true,                         '',            group=gL,         inline='Level1')
levelValue1     = input.float   (0.382,                         '',           group=gL,         inline='Level1')
levelColor1     = input.color   (color.new(#4682B4, 30),        '',           group=gL,         inline='Level1')
levelThick1     = input.string  ('▬▬▬',        title =          '',           group=gL,         inline='Level1',
                                 options=['────', '▬▬▬', '▄▄▄▄'],                                                tooltip=ttLev)
isEnabled2      = input.bool    (true,                          '',           group=gL,         inline='Level2')
levelValue2     = input.float   (0.500,                         '',           group=gL,         inline='Level2')
levelColor2     = input.color   (color.new(#32CD32, 30),        '',           group=gL,         inline='Level2')
levelThick2     = input.string  ('▬▬▬',        title =          '',           group=gL,         inline='Level2',
                                 options=['────', '▬▬▬', '▄▄▄▄'],                                                tooltip=ttLev)
isEnabled3      = input.bool    (true,                         '' ,           group=gL,         inline='Level3')
levelValue3     = input.float   (0.618,                         '',           group=gL,         inline='Level3')
levelColor3     = input.color   (color.new(#FFEB3B, 30),        '',           group=gL,         inline='Level3')
levelThick3     = input.string  ('▬▬▬',        title =          '',           group=gL,         inline='Level3',
                                 options=['────', '▬▬▬', '▄▄▄▄'],                                                tooltip=ttLev)
isEnabled4      = input.bool    (true,                         '' ,           group=gL,         inline='Level4')
levelValue4     = input.float   (0.786,                         '',           group=gL,         inline='Level4')
levelColor4     = input.color   (color.new(#FF8C00, 30),        '',           group=gL,         inline='Level4')
levelThick4     = input.string  ('▬▬▬',        title =          '',           group=gL,         inline='Level4',
                                 options=['────', '▬▬▬', '▄▄▄▄'],                                                tooltip=ttLev)
isEnabled5      = input.bool    (true,                          '',           group=gL,         inline='Level5')
levelValue5     = input.float   (1.000,                         '',           group=gL,         inline='Level5')
levelColor5     = input.color   (color.new(#8B0000, 30),        '',           group=gL,         inline='Level5')
levelThick5     = input.string  ('▬▬▬',        title =          '',           group=gL,         inline='Level5',
                                 options=['────', '▬▬▬', '▄▄▄▄'],                                                tooltip=ttLev)
isEnabled6      = input.bool    (false,                         '',           group=gL,         inline='Level6')
levelValue6     = input.float   (1.236,                         '',           group=gL,         inline='Level6')
levelColor6     = input.color   (color.new(#6A5ACD, 30),        '',           group=gL,         inline='Level6')
levelThick6     = input.string  ('▬▬▬',        title =          '',           group=gL,         inline='Level6',
                                 options=['────', '▬▬▬', '▄▄▄▄'],                                                tooltip=ttLev)

gS              = 'Setup'
ZoneType        = input.string  ('Retracement', 'Zone Type',                  group=gS,         inline='s1',
                                 options=['Retracement','Extension','Both'],                                     tooltip=ttZone)   

Shape           = input.string   ('Circular',  'Shape      ',                 group=gS,         inline='s3',     
                                 options=['Circular', 'Orthogonal ',
                                 'Slope', 'Horizontal' ],                                                        tooltip=ttShape)

gV              = 'Visual Settings'
fillT           = input.float   (15, 'Fill %  ', maxval=100, minval=0,        group=gV,          inline='v1',    tooltip=ttFill)
ShowTrend       = input.bool    (true,   'Trendline     ',                    group=gV,          inline='t1',    tooltip=ttTrend)
colTrend        = input.color   (color.new(color.aqua, 75), '',               group=gV,          inline='t1',    tooltip=ttTrend)
ShowExtend      = input.bool    (false,  'Extension     ',                    group=gV,          inline='t2',    tooltip=ttTrend)
colExtend       = input.color   (color.new(color.blue, 75), '',               group=gV,          inline='t2',    tooltip=ttTrend)
ShowRetrace     = input.bool    (false,  'Retracement',                       group=gV,          inline='t3',    tooltip=ttTrend)
colRetrace      = input.color   (color.new(color.blue, 75), '',               group=gV,          inline='t3',    tooltip=ttTrend)

gLab            = 'Labels'
ShowA           = input.bool    (true,  'A ',                                 group=gLab,        inline='p1',    tooltip=ttPoint)
ShowB           = input.bool    (true,  'B ',                                 group=gLab,        inline='p1',    tooltip=ttPoint)
ShowC           = input.bool    (false, 'C ',                                 group=gLab,        inline='p1',    tooltip=ttPoint)
ShowD           = input.bool    (false, 'D ',                                 group=gLab,        inline='p1',    tooltip=ttPoint)
ShowLabels      = input.bool    (true, 'Fib Levels',                          group=gLab,        inline='l1',    tooltip=ttLabel)

TP              = 'Time/Price'  
A_Time_         = input.time    (timestamp('2024-08-12'), '', confirm=true,   group=TP,          inline='B')
A_Price_        = input.price   (0, '', confirm=true,                         group=TP,          inline='B',     tooltip=ttA)
B_Time_         = input.time    (timestamp('2024-08-12'), '', confirm=true,   group=TP,          inline='C')
B_Price_        = input.price   (0, '', confirm=true,                         group=TP,          inline='C',     tooltip=ttC)


// ===========================  VARIABLES  ===========================

// Ensure A_Time is less than B_Time, otherwise swap values
A_Price        = A_Time_ > B_Time_ ? B_Price_ : A_Price_
A_Time         = A_Time_ > B_Time_ ? B_Time_  : A_Time_
B_Price        = A_Time_ > B_Time_ ? A_Price_ : B_Price_
B_Time         = A_Time_ > B_Time_ ? A_Time_  : B_Time_

// Assign Time/Bar Index Variables
float A             = A_Price
float B             = B_Price
var int A_Index     = na  
var int B_Index     = na  
var int C_Index     = na  
var int D_Index     = na  
var float C_Price   = na  
var float D_Price   = na  

if na(A_Index) and time == A_Time
    A_Index         := bar_index 

if na(B_Index) and time == B_Time
    B_Index         := bar_index  
    AB_IndexDiff    =  B_Index - A_Index
    AB_PriceDiff    =  B_Price - A_Price
    C_Index         := B_Index  + AB_IndexDiff
    D_Index         := B_Index  + AB_IndexDiff
    C_Price         := B_Price  + AB_PriceDiff
    D_Price         := B_Price  - AB_PriceDiff

After_A             = time >= A_Time
After_B             = time >= B_Time
Setup               = After_A and not After_B
InRange             = After_A and bar_index <= C_Index

// Assign Trend Direction Variables and Segment Fill
var int Trend       =  A_Price < B_Price ? 1 : -1
bool U              = ZoneType == 'Both' or (Trend == 1 and ZoneType == 'Extension')   or (Trend == -1 and ZoneType == 'Retracement')
bool L              = ZoneType == 'Both' or (Trend == 1 and ZoneType == 'Retracement') or (Trend == -1 and ZoneType == 'Extension')
T                   =  100-fillT
Fill                =  fillT > 0  and After_A

// Initializes arrays to store the radii, upper boundaries, and lower boundaries of circles for each level.
var float[] upperArray      =  array.new_float(7)
var float[] lowerArray      =  array.new_float(7)
var float[] upperInitial    =  array.new_float(7)
var float[] lowerInitial    =  array.new_float(7)

// Arrays for storing Fibonacci level configurations
EnablArray          = array.from (isEnabled0,  isEnabled1,  isEnabled2,  isEnabled3,  isEnabled4,  isEnabled5,  isEnabled6)
LevlArray           = array.from (levelValue0, levelValue1, levelValue2, levelValue3, levelValue4, levelValue5, levelValue6)
ColorArray          = array.from (levelColor0, levelColor1, levelColor2, levelColor3, levelColor4, levelColor5, levelColor6)
ThickArray          = array.from (levelThick0, levelThick1, levelThick2, levelThick3, levelThick4, levelThick5, levelThick6)


// ===========================  FUNCTIONS  ===========================

f_lw(weight) => 
    weight  == '────'?   1  :  weight == '▬▬▬'?    2  :   weight == '▄▄▄▄'?   3  :  1

f_fib_radius    (base_radius, scale_factor, fib_level) => base_radius * fib_level * scale_factor

f_calc_y_values(radius, adj_x, start_price, end_price, aspect_ratio) =>
    x_center            = (B_Index - A_Index) * aspect_ratio  
    y_offset_sq         = radius * radius - math.pow(adj_x - x_center, 2)
    y_offset            = y_offset_sq >= 0 ? math.sqrt(y_offset_sq) : na
    y_center            = B_Price
    y_upper             = not na(y_offset)? y_center + y_offset : na
    y_lower             = not na(y_offset)? y_center - y_offset : na
    [y_upper, y_lower]

f_calc_fib(start_price, end_price, fib_level, trend, scale_factor) =>   
    price_diff          = end_price - start_price
    offset              = price_diff * math.sqrt(2) * scale_factor * fib_level
    upper_fib           = trend == 1?  end_price + offset : end_price - offset
    lower_fib           = trend == 1?  end_price - offset : end_price + offset
    [upper_fib, lower_fib]

f_slope_line(start_index, start_price, slope, index_input) =>
    delta_index         = (index_input - start_index)  
    slope_adj_price     = start_price + (slope * delta_index)                     
    slope_adj_price

f_text_box(boxtext, col, y_upper, y_lower) =>
    var box text_upper  = na
    var box text_lower  = na
    var bool created    = false
    if not created and (not na(y_lower)  or not na(y_upper))
        box.new(bar_index, y_upper, bar_index, y_upper, xloc=xloc.bar_index, border_width=0, 
                     text=boxtext, text_color=col, text_size=size.normal, text_halign=text.align_right)
        box.new(bar_index, y_lower, bar_index, y_lower, xloc=xloc.bar_index, border_width=0, 
                     text=boxtext, text_color=col, text_size=size.normal, text_halign=text.align_right)
        created := true
    if na(text_lower) 
        text_lower := box.new(bar_index, y_lower, bar_index, y_lower, xloc=xloc.bar_index, border_width=0, text=' ' + boxtext,
                     text_color=col, text_size=size.normal, text_halign=text.align_left, text_valign= text.align_top)
    if na(text_upper)
        text_upper := box.new(bar_index, y_upper, bar_index, y_upper, xloc=xloc.bar_index, border_width=0, text=' ' + boxtext,
                     text_color=col, text_size=size.normal, text_halign=text.align_left, text_valign= text.align_bottom) 
    if not na(y_lower) 
        box.set_right   (text_lower, bar_index)
        box.set_left    (text_lower, bar_index)
        box.set_top     (text_lower, y_lower)
        box.set_bottom  (text_lower, y_lower)
    if not na(y_upper)
        box.set_right   (text_upper, bar_index)
        box.set_left    (text_upper, bar_index)
        box.set_top     (text_upper, y_upper)
        box.set_bottom  (text_upper, y_upper)
    if na(y_upper) and na(y_lower) and not na(text_upper) and not na(text_lower)
        var EndBox = box.new(bar_index, B_Price, bar_index, B_Price, xloc=xloc.bar_index, border_width=0, 
                     text_valign= text.align_center, text=boxtext, text_color=col, text_size=size.normal, text_halign=text.align_left)
        box.delete(text_upper)
        box.delete(text_lower)
    [text_upper, text_lower]


// ===========================  MAIN CODE  ===========================

// Calculate slope and circle parameters
scale_factor =  Shape=='Circular'? math.log(2) : math.sqrt(2) / 2
float Slope                 =  na(A_Index) or na(B_Index) ? na : (B_Price - A_Price) / (B_Index - A_Index)  
s_line                      =  f_slope_line(A_Index, A_Price,  Slope,  bar_index)
r_line                      =  f_slope_line(B_Index, B_Price, -Slope,  bar_index)

var float radius            =  na
var float aspect_ratio      =  na
if  time == B_Time
    radius                  := 0
    aspect_ratio            := 0
    delta_price             =  B_Price - A_Price
    delta_index             =  B_Index - A_Index
    aspect_ratio            := nz(delta_index != 0 ? delta_price / delta_index : 0)
    float adj_delta         =  delta_index * aspect_ratio
    radius                  := math.sqrt(adj_delta * adj_delta + delta_price * delta_price)
    
float adj_x                 =  (bar_index - A_Index) * aspect_ratio

// Initialize the Fibonacci levels for the first time when A_Time is reached.
if time == A_Time
    for [i, level] in LevlArray
        isEnabled = array.get(EnablArray, i)

        if isEnabled
            // Calculate the initial Fibonacci levels using the scaled function
            [initialUpper, initialLower] = f_calc_fib(A_Price, B_Price, level, Trend, scale_factor)

            // Assign values to the initial arrays
            array.set(upperInitial, i, initialUpper)
            array.set(lowerInitial, i, initialLower)
        else
            // Assign 'na' for disabled levels
            array.set(upperInitial, i, na)
            array.set(lowerInitial, i, na)

// After A_Time, calculate the radii, upper boundaries, and lower boundaries of the circles for each enabled level.
if After_A
    for [i, level] in LevlArray
        isEnabled = array.get(EnablArray, i)
        if isEnabled  // Only perform calculations if level is enabled
            //level_radius  = f_fib_radius(radius, scale_factor, level)
            level_radius  = f_fib_radius(radius, scale_factor, level)
            aspect_radius = math.abs(math.round(level_radius / aspect_ratio))
            initial_upper = array.get(upperInitial, i)
            initial_lower = array.get(lowerInitial, i)
            inRadius      = bar_index <= aspect_radius + B_Index
            
            if Setup 
                upperValue = array.get(upperInitial, i)
                lowerValue = array.get(lowerInitial, i)
                array.set(upperArray, i, upperValue)
                array.set(lowerArray, i, lowerValue)
            else
                [upperCir, lowerCir] = f_calc_y_values(level_radius, adj_x, A_Price, B_Price, aspect_ratio)
                upperLin    = Shape == "Horizontal" or Shape == 'Orthogonal ' and inRadius?  initial_upper : na
                lowerLin    = Shape == "Horizontal" or Shape == 'Orthogonal ' and inRadius?  initial_lower : na
                upperSlope  = inRadius ?  f_slope_line(B_Index, initial_upper, Trend * -Slope,  bar_index) : na
                lowerSlope  = inRadius ?  f_slope_line(B_Index, initial_lower, Trend * Slope,   bar_index) : na
                upperValue  = Shape == 'Circular' ? upperCir : Shape != "Slope"? upperLin : upperSlope  
                lowerValue  = Shape == 'Circular' ? lowerCir : Shape != "Slope"? lowerLin : lowerSlope
                
                array.set(upperArray, i, upperValue)
                array.set(lowerArray, i, lowerValue)

                // Draw horizontal connecting line, only for 'Orthogonal ' type
                if (bar_index >= aspect_radius + B_Index and bar_index-1 < aspect_radius + B_Index) and Shape != 'Circular'
                    line_color = array.get(ColorArray, i)
                    lw         = f_lw(array.get(ThickArray, i))
                    DrawUpper  = Trend == 1 and ZoneType != 'Retracement' or Trend == -1 and ZoneType != 'Extension'
                    DrawLower  = Trend == 1 and ZoneType != 'Extension'   or Trend == -1 and ZoneType != 'Retracement'
                    if DrawUpper and Shape == 'Orthogonal '
                        line.new(bar_index, upperValue, bar_index, B_Price, xloc=xloc.bar_index, color=line_color,
                         width=lw, style=line.style_solid)
                    if DrawLower and Shape == 'Orthogonal '
                        line.new(bar_index, lowerValue, bar_index, B_Price, xloc=xloc.bar_index, color=line_color,
                         width=lw, style=line.style_solid)
        else
            array.set(upperArray, i, na)
            array.set(lowerArray, i, na)

    f_text_box(ShowLabels and isEnabled0?str.tostring(levelValue0):'', levelColor0, U?array.get(upperArray, 0):na, L?array.get(lowerArray, 0):na)   
    f_text_box(ShowLabels and isEnabled1?str.tostring(levelValue1):'', levelColor1, U?array.get(upperArray, 1):na, L?array.get(lowerArray, 1):na)
    f_text_box(ShowLabels and isEnabled2?str.tostring(levelValue2):'', levelColor2, U?array.get(upperArray, 2):na, L?array.get(lowerArray, 2):na)
    f_text_box(ShowLabels and isEnabled3?str.tostring(levelValue3):'', levelColor3, U?array.get(upperArray, 3):na, L?array.get(lowerArray, 3):na)
    f_text_box(ShowLabels and isEnabled4?str.tostring(levelValue4):'', levelColor4, U?array.get(upperArray, 4):na, L?array.get(lowerArray, 4):na)
    f_text_box(ShowLabels and isEnabled5?str.tostring(levelValue5):'', levelColor5, U?array.get(upperArray, 5):na, L?array.get(lowerArray, 5):na)
    f_text_box(ShowLabels and isEnabled6?str.tostring(levelValue6):'', levelColor6, U?array.get(upperArray, 6):na, L?array.get(lowerArray, 6):na)

// Plots the circles for each enabled level, then applies the fill
Mid_U    =  U? na : B_Price
Mid_L    =  L? na : B_Price
P0_Upper = plot(isEnabled0 and U and After_A? array.get(upperArray, 0) : Mid_U, 'Level 0 Upper', color=U?levelColor0:na, linewidth=f_lw(levelThick0))
P1_Upper = plot(isEnabled1 and U and After_A? array.get(upperArray, 1) : Mid_U, 'Level 1 Upper', color=U?levelColor1:na, linewidth=f_lw(levelThick1))
P2_Upper = plot(isEnabled2 and U and After_A? array.get(upperArray, 2) : Mid_U, 'Level 2 Upper', color=U?levelColor2:na, linewidth=f_lw(levelThick2))
P3_Upper = plot(isEnabled3 and U and After_A? array.get(upperArray, 3) : Mid_U, 'Level 3 Upper', color=U?levelColor3:na, linewidth=f_lw(levelThick3))
P4_Upper = plot(isEnabled4 and U and After_A? array.get(upperArray, 4) : Mid_U, 'Level 4 Upper', color=U?levelColor4:na, linewidth=f_lw(levelThick4))
P5_Upper = plot(isEnabled5 and U and After_A? array.get(upperArray, 5) : Mid_U, 'Level 5 Upper', color=U?levelColor5:na, linewidth=f_lw(levelThick5))
P6_Upper = plot(isEnabled6 and U and After_A? array.get(upperArray, 6) : Mid_U, 'Level 6 Upper', color=U?levelColor6:na, linewidth=f_lw(levelThick6))
P0_Mid   = plot(After_A? B_Price : na,                                          'B Price',       color=color.new(color.aqua, 100))
P0_Lower = plot(isEnabled0 and L and After_A? array.get(lowerArray, 0) : Mid_L, 'Level 0 Lower', color=L?levelColor0:na, linewidth=f_lw(levelThick0))
P1_Lower = plot(isEnabled1 and L and After_A? array.get(lowerArray, 1) : Mid_L, 'Level 1 Lower', color=L?levelColor1:na, linewidth=f_lw(levelThick1))
P2_Lower = plot(isEnabled2 and L and After_A? array.get(lowerArray, 2) : Mid_L, 'Level 2 Lower', color=L?levelColor2:na, linewidth=f_lw(levelThick2))
P3_Lower = plot(isEnabled3 and L and After_A? array.get(lowerArray, 3) : Mid_L, 'Level 3 Lower', color=L?levelColor3:na, linewidth=f_lw(levelThick3))
P4_Lower = plot(isEnabled4 and L and After_A? array.get(lowerArray, 4) : Mid_L, 'Level 4 Lower', color=L?levelColor4:na, linewidth=f_lw(levelThick4))
P5_Lower = plot(isEnabled5 and L and After_A? array.get(lowerArray, 5) : Mid_L, 'Level 5 Lower', color=L?levelColor5:na, linewidth=f_lw(levelThick5))
P6_Lower = plot(isEnabled6 and L and After_A? array.get(lowerArray, 6) : Mid_L, 'Level 6 Lower', color=L?levelColor6:na, linewidth=f_lw(levelThick6))

fill (P6_Upper, P6_Lower, color = Fill and na(array.get(upperArray,5)) ?     color.new(array.get(ColorArray, 6), T): na)
fill (P5_Upper, P5_Lower, color = Fill and na(array.get(upperArray,4)) ?     color.new(array.get(ColorArray, 5), T): na)
fill (P4_Upper, P4_Lower, color = Fill and na(array.get(upperArray,3)) ?     color.new(array.get(ColorArray, 4), T): na)
fill (P3_Upper, P3_Lower, color = Fill and na(array.get(upperArray,2)) ?     color.new(array.get(ColorArray, 3), T): na)
fill (P2_Upper, P2_Lower, color = Fill and na(array.get(upperArray,1)) ?     color.new(array.get(ColorArray, 2), T): na)
fill (P1_Upper, P1_Lower, color = Fill and na(array.get(upperArray,0)) ?     color.new(array.get(ColorArray, 1), T): na)
fill (P0_Upper, P0_Lower, color = Fill and na(array.get(upperArray,0)) ?     color.new(array.get(ColorArray, 0), T): na)
fill (P0_Upper, P1_Upper, color = Fill and not na(array.get(upperArray,1)) ? color.new(array.get(ColorArray, 1), T): na)
fill (P1_Upper, P2_Upper, color = Fill and not na(array.get(upperArray,2)) ? color.new(array.get(ColorArray, 2), T): na)
fill (P2_Upper, P3_Upper, color = Fill and not na(array.get(upperArray,3)) ? color.new(array.get(ColorArray, 3), T): na)
fill (P3_Upper, P4_Upper, color = Fill and not na(array.get(upperArray,4)) ? color.new(array.get(ColorArray, 4), T): na)
fill (P4_Upper, P5_Upper, color = Fill and not na(array.get(upperArray,5)) ? color.new(array.get(ColorArray, 5), T): na)
fill (P5_Upper, P6_Upper, color = Fill and not na(array.get(upperArray,6)) ? color.new(array.get(ColorArray, 6), T): na)
fill (P0_Lower, P1_Lower, color = Fill and not na(array.get(lowerArray,1)) ? color.new(array.get(ColorArray, 1), T): na)
fill (P1_Lower, P2_Lower, color = Fill and not na(array.get(lowerArray,2)) ? color.new(array.get(ColorArray, 2), T): na)
fill (P2_Lower, P3_Lower, color = Fill and not na(array.get(lowerArray,3)) ? color.new(array.get(ColorArray, 3), T): na)
fill (P3_Lower, P4_Lower, color = Fill and not na(array.get(lowerArray,4)) ? color.new(array.get(ColorArray, 4), T): na)
fill (P4_Lower, P5_Lower, color = Fill and not na(array.get(lowerArray,5)) ? color.new(array.get(ColorArray, 5), T): na)
fill (P5_Lower, P6_Lower, color = Fill and not na(array.get(lowerArray,6)) ? color.new(array.get(ColorArray, 6), T): na)

// Calculates the upper and lower boundaries of the fill area based on the slope line and the circles.
float UpperValue        =  na,      float LowerValue        =  na
float ExtenLine         =  na,      float RetraceLine       =  na

if After_B and Trend == 1
    UpperValue          := math.min(array.max(upperArray, 0), math.max(s_line, r_line))
    LowerValue          := math.max(array.min(lowerArray, 0), math.min(s_line, r_line))
    ExtenLine           := na(UpperValue) or not(ShowExtend)?  na : s_line
    RetraceLine         := na(LowerValue) or not(ShowRetrace)? na : r_line

if After_B and Trend == -1
    UpperValue          := math.max(array.max(upperArray, 0), math.max(s_line, r_line))
    LowerValue          := math.min(array.min(lowerArray, 0), math.min(s_line, r_line))
    ExtenLine           := na(LowerValue) or not(ShowExtend)?  na : s_line
    RetraceLine         := na(UpperValue) or not(ShowRetrace)? na : r_line

// Draws the Trend Setup line and plots the Extension and Retracement lines.
if time == B_Time and ShowTrend
    line.new(A_Time, A_Price, B_Time, B_Price, xloc=xloc.bar_time,
     width=4, color=color.new(color.aqua, 60), extend=extend.none, style=line.style_dotted)

plot(ShowExtend  and bar_index % 10 == 0 and InRange? ExtenLine   : na, 'Slope Line',   color=colExtend,  linewidth=2, style=plot.style_circles)
plot(ShowRetrace and bar_index % 10 == 0 and InRange? RetraceLine : na, 'Retrace Line', color=colRetrace, linewidth=2, style=plot.style_circles)

// Labels for Points A, B, C, and D
if time == A_Time and ShowA
    box.new(A_Time,A_Price,A_Time,A_Price, xloc=xloc.bar_time, border_width=0, text_valign= text.align_center,
         border_color=na, text='A', text_color=color.new(color.aqua,0), text_size=size.large, text_halign=text.align_center)
if time == B_Time and ShowB
    box.new(B_Time,B_Price,B_Time,B_Price, xloc=xloc.bar_time, border_width=0, text_valign= text.align_center,
         border_color=na, text='B', text_color=color.new(color.aqua,0), text_size=size.large, text_halign=text.align_center)
if bar_index == C_Index and ShowC
    box.new(C_Index,C_Price,C_Index,C_Price, xloc=xloc.bar_index, border_width=0, text_valign= text.align_center,
         border_color=na, text='C', text_color=color.new(color.aqua,0), text_size=size.large, text_halign=text.align_center)
if bar_index == D_Index and ShowD
    box.new(D_Index,D_Price,D_Index,D_Price, xloc=xloc.bar_index, border_width=0, text_valign= text.align_center,
         border_color=na, text='D', text_color=color.new(color.aqua,0), text_size=size.large, text_halign=text.align_center)
