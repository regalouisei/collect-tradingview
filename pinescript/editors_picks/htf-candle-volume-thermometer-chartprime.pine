// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ChartPrime

//@version=6
indicator("HTF Candle Volume Thermometer [ChartPrime]", overlay = true, max_boxes_count = 500, max_bars_back = 1000)


// --------------------------------------------------------------------------------------------------------------------}
// ğ™ğ™ğ™€ğ™ ğ™„ğ™‰ğ™‹ğ™ğ™ğ™
// --------------------------------------------------------------------------------------------------------------------{
timeframe = input.timeframe("D")
resolution = input.string("Mid", "Resolution", ["High", "Mid", "Low"])
color_up = input.color(color.lime, "Bull/Bear", inline = "col_candle")
color_dn = input.color(color.red, "", inline = "col_candle")
transp  = input.int(80, "", inline = "col_candle")
color_heat = input.color(color.yellow, "Heat/Max", inline = "map")
color_poc = input.color(color.red, "", inline = "map")


// --------------------------------------------------------------------------------------------------------------------}
// ğ™„ğ™‰ğ˜¿ğ™„ğ˜¾ğ˜¼ğ™ğ™Šğ™ ğ˜¾ğ˜¼ğ™‡ğ˜¾ğ™ğ™‡ğ˜¼ğ™ğ™„ğ™Šğ™‰ğ™
// --------------------------------------------------------------------------------------------------------------------{

close_htf = request.security(syminfo.tickerid, timeframe, close[1], lookahead = barmerge.lookahead_on)
open_htf = request.security(syminfo.tickerid, timeframe, open[1], lookahead = barmerge.lookahead_on)

time_change = timeframe.change(timeframe)

// Declare arrays to store high/low values during each timeframe period
var array<float> loww = array.new<float>()
var array<float> highh = array.new<float>()

var float H = na
var float L = na
var int index = na

// Dynamic array for bin volumes
var array<float> bin_volumes = array.new<float>()

if time_change
    index := bar_index
    highh.clear()
    loww.clear()
    bin_volumes.clear()  // Reset volume storage

if not time_change
    highh.push(high)
    H := array.max(highh)

    loww.push(low)
    L := array.min(loww)

// Step size based on ATR (dividing into segments)

div = switch resolution
    "High" => 5
    "Mid" => 3
    "Low" => 1

step = ta.atr(200) / div

// --------------------------------------------------------------------------------------------------------------------}
// ğ™‘ğ™„ğ™ğ™ğ˜¼ğ™‡ğ™„ğ™•ğ˜¼ğ™ğ™„ğ™Šğ™‰
// --------------------------------------------------------------------------------------------------------------------{
if time_change
    box_size = H - L
    levels = int(box_size / step)
    bin = box_size / levels  // Prevent division by zero


    // Initialize bin volume storages
    for i = 0 to levels - 1
        array.push(bin_volumes, 0)

    // Calculate volume per bin
    for j = 0 to bar_index - index[1]
        for i = 0 to levels - 1
            lower = L + bin * i
            upper = lower + bin

            if close[j] >= lower and close[j] <= upper
                array.set(bin_volumes, i, array.get(bin_volumes, i) + volume[j])

    // Normalize volumes to create a gradient
    min_vol = array.min(bin_volumes)

    max_vol = array.max(bin_volumes)
    
    if array.size(bin_volumes) > 0 and max_vol > min_vol
        for i = 0 to levels - 1
            norm_vol = (array.get(bin_volumes, i) - min_vol) / (max_vol - min_vol)
            box_color1 = color.from_gradient(norm_vol, 0, 1, color.new(color_up, transp), color_heat)
            box_color2 = color.from_gradient(norm_vol, 0, 1, color.new(color_dn, transp), color_heat)

            box_color = max_vol == array.get(bin_volumes, i) ? color_poc : close_htf > open_htf ? box_color1 : box_color2

            lower = L + bin * i
            upper = lower + bin

            max_volume_val = max_vol == array.get(bin_volumes, i) ? str.tostring(array.get(bin_volumes, i), format.volume) : ""

            box.new(index[1], upper, bar_index, lower, bgcolor=box_color, border_color = na, text = max_volume_val)
// --------------------------------------------------------------------------------------------------------------------}
