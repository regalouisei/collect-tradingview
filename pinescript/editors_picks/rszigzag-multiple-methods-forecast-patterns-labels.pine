//@version=5
//  |{-------------------------------------------------------------------------||
//  ||  author: RicardoSantos
//  ||-------------------------------------------------------------------------||
//  ||  description:
//  ||      • Zig Zag indicator with multiple formation methods.
//    ||        • Forecasts area based on zigzag statistics.
//    ||        • Displays labels with detected patterns.
//    ||        • Displays slope information rate of price, time diferentials and angle(experimental)
//  ||      • Tags: zigzag, range, average, forecast, pattern, time, levels
//  ||---}---------------------------------------------------------------------||
//  |{-------------------------------------------------------------------------||
indicator( 
     title="[RS]ZigZag Multiple Methods - Forecast - patterns - labels", 
     shorttitle="ZZ", 
     overlay=true
     )
//  ||---}---------------------------------------------------------------------||

import RicardoSantos/ColorExtension/4 as colore
import RicardoSantos/HarmonicPattern/3 as pattern
import RicardoSantos/FunctionZigZagMultipleMethods/1 as zigzag


//  |--------------------------------------------------------------------------||
//  |   ZigZag:                                                                ||
//  |--------------------------------------------------------------------------||
//  |{

// ZigZag options:
bool show_real_pivots = input.bool(defval=true, title="Show real zigzag pivots:", group='ZigZag Options:')
bool show_zigzag_lines = input.bool(defval=true, title="Show zigzag lines:", group='ZigZag Options:')

string m_000 = '(MANUAL) Percent price move over X * Y'
string m_001 = 'Percent price move over atr(X) * Y'
string m_002 = 'Percent price move over max(tr) * Y'
string m_003 = 'high or low pivot(X, Y)'
string m_004 = 'Price Action'
string zigzag_method = input.string(
         defval=m_000, 
         title="Method to use for the zigzag:", 
         options=[m_000, m_001, m_002, m_003, m_004], 
         group='ZigZag Options:'
         )

float param_x = input.float(defval=1.0, title='parameter X', group='ZigZag Options:')
float param_y = input.float(defval=1.0, title='parameter Y', group='ZigZag Options:')

// Label options:
bool show_pivot_price = input.bool(defval=true, title="Show price labels on zigzag:", group='Label Options:')
bool show_triangle_rates = input.bool(defval=true, title="Show rate labels on triangles:", group='Label Options:')
bool show_angles = input.bool(defval=false, title="Show Angle Degree information(EXPERIMENTAL):", group='Label Options:')
// Pattern Options:
bool show_patterns = input.bool(defval=true, title="Show Patterns:", group='Pattern Options:')
float err = input.float(defval=5.0, title='Pattern Error Margin:', group='Pattern Options:')
// Forecast options:
bool show_projections = input.bool(defval=true, title="Show projections forecast of zigzag:", group='Projection Options:')
bool show_projections_square = input.bool(defval=true, title="Show projections forecast Bounds:", group='Projection Options:')
bool show_projections_square_rates = input.bool(defval=false, title="Show projections target rates:", group='Projection Options:')
float weight = 2 / (input.float(defval=10., title='Averaging Weight:', group='Projection Options:') + 1)
// Color Profile:
int i_color_hue_zig = input.int(defval=175, minval=0, maxval=360, title='Zig Color Hue:', group='Color Profile')
int i_color_hue_zag = input.int(defval=020, minval=0, maxval=360, title='Zag Color Hue:', group='Color Profile')
int i_color_hue_rate = input.int(defval=200, minval=0, maxval=360, title='Rate Color Hue:', group='Color Profile')
int i_color_hue_ptarget = input.int(defval=200, minval=0, maxval=360, title='Proj. target Color Hue:', group='Color Profile')
int i_color_hue_zigbox = input.int(defval=175, minval=0, maxval=360, title='Zig Proj. box Color Hue:', group='Color Profile')
int i_color_hue_zagbox = input.int(defval=020, minval=0, maxval=360, title='Zag Proj. box Color Hue:', group='Color Profile')
color i_color_reverse = input.color(defval=color.gray, title='Reverse Line:', group='Color Profile')

int i_color_saturation = input.int(defval=080, minval=0, maxval=100, title='Color Saturation:', group='Color Profile')
int i_color_lightness = input.int(defval=070, minval=0, maxval=100, title='Color Lightness:', group='Color Profile')
int i_color_transparency = 0//input(defval=000, minval=0, maxval=100, title='Color Transparency:', group='Color Profile')

string i_label_text_size = input.string(defval=size.small, title='Text Size:', options=[size.tiny, size.small, size.normal, size.large, size.huge, size.auto], group='Color Profile')

color c_zig = colore.hsl(i_color_hue_zig, i_color_saturation, i_color_lightness, i_color_transparency)
color c_zag = colore.hsl(i_color_hue_zag, i_color_saturation, i_color_lightness, i_color_transparency)
color c_rate = colore.hsl(i_color_hue_rate, 10, i_color_lightness, i_color_transparency)
color c_ptarget = colore.hsl(i_color_hue_ptarget, i_color_saturation, i_color_lightness, i_color_transparency)
color c_zigbox = colore.hsl(i_color_hue_zigbox, i_color_saturation, i_color_lightness, 75)
color c_zagbox = colore.hsl(i_color_hue_zigbox, i_color_saturation, i_color_lightness, 75)
color c_text = colore.hsl(200, 10, 100-i_color_lightness, i_color_transparency)

[price_a, is_up, reverse, _rl_time] = zigzag.function(zigzag_method, param_x, param_y)
//  ||-------------------------------------------------------------------------||
//  ||  zigzag data:
//  ||-------------------------------------------------------------------------||
//  |{
alt_time = show_real_pivots ? _rl_time : time

zz_color = is_up ? c_zag : c_zig
is_new_zig = ta.change(price_a) != 0 ? price_a : na
//  
//plot(is_new_zig, title="Z", color=zz_color, linewidth=1, transp=80)

plot(reverse, title="R", color=i_color_reverse, style=plot.style_stepline, linewidth=1, offset=1)
plot(reverse, title="R", color=i_color_reverse, style=plot.style_circles, linewidth=4, offset=1, show_last=1)

//  |   Get Pivots:
var int time_a = na
var int time_b = na, var float price_b = na
var int time_c = na, var float price_c = na
var int time_d = na, var float price_d = na
var int time_e = na, var float price_e = na
var int time_f = na, var float price_f = na
var int time_g = na, var float price_g = na

int cumvol = int(ta.cum(volume))
var int vol_a = na
var int vol_b = na

if is_new_zig
    time_a := alt_time, 
    time_b := time_a[1], price_b := price_a[1]
    time_c := time_b[1], price_c := price_b[1]
    time_d := time_c[1], price_d := price_c[1]
    time_e := time_d[1], price_e := price_d[1]
    time_f := time_e[1], price_f := price_e[1]
    time_g := time_f[1], price_g := price_f[1]
    vol_a := cumvol, vol_b := vol_a[1]
    

float AB_price_difference = math.abs(price_a - price_b)
//float AC_price_difference = math.abs(price_a - price_c)

int AB_time_difference = time_a - time_b
//int AC_time_difference = time_a - time_c

int AB_volume = vol_a - vol_b

// ||   |}---------------------------------------------------------------------<•

//  ||-------------------------------------------------------------------------||
//  ||  Draw zigzag:
//  ||-------------------------------------------------------------------------||
//  |{
int max_zigzag_lines = 20
var line[] zigzag_lines = array.new_line(max_zigzag_lines, line(na))
f_draw_zigzag_lines()=>
    var line _li = na
    _li_color = price_a > price_b ? c_zig : c_zag
    if is_new_zig
        if array.size(zigzag_lines) >= max_zigzag_lines
            line.delete(array.pop(zigzag_lines))
        _li := line.new(
             time_a, price_a, 
             time_b, price_b, 
             xloc.bar_time, extend=extend.none, color=_li_color, width=2
             )
        array.unshift(zigzag_lines, _li)

if show_zigzag_lines
    f_draw_zigzag_lines()
//  ||  |}---------------------------------------------------------------------<•

// ||   |}---------------------------------------------------------------------<•

//  ||-------------------------------------------------------------------------||
//  ||  Pivot Labels:
//  ||-------------------------------------------------------------------------||
//  |{
int max_zigzag_labels = 20
var label[] zigzag_labels = array.new_label(max_zigzag_labels, label(na))
f_draw_zigzag_labels(_text)=>
    var label _la = na
    color _la_color = price_a > price_b ? c_zag : c_zig
    string _la_style = price_a > price_b ? label.style_label_down : label.style_label_up
    string _la_text = na
    if show_pivot_price
        _la_text := price_a > price_b ? str.tostring(price_a, "#.#####") + ', V: ' + str.tostring(AB_volume, '#') + _text : _text + str.tostring(price_a, "#.#####") + ', V: ' + str.tostring(AB_volume, '#')
    else
        _la_text := _text
    if is_new_zig
        if array.size(zigzag_labels) >= max_zigzag_labels
            label.delete(array.pop(zigzag_labels))
        _la := label.new(
             x=time_a, y=price_a, 
             text=_la_text, 
             xloc=xloc.bar_time, yloc=yloc.price, 
             style=_la_style, 
             color=_la_color, textcolor=c_text, size=i_label_text_size
             )
        array.unshift(zigzag_labels, _la)
//  ||  |}---------------------------------------------------------------------<•

//  ||-------------------------------------------------------------------------||
//  ||  Function to process data, return range, avg, +/- dev, max to be ploted:
//  ||-------------------------------------------------------------------------||
//  |{
f_mode_process_stats(_weight, _data)=>
    float _avg_range = _data, float _max_range = 0.0
    if bar_index < 1
        // on 1st bar, make it equal to _data
        _avg_range := _data
    else
        if _data != _data[1]
            _weight_data = _weight * _data
            _weight_previous = (1 - _weight) * nz(_avg_range[1], _data[1])
            _avg_range := _weight_data + _weight_previous
        else
            _avg_range := _avg_range[1]
    
        _max_range := math.max(nz(_max_range[1], _data), _data)
        
    _pos_range = math.max(0.0, _data - _avg_range)
    _neg_range = math.min(0.0, _data - _avg_range)
    
    var float _pos_dev = 0.0, var float _neg_dev = 0.0
    if bar_index >= 1
        if _pos_range != _pos_range[1]
            _pos_dev := _weight * _pos_range + (1 - _weight) * _pos_dev[1]
        else
            _pos_dev := _pos_dev[1]
        if _neg_range != _neg_range[1]
            _neg_dev := _weight * _neg_range + (1 - _weight) * _neg_dev[1]
        else
            _neg_dev := _neg_dev[1]

    [_avg_range, _max_range, _pos_dev, _neg_dev]
//  |}---------------------------------------------------------------------<•
//  |{
[price_avg_range, price_max_range, price_pos_dev, price_neg_dev] = f_mode_process_stats(weight, AB_price_difference)
[time_avg_range, time_max_range, time_pos_dev, time_neg_dev] = f_mode_process_stats(weight, AB_time_difference)

target_avg_price = price_a > price_b ? price_a - price_avg_range : price_a + price_avg_range
target_price_upper_dev = price_a > price_b ? price_a - price_avg_range - price_neg_dev : price_a + price_avg_range + price_neg_dev
target_price_lower_dev = price_a > price_b ? price_a - price_avg_range - price_pos_dev : price_a + price_avg_range + price_pos_dev
target_price_0618_dev = price_a > price_b ? price_a - (price_avg_range + price_neg_dev) * 0.618 : price_a + (price_avg_range + price_neg_dev) * 0.618
target_price_1618_dev = price_a > price_b ? price_a - (price_avg_range + price_pos_dev) * 1.618 : price_a + (price_avg_range + price_pos_dev) * 1.618

target_avg_time = int(time_a + time_avg_range)
target_time_upper_dev = int(target_avg_time + time_pos_dev)
target_time_lower_dev = int(target_avg_time + time_neg_dev)
target_time_0618_dev = int(time_a + (time_avg_range + time_neg_dev) * 0.618)
target_time_1618_dev = int(time_a + (time_avg_range + time_pos_dev) * 1.618)
//  ||  |}---------------------------------------------------------------------<•


//  ||-------------------------------------------------------------------------||
//  ||  Line projection:
//  ||-------------------------------------------------------------------------||
//  |{
max_forecast_boxs = 1
var forecast_boxs = array.new_box(max_forecast_boxs, box(na))
f_cast_projections()=>
    var line line_midline = na
    var line line_price_dev = na
    var line line_time_dev = na
    var label _la0618 = na
    var label _la1618 = na
    //  ||  Style abreviation:
    xtend = extend.right
    st_dash = line.style_dashed
    st_arrow = line.style_arrow_both

    //  |   clear past lines:
    line.delete(line_midline)
    line.delete(line_price_dev)
    line.delete(line_time_dev)
    label.delete(_la0618)
    label.delete(_la1618)
    
    line_midline := line.new( 
                 time_a, price_a, 
                 target_avg_time, target_avg_price, 
                 xloc.bar_time, extend=xtend, color=c_ptarget, style=st_dash, width=1
                 )
    line_price_dev := line.new(
                 target_avg_time, target_price_lower_dev, 
                 target_avg_time, target_price_upper_dev, 
                 xloc.bar_time, color=c_ptarget, style=st_arrow, width=1
                 )
    line_time_dev := line.new( 
                 target_time_lower_dev, target_avg_price, 
                 target_time_upper_dev, target_avg_price, 
                 xloc.bar_time, color=c_ptarget, style=st_arrow, width=1
                 )

    if show_projections_square
        if array.size(forecast_boxs) >= max_forecast_boxs
            box.delete(array.pop(forecast_boxs))
        _c = is_up ? c_zigbox : c_zagbox
        _bo = box.new(
             left=target_time_0618_dev, top=target_price_0618_dev, 
             right=target_time_1618_dev, bottom=target_price_1618_dev, 
             border_color=color.gray,  border_style=line.style_dashed, border_width=1,
             xloc=xloc.bar_time, extend=extend.none, bgcolor=_c
             )
        array.unshift(forecast_boxs, _bo)

        if show_projections_square_rates
            _la0618 := label.new(
                     x=target_time_1618_dev, y=target_price_1618_dev, 
                     text="Max. Target 1.618 @ " + str.tostring(target_price_1618_dev, "#.#####"), 
                     xloc=xloc.bar_time, yloc=yloc.price, 
                     style=is_up ? label.style_label_down : label.style_label_up, 
                     color=c_rate, textcolor=c_text, size=i_label_text_size,
                     tooltip='Likelyhood taken from the zigzag swing distribution.'
                     )
            _la1618 := label.new(
                     x=target_time_0618_dev, y=target_price_0618_dev, 
                     text="Min. Target 0.618 @ " + str.tostring(target_price_0618_dev, "#.#####"), 
                     xloc=xloc.bar_time, yloc=yloc.price, 
                     style=is_up ? label.style_label_up : label.style_label_down, 
                     color=c_rate, textcolor=c_text, size=i_label_text_size, 
                     tooltip='Likelyhood taken from the zigzag swing distribution.'
                     )

first_realtime_bar = (barstate.islast and barstate.ishistory[1])
    
if show_projections and (is_new_zig or first_realtime_bar)
    f_cast_projections()
//  ||  |}---------------------------------------------------------------------<•

//  ||-------------------------------------------------------------------------||
//  ||  Detect patterns:
//  ||-------------------------------------------------------------------------||
//  |{
//  ||  Pattern Functions:

f_draw_rate_lines_and_label(_price_rate, _time_rate, _x1, _y1, _x2, _y2, _is_up)=>
    if show_triangle_rates
        _text = "Price: " + str.tostring(_price_rate, "#.###") + (not show_angles ? "" : ", (sin:" + str.tostring(nz(math.asin(_price_rate)*(180/3.1416), 0), "#") + "º, cos:" + str.tostring(nz(math.acos(_price_rate)*(180/3.1416), 0), "#") + "º" + ", tan:" + str.tostring(nz(math.atan(_price_rate)*(180/3.1416), 0), "#") + "º)")
        _text := _text + "\nTime: " + str.tostring(_time_rate, "#.###") + (not show_angles ? "" : ", (sin:" + str.tostring(nz(math.asin(_time_rate)*(180/3.1416), 0), "#.###") + "º, cos:" + str.tostring(nz(math.acos(_time_rate)*(180/3.1416), 0), "#.###") + "º" + ", tan:" + str.tostring(nz(math.atan(_time_rate)*(180/3.1416), 0), "#.###") + "º)")
        
        var line _li = na
        var label _la = na
        line.delete(_li)
        label.delete(_la)
        _li := line.new( 
             x1 = _x1, y1 = _y1, 
             x2 = _x2, y2 = _y2, 
             xloc = xloc.bar_time, extend = extend.none, 
             color = color.gray, style = line.style_dashed, width = 1 
             )
        _la := label.new( 
             x=math.round((_x1 + _x2) / 2), y=(_y1 + _y2) / 2, 
             text=_text, 
             xloc=xloc.bar_time, yloc=yloc.price, 
             style=_is_up ? label.style_label_up : label.style_label_down, 
             color=c_rate, textcolor=c_text, size=i_label_text_size
             )

//  |}
//  |{-------------------------------------------------------------------------||
//  ||  Parameters:
//  ||      _percent_of_error   (float)     : Margin of error in percentage.
f_Detect_Patterns(_percent_of_error)=>
    //  Placeholder for pattern label
    string _pattern_label_placeholder = ""
    // adjust margin of error into multiplier
    float _margin_of_error = _percent_of_error / 100
    
    if show_patterns
        string _format = is_up ? '{0}\n' : '\n{0}'
        string[] _pattern_list = pattern.extract(price_g, price_f, price_e, price_d, price_c, price_b, price_a, _margin_of_error)
        f_draw_zigzag_labels(array.size(_pattern_list) > 0 ? str.format(_format, array.join(_pattern_list, '\n')) : '')
    else
    // Only shows price label:
        if show_pivot_price
            f_draw_zigzag_labels("")
    
    
    //  Draw rate lines and labels code:
    if show_triangle_rates
        float _price_cba = pattern.line_price_rate(price_c, price_b, price_a)
        float _price_edc = pattern.line_price_rate(price_e, price_d, price_c)
        float _price_gfe = pattern.line_price_rate(price_g, price_f, price_e)
        float _price_dcb = pattern.line_price_rate(price_d, price_c, price_b)
        if _price_cba < _price_edc and _price_edc < _price_gfe
            f_draw_rate_lines_and_label(pattern.line_price_rate(price_g, price_f, price_a), pattern.line_time_rate(time_g, time_f, time_a), time_a, price_a, time_g, price_g, (price_a < price_f))
            f_draw_rate_lines_and_label(pattern.line_price_rate(price_g, price_d, price_a), pattern.line_time_rate(time_g, time_d, time_a), time_a, price_a, time_g, price_g, (price_a < price_d))
            f_draw_rate_lines_and_label(pattern.line_price_rate(price_g, price_b, price_a), pattern.line_time_rate(time_g, time_b, time_a), time_a, price_a, time_g, price_g, (price_a < price_b))
        if _price_cba < _price_edc
            f_draw_rate_lines_and_label(pattern.line_price_rate(price_e, price_d, price_a), pattern.line_time_rate(time_e, time_d, time_a), time_a, price_a, time_e, price_e, (price_a < price_d))
            f_draw_rate_lines_and_label(pattern.line_price_rate(price_e, price_b, price_a), pattern.line_time_rate(time_e, time_b, time_a), time_a, price_a, time_e, price_e, (price_a < price_b))
        f_draw_rate_lines_and_label(_price_cba, pattern.line_time_rate(time_c, time_b, time_a), time_a, price_a, time_c, price_c, (price_a < price_b))
        f_draw_rate_lines_and_label(_price_dcb, pattern.line_time_rate(time_d, time_c, time_b), time_b, price_b, time_d, price_d, (price_b < price_c))
        if _price_dcb < pattern.line_price_rate(price_f, price_e, price_d) 
            f_draw_rate_lines_and_label(pattern.line_price_rate(price_f, price_e, price_b), pattern.line_time_rate(time_f, time_e, time_b), time_b, price_b, time_f, price_f, (price_b < price_e))
    

if (show_pivot_price or show_patterns) and (is_new_zig)// or first_realtime_bar)
    f_Detect_Patterns(err)
    
    
//  ||  |}---------------------------------------------------------------------<•
