// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Ki11a_B

//@version=6
indicator("BK AK-Ghost Ladder", shorttitle="ğŸ‘»", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL APPEARANCE / COLORS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupAppearance = "Appearance"
bullColor       = input.color(#00ffbb, "Bullish Color", group=groupAppearance)
bearColor       = input.color(#ff1100, "Bearish Color", group=groupAppearance)
divergenceColor = input.color(#FF9800, "Divergence Warning Color", group=groupAppearance)
pocColor        = input.color(#FFEB3B, "POC Line Color", group=groupAppearance)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOLUME PROFILE (IN-ZONE)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupVP = "Volume Profile"
enableVolumeProfile   = input.bool(true, "Enable Volume Profile in Zones", group=groupVP)
volumeProfileBins     = input.int(10, "Volume Profile Resolution", minval=5, maxval=30, tooltip="Number of price bins per zone", group=groupVP)
showPOC               = input.bool(true, "Show POC Line", tooltip="Point of Control within zone", group=groupVP)
pocLineWidth          = input.int(2, "POC Line Width", minval=1, maxval=4, group=groupVP)
pocLineTransparency   = input.int(60, "POC Line Transparency", minval=0, maxval=100, group=groupVP)
volumeProfileTransp   = input.int(83, "Profile Transparency", minval=0, maxval=100, group=groupVP)
useLTFVolumeProfile   = input.bool(true, "Use Lower TF for Profile", group=groupVP)
ltfProfileDivider     = input.int(10, "LTF Profile Divider", minval=2, maxval=20, group=groupVP)
volumeProfileWidth    = input.float(40.0, "Profile Width %", minval=10, maxval=80, step=5, tooltip="Width as % of zone width", group=groupVP)
showVolumeSum         = input.bool(false, "Show Total Volume in Zone", group=groupVP)
volumeSumSize         = input.string("Normal", "Volume Sum Label Size", options=["Tiny","Small","Normal"], tooltip="Size of the total volume label", group=groupVP)
volumeSumTransparency = input.int(38, "Volume Sum Label Transparency", minval=0, maxval=100, tooltip="Transparency of the total volume label background", group=groupVP)
enableVolumeDelta     = input.bool(true, "Enable Volume Delta Display", tooltip="Show buy/sell pressure on POC line", group=groupVP)
deltaColorStrength    = input.int(83, "Delta Color Strength", minval=0, maxval=100, group=groupVP)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STAR LABEL POSITION / SIZE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupStars   = "Strength Rating"
starPosition = input.string("Right", "Star Label Position", options=["Right", "Left Inside"], group=groupStars)
showStrength = input.bool(true, "Show Strength Rating", group=groupStars)
starSizeInp  = input.string("Small", "Star Label Size", options=["Tiny","Small","Normal","Large","Huge"], group=groupStars)
starTransp   = input.int(0, "Star Transparency", minval=0, maxval=100, group=groupStars)
showLabelBackground = input.bool(false, "Show Label Background", tooltip="Star label background (does NOT affect box transparency)", group=groupStars)
labelBgTransparency = input.int(0, "Label Background Transparency", minval=0, maxval=100, group=groupStars)
preventLabelOverlap = input.bool(true, "Prevent Label Overlap", tooltip="Automatically adjust label positions to avoid overlap", group=groupStars)
minLabelDistance    = input.float(2.0, "Min Label Distance (% of ATR)", minval=0.5, maxval=10.0, step=0.5, group=groupStars)
volMultiplier       = input.float(1.5, "Institutional Volume Threshold", minval=1.0, maxval=5.0, step=0.1, group=groupStars)
gapSizeWeight       = input.float(50, "Gap Size Weight (%)", minval=0, maxval=100, step=5, group=groupStars)
pivotConfluenceBonus= input.int(15, "Pivot Confluence Bonus", minval=0, maxval=30, group=groupStars)
touchPointsEach     = input.int(2, "Points Per Historical Touch", minval=1, maxval=5, group=groupStars)
maxTouchPoints      = input.int(15, "Max Points from Touches", minval=5, maxval=30, group=groupStars)
star5Threshold      = input.float(90, "5â˜… Threshold", minval=50, maxval=100, step=5, group=groupStars)
star4Threshold      = input.float(75, "4â˜… Threshold", minval=40, maxval=90, step=5, group=groupStars)
star3Threshold      = input.float(60, "3â˜… Threshold", minval=30, maxval=80, step=5, group=groupStars)
star2Threshold      = input.float(40, "2â˜… Threshold", minval=20, maxval=70, step=5, group=groupStars)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FVG DETECTION
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupFVG = "FVG Detection"
maxBoxAge      = input.int(1000, "Zone Expiration Bars", group=groupFVG)
resetAgeOnTouch= input.bool(true, "Reset Age on Touch", group=groupFVG)
preventOverlap = input.bool(true, "Prevent Overlap", group=groupFVG)
proximityBars  = input.int(3, "Minimum Distance (Bars)", minval=0, maxval=10, group=groupFVG)
keepStrongest  = input.bool(true, "Keep Only Strongest in Proximity", group=groupFVG)
showBull       = input.bool(true, "Show Bullish FVGs", group=groupFVG)
showBear       = input.bool(true, "Show Bearish FVGs", group=groupFVG)
distanceMode   = input.string("ATR", "Distance Filter Mode", options=["ATR","Percent"], group=groupFVG)

// â•â•â• NEW: Timeframe-Adaptive Settings â•â•â•
enableTFAdaptive = input.bool(true, "Enable Timeframe-Adaptive Filters", tooltip="Use separate settings for <1H and â‰¥1H timeframes", group=groupFVG)

// HTF Settings (1H and above)
distanceFilterATR_HTF = input.float(3.0, "HTF Distance Filter (ATR) â‰¥1H", minval=0, maxval=10, group=groupFVG, inline="htf")
distanceFilterPct_HTF = input.float(1.0, "HTF Distance Filter (%) â‰¥1H", minval=0, maxval=50, group=groupFVG, inline="htf")

// LTF Settings (under 1H)  
distanceFilterATR_LTF = input.float(7.0, "LTF Distance Filter (ATR) <1H", minval=0, maxval=20, group=groupFVG, inline="ltf")
distanceFilterPct_LTF = input.float(2.0, "LTF Distance Filter (%) <1H", minval=0, maxval=50, group=groupFVG, inline="ltf")

// â•â•â• Determine which settings to use â•â•â•
isLowerTimeframe = timeframe.in_seconds() < 3600  // Under 1 hour (3600 seconds)

distanceFilterATR = enableTFAdaptive ? (isLowerTimeframe ? distanceFilterATR_LTF : distanceFilterATR_HTF) : distanceFilterATR_HTF
distanceFilterPct = enableTFAdaptive ? (isLowerTimeframe ? distanceFilterPct_LTF : distanceFilterPct_HTF) : distanceFilterPct_HTF
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREAK DETECTION
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupBreak = "Break Detection"
breakConfirmBars = input.int(2, "Break Confirmation Bars", minval=1, maxval=5, group=groupBreak)
breakRequireBody = input.bool(true, "Require Body Break", group=groupBreak)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIVERGENCE (REAL-TIME)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupDiv = "Divergence Detection"
enableRealtimeDivergence = input.bool(true, "Enable Real-Time Divergence", group=groupDiv)
rsiPeriod              = input.int(14, "RSI Period", minval=2, maxval=50, group=groupDiv)
rsiDivergenceThreshold = input.float(5.0, "RSI Divergence Threshold", minval=1.0, maxval=20.0, group=groupDiv)
enableOBV              = input.bool(true, "Enable OBV Divergence", group=groupDiv)
obvLookback            = input.int(10, "OBV Lookback", minval=5, maxval=50, group=groupDiv)
enableADX              = input.bool(true, "Enable ADX Momentum Check", group=groupDiv)
adxPeriod              = input.int(14, "ADX Period", minval=7, maxval=50, group=groupDiv)
adxWeakThreshold       = input.float(20.0, "ADX Weak Momentum Threshold", minval=10.0, maxval=40.0, group=groupDiv)
divergenceVisualMode   = input.string("Border + Icon", "Visual Mode", options=["Border Only", "Icon Only", "Border + Icon", "Color Change"], group=groupDiv)
divergenceBorderWidth  = input.int(1, "Divergence Border Width", minval=1, maxval=5, group=groupDiv)
divergenceBorderTransp = input.int(0, "Divergence Border Transparency", minval=0, maxval=100, group=groupDiv)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SMART POSITIONING (S/R Logic)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupSmart = "Smart Positioning"
enableSmartPositioning = input.bool(true, "Enable Smart S/R Positioning", group=groupSmart)
positionFilterMode = input.string("Auto Role Flip", "Position Filter Mode", options=["Show All", "Hide Wrong Side", "Auto Role Flip"], group=groupSmart)
reactivateOnReversal = input.bool(true, "Reactivate Zones on Reversal", group=groupSmart)
positionBuffer       = input.float(0.2, "Position Buffer (%)", minval=0.0, maxval=2.0, step=0.1, group=groupSmart)
showReactivatedBadge = input.bool(true, "Show Reactivated Badge", group=groupSmart)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOX / TEXT APPEARANCE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupBox = "Box Settings"
boxExtension       = input.int(5, "Box Extension (Bars)", minval=1, maxval=500, group=groupBox)
cleanMode          = input.bool(false, "Clean Chart Mode", group=groupBox)
cleanModeOffset    = input.int(5, "Clean Mode Offset (Bars)", minval=0, maxval=100, group=groupBox)
cleanModeExtension = input.int(50, "Clean Mode Extension (Bars)", minval=1, maxval=500, group=groupBox)
boxTransp          = input.int(95, "Box Background Transparency", minval=0, maxval=100, group=groupBox)
boxBorderTransp    = input.int(95, "Box Border Transparency", minval=0, maxval=100, group=groupBox)
boxBorderWidth     = input.int(1, "Box Border Width", minval=1, maxval=5, tooltip="Default border width for all zones", group=groupBox)
showGapZone        = input.bool(true, "Show Main Gap Zone", group=groupBox)
groupVolText      = "Volume Text Display"
showVolumeText    = input.bool(false, "Show Volume Text in Boxes", group=groupVolText)
volumeDisplayMode = input.string("Both Numbers", "Volume Display Mode", options=["Bull Numbers", "Bear Numbers", "Both Numbers", "Bull Percentage", "Bear Percentage", "Both Percentages", "Numbers and Percentages"], group=groupVolText)
text_size         = input.string("Medium", "Volume Text Size", options=["Auto","Tiny","Small","Medium","Large"], group=groupVolText)
textTransp        = input.int(0, "Volume Text Transparency", minval=0, maxval=100, group=groupVolText)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOLUME SETTINGS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupVol = "Volume Settings"
useVolumeDynamics = input.bool(true, "Use Volume-Based Box Transparency", tooltip="Higher volume zones = more visible boxes", group=groupVol)
volTranspMin      = input.int(88, "Min Box Transparency (High Volume)", minval=0, maxval=100, group=groupVol)
volTranspMax      = input.int(97, "Max Box Transparency (Low Volume)", minval=0, maxval=100, group=groupVol)
useLTFVolume      = input.bool(true, "Use Lower Timeframe Volume", group=groupVol)
ltfDivider        = input.int(10, "LTF Divider", minval=2, maxval=20, group=groupVol)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILTERS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupFilt = "Filtering"
enableMinStrength     = input.bool(false, "Enable Minimum Strength Filter", group=groupFilt)
minStarRating         = input.int(3, "Minimum Star Rating", minval=1, maxval=5, group=groupFilt)
showOnlyInstitutional = input.bool(false, "Show Only Institutional FVGs", group=groupFilt)
dynamicInstitutional  = input.bool(true, "Dynamic Institutional Classification", group=groupFilt)
autoHideWeakZones     = input.bool(false, "Auto-Hide Weak Zones", group=groupFilt)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIVOTS / MTF
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupPivot = "Pivot S/R"
enablePivots     = input.bool(true, "Enable Pivot S/R Analysis", group=groupPivot)
pivotPeriod      = input.int(10, "Pivot Lag Period", minval=4, maxval=30, group=groupPivot)
pivotLookback    = input.int(300, "Pivot Lookback", minval=100, maxval=500, group=groupPivot)
pivotSource      = input.string("High/Low", "Pivot Source", options=["High/Low", "Close/Open"], group=groupPivot)
showPivotMarkers = input.bool(true, "Show Pivot Markers", group=groupPivot)
pivotDisplay     = input.string("Both", "Pivot Confluence Display", options=["Off", "Border Only", "Icon Only", "Both"], group=groupPivot)
pivotToleranceATR= input.float(0.5, "Pivot Tolerance (ATR)", minval=0.1, maxval=2.0, step=0.1, group=groupPivot)
groupMTF = "MTF Confluence"
enableMTFConfluence = input.bool(true, "Enable MTF Confluence", group=groupMTF)
mtfTimeframe1       = input.timeframe("15", "MTF Timeframe 1", group=groupMTF)
mtfTimeframe2       = input.timeframe("60", "MTF Timeframe 2", group=groupMTF)
mtfConfluenceBonus  = input.int(10, "Bonus per aligned TF", minval=0, maxval=20, group=groupMTF)
mtfDisplay          = input.string("Both", "MTF Confluence Display", options=["Off", "Border Only", "Icon Only", "Both"], group=groupMTF)
mtfBorderWidth      = input.int(1, "MTF Border Width", minval=1, maxval=5, group=groupMTF)
mtfBorderTransp     = input.int(50, "MTF Border Transparency", minval=0, maxval=100, group=groupMTF)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROLE REVERSAL
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupRR = "Role Reversal"
enableRoleReversal  = input.bool(true, "Enable Role Reversal Detection", group=groupRR)
keepBrokenZones     = input.int(50, "Keep Broken Zones (Bars)", minval=10, maxval=200, group=groupRR)
reversalConfirmBars = input.int(2, "Reversal Confirmation Bars", minval=1, maxval=5, group=groupRR)
roleReversalBonus   = input.int(20, "Role Reversal Strength Bonus", minval=0, maxval=30, group=groupRR)
brokenBoxDisplay    = input.string("Both", "Broken Box Display", options=["None", "Border Only", "Icon Only", "Both"], group=groupRR)
reversalBorderWidth = input.int(1, "Role Reversal Border Width", minval=1, maxval=5, group=groupRR)
reversalBorderTransp= input.int(50, "Role Reversal Border Transparency", minval=0, maxval=100, group=groupRR)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSOLIDATION / MERGING / CLUSTERING
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupMerge = "Zone Consolidation"
enableMerging        = input.bool(true, "Enable Zone Merging", group=groupMerge)
mergeTolerance       = input.int(5, "Merge Tolerance (Ticks)", minval=0, maxval=10, group=groupMerge)
mergeAtrPercent      = input.float(0.2, "Extra Tolerance (% ATR)", minval=0.0, maxval=1.0, step=0.05, group=groupMerge)
mergeMaxAgeDiff      = input.int(50, "Max Age Difference", minval=0, maxval=200, group=groupMerge)
mergeStrengthMethod  = input.string("Weighted", "Strength Merge Method", options=["Max", "Weighted", "Average"], group=groupMerge)
mergeVolumeMethod    = input.string("Sum", "Volume Merge Method", options=["Sum", "Max", "Average"], group=groupMerge)
mergeDontMergeBroken = input.bool(true, "Don't Merge Broken Zones", group=groupMerge)
showConsolidationInfo= input.bool(true, "Show Consolidation Info", group=groupMerge)
showMergeAnimation   = input.bool(true, "Show Merge Indicator", tooltip="ğŸ”— icon when zones merge", group=groupMerge)
groupCluster = "Zone Clustering"
enableZoneClustering = input.bool(true, "Enable Zone Clustering", group=groupCluster)
clusterThreshold     = input.int(3, "Min Zones for Cluster", minval=2, maxval=5, group=groupCluster)
showClusterBadge     = input.bool(true, "Show Cluster Badge", group=groupCluster)
clusterBonus         = input.int(20, "Cluster Strength Bonus", minval=0, maxval=30, group=groupCluster)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED FEATURES (OB, Imbalance, VWAP, Magnetic)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupEnh = "Enhanced Features"
enableOrderBlocks    = input.bool(true, "Enable Order Block Detection", group=groupEnh)
obLookback           = input.int(50, "Order Block Lookback", minval=10, maxval=200, group=groupEnh)
obMinEngulfing       = input.float(1.5, "Min Engulfing Ratio", minval=1.0, maxval=3.0, step=0.1, group=groupEnh)
obVolumeThreshold    = input.float(1.5, "OB Volume Threshold", minval=1.0, maxval=3.0, step=0.1, group=groupEnh)
obConfluenceBonus    = input.int(15, "Order Block Confluence Bonus", minval=0, maxval=30, group=groupEnh)
enableImbalanceZones = input.bool(true, "Enable Imbalance Detection", group=groupEnh)
imbalanceRatio       = input.float(3.0, "Imbalance Ratio Threshold", minval=2.0, maxval=10.0, step=0.5, group=groupEnh)
imbalanceMinVolume   = input.float(1.2, "Min Volume for Imbalance", minval=0.5, maxval=3.0, step=0.1, group=groupEnh)
imbalanceConfluenceBonus = input.int(10, "Imbalance Confluence Bonus", minval=0, maxval=25, group=groupEnh)
enableVWAPAnalysis   = input.bool(true, "Enable VWAP Analysis", group=groupEnh)
vwapSource           = input.source(hlc3, "VWAP Source", group=groupEnh)
showVWAPLine         = input.bool(true, "Show VWAP Line", group=groupEnh)
vwapLineColor        = input.color(#9C27B0, "VWAP Line Color", group=groupEnh)
vwapLineWidth        = input.int(2, "VWAP Line Width", minval=1, maxval=5, group=groupEnh)
vwapLineTransp       = input.int(0, "VWAP Line Transparency", minval=0, maxval=100, group=groupEnh)
vwapShortForm        = input.bool(true, "Short Form VWAP", tooltip="Only show VWAP for the last N bars of loaded data", group=groupEnh)
vwapShortBars        = input.int(5, "VWAP Short Form Bars", minval=1, maxval=100, group=groupEnh)
vwapProximityBonus   = input.int(10, "VWAP Proximity Bonus", minval=0, maxval=20, group=groupEnh)
vwapExtremesBonus    = input.int(15, "VWAP Extremes Bonus", minval=0, maxval=25, group=groupEnh)
vwapProximityThreshold = input.float(0.5, "VWAP Proximity % Threshold", minval=0.1, maxval=2.0, step=0.1, group=groupEnh)
enableMagneticLevels = input.bool(true, "Enable Magnetic Price Levels", group=groupEnh)
magneticStrength     = input.float(1.0, "Magnetic Field Strength", minval=0.1, maxval=3.0, step=0.1, group=groupEnh)
magneticRange        = input.float(0.5, "Magnetic Range (ATR)", minval=0.1, maxval=2.0, step=0.1, group=groupEnh)
magneticDecay        = input.float(0.95, "Magnetic Decay Rate", minval=0.5, maxval=1.0, step=0.05, group=groupEnh)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADAPTIVE LEARNING & ML
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupAL = "Adaptive Learning & ML"
enableAdaptiveOptimization = input.bool(true, "Enable Adaptive Optimization", group=groupAL)
learningPeriod       = input.int(500, "Learning Period (Bars)", minval=100, maxval=2000, group=groupAL)
performanceWeight    = input.float(0.7, "Performance Weight", minval=0.1, maxval=1.0, step=0.1, group=groupAL)
adaptiveUpdateFreq   = input.int(50, "Update Frequency (Bars)", minval=10, maxval=200, group=groupAL)
minSampleSize        = input.int(10, "Min Sample Size", minval=5, maxval=50, group=groupAL)
enableDynamicTooltips= input.bool(true, "Enable Dynamic Tooltip Updates", group=groupAL)
tooltipUpdateFreq    = input.int(10, "Tooltip Update Frequency (Bars)", minval=1, maxval=50, group=groupAL)
enableMLPredictions  = input.bool(true, "Enable ML Predictions", tooltip="Auto-adjust based on performance", group=groupAL)
mlConfidenceThreshold= input.float(0.7, "ML Confidence Threshold", minval=0.5, maxval=1.0, step=0.05, group=groupAL)
showMLBadge          = input.bool(true, "Show ML Confidence Badge", group=groupAL)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKTESTING
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupBacktest = "Backtesting Mode"
enableBacktesting    = input.bool(true, "Enable Backtesting", group=groupBacktest)
backtestLookback     = input.int(500, "Backtest Lookback Period", minval=100, maxval=2000, group=groupBacktest)
successThresholdPips = input.float(10.0, "Success Threshold (Points)", minval=1.0, maxval=100.0, tooltip="Price must move this many points for success", group=groupBacktest)
failureThresholdPips = input.float(20.0, "Failure Threshold (Points)", minval=1.0, maxval=100.0, tooltip="Break beyond this = failure", group=groupBacktest)
showWinRate          = input.bool(true, "Show Win Rate in Tooltip", group=groupBacktest)
minTouchesForStats   = input.int(3, "Min Touches for Statistics", minval=1, maxval=10, group=groupBacktest)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupFib = "Fibonacci Detection"
enableFibDetection = input.bool(true, "Enable Fibonacci Level Detection", group=groupFib)
fibLookback        = input.int(100, "Fib Lookback Period", minval=50, maxval=500, group=groupFib)
fibTolerance       = input.float(0.5, "Fib Alignment Tolerance %", minval=0.1, maxval=2.0, step=0.1, group=groupFib)
fibConfluenceBonus = input.int(15, "Fib Confluence Bonus", minval=0, maxval=30, group=groupFib)
showFibLevels      = input.bool(false, "Show Fib Levels", group=groupFib)
showOnlyCurrentFib = input.bool(true, "Show Only Current Fib Levels", tooltip="Remove previous fib lines", group=groupFib)
fibLineExtension   = input.int(5, "Fib Line Extension (Bars)", minval=0, maxval=500, group=groupFib)
showFibLabels      = input.bool(true, "Show Fib Level Labels", group=groupFib)
fibLabelPosition   = input.string("Right", "Fib Label Position", options=["Left", "Right"], group=groupFib)
fibLabelBgTransp   = input.int(92, "Fib Label Background Transparency", minval=0, maxval=100, group=groupFib)
fibLineWidth       = input.int(1, "Fib Line Width", minval=1, maxval=4, group=groupFib)
fibTransparency    = input.int(70, "Fib Line Transparency", minval=0, maxval=100, group=groupFib)
fib236Color        = input.color(#F23645, "Fib 0.236 Color", group=groupFib)
fib382Color        = input.color(#FFEB3B, "Fib 0.382 Color", group=groupFib)
fib500Color        = input.color(#4CAF50, "Fib 0.500 Color", group=groupFib)
fib618Color        = input.color(#00BCD4, "Fib 0.618 Color", group=groupFib)
fib786Color        = input.color(#2962FF, "Fib 0.786 Color", group=groupFib)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DELTA DIVERGENCE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupDelta = "Delta Divergence"
enableDeltaDivergence = input.bool(true, "Enable Delta Divergence", group=groupDelta)
deltaThreshold        = input.float(2.0, "Delta Divergence Ratio", minval=1.5, maxval=5.0, step=0.5, group=groupDelta)
deltaDivergenceBonus  = input.int(15, "Delta Divergence Bonus", minval=0, maxval=30, group=groupDelta)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSIONS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupSess = "Session Analysis"
enableSessionWeighting = input.bool(true, "Enable Session-Based Weighting", group=groupSess)
showSessionBackgrounds = input.bool(false, "Show Session Backgrounds", group=groupSess)
sessionBgTransparency  = input.int(95, "Session Background Transparency", minval=80, maxval=100, group=groupSess)
asianSessionTime       = input.session("1700-0200", "Asian Session (EST)", group=groupSess)
londonSessionTime      = input.session("0200-0700", "London Session (EST)", group=groupSess)
nySessionTime          = input.session("0700-1600", "New York Session (EST)", group=groupSess)
asianMultiplier        = input.float(0.8, "Asian Session Multiplier", minval=0.1, maxval=2.0, step=0.1, group=groupSess)
londonMultiplier       = input.float(1.3, "London Session Multiplier", minval=0.1, maxval=2.0, step=0.1, group=groupSess)
nyMultiplier           = input.float(1.2, "NY Session Multiplier", minval=0.1, maxval=2.0, step=0.1, group=groupSess)
overlapMultiplier      = input.float(1.5, "Overlap Period Multiplier", minval=0.1, maxval=2.0, step=0.1, group=groupSess)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INFO TABLE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
groupTable = "Information Table"
showInfoTable      = input.bool(true, "Show Info Table", group=groupTable)
tablePosition      = input.string("Top Middle", "Table Position", options=["Top Left", "Top Middle", "Top Right", "Bottom Left", "Bottom Middle", "Bottom Right", "Middle Left", "Middle Right"], group=groupTable)
tableLayout        = input.string("Horizontal", "Table Layout", options=["Vertical", "Horizontal"], group=groupTable)
tableSize          = input.string("Small", "Table Size", options=["Tiny", "Small", "Normal", "Large"], group=groupTable)
tableTransparency  = input.int(10, "Table Background Transparency", minval=0, maxval=100, group=groupTable)
showZoneCount      = input.bool(true, "Show Zone Count", group=groupTable)
showMarketPosition = input.bool(true, "Show Market Position", group=groupTable)
showNearestLevels  = input.bool(true, "Show Nearest S/R Levels", group=groupTable)
showTradeBias      = input.bool(true, "Show Trade Bias", group=groupTable)
showCurrentSession = input.bool(true, "Show Active Session", group=groupTable)
showRiskLevel      = input.bool(true, "Show Risk Assessment", group=groupTable)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATIONS - TIME, VOLUME, ATR, INDICATORS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
timeMinutes = timeframe.in_seconds(timeframe.period) / 60

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SAFE LOWER-TF RESOLUTION (prevents invalid strings like "2016" on Weekly)
// NOTE: request.security_lower_tf() does NOT like arbitrary minute values.
// We SNAP to common supported intraday frames and CLAMP to max 720m (12H).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var int[] _ltfFrames = array.from(1, 2, 3, 5, 10, 15, 30, 45, 60, 120, 240, 360, 480, 720)

f_snapLTFMinutes(int mins) =>
    // clamp first
    int first = array.get(_ltfFrames, 0)
    int last  = array.get(_ltfFrames, array.size(_ltfFrames) - 1)
    if mins <= first
        first
    else if mins >= last
        last
    else
        int   best     = first
        float bestDiff = math.abs(mins - best)
        for i = 1 to array.size(_ltfFrames) - 1
            int f = array.get(_ltfFrames, i)
            float d = math.abs(mins - f)
            if d < bestDiff
                best := f
                bestDiff := d
        best

f_tfStrFromMinutes(int mins) =>
    // intraday minutes only (we clamp to <= 720 above)
    mins == 60 ? "60" : str.tostring(mins)

// â”€â”€â”€ LTF for volume delta / institutional classification
ltfMinutesRaw = int(math.max(1, math.ceil(timeMinutes / ltfDivider)))
ltfMinutes    = f_snapLTFMinutes(ltfMinutesRaw)
ltfString     = f_tfStrFromMinutes(ltfMinutes)

// â”€â”€â”€ LTF for volume profile bins inside zones
ltfProfileMinutesRaw = int(math.max(1, math.ceil(timeMinutes / ltfProfileDivider)))
ltfProfileMinutes    = f_snapLTFMinutes(ltfProfileMinutesRaw)
ltfProfileString     = f_tfStrFromMinutes(ltfProfileMinutes)

var float upVolume   = 0.0
var float downVolume = 0.0

if useLTFVolume
    ltfBullVol = request.security_lower_tf(syminfo.tickerid, ltfString, (close > open ? volume : 0.0))
    ltfBearVol = request.security_lower_tf(syminfo.tickerid, ltfString, (close < open ? volume : 0.0))

    bSz = array.size(ltfBullVol)
    sSz = array.size(ltfBearVol)

    bSum = 0.0
    sSum = 0.0

    if bSz > 0
        for k = 0 to bSz - 1
            bSum += array.get(ltfBullVol, k)

    if sSz > 0
        for k = 0 to sSz - 1
            sSum += array.get(ltfBearVol, k)

    upVolume   := bSum
    downVolume := sSum
else
    priceChange = close - open
    upVolume   := priceChange >= 0 ? volume : volume * 0.3
    downVolume := priceChange < 0  ? volume : volume * 0.3

atrMultiplier = isLowerTimeframe ? 0.15 : 0.3  // More sensitive on LTF
atr150 = ta.atr(150) * atrMultiplier
atr50  = ta.atr(50)
atr14  = ta.atr(14)

rsiValue = ta.rsi(close, rsiPeriod)
obvValue = ta.cum(math.sign(ta.change(close)) * volume)
[adxValue, diPlus, diMinus] = ta.dmi(adxPeriod, adxPeriod)

avgVolume  = ta.sma(volume, 50)
avgGapSize = atr50

bullFVG = showBull and not na(high[2]) and low > high[2] and (low - high[2]) > atr150
bearFVG = showBear and not na(low[2])  and high < low[2]  and (low[2] - high) > atr150
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIVOTS - FIXED VERSION
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float pivotSrc1 = pivotSource == "High/Low" ? high : math.max(close, open)
float pivotSrc2 = pivotSource == "High/Low" ? low  : math.min(close, open)
float pivotHigh = ta.pivothigh(pivotSrc1, pivotPeriod, pivotPeriod)
float pivotLow  = ta.pivotlow(pivotSrc2, pivotPeriod, pivotPeriod)
var float[] storedPivotHighs = array.new_float()
var float[] storedPivotLows  = array.new_float()
var int[] pivotHighBars = array.new_int()
var int[] pivotLowBars = array.new_int()
if not na(pivotHigh) and enablePivots
    array.unshift(storedPivotHighs, pivotHigh)
    array.unshift(pivotHighBars, bar_index - pivotPeriod)
    if array.size(storedPivotHighs) > pivotLookback
        array.pop(storedPivotHighs)
        array.pop(pivotHighBars)
if not na(pivotLow) and enablePivots
    array.unshift(storedPivotLows, pivotLow)
    array.unshift(pivotLowBars, bar_index - pivotPeriod)
    if array.size(storedPivotLows) > pivotLookback
        array.pop(storedPivotLows)
        array.pop(pivotLowBars)
// FIX #1: Plot pivots at correct historical bar location with offset
if showPivotMarkers and not na(pivotHigh)
    label.new(
         bar_index - pivotPeriod, pivotHigh, "H",
         style = label.style_label_down,
         yloc  = yloc.abovebar,
         color = na,
         textcolor = color.new(bearColor, 0),
         size  = size.tiny)

if showPivotMarkers and not na(pivotLow)
    label.new(
         bar_index - pivotPeriod, pivotLow, "L",
         style = label.style_label_up,
         yloc  = yloc.belowbar,
         color = na,
         textcolor = color.new(bullColor, 0),
         size  = size.tiny)
var bool mtfBull1_cached = false
var bool mtfBear1_cached = false
var bool mtfBull2_cached = false
var bool mtfBear2_cached = false
if enableMTFConfluence
    mtfBull1_cached := request.security(syminfo.tickerid, mtfTimeframe1, bullFVG)
    mtfBear1_cached := request.security(syminfo.tickerid, mtfTimeframe1, bearFVG)
    mtfBull2_cached := request.security(syminfo.tickerid, mtfTimeframe2, bullFVG)
    mtfBear2_cached := request.security(syminfo.tickerid, mtfTimeframe2, bearFVG)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI LEVELS - FIXED RETRACEMENT LOGIC
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var float fibHigh = na
var float fibLow  = na
var int   fibHighBar = 0
var int   fibLowBar = 0
if enableFibDetection
    lookbackHigh = ta.highest(high, fibLookback)
    lookbackLow  = ta.lowest(low, fibLookback)
    if not na(lookbackHigh) and not na(lookbackLow)
        fibHigh := lookbackHigh
        fibLow  := lookbackLow
        for i = 0 to fibLookback - 1
            if high[i] == lookbackHigh
                fibHighBar := bar_index - i
            if low[i] == lookbackLow
                fibLowBar := bar_index - i
fib236 = enableFibDetection and not na(fibHigh) and not na(fibLow) ? fibHigh - (fibHigh - fibLow) * 0.236 : na
fib382 = enableFibDetection and not na(fibHigh) and not na(fibLow) ? fibHigh - (fibHigh - fibLow) * 0.382 : na
fib500 = enableFibDetection and not na(fibHigh) and not na(fibLow) ? fibHigh - (fibHigh - fibLow) * 0.500 : na
fib618 = enableFibDetection and not na(fibHigh) and not na(fibLow) ? fibHigh - (fibHigh - fibLow) * 0.618 : na
fib786 = enableFibDetection and not na(fibHigh) and not na(fibLow) ? fibHigh - (fibHigh - fibLow) * 0.786 : na
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA STRUCTURES
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var box[]    gapBoxes           = array.new_box()
var int[]    gapTypes           = array.new_int()
var line[]   gapLines           = array.new_line()
var float[]  bullVolData        = array.new_float()
var float[]  bearVolData        = array.new_float()
var float[]  totalVolData       = array.new_float()
var float[]  gapSizeData        = array.new_float()
var int[]    strengthScores     = array.new_int()
var label[]  strengthLabels     = array.new_label()
var float[]  labelYPositions    = array.new_float()
var int[]    pivotConfluenceArr = array.new_int()
var int[]    historicalTouches  = array.new_int()
var int[]    mtfConfluenceArr   = array.new_int()
var bool[]   isBroken           = array.new_bool()
var int[]    brokenAge          = array.new_int()
var int[]    breakConfirmCount  = array.new_int()
var bool[]   roleReversed       = array.new_bool()
var int[]    reversalTouches    = array.new_int()
var bool[]   gapInsideFlags     = array.new_bool()
var bool[]   isInstitutionalArr = array.new_bool()
var bool[]   hasGraduated       = array.new_bool()
var int[]    consolidatedCount  = array.new_int()
var bool[]   isConsolidated     = array.new_bool()
var float[]  zoneSuccessRate    = array.new_float()
var int[]    zoneTouchCount     = array.new_int()
var float[]  adaptiveWeight     = array.new_float()
var int[]    fibConfluenceArr   = array.new_int()
var string[] fibLevelsString    = array.new_string()
var bool[]   hasDeltaDivergence = array.new_bool()
var int[]    clusterCount       = array.new_int()
var int[]    lastTooltipUpdate  = array.new_int()
var int[]    originalDirection  = array.new_int()
var int[]    zoneAge            = array.new_int()
var bool[]   isHidden           = array.new_bool()
var bool[]   wasReactivated     = array.new_bool()
var bool[]   hasDivergence      = array.new_bool()
var string[] divergenceType     = array.new_string()
var int[]    divergenceStrength = array.new_int()
var box[]    bullvolBars        = array.new_box()
var box[]    bearvolBars        = array.new_box()
var bool[]   justMerged         = array.new_bool()
var int[]    successfulTouches  = array.new_int()
var int[]    failedTouches      = array.new_int()
var float[]  mlConfidence       = array.new_float()
var int[]    lastTouchBar       = array.new_int()
var string[] storedTooltips     = array.new_string()
var line[]   fib236Lines        = array.new_line()
var line[]   fib382Lines        = array.new_line()
var line[]   fib500Lines        = array.new_line()
var line[]   fib618Lines        = array.new_line()
var line[]   fib786Lines        = array.new_line()
var label[]  fib236Labels       = array.new_label()
var label[]  fib382Labels       = array.new_label()
var label[]  fib500Labels       = array.new_label()
var label[]  fib618Labels       = array.new_label()
var label[]  fib786Labels       = array.new_label()
var int      lastFibBar         = 0
type VolumeProfileData
    array<float> volumeProfile
    array<box> profileBoxes
    line pocLine
    label volumeSumLabel
var VolumeProfileData[] volumeProfileData = array.new<VolumeProfileData>()
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
textSize(s) =>
    switch s
        "Auto"   => size.auto
        "Tiny"   => size.tiny
        "Small"  => size.small
        "Normal" => size.normal
        "Medium" => size.normal
        "Large"  => size.large
        "Huge"   => size.huge
labelSize(s) =>
    switch s
        "Tiny"   => size.tiny
        "Small"  => size.small
        "Normal" => size.normal
        "Large"  => size.large
        "Huge"   => size.huge
tableTextSize(s) =>
    switch s
        "Tiny"   => size.tiny
        "Small"  => size.small
        "Normal" => size.normal
        "Large"  => size.large
getTablePosition(pos) =>
    switch pos
        "Top Left"      => position.top_left
        "Top Middle"    => position.top_center
        "Top Right"     => position.top_right
        "Bottom Left"   => position.bottom_left
        "Bottom Middle" => position.bottom_center
        "Bottom Right"  => position.bottom_right
        "Middle Left"   => position.middle_left
        "Middle Right"  => position.middle_right
        => position.bottom_center
formatVolumeText(float bullVol, float bearVol, float totalVol) =>
    txt = ""
    if showVolumeText
        switch volumeDisplayMode
            "Bull Numbers"       => txt := "â–²: " + str.tostring(bullVol, format.volume)
            "Bear Numbers"       => txt := "â–¼: " + str.tostring(bearVol, format.volume)
            "Both Numbers"       => txt := "â–²: " + str.tostring(bullVol, format.volume) + " | â–¼: " + str.tostring(bearVol, format.volume)
            "Bull Percentage"    => txt := "â–²: " + str.tostring(totalVol > 0 ? (bullVol / totalVol) * 100 : 0, "#.#") + "%"
            "Bear Percentage"    => txt := "â–¼: " + str.tostring(totalVol > 0 ? (bearVol / totalVol) * 100 : 0, "#.#") + "%"
            "Both Percentages"   => txt := "â–²: " + str.tostring(totalVol > 0 ? (bullVol / totalVol) * 100 : 0, "#.#") + "% | â–¼: " + str.tostring(totalVol > 0 ? (bearVol / totalVol) * 100 : 0, "#.#") + "%"
            "Numbers and Percentages" => txt := "â–²: " + str.tostring(bullVol, format.volume) + " (" + str.tostring(totalVol > 0 ? (bullVol / totalVol) * 100 : 0, "#.#") + "%) | â–¼: " + str.tostring(bearVol, format.volume) + " (" + str.tostring(totalVol > 0 ? (bearVol / totalVol) * 100 : 0, "#.#") + "%)"
    txt
isInSession(sess) =>
    not na(time(timeframe.period, sess))
getCurrentSession() =>
    inAsian  = isInSession(asianSessionTime)
    inLondon = isInSession(londonSessionTime)
    inNY     = isInSession(nySessionTime)
    _s = "NONE"
    if (inAsian and inLondon) or (inLondon and inNY)
        _s := "OVERLAP"
    else if inNY
        _s := "NY"
    else if inLondon
        _s := "LONDON"
    else if inAsian
        _s := "ASIAN"
    _s
getSessionMultiplier(sess) =>
    mult = 1.0
    if enableSessionWeighting
        if sess == "OVERLAP"
            mult := overlapMultiplier
        else if sess == "NY"
            mult := nyMultiplier
        else if sess == "LONDON"
            mult := londonMultiplier
        else if sess == "ASIAN"
            mult := asianMultiplier
        else
            mult := 1.0
    mult
detectOrderBlock(float zoneTop, float zoneBottom) =>
    hasOB = false
    if enableOrderBlocks
        for i = 1 to obLookback
            if i < bar_index
                // Bearish engulfing (as in your original logic)
                bearEngulf =
                     close[i] < open[i] and           // bar i is bearish
                     close[i-1] > open[i-1] and       // bar i-1 is bullish
                     volume[i] > avgVolume * obVolumeThreshold and
                     (close[i-1] - open[i-1]) > (open[i] - close[i]) * obMinEngulfing

                // NEW: Bullish engulfing (mirror condition)
                bullEngulf =
                     close[i] > open[i] and           // bar i is bullish
                     close[i-1] < open[i-1] and       // bar i-1 is bearish
                     volume[i] > avgVolume * obVolumeThreshold and
                     (open[i-1] - close[i-1]) > (close[i] - open[i]) * obMinEngulfing

                if bearEngulf or bullEngulf
                    obTop    = high[i]
                    obBottom = low[i]
                    // OB candle overlaps this zone
                    if obTop >= zoneBottom and obBottom <= zoneTop
                        hasOB := true
                        break
    hasOB
detectImbalance() =>
    hasImb = false
    if enableImbalanceZones
        buyVolRatio  = upVolume / math.max(downVolume, 1)
        sellVolRatio = downVolume / math.max(upVolume, 1)
        if (buyVolRatio > imbalanceRatio or sellVolRatio > imbalanceRatio) and volume > avgVolume * imbalanceMinVolume
            hasImb := true
    hasImb
detectDeltaDivergence(float bullVol, float bearVol, bool isBullish) =>
    hasDiv = false
    if enableDeltaDivergence
        volRatio = bullVol / math.max(bearVol, 1)
        hasDiv := isBullish ? (volRatio < 1.0 / deltaThreshold) : (volRatio > deltaThreshold)
    hasDiv
checkFibConfluence(float top, float bottom) =>
    fibConf = 0
    fibLevelsStr = ""
    if enableFibDetection
        tolerance = (top - bottom) * fibTolerance / 100.0
        levelNames  = array.from("0.236","0.382","0.500","0.618","0.786")
        levelValues = array.from(fib236, fib382, fib500, fib618, fib786)
        for i = 0 to array.size(levelValues) - 1
            lvl = array.get(levelValues, i)
            if not na(lvl) and lvl >= bottom - tolerance and lvl <= top + tolerance
                fibConf += 1
                fibLevelsStr += (fibLevelsStr == "" ? "" : ", ") + array.get(levelNames, i)
    [fibConf, fibLevelsStr]
getVWAPBonus(float zoneCenter) =>
    bonus = 0
    if enableVWAPAnalysis
        vwapValue = ta.vwap(vwapSource)
        deviation = ta.stdev(vwapSource, 20)
        distancePct = math.abs(zoneCenter - vwapValue) / zoneCenter * 100
        if distancePct < vwapProximityThreshold
            bonus := vwapProximityBonus
        else if math.abs(zoneCenter - vwapValue) > deviation * 2
            bonus := vwapExtremesBonus
    bonus
calculateMagneticPull(float zoneTop, float zoneBottom) =>
    pull = 0.0
    if enableMagneticLevels
        magneticRangePrice = atr14 * magneticRange
        distanceToZone = close > zoneTop ? (close - zoneTop) : close < zoneBottom ? (zoneBottom - close) : 0.0
        if distanceToZone > 0 and distanceToZone < magneticRangePrice
            pull := math.pow(1 - (distanceToZone / magneticRangePrice), magneticDecay) * magneticStrength * 10.0
    pull
getAdaptiveWeight(int zoneIndex) =>
    enableAdaptiveOptimization and zoneIndex < array.size(adaptiveWeight) ? array.get(adaptiveWeight, zoneIndex) : 1.0
checkPivotConfluence(float top, float bottom) =>
    cnt = 0
    tol = atr14 * pivotToleranceATR
    if enablePivots
        highCount = array.size(storedPivotHighs)
        if highCount > 0
            for i = 0 to math.min(highCount - 1, 50)
                ph = array.get(storedPivotHighs, i)
                if ph <= top + tol and ph >= bottom - tol
                    cnt += 1

        lowCount = array.size(storedPivotLows)
        if lowCount > 0
            for i = 0 to math.min(lowCount - 1, 50)
                pl = array.get(storedPivotLows, i)
                if pl <= top + tol and pl >= bottom - tol
                    cnt += 1
    cnt
countHistoricalTouches(float top, float bottom) =>
    touches = 0
    lookback = math.min(300, bar_index)
    tolerance = (top - bottom) * 0.2
    for i = 1 to lookback
        touchedMeaningfully = (close[i] <= top and close[i] >= bottom) or (high[i] <= top + tolerance and high[i] >= top and low[i] < bottom) or (low[i]  >= bottom - tolerance and low[i] <= bottom and high[i] > top)
        if touchedMeaningfully
            touches += 1
    touches
checkMTFConfluence(float top, float bottom) =>
    cnt = 0
    if enableMTFConfluence
        if mtfBull1_cached or mtfBear1_cached
            cnt += 1
        if mtfBull2_cached or mtfBear2_cached
            cnt += 1
    cnt
countOverlappingZones(float top, float bottom, int currentIndex) =>
    c = 0
    if enableZoneClustering and array.size(gapBoxes) > 0
        for i = 0 to array.size(gapBoxes) - 1
            if i != currentIndex
                bx = array.get(gapBoxes, i)
                zTop = box.get_top(bx)
                zBot = box.get_bottom(bx)
                overlaps = not (top <= zBot or bottom >= zTop)
                if overlaps
                    c += 1
    c
scoreToStars(float score) =>
    _r = "â˜…"
    if score >= star5Threshold
        _r := "â˜…â˜…â˜…â˜…â˜…"
    else if score >= star4Threshold
        _r := "â˜…â˜…â˜…â˜…"
    else if score >= star3Threshold
        _r := "â˜…â˜…â˜…"
    else if score >= star2Threshold
        _r := "â˜…â˜…"
    else
        _r := "â˜…"
    _r
getStarBgColor(float score, color baseColor) =>
    _c = color.new(baseColor, 100)
    if not showLabelBackground
        _c := color.new(baseColor, 100)
    else if score >= star5Threshold
        _c := color.new(baseColor, labelBgTransparency)
    else if score >= star4Threshold
        _c := color.new(baseColor, math.max(30, labelBgTransparency))
    else if score >= star3Threshold
        _c := color.new(baseColor, math.max(60, labelBgTransparency))
    else if score >= star2Threshold
        _c := color.new(baseColor, math.max(80, labelBgTransparency))
    else
        _c := color.new(baseColor, math.max(90, labelBgTransparency))
    _c
getStarCount(float score) =>
    _n = 1
    if score >= star5Threshold
        _n := 5
    else if score >= star4Threshold
        _n := 4
    else if score >= star3Threshold
        _n := 3
    else if score >= star2Threshold
        _n := 2
    else
        _n := 1
    _n
passesFilters(float score, float totalVol, float avgVol, bool wasInstitutional, bool isCurrentlyInstitutional) =>
    ok = true
    if autoHideWeakZones or enableMinStrength
        ok := getStarCount(score) >= minStarRating
    if ok and showOnlyInstitutional
        ok := dynamicInstitutional ? isCurrentlyInstitutional : wasInstitutional
    ok
isTooFar(float top, float bottom) =>
    mid = (top + bottom) / 2.0
    distance = math.abs(close - mid)
    _res = false
    if distanceMode == "ATR"
        _res := distance > (atr14 * distanceFilterATR)
    else
        _res := (math.abs(close - mid) / close * 100) > distanceFilterPct
    _res
checkZonePosition(float zoneTop, float zoneBottom, int zoneType) =>
    buffer = close * (positionBuffer / 100.0)
    _p = 0
    if zoneType == 1
        _p := close > zoneTop + buffer ? 1 : close < zoneBottom - buffer ? -1 : 0
    else
        _p := close < zoneBottom - buffer ? 1 : close > zoneTop + buffer ? -1 : 0
    _p
shouldHideZone(int position, string mode) =>
    _hide = false
    if enableSmartPositioning
        if mode == "Hide Wrong Side"
            _hide := position == -1
        else
            _hide := false
    else
        _hide := false
    _hide
getEffectiveRole(int originalType, int position, string mode) =>
    _role = originalType
    if enableSmartPositioning and mode == "Auto Role Flip"
        _role := position == -1 ? originalType * -1 : originalType
    _role
getFVGType(float totalVol, float avgVol) =>
    totalVol >= avgVol * volMultiplier ? "INSTITUTIONAL" : "RETAIL"
calcDynamicTransp(float totalVol, float avgVol) =>
    _t = boxTransp
    if useVolumeDynamics
        _ratio = totalVol / math.max(avgVol, 1)
        _x = math.min(math.max((_ratio - 0.5) / 2.5, 0), 1)
        _t := int(volTranspMax - _x * (volTranspMax - volTranspMin))
    _t
calculateMLConfidence(int successTouch, int failTouch, int totalTouch) =>
    confidence = 0.5
    if enableMLPredictions and totalTouch >= minSampleSize
        successRate = successTouch / math.max(totalTouch, 1)
        confidence := successRate
    confidence
// FIX #3: Corrected backtest reaction check with proper bar indexing
checkZoneReaction(float zoneTop, float zoneBottom, bool isBullZone, int touchBar) =>
    success = false
    failed = false
    if enableBacktesting and touchBar > 0
        barsS = bar_index - touchBar
        if barsS > 0 and barsS <= 50
            for j = 1 to math.min(barsS, 50)
                barIdx = barsS - j
                if barIdx >= 0
                    if isBullZone
                        moveUp = low[barIdx] - zoneTop
                        if moveUp >= successThresholdPips * syminfo.mintick
                            success := true
                            break
                        if close[barIdx] < zoneBottom - failureThresholdPips * syminfo.mintick
                            failed := true
                            break
                    else
                        moveDown = zoneBottom - high[barIdx]
                        if moveDown >= successThresholdPips * syminfo.mintick
                            success := true
                            break
                        if close[barIdx] > zoneTop + failureThresholdPips * syminfo.mintick
                            failed := true
                            break
    [success, failed]
adjustLabelPosition(float proposedY, int idx) =>
    adjustedY = proposedY
    if preventLabelOverlap and array.size(labelYPositions) > 0
        minDist = atr14 * (minLabelDistance / 100.0)
        collision = true
        attempts = 0
        while collision and attempts < 20
            collision := false
            for i = 0 to array.size(labelYPositions) - 1
                if i != idx
                    existingY = array.get(labelYPositions, i)
                    if math.abs(adjustedY - existingY) < minDist
                        collision := true
                        adjustedY := adjustedY + minDist
                        break
            attempts += 1
    adjustedY
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TOOLTIP BUILDER (COPY/PASTE)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
buildTooltip(
     float  score,
     string fvgType,
     float  totalVol,
     float  gapSize,
     bool   isBull,
     float  bullVol,
     float  bearVol,
     int    pivotConf,
     int    touches,
     bool   reversed,
     int    revTouches,
     int    mtfConf,
     bool   wasInstitutional,
     bool   isNowInstitutional,
     int    fibConf,
     string fibLevelsStr,
     bool   deltaDiverg,
     int    clusterCnt,
     int    consolidationCnt,
     bool   isConsolidatedZone,
     bool   wasMerged,
     int    successTouch,
     int    failTouch,
     float  mlConf,
     float  volDelta
 ) =>
    int    rounded   = int(math.round(score))
    string stars     = scoreToStars(rounded)
    float  bullPct   = totalVol > 0 ? (bullVol / totalVol) * 100.0 : 0.0
    float  bearPct   = totalVol > 0 ? (bearVol / totalVol) * 100.0 : 0.0
    bool   graduated = (not wasInstitutional) and isNowInstitutional

    bool  obHit  = detectOrderBlock(high, low)
    bool  imbHit = detectImbalance()
    float vwapB  = getVWAPBonus((high + low) / 2.0)
    float mpull  = calculateMagneticPull(high, low)

    int   totalTouches = successTouch + failTouch
    float winRate      = totalTouches > 0 ? (successTouch / totalTouches) * 100.0 : 0.0

    string t = ""
    t += "â•”â•â•â• STRENGTH ANALYSIS â•â•â•â•—\n"
    t += "Rating: " + stars + " (" + str.tostring(rounded) + "/100)\n"

    if enableMLPredictions and mlConf > 0.5
        t += "ğŸ¤– ML Confidence: " + str.tostring(mlConf * 100.0, "#.#") + "%\n"

    string sess = getCurrentSession()
    if sess != "NONE"
        t += "Session: " + sess + "\n"

    if showConsolidationInfo and isConsolidatedZone and consolidationCnt > 0
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "ğŸ”— CONSOLIDATED ZONE\n"
        t += str.tostring(consolidationCnt + 1) + " FVGs merged\n"

    if wasMerged and showMergeAnimation
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "ğŸ”— RECENTLY MERGED\n"

    if graduated
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "ğŸ“ˆ UPGRADED TO INSTITUTIONAL\n"

    if reversed
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "âŸ³ ROLE REVERSED\n"
        t += (isBull ? "Was support â†’ now resistance\n" : "Was resistance â†’ now support\n")
        t += "Confirmed touches: " + str.tostring(revTouches) + "x\n"

    t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
    t += "Type: " + fvgType + "  Gap: " + str.tostring(gapSize, format.mintick) + "\n"
    t += "Volume: " + str.tostring(totalVol, format.volume) + "\n"
    t += "Bull: " + str.tostring(bullPct, "#.#") + "%  Bear: " + str.tostring(bearPct, "#.#") + "%\n"

    if enableVolumeDelta
        t += "Volume Delta: " + str.tostring(volDelta, "#.##") + "\n"

    if enableBacktesting and totalTouches >= minTouchesForStats and showWinRate
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "ğŸ“Š BACKTEST STATS\n"
        t += "Win Rate: " + str.tostring(winRate, "#.#") + "% (" + str.tostring(successTouch) + "W/" + str.tostring(failTouch) + "L)\n"

    if mtfConf > 0
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "âš¡ MTF CONFLUENCE: " + str.tostring(mtfConf) + " TF(s)\n"

    if pivotConf > 0
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "ğŸ¯ PIVOT CONFLUENCE: " + str.tostring(pivotConf) + "\n"

    if touches > 0
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "â—† HISTORICAL: " + str.tostring(touches) + " touches\n"

    if fibConf > 0
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "ğŸ“ FIB CONFLUENCE: " + fibLevelsStr + "\n"

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âš  DELTA DIVERGENCE (ORDER-FLOW IMBALANCE)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if deltaDiverg
        float vr       = bullVol / math.max(bearVol, 1.0)
        string domSide = vr >= 1.0 ? "BUYING dominant" : "SELLING dominant"
        string ruleTxt = isBull ? ("Support wants vr â‰¥ " + str.tostring(1.0 / deltaThreshold, "#.##")) : ("Resistance wants vr â‰¤ " + str.tostring(deltaThreshold, "#.##"))

        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "âš  DELTA DIVERGENCE (ORDER-FLOW IMBALANCE)\n"
        t += "Dominance: " + domSide + "\n"
        t += "Bull%: " + str.tostring(bullPct, "#.#") + " | Bear%: " + str.tostring(bearPct, "#.#") + "\n"
        t += "Bull/Bear vol ratio: " + str.tostring(vr, "#.##") + " (" + ruleTxt + ")\n"
        t += "Volume Delta (normalized): " + str.tostring(volDelta, "#.##") + "\n"
        t += "Interpretation: opposite-side aggression inside the zone â†’ rejection/absorption risk elevated.\n"

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ğŸ”¥ CLUSTER / SUPER ZONE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if clusterCnt >= clusterThreshold
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "ğŸ”¥ SUPER ZONE (CLUSTER)\n"
        t += "Overlaps: " + str.tostring(clusterCnt) + " other zone(s) (total stacked: " + str.tostring(clusterCnt + 1) + ")\n"

    t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
    t += "Enhanced: OB:" + (obHit ? "âœ“" : "Ã—") + "  Imb:" + (imbHit ? "âœ“" : "Ã—") + "  VWAP:" + (vwapB > 0 ? "âœ“" : "Ã—") + "\n"
    t += "Magnetic: " + str.tostring(mpull, "#.##") + "\n"

    t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
    t += (isBull ? "Support" : "Resistance") + " Strength: "
    if score >= 85
        t += "VERY STRONG\n"
    else if score >= 70
        t += "STRONG\n"
    else if score >= 55
        t += "MODERATE\n"
    else if score >= 40
        t += "WEAK\n"
    else
        t += "VERY WEAK\n"

    if fvgType == "INSTITUTIONAL"
        t += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
        t += "âš  Smart Money Zone\n"

    t += "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    t
calculateVolumeProfile(float zoneTop, float zoneBottom) =>
    vp = array.new_float(volumeProfileBins, 0.0)
    if useLTFVolumeProfile
        cls_arr = request.security_lower_tf(syminfo.tickerid, ltfProfileString, close)
        vol_arr = request.security_lower_tf(syminfo.tickerid, ltfProfileString, volume)
        if array.size(cls_arr) > 0
            binSize = (zoneTop - zoneBottom) / volumeProfileBins
            for k = 0 to volumeProfileBins - 1
                lower = zoneBottom + binSize * k
                mid   = lower + binSize / 2
                for i = 0 to array.size(cls_arr) - 1
                    c = array.get(cls_arr, i)
                    v = array.get(vol_arr, i)
                    if math.abs(c - mid) <= binSize
                        array.set(vp, k, array.get(vp, k) + v)
    vp
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIBONACCI LEVELS - Display with FIXED retracement logic
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fibChanged = false
if enableFibDetection and not na(fibHigh) and not na(fibLow)
    fibChanged := fibHigh != fibHigh[1] or fibLow != fibLow[1]
    if showOnlyCurrentFib and fibChanged and showFibLevels
        if array.size(fib236Lines) > 0
            for ln in fib236Lines
                line.delete(ln)
            array.clear(fib236Lines)
        if array.size(fib382Lines) > 0
            for ln in fib382Lines
                line.delete(ln)
            array.clear(fib382Lines)
        if array.size(fib500Lines) > 0
            for ln in fib500Lines
                line.delete(ln)
            array.clear(fib500Lines)
        if array.size(fib618Lines) > 0
            for ln in fib618Lines
                line.delete(ln)
            array.clear(fib618Lines)
        if array.size(fib786Lines) > 0
            for ln in fib786Lines
                line.delete(ln)
            array.clear(fib786Lines)
        if array.size(fib236Labels) > 0
            for lbl in fib236Labels
                label.delete(lbl)
            array.clear(fib236Labels)
        if array.size(fib382Labels) > 0
            for lbl in fib382Labels
                label.delete(lbl)
            array.clear(fib382Labels)
        if array.size(fib500Labels) > 0
            for lbl in fib500Labels
                label.delete(lbl)
            array.clear(fib500Labels)
        if array.size(fib618Labels) > 0
            for lbl in fib618Labels
                label.delete(lbl)
            array.clear(fib618Labels)
        if array.size(fib786Labels) > 0
            for lbl in fib786Labels
                label.delete(lbl)
            array.clear(fib786Labels)
if showFibLevels and enableFibDetection and not na(fib236)
    rightBar = bar_index + fibLineExtension
    leftBar = fibHighBar
    shouldCreate = showOnlyCurrentFib ? (bar_index != lastFibBar and fibChanged) : true
    if shouldCreate
        labelX = fibLabelPosition == "Right" ? rightBar : leftBar
        labelStyle = fibLabelPosition == "Right" ? label.style_label_left : label.style_label_right
        if not na(fib236)
            ln236 = line.new(leftBar, fib236, rightBar, fib236, color=color.new(fib236Color, fibTransparency), width=fibLineWidth)
            array.push(fib236Lines, ln236)
            if showFibLabels
                lbl236 = label.new(labelX, fib236, "0.236", style=labelStyle, color=color.new(fib236Color, fibLabelBgTransp), textcolor=color.new(color.white, 0), size=size.tiny)
                array.push(fib236Labels, lbl236)
        if not na(fib382)
            ln382 = line.new(leftBar, fib382, rightBar, fib382, color=color.new(fib382Color, fibTransparency), width=fibLineWidth)
            array.push(fib382Lines, ln382)
            if showFibLabels
                lbl382 = label.new(labelX, fib382, "0.382", style=labelStyle, color=color.new(fib382Color, fibLabelBgTransp), textcolor=color.new(color.white, 0), size=size.tiny)
                array.push(fib382Labels, lbl382)
        if not na(fib500)
            ln500 = line.new(leftBar, fib500, rightBar, fib500, color=color.new(fib500Color, fibTransparency), width=fibLineWidth)
            array.push(fib500Lines, ln500)
            if showFibLabels
                lbl500 = label.new(labelX, fib500, "0.500", style=labelStyle, color=color.new(fib500Color, fibLabelBgTransp), textcolor=color.new(color.white, 0), size=size.tiny)
                array.push(fib500Labels, lbl500)
        if not na(fib618)
            ln618 = line.new(leftBar, fib618, rightBar, fib618, color=color.new(fib618Color, fibTransparency), width=fibLineWidth)
            array.push(fib618Lines, ln618)
            if showFibLabels
                lbl618 = label.new(labelX, fib618, "0.618", style=labelStyle, color=color.new(fib618Color, fibLabelBgTransp), textcolor=color.new(color.white, 0), size=size.tiny)
                array.push(fib618Labels, lbl618)
        if not na(fib786)
            ln786 = line.new(leftBar, fib786, rightBar, fib786, color=color.new(fib786Color, fibTransparency), width=fibLineWidth)
            array.push(fib786Lines, ln786)
            if showFibLabels
                lbl786 = label.new(labelX, fib786, "0.786", style=labelStyle, color=color.new(fib786Color, fibLabelBgTransp), textcolor=color.new(color.white, 0), size=size.tiny)
                array.push(fib786Labels, lbl786)
        lastFibBar := bar_index
    else
        leftBarUpdate = fibHighBar
        if array.size(fib236Lines) > 0
            line.set_x2(array.get(fib236Lines, array.size(fib236Lines) - 1), rightBar)
            line.set_x1(array.get(fib236Lines, array.size(fib236Lines) - 1), leftBarUpdate)
            if showFibLabels and array.size(fib236Labels) > 0
                labelX = fibLabelPosition == "Right" ? rightBar : leftBarUpdate
                label.set_x(array.get(fib236Labels, array.size(fib236Labels) - 1), labelX)
        if array.size(fib382Lines) > 0
            line.set_x2(array.get(fib382Lines, array.size(fib382Lines) - 1), rightBar)
            line.set_x1(array.get(fib382Lines, array.size(fib382Lines) - 1), leftBarUpdate)
            if showFibLabels and array.size(fib382Labels) > 0
                labelX = fibLabelPosition == "Right" ? rightBar : leftBarUpdate
                label.set_x(array.get(fib382Labels, array.size(fib382Labels) - 1), labelX)
        if array.size(fib500Lines) > 0
            line.set_x2(array.get(fib500Lines, array.size(fib500Lines) - 1), rightBar)
            line.set_x1(array.get(fib500Lines, array.size(fib500Lines) - 1), leftBarUpdate)
            if showFibLabels and array.size(fib500Labels) > 0
                labelX = fibLabelPosition == "Right" ? rightBar : leftBarUpdate
                label.set_x(array.get(fib500Labels, array.size(fib500Labels) - 1), labelX)
        if array.size(fib618Lines) > 0
            line.set_x2(array.get(fib618Lines, array.size(fib618Lines) - 1), rightBar)
            line.set_x1(array.get(fib618Lines, array.size(fib618Lines) - 1), leftBarUpdate)
            if showFibLabels and array.size(fib618Labels) > 0
                labelX = fibLabelPosition == "Right" ? rightBar : leftBarUpdate
                label.set_x(array.get(fib618Labels, array.size(fib618Labels) - 1), labelX)
        if array.size(fib786Lines) > 0
            line.set_x2(array.get(fib786Lines, array.size(fib786Lines) - 1), rightBar)
            line.set_x1(array.get(fib786Lines, array.size(fib786Lines) - 1), leftBarUpdate)
            if showFibLabels and array.size(fib786Labels) > 0
                labelX = fibLabelPosition == "Right" ? rightBar : leftBarUpdate
                label.set_x(array.get(fib786Labels, array.size(fib786Labels) - 1), labelX)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STRENGTH SCORE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
calcStrengthScore(float totalVol, float gapSize, float avgVol, float avgGap, int pivotConf, int touches, bool reversed, int mtfConf, float zoneTop, float zoneBottom, bool isBullish, int zoneIndex, int fibConf, bool deltaDiverg, int clusterCnt) =>
    volRatio = totalVol / math.max(avgVol, 1)
    volScore = math.min((volRatio - 0.5) / 2.5, 1.0) * (100 - gapSizeWeight)
    volScore := math.max(volScore, 0)
    gapRatio = gapSize / math.max(avgGap, 0.0001)
    gapScore = math.min((gapRatio - 0.3) / 2.0, 1.0) * gapSizeWeight
    gapScore := math.max(gapScore, 0)
    baseScore = volScore + gapScore
    pivotBonus        = pivotConf > 0 ? math.min(pivotConf * pivotConfluenceBonus / 3.0, pivotConfluenceBonus) : 0.0
    touchBonus        = math.min(touches * touchPointsEach, maxTouchPoints)
    reversalBonusVal  = reversed and enableRoleReversal ? roleReversalBonus : 0.0
    mtfBonus          = mtfConf > 0 ? mtfConf * mtfConfluenceBonus : 0.0
    fibBonus          = fibConf > 0 ? fibConfluenceBonus : 0.0
    deltaBonus        = deltaDiverg ? deltaDivergenceBonus : 0.0
    clusterBonusVal   = enableZoneClustering and clusterCnt >= clusterThreshold ? clusterBonus : 0.0
    sessionMult = 1.0
    if enableSessionWeighting
        sessionMult := getSessionMultiplier(getCurrentSession())
    obBonus       = detectOrderBlock(zoneTop, zoneBottom) ? obConfluenceBonus : 0.0
    imbBonus      = detectImbalance() ? imbalanceConfluenceBonus : 0.0
    vwapBonus     = getVWAPBonus((zoneTop + zoneBottom) / 2.0)
    magneticBonus = calculateMagneticPull(zoneTop, zoneBottom)
    adaptWeight = getAdaptiveWeight(zoneIndex)
    totalScore = (baseScore + pivotBonus + touchBonus + reversalBonusVal + mtfBonus + obBonus + imbBonus + vwapBonus + magneticBonus + fibBonus + deltaBonus + clusterBonusVal) * sessionMult * adaptWeight
    math.min(totalScore, 100.0)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Continue with merge/create logic...
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tPropBull = low
bPropBull = nz(high[2], low)
tPropBear = nz(low[2], high)
bPropBear = high
bullPivotConf = checkPivotConfluence(tPropBull, bPropBull)
bullTouches   = countHistoricalTouches(tPropBull, bPropBull)
bullMTFConf   = checkMTFConfluence(tPropBull, bPropBull)
[bullFibConf, bullFibLevels] = checkFibConfluence(tPropBull, bPropBull)
bearPivotConf = checkPivotConfluence(tPropBear, bPropBear)
bearTouches   = countHistoricalTouches(tPropBear, bPropBear)
bearMTFConf   = checkMTFConfluence(tPropBear, bPropBear)
[bearFibConf, bearFibLevels] = checkFibConfluence(tPropBear, bPropBear)
totalVolNow   = upVolume + math.abs(downVolume)
bullGapSize   = math.abs(tPropBull - bPropBull)
bearGapSize   = math.abs(tPropBear - bPropBear)
bullDeltaDiverg = detectDeltaDivergence(upVolume, math.abs(downVolume), true)
bearDeltaDiverg = detectDeltaDivergence(upVolume, math.abs(downVolume), false)
bullStrengthScore = calcStrengthScore(totalVolNow, bullGapSize, avgVolume, avgGapSize, bullPivotConf, bullTouches, false, bullMTFConf, tPropBull, bPropBull, true, array.size(gapBoxes), bullFibConf, bullDeltaDiverg, 0)
bearStrengthScore = calcStrengthScore(totalVolNow, bearGapSize, avgVolume, avgGapSize, bearPivotConf, bearTouches, false, bearMTFConf, tPropBear, bPropBear, false, array.size(gapBoxes), bearFibConf, bearDeltaDiverg, 0)
instNow     = totalVolNow >= avgVolume * volMultiplier
fvgTypeBull = getFVGType(totalVolNow, avgVolume)
fvgTypeBear = fvgTypeBull
volDeltaBull = (upVolume - math.abs(downVolume)) / math.max(totalVolNow, 1)
volDeltaBear = volDeltaBull
bullTooltip_CONST = buildTooltip(bullStrengthScore, fvgTypeBull, totalVolNow, bullGapSize, true, upVolume, math.abs(downVolume), bullPivotConf, bullTouches, false, 0, bullMTFConf, instNow, instNow, bullFibConf, bullFibLevels, bullDeltaDiverg, 0, 0, false, false, 0, 0, 0.5, volDeltaBull)
bearTooltip_CONST = buildTooltip(bearStrengthScore, fvgTypeBear, totalVolNow, bearGapSize, false, upVolume, math.abs(downVolume), bearPivotConf, bearTouches, false, 0, bearMTFConf, instNow, instNow, bearFibConf, bearFibLevels, bearDeltaDiverg, 0, 0, false, false, 0, 0, 0.5, volDeltaBear)
f_can_create(float tNew, float bNew, int idx, float newStrength, int dir) =>
    canCreate = true
    merged = false
    if (preventOverlap or enableMerging) and array.size(gapBoxes) > 0
        for j = array.size(gapBoxes) - 1 to 0
            if merged
                break
            bx = array.get(gapBoxes, j)
            existingBottom = box.get_bottom(bx)
            existingTop    = box.get_top(bx)
            existingLeft   = box.get_left(bx)
            existingType   = array.get(gapTypes, j)
            mergeTol = enableMerging ? syminfo.mintick * mergeTolerance + atr14 * (mergeAtrPercent / 100.0) : 0.0
            overlaps = enableMerging ? not (tNew < existingBottom - mergeTol or bNew > existingTop + mergeTol) : not (tNew <= existingBottom or bNew >= existingTop)
            if overlaps and existingType == dir
                if enableMerging
                    zoneIsBroken = array.get(isBroken, j)
                    ageExisting  = bar_index - existingLeft
                    ageOk        = mergeMaxAgeDiff == 0 or ageExisting <= mergeMaxAgeDiff
                    shouldMerge  = (not (mergeDontMergeBroken and zoneIsBroken)) and ageOk
                    if shouldMerge
                        if j < array.size(strengthLabels)
                            oldLabel = array.get(strengthLabels, j)
                            if not na(oldLabel)
                                label.delete(oldLabel)
                                array.set(strengthLabels, j, na)
                        if j < array.size(labelYPositions)
                            array.set(labelYPositions, j, na)
                        mergedTop    = math.max(tNew, existingTop)
                        mergedBottom = math.min(bNew, existingBottom)
                        mergedSize   = math.abs(mergedTop - mergedBottom)
                        box.set_top(bx, mergedTop)
                        box.set_bottom(bx, mergedBottom)
                        if j < array.size(gapSizeData)
                            array.set(gapSizeData, j, mergedSize)
                        if j < array.size(strengthScores)
                            oldStrength = array.get(strengthScores, j)
                            oldSize = math.abs(existingTop - existingBottom)
                            newSize = math.abs(tNew - bNew)
                            mergedStrength = mergeStrengthMethod == "Max" ? math.max(oldStrength, newStrength) : mergeStrengthMethod == "Weighted" ? ((oldStrength * oldSize) + (newStrength * newSize)) / math.max(mergedSize, 0.00001) : (oldStrength + newStrength) / 2.0
                            array.set(strengthScores, j, int(math.round(mergedStrength)))
                        if j < array.size(totalVolData)
                            oldVol = array.get(totalVolData, j)
                            newVol = upVolume + math.abs(downVolume)
                            mergedVol = mergeVolumeMethod == "Sum" ? oldVol + newVol : mergeVolumeMethod == "Max" ? math.max(oldVol, newVol) : (oldVol + newVol) / 2.0
                            array.set(totalVolData, j, mergedVol)
                        if j < array.size(bullVolData) and j < array.size(bearVolData)
                            oldBull = array.get(bullVolData, j)
                            oldBear = array.get(bearVolData, j)
                            array.set(bullVolData, j, mergeVolumeMethod == "Sum" ? oldBull + upVolume : mergeVolumeMethod == "Max" ? math.max(oldBull, upVolume) : (oldBull + upVolume) / 2.0)
                            array.set(bearVolData, j, mergeVolumeMethod == "Sum" ? oldBear + math.abs(downVolume) : mergeVolumeMethod == "Max" ? math.max(oldBear, math.abs(downVolume)) : (oldBear + math.abs(downVolume)) / 2.0)
                        if j < array.size(pivotConfluenceArr)
                            array.set(pivotConfluenceArr, j, math.max(array.get(pivotConfluenceArr, j), checkPivotConfluence(mergedTop, mergedBottom)))
                        if j < array.size(historicalTouches)
                            array.set(historicalTouches, j, math.max(array.get(historicalTouches, j), countHistoricalTouches(mergedTop, mergedBottom)))
                        if j < array.size(mtfConfluenceArr)
                            array.set(mtfConfluenceArr, j, math.max(array.get(mtfConfluenceArr, j), checkMTFConfluence(mergedTop, mergedBottom)))
                        if j < array.size(fibConfluenceArr) and j < array.size(fibLevelsString)
                            [fc, fl] = checkFibConfluence(mergedTop, mergedBottom)
                            array.set(fibConfluenceArr, j, fc)
                            array.set(fibLevelsString, j, fl)
                        if enableZoneClustering and j < array.size(clusterCount)
                            array.set(clusterCount, j, countOverlappingZones(mergedTop, mergedBottom, j))
                        if j < array.size(consolidatedCount) and j < array.size(isConsolidated)
                            array.set(consolidatedCount, j, array.get(consolidatedCount, j) + 1)
                            array.set(isConsolidated, j, true)
                        if j < array.size(justMerged)
                            array.set(justMerged, j, true)
                        if j < array.size(isInstitutionalArr)
                            mVol = array.get(totalVolData, j)
                            isInstNow = mVol >= avgVolume * volMultiplier
                            if isInstNow and not array.get(isInstitutionalArr, j)
                                array.set(hasGraduated, j, true)
                            array.set(isInstitutionalArr, j, isInstNow)
                        merged := true
                        canCreate := false
                if not enableMerging and keepStrongest
                    oldStrength = array.get(strengthScores, j)
                    if newStrength <= oldStrength
                        canCreate := false
                    else
                        if j < array.size(strengthLabels)
                            lab = array.get(strengthLabels, j)
                            if not na(lab)
                                label.delete(lab)
                        if j < array.size(gapLines)
                            ln = array.get(gapLines, j)
                            if not na(ln)
                                line.delete(ln)
                        if j < array.size(volumeProfileData)
                            vpData = array.get(volumeProfileData, j)
                            if not na(vpData)
                                if not na(vpData.pocLine)
                                    line.delete(vpData.pocLine)
                                if not na(vpData.volumeSumLabel)
                                    label.delete(vpData.volumeSumLabel)
                                if not na(vpData.profileBoxes)
                                    for vb in vpData.profileBoxes
                                        box.delete(vb)
                        if j < array.size(bullvolBars)
                            box.delete(array.get(bullvolBars, j))
                        if j < array.size(bearvolBars)
                            box.delete(array.get(bearvolBars, j))
                        box.delete(bx)
                        array.remove(gapBoxes, j)
                        array.remove(gapTypes, j)
                        if j < array.size(totalVolData)
                            array.remove(totalVolData, j)
                        if j < array.size(gapSizeData)
                            array.remove(gapSizeData, j)
                        if j < array.size(strengthScores)
                            array.remove(strengthScores, j)
                        if j < array.size(pivotConfluenceArr)
                            array.remove(pivotConfluenceArr, j)
                        if j < array.size(historicalTouches)
                            array.remove(historicalTouches, j)
                        if j < array.size(mtfConfluenceArr)
                            array.remove(mtfConfluenceArr, j)
                        if j < array.size(isBroken)
                            array.remove(isBroken, j)
                        if j < array.size(brokenAge)
                            array.remove(brokenAge, j)
                        if j < array.size(roleReversed)
                            array.remove(roleReversed, j)
                        if j < array.size(reversalTouches)
                            array.remove(reversalTouches, j)
                        if j < array.size(gapInsideFlags)
                            array.remove(gapInsideFlags, j)
                        if j < array.size(isInstitutionalArr)
                            array.remove(isInstitutionalArr, j)
                        if j < array.size(hasGraduated)
                            array.remove(hasGraduated, j)
                        if j < array.size(consolidatedCount)
                            array.remove(consolidatedCount, j)
                        if j < array.size(isConsolidated)
                            array.remove(isConsolidated, j)
                        if enableAdaptiveOptimization
                            if j < array.size(zoneSuccessRate)
                                array.remove(zoneSuccessRate, j)
                            if j < array.size(zoneTouchCount)
                                array.remove(zoneTouchCount, j)
                            if j < array.size(adaptiveWeight)
                                array.remove(adaptiveWeight, j)
                        if j < array.size(fibConfluenceArr)
                            array.remove(fibConfluenceArr, j)
                        if j < array.size(fibLevelsString)
                            array.remove(fibLevelsString, j)
                        if j < array.size(hasDeltaDivergence)
                            array.remove(hasDeltaDivergence, j)
                        if j < array.size(clusterCount)
                            array.remove(clusterCount, j)
                        if j < array.size(lastTooltipUpdate)
                            array.remove(lastTooltipUpdate, j)
                        if j < array.size(strengthLabels)
                            array.remove(strengthLabels, j)
                        if j < array.size(gapLines)
                            array.remove(gapLines, j)
                        if j < array.size(volumeProfileData)
                            array.remove(volumeProfileData, j)
                        if j < array.size(bullvolBars)
                            array.remove(bullvolBars, j)
                        if j < array.size(bearvolBars)
                            array.remove(bearvolBars, j)
                        if j < array.size(justMerged)
                            array.remove(justMerged, j)
                        if j < array.size(successfulTouches)
                            array.remove(successfulTouches, j)
                        if j < array.size(failedTouches)
                            array.remove(failedTouches, j)
                        if j < array.size(mlConfidence)
                            array.remove(mlConfidence, j)
                        if j < array.size(lastTouchBar)
                            array.remove(lastTouchBar, j)
                        if j < array.size(labelYPositions)
                            array.remove(labelYPositions, j)
                        if j < array.size(storedTooltips)
                            array.remove(storedTooltips, j)
    if canCreate and proximityBars > 0 and array.size(gapBoxes) > 0
        for j = array.size(gapBoxes) - 1 to 0
            bx  = array.get(gapBoxes, j)
            typ = array.get(gapTypes, j)
            lOld= box.get_left(bx)
            within = math.abs(idx - lOld) <= proximityBars
            if within and typ == dir
                if keepStrongest
                    oldStrength = array.get(strengthScores, j)
                    canCreate := newStrength > oldStrength
                else
                    canCreate := false
    canCreate
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN ZONE MANAGEMENT
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
visibleCount = 0

// Sync tooltip array size with zones
while array.size(storedTooltips) < array.size(gapBoxes)
    array.push(storedTooltips, "")
while array.size(storedTooltips) > array.size(gapBoxes)
    array.pop(storedTooltips)

if array.size(gapBoxes) > 0
    for i = array.size(gapBoxes) - 1 to 0
        if i < 0 or i >= array.size(gapBoxes) or i >= array.size(gapTypes)
            continue

        bx  = array.get(gapBoxes, i)
        l   = box.get_left(bx)
        t   = box.get_top(bx)
        b   = box.get_bottom(bx)
        typ = array.get(gapTypes, i)

        age    = i < array.size(zoneAge) ? array.get(zoneAge, i) : (bar_index - l)
        broken = i < array.size(isBroken) ? array.get(isBroken, i) : false

        zonePosition = enableSmartPositioning ? checkZonePosition(t, b, typ) : 1
        wasHidden    = i < array.size(isHidden) ? array.get(isHidden, i) : false
        toHide       = shouldHideZone(zonePosition, positionFilterMode)

        if reactivateOnReversal and wasHidden and not toHide
            if i < array.size(wasReactivated)
                array.set(wasReactivated, i, true)

        if i < array.size(isHidden)
            array.set(isHidden, i, toHide)

        tooFar   = distanceMode == "ATR" and distanceFilterATR <= 0 ? false : distanceMode == "Percent" and distanceFilterPct <= 0 ? false : isTooFar(t, b)
        totalVol = i < array.size(totalVolData) ? array.get(totalVolData, i) : 0.0
        score    = i < array.size(strengthScores) ? array.get(strengthScores, i) : 0.0
        wasInst  = i < array.size(isInstitutionalArr) ? array.get(isInstitutionalArr, i) : false
        isInstNow = totalVol >= avgVolume * volMultiplier

        shouldDelete = not passesFilters(score, totalVol, avgVolume, wasInst, isInstNow) or (age > maxBoxAge) or tooFar or (broken and i < array.size(brokenAge) and array.get(brokenAge, i) > keepBrokenZones)

        if shouldDelete
            if i < array.size(strengthLabels)
                lb = array.get(strengthLabels, i)
                if not na(lb)
                    label.delete(lb)

            if i < array.size(gapLines)
                ln = array.get(gapLines, i)
                if not na(ln)
                    line.delete(ln)

                if i < array.size(volumeProfileData)
                    vpD = array.get(volumeProfileData, i)

                    if not na(vpD.pocLine)
                        line.delete(vpD.pocLine)
                    if not na(vpD.volumeSumLabel)
                        label.delete(vpD.volumeSumLabel)

                    // profileBoxes is always an array, no need for na() check
                    for vb in vpD.profileBoxes
                        box.delete(vb)

            if i < array.size(bullvolBars)
                box.delete(array.get(bullvolBars, i))
            if i < array.size(bearvolBars)
                box.delete(array.get(bearvolBars, i))

            box.delete(bx)
            array.remove(gapBoxes, i)
            array.remove(gapTypes, i)

            if i < array.size(totalVolData)
                array.remove(totalVolData, i)
            if i < array.size(gapSizeData)
                array.remove(gapSizeData, i)
            if i < array.size(strengthScores)
                array.remove(strengthScores, i)
            if i < array.size(gapLines)
                array.remove(gapLines, i)
            if i < array.size(strengthLabels)
                array.remove(strengthLabels, i)
            if i < array.size(pivotConfluenceArr)
                array.remove(pivotConfluenceArr, i)
            if i < array.size(historicalTouches)
                array.remove(historicalTouches, i)
            if i < array.size(mtfConfluenceArr)
                array.remove(mtfConfluenceArr, i)
            if i < array.size(isBroken)
                array.remove(isBroken, i)
            if i < array.size(brokenAge)
                array.remove(brokenAge, i)
            if i < array.size(roleReversed)
                array.remove(roleReversed, i)
            if i < array.size(reversalTouches)
                array.remove(reversalTouches, i)
            if i < array.size(gapInsideFlags)
                array.remove(gapInsideFlags, i)
            if i < array.size(isInstitutionalArr)
                array.remove(isInstitutionalArr, i)
            if i < array.size(hasGraduated)
                array.remove(hasGraduated, i)
            if i < array.size(consolidatedCount)
                array.remove(consolidatedCount, i)
            if i < array.size(isConsolidated)
                array.remove(isConsolidated, i)
            if i < array.size(zoneSuccessRate)
                array.remove(zoneSuccessRate, i)
            if i < array.size(zoneTouchCount)
                array.remove(zoneTouchCount, i)
            if i < array.size(adaptiveWeight)
                array.remove(adaptiveWeight, i)
            if i < array.size(fibConfluenceArr)
                array.remove(fibConfluenceArr, i)
            if i < array.size(fibLevelsString)
                array.remove(fibLevelsString, i)
            if i < array.size(hasDeltaDivergence)
                array.remove(hasDeltaDivergence, i)
            if i < array.size(clusterCount)
                array.remove(clusterCount, i)
            if i < array.size(lastTooltipUpdate)
                array.remove(lastTooltipUpdate, i)
            if i < array.size(originalDirection)
                array.remove(originalDirection, i)
            if i < array.size(zoneAge)
                array.remove(zoneAge, i)
            if i < array.size(isHidden)
                array.remove(isHidden, i)
            if i < array.size(wasReactivated)
                array.remove(wasReactivated, i)
            if i < array.size(hasDivergence)
                array.remove(hasDivergence, i)
            if i < array.size(divergenceType)
                array.remove(divergenceType, i)
            if i < array.size(divergenceStrength)
                array.remove(divergenceStrength, i)
            if i < array.size(bullVolData)
                array.remove(bullVolData, i)
            if i < array.size(bearVolData)
                array.remove(bearVolData, i)
            if i < array.size(volumeProfileData)
                array.remove(volumeProfileData, i)
            if i < array.size(bullvolBars)
                array.remove(bullvolBars, i)
            if i < array.size(bearvolBars)
                array.remove(bearvolBars, i)
            if i < array.size(justMerged)
                array.remove(justMerged, i)
            if i < array.size(successfulTouches)
                array.remove(successfulTouches, i)
            if i < array.size(failedTouches)
                array.remove(failedTouches, i)
            if i < array.size(mlConfidence)
                array.remove(mlConfidence, i)
            if i < array.size(lastTouchBar)
                array.remove(lastTouchBar, i)
            if i < array.size(labelYPositions)
                array.remove(labelYPositions, i)
            if i < array.size(storedTooltips)
                array.remove(storedTooltips, i)
            continue

        if toHide
            if visibleCount < 50
                box.set_bgcolor(bx, color.new(bullColor, 100))
                box.set_border_color(bx, color.new(bullColor, 100))
            continue

        visibleCount += 1

        hasDivNow   = false
        divTypeNow  = ""
        divStrNow   = 0

        if enableRealtimeDivergence
            isAtZone = (low <= t and high >= b)
            if isAtZone
                rsiDiv = (typ == 1 and close < close[obvLookback] and rsiValue > rsiValue[obvLookback] + rsiDivergenceThreshold) or (typ == -1 and close > close[obvLookback] and rsiValue < rsiValue[obvLookback] - rsiDivergenceThreshold)
                if rsiDiv
                    divStrNow += 1

                obvDiv = false
                if enableOBV
                    obvDiv := (typ == 1 and close < close[obvLookback] and obvValue < obvValue[obvLookback]) or (typ == -1 and close > close[obvLookback] and obvValue < obvValue[obvLookback])
                    if obvDiv
                        divStrNow += 1

                adxWeak = false
                if enableADX
                    adxWeak := adxValue < adxWeakThreshold
                    if adxWeak
                        divStrNow += 1

                if divStrNow >= 1
                    hasDivNow  := true
                    divTypeNow := divStrNow >= 3 ? "TRIPLE" : rsiDiv and obvDiv ? "RSI+OBV" : rsiDiv and adxWeak ? "RSI+Weak ADX" : obvDiv and adxWeak ? "OBV+Weak ADX" : rsiDiv ? "RSI" : obvDiv ? "OBV" : "Weak ADX"

        if i < array.size(hasDivergence)
            array.set(hasDivergence, i, hasDivNow)
        if i < array.size(divergenceType)
            array.set(divergenceType, i, divTypeNow)
        if i < array.size(divergenceStrength)
            array.set(divergenceStrength, i, divStrNow)

        effectiveRole  = getEffectiveRole(typ, zonePosition, positionFilterMode)
        effectiveColor = effectiveRole == 1 ? bullColor : bearColor

        if hasDivNow and divergenceVisualMode != "Icon Only"
            if divergenceVisualMode == "Color Change"
                effectiveColor := divergenceColor
            else
                box.set_border_color(bx, color.new(divergenceColor, divergenceBorderTransp))
                box.set_border_width(bx, divergenceBorderWidth)

        dynTransp = calcDynamicTransp(totalVol, avgVolume)
        box.set_bgcolor(bx, color.new(effectiveColor, dynTransp))

        if not (hasDivNow and (divergenceVisualMode == "Border + Icon" or divergenceVisualMode == "Border Only"))
            box.set_border_width(bx, boxBorderWidth)

        r = cleanMode ? bar_index + cleanModeOffset + cleanModeExtension : bar_index + boxExtension
        box.set_right(bx, r)

        if i < array.size(gapLines)
            midLine = array.get(gapLines, i)
            if not na(midLine)
                midY = (t + b) / 2.0
                line.set_x2(midLine, r)
                line.set_y1(midLine, midY)
                line.set_y2(midLine, midY)

        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // VOLUME PROFILE RENDERING + POC / DELTA (no color.from_gradient)
        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if enableVolumeProfile and i < array.size(volumeProfileData)
            vpData = array.get(volumeProfileData, i)
            vprof  = vpData.volumeProfile
            vpSize = array.size(vprof)

            if vpSize > 0
                // compute max volume safely
                maxVol = 0.0
                for k = 0 to vpSize - 1
                    volkTmp = array.get(vprof, k)
                    if volkTmp > maxVol
                        maxVol := volkTmp

                binSize         = (t - b) / vpSize
                zoneWidth       = r - l
                maxProfileWidth = zoneWidth * (volumeProfileWidth / 100.0)
                pocLevel        = 0
                pocVol          = 0.0

                for k = 0 to vpSize - 1
                    lower = b + binSize * k
                    upper = lower + binSize
                    volk  = array.get(vprof, k)

                    if volk > pocVol
                        pocVol   := volk
                        pocLevel := k

                    if k < array.size(vpData.profileBoxes)
                        vpBox = array.get(vpData.profileBoxes, k)
                        if volk > 0 and maxVol > 0
                            volRatio   = volk / maxVol
                            boxWidth   = math.round(volRatio * maxProfileWidth)

                            // emulate gradient: low volume = very transparent, high volume = closer to volumeProfileTransp
                            transpBox  = int(100 - volRatio * (100 - volumeProfileTransp))
                            transpBox  := math.max(0, math.min(100, transpBox))
                            bgColor    = color.new(effectiveColor, transpBox)

                            box.set_lefttop(vpBox, l, upper)
                            box.set_rightbottom(vpBox, l + boxWidth, lower)
                            box.set_bgcolor(vpBox, bgColor)
                            box.set_border_color(vpBox, color.new(effectiveColor, 90))
                            box.set_border_width(vpBox, 1)
                        else
                            box.set_bgcolor(vpBox, color.new(effectiveColor, 100))
                            box.set_border_color(vpBox, color.new(effectiveColor, 100))

                // POC line
                if showPOC and not na(vpData.pocLine)
                    pocY = b + binSize * (pocLevel + 0.5)
                    line.set_xy1(vpData.pocLine, l, pocY)
                    line.set_xy2(vpData.pocLine, r, pocY)

                    if enableVolumeDelta and i < array.size(bullVolData) and i < array.size(bearVolData)
                        bullV = array.get(bullVolData, i)
                        bearV = array.get(bearVolData, i)
                        delta = (bullV - bearV) / math.max(totalVol, 1.0)

                        // stronger delta â†’ less transparent POC line
                        deltaAbs      = math.min(math.abs(delta), 1.0)
                        extraTransp   = int(deltaAbs * deltaColorStrength)
                        baseColorPOC  = delta > 0.0 ? bullColor : bearColor
                        pocTransp     = math.max(pocLineTransparency - extraTransp, 0)

                        line.set_color(vpData.pocLine, color.new(baseColorPOC, pocTransp))
                    else
                        line.set_color(vpData.pocLine, color.new(pocColor, pocLineTransparency))

                    line.set_width(vpData.pocLine, pocLineWidth)

                // total volume label in zone
                if showVolumeSum and not na(vpData.volumeSumLabel)
                    zoneVolume = i < array.size(totalVolData) ? array.get(totalVolData, i) : 0.0
                    label.set_xy(vpData.volumeSumLabel, r, typ == 1 ? b : t)
                    label.set_text(vpData.volumeSumLabel, str.tostring(zoneVolume, format.volume))
                    label.set_color(vpData.volumeSumLabel, color.new(effectiveColor, volumeSumTransparency))
                    label.set_textcolor(vpData.volumeSumLabel, color.new(color.white, 0))
                    label.set_size(vpData.volumeSumLabel, textSize(volumeSumSize))

        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // STRENGTH LABELS - WITH RECREATION FIX (COPY/PASTE)
        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if showStrength
            sLbl = i < array.size(strengthLabels) ? array.get(strengthLabels, i) : na

            // Build label text
            string stars     = scoreToStars(score)
            string labelText = stars

            bool wasMergedLocal = i < array.size(justMerged) ? array.get(justMerged, i) : false
            if wasMergedLocal and showMergeAnimation
                labelText := "ğŸ”—" + labelText

            // Live divergence state (used for icon + tooltip)
            bool   liveDiv  = i < array.size(hasDivergence)      ? array.get(hasDivergence, i)      : false
            string liveType = i < array.size(divergenceType)     ? array.get(divergenceType, i)     : ""
            int    liveStr  = i < array.size(divergenceStrength) ? array.get(divergenceStrength, i) : 0

            if liveDiv and (divergenceVisualMode == "Icon Only" or divergenceVisualMode == "Border + Icon")
                labelText := "âš ï¸" + labelText

            bool reactNow = showReactivatedBadge and i < array.size(wasReactivated) and array.get(wasReactivated, i)
            if reactNow
                labelText := "ğŸ”„" + labelText

            bool consNow = showConsolidationInfo and i < array.size(isConsolidated) and array.get(isConsolidated, i)
            if consNow
                labelText := "ğŸ”—" + labelText

            int  cl       = (enableZoneClustering and i < array.size(clusterCount)) ? array.get(clusterCount, i) : 0
            bool clusterNow = enableZoneClustering and showClusterBadge and (cl >= clusterThreshold)
            if clusterNow
                labelText := "ğŸ”¥" + labelText

            bool gradNow = i < array.size(hasGraduated) and array.get(hasGraduated, i)
            if gradNow
                labelText := "ğŸ“ˆ" + labelText

            int  fibNow = i < array.size(fibConfluenceArr) ? array.get(fibConfluenceArr, i) : 0
            bool fibFlag = fibNow > 0
            if fibFlag
                labelText := "ğŸ“" + labelText

            bool deltaNow = i < array.size(hasDeltaDivergence) and array.get(hasDeltaDivergence, i)
            if deltaNow
                labelText := "âš " + labelText

            int pivNow = ((pivotDisplay == "Icon Only" or pivotDisplay == "Both") and i < array.size(pivotConfluenceArr)) ? array.get(pivotConfluenceArr, i) : 0
            if pivNow > 0
                labelText := "ğŸ¯" + labelText

            int mtfNow = ((mtfDisplay == "Icon Only" or mtfDisplay == "Both") and i < array.size(mtfConfluenceArr)) ? array.get(mtfConfluenceArr, i) : 0
            if mtfNow > 0
                labelText := "âš¡" + labelText

            float mlConfNow = (enableMLPredictions and showMLBadge and i < array.size(mlConfidence)) ? array.get(mlConfidence, i) : na
            bool  mlBadgeNow = enableMLPredictions and showMLBadge and (not na(mlConfNow)) and (mlConfNow >= mlConfidenceThreshold)
            if mlBadgeNow
                labelText := "ğŸ¤–" + labelText

            midY      = (t + b) / 2.0
            adjustedY = adjustLabelPosition(midY, i)

            if i < array.size(labelYPositions)
                array.set(labelYPositions, i, adjustedY)

            labelBg        = getStarBgColor(score, effectiveColor)
            labelTextColor = showLabelBackground ? color.new(color.white, starTransp) : color.new(effectiveColor, starTransp)

            // Base tooltip from stored text
            string tooltipText = i < array.size(storedTooltips) ? array.get(storedTooltips, i) : ""

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // âš ï¸ REAL-TIME DIVERGENCE TOOLTIP (safe: no name collisions)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            bool   _liveDiv  = i < array.size(hasDivergence)      ? array.get(hasDivergence, i)      : false
            string _liveType = i < array.size(divergenceType)     ? array.get(divergenceType, i)     : ""
            int    _liveStr  = i < array.size(divergenceStrength) ? array.get(divergenceStrength, i) : 0

            if _liveDiv
                string _sideTxt = typ == 1 ? "SUPPORT" : "RESISTANCE"
                tooltipText += "\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
                tooltipText += "âš ï¸ REAL-TIME DIVERGENCE @ " + _sideTxt + "\n"
                tooltipText += "Zone: " + str.tostring(b, format.mintick) + " â†’ " + str.tostring(t, format.mintick) + "\n"
                tooltipText += "Type: " + _liveType + " | Strength: " + str.tostring(_liveStr) + "/3\n"
                if str.contains(_liveType, "RSI")
                    tooltipText += "- RSI: len=" + str.tostring(rsiPeriod) + ", lookback=" + str.tostring(obvLookback) + ", threshold=" + str.tostring(rsiDivergenceThreshold) + "\n"
                if str.contains(_liveType, "OBV")
                    tooltipText += "- OBV: lookback=" + str.tostring(obvLookback) + "\n"
                if str.contains(_liveType, "ADX")
                    tooltipText += "- ADX: len=" + str.tostring(adxPeriod) + ", weak<" + str.tostring(adxWeakThreshold) + "\n"
                tooltipText += "Meaning: zone test is not confirmed by momentum/flow â†’ reaction / failed break risk elevated.\n"

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // âš  DELTA DIVERGENCE TOOLTIP (explains the plain âš  icon)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if deltaNow
                float bullV = i < array.size(bullVolData) ? array.get(bullVolData, i) : 0.0
                float bearV = i < array.size(bearVolData) ? array.get(bearVolData, i) : 0.0
                float vr    = bullV / math.max(bearV, 1.0)
                string ruleTxt = typ == 1 ? ("Support wants vr â‰¥ " + str.tostring(1.0 / deltaThreshold, "#.##")) : ("Resistance wants vr â‰¤ " + str.tostring(deltaThreshold, "#.##"))
                tooltipText += "\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
                tooltipText += "âš  DELTA DIVERGENCE (ORDER-FLOW)\n"
                tooltipText += "Bull/Bear vol ratio: " + str.tostring(vr, "#.##") + " (" + ruleTxt + ")\n"
                tooltipText += "Meaning: opposite-side aggression dominates inside the zone â†’ absorption/trap risk.\n"

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Badge legend (quick decode of icons shown on the label)
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            string badgeTxt = ""
            if wasMergedLocal and showMergeAnimation
                badgeTxt += "ğŸ”— merged\n"
            if consNow
                badgeTxt += "ğŸ”— consolidated\n"
            if clusterNow
                badgeTxt += "ğŸ”¥ cluster\n"
            if gradNow
                badgeTxt += "ğŸ“ˆ upgraded\n"
            if fibFlag
                badgeTxt += "ğŸ“ fib confluence\n"
            if pivNow > 0
                badgeTxt += "ğŸ¯ pivot confluence\n"
            if mtfNow > 0
                badgeTxt += "âš¡ mtf confluence\n"
            if mlBadgeNow
                badgeTxt += "ğŸ¤– ML confidence\n"
            if str.length(badgeTxt) > 0
                tooltipText += "\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
                tooltipText += "BADGES:\n" + badgeTxt

            if not na(sLbl)
                // UPDATE existing label
                label.set_text(sLbl, labelText)

                if starPosition == "Left Inside"
                    label.set_xy(sLbl, l + 5, adjustedY)
                    label.set_style(sLbl, label.style_label_right)
                else
                    label.set_xy(sLbl, r, adjustedY)
                    label.set_style(sLbl, label.style_label_left)

                label.set_color(sLbl, labelBg)
                label.set_textcolor(sLbl, labelTextColor)
                label.set_tooltip(sLbl, tooltipText)
            else
                // RECREATE missing label
                labelStyle = starPosition == "Left Inside" ? label.style_label_right : label.style_label_left
                labelX     = starPosition == "Left Inside" ? l + 5 : r

                newLbl = label.new(
                     x         = labelX,
                     y         = adjustedY,
                     text      = labelText,
                     style     = labelStyle,
                     color     = labelBg,
                     textcolor = labelTextColor,
                     size      = labelSize(starSizeInp),
                     tooltip   = tooltipText)

                if i < array.size(strengthLabels)
                    array.set(strengthLabels, i, newLbl)

        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // TOUCH / BACKTEST / ML
        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        insideNow = (close <= t) and (close >= b)
        wasInside = i < array.size(gapInsideFlags) ? array.get(gapInsideFlags, i) : false

        if insideNow and not wasInside and i < array.size(lastTouchBar)
            array.set(lastTouchBar, i, bar_index)
            if enableBacktesting
                [success, failed] = checkZoneReaction(t, b, typ == 1, bar_index)
                if success and i < array.size(successfulTouches)
                    array.set(successfulTouches, i, array.get(successfulTouches, i) + 1)
                if failed and i < array.size(failedTouches)
                    array.set(failedTouches, i, array.get(failedTouches, i) + 1)
                if enableMLPredictions and i < array.size(mlConfidence)
                    successT = array.get(successfulTouches, i)
                    failT    = array.get(failedTouches, i)
                    totalT   = successT + failT
                    newMLConf = calculateMLConfidence(successT, failT, totalT)
                    array.set(mlConfidence, i, newMLConf)

        if resetAgeOnTouch and insideNow and not wasInside
            if i < array.size(zoneAge)
                array.set(zoneAge, i, 0)

        if i < array.size(zoneAge)
            array.set(zoneAge, i, array.get(zoneAge, i) + 1)

        if i < array.size(gapInsideFlags)
            array.set(gapInsideFlags, i, insideNow)

        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // BREAK / ROLE REVERSAL
        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        brokeNow = false
        if not broken
            if typ == 1
                brokeNow := breakRequireBody ? (close < b) : (low < b)
            else
                brokeNow := breakRequireBody ? (close > t) : (high > t)

            cnt = i < array.size(breakConfirmCount) ? array.get(breakConfirmCount, i) : 0
            if brokeNow
                cnt += 1
            else
                cnt := math.max(0, cnt - 1)

            if i < array.size(breakConfirmCount)
                array.set(breakConfirmCount, i, cnt)

            if cnt >= breakConfirmBars and i < array.size(isBroken) and i < array.size(brokenAge)
                array.set(isBroken, i, true)
                array.set(brokenAge, i, 0)
                box.set_border_style(bx, line.style_dashed)
                box.set_bgcolor(bx, color.new(typ == 1 ? bearColor : bullColor, 95))
        else
            if i < array.size(brokenAge)
                array.set(brokenAge, i, array.get(brokenAge, i) + 1)

        reversed = i < array.size(roleReversed) ? array.get(roleReversed, i) : false
        if enableRoleReversal and i < array.size(isBroken) and array.get(isBroken, i) and not reversed
            revT = i < array.size(reversalTouches) ? array.get(reversalTouches, i) : 0
            if (typ == 1 and close > b and insideNow and not wasInside) or (typ == -1 and close < t and insideNow and not wasInside)
                revT += 1
            if i < array.size(reversalTouches)
                array.set(reversalTouches, i, revT)
            if revT >= reversalConfirmBars and i < array.size(roleReversed)
                array.set(roleReversed, i, true)

        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // VOLUME TEXT + BARS
        //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if i < array.size(bullVolData) and i < array.size(bearVolData)
            bullVol = array.get(bullVolData, i)
            bearVol = array.get(bearVolData, i)
            volText = formatVolumeText(bullVol, bearVol, totalVol)
            box.set_text(bx, volText)
            box.set_text_size(bx, textSize(text_size))
            box.set_text_color(bx, color.new(color.white, textTransp))
            box.set_text_halign(bx, text.align_right)
            box.set_text_valign(bx, text.align_bottom)

        if i < array.size(bullvolBars) and i < array.size(bearvolBars)
            bullBar = array.get(bullvolBars, i)
            bearBar = array.get(bearvolBars, i)
            volRatio = (i < array.size(bullVolData) and i < array.size(bearVolData)) ? array.get(bullVolData, i) / math.max(array.get(bearVolData, i), 0.0000001) : 1.0
            midY = (t + b) / 2.0

            if cleanMode
                leftM  = bar_index + cleanModeOffset - 1
                rightM = bar_index + cleanModeOffset
                box.set_left(bullBar, leftM)
                box.set_right(bullBar, rightM)
                box.set_top(bullBar, t)
                box.set_bottom(bullBar, midY)
                box.set_left(bearBar, leftM)
                box.set_right(bearBar, rightM)
                box.set_top(bearBar, midY)
                box.set_bottom(bearBar, b)
            else
                volMidCalc = int(math.avg(l, l + boxExtension))
                if volRatio > 1
                    box.set_right(bullBar, volMidCalc)
                    box.set_right(bearBar, int(l + (volMidCalc - l) / volRatio))
                else
                    box.set_right(bullBar, int(l + (volMidCalc - l) * volRatio))
                    box.set_right(bearBar, volMidCalc)
                box.set_top(bullBar, t)
                box.set_bottom(bullBar, midY)
                box.set_top(bearBar, midY)
                box.set_bottom(bearBar, b)

        if i < array.size(justMerged) and bar_index % 5 == 0
            array.set(justMerged, i, false)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CREATE ZONE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
create_zone(bool isBull, float tProp, float bProp, float sNow, int pivotConf, int touches, int mtfConf, int fibConf, string fibLevelsStr, bool deltaDiverg, string tooltipStr) =>
    totalVol   = totalVolNow
    gapSize    = math.abs(tProp - bProp)
    clusterCnt = countOverlappingZones(tProp, bProp, -1)
    institutional = instNow

    if passesFilters(sNow, totalVol, avgVolume, institutional, institutional) and (not preventOverlap or f_can_create(tProp, bProp, bar_index, sNow, isBull ? 1 : -1))
        lNew = cleanMode ? bar_index + cleanModeOffset : bar_index - 1
        rNew = cleanMode ? bar_index + cleanModeOffset + cleanModeExtension : bar_index + boxExtension

        dynTransp = calcDynamicTransp(totalVol, avgVolume)
        bgT       = showGapZone ? dynTransp : 100
        brdT      = showGapZone ? boxBorderTransp : 100

        volText = formatVolumeText(upVolume, math.abs(downVolume), totalVol)

        big = box.new(
             lNew, tProp, rNew, bProp,
             bgcolor      = color.new(isBull ? bullColor : bearColor, bgT),
             border_color = color.new(isBull ? bullColor : bearColor, brdT),
             border_width = boxBorderWidth,
             text         = volText,
             text_size    = textSize(text_size),
             text_color   = color.new(color.white, textTransp),
             text_halign  = text.align_right,
             text_valign  = text.align_bottom)

        if enableZoneClustering and clusterCnt >= clusterThreshold
            box.set_border_color(big, color.new(color.yellow, 50))
            box.set_border_width(big, 3)
        else if mtfConf > 0 and (mtfDisplay == "Border Only" or mtfDisplay == "Both")
            box.set_border_color(big, color.new(color.purple, mtfBorderTransp))
            box.set_border_width(big, mtfBorderWidth)
        else if pivotConf >= 1 and (pivotDisplay == "Border Only" or pivotDisplay == "Both")
            box.set_border_color(big, color.new(color.orange, 40))
            box.set_border_width(big, 2)

        array.unshift(gapBoxes, big)
        array.unshift(gapTypes, isBull ? 1 : -1)
        array.unshift(totalVolData, totalVol)
        array.unshift(gapSizeData, gapSize)
        array.unshift(strengthScores, int(math.round(sNow)))
        array.unshift(pivotConfluenceArr, pivotConf)
        array.unshift(historicalTouches, touches)
        array.unshift(mtfConfluenceArr, mtfConf)
        array.unshift(isBroken, false)
        array.unshift(brokenAge, 0)
        array.unshift(breakConfirmCount, 0)
        array.unshift(roleReversed, false)
        array.unshift(reversalTouches, 0)
        array.unshift(isInstitutionalArr, institutional)
        array.unshift(hasGraduated, false)
        array.unshift(consolidatedCount, 0)
        array.unshift(isConsolidated, false)
        array.unshift(fibConfluenceArr, fibConf)
        array.unshift(fibLevelsString, fibLevelsStr)
        array.unshift(hasDeltaDivergence, deltaDiverg)
        array.unshift(clusterCount, clusterCnt)
        array.unshift(lastTooltipUpdate, bar_index)
        array.unshift(originalDirection, isBull ? 1 : -1)
        array.unshift(zoneAge, 0)
        array.unshift(isHidden, false)
        array.unshift(wasReactivated, false)
        array.unshift(hasDivergence, false)
        array.unshift(divergenceType, "")
        array.unshift(divergenceStrength, 0)
        array.unshift(bullVolData, upVolume)
        array.unshift(bearVolData, math.abs(downVolume))
        array.unshift(justMerged, false)
        array.unshift(successfulTouches, 0)
        array.unshift(failedTouches, 0)
        array.unshift(mlConfidence, 0.5)
        array.unshift(lastTouchBar, 0)
        array.unshift(storedTooltips, tooltipStr)

        if enableAdaptiveOptimization
            array.unshift(zoneSuccessRate, 0.5)
            array.unshift(zoneTouchCount, 0)
            array.unshift(adaptiveWeight, 1.0)

        midY = (tProp + bProp) / 2.0

        if showStrength
            stars    = scoreToStars(math.round(sNow))
            labelText = stars

            if enableZoneClustering and clusterCnt >= clusterThreshold and showClusterBadge
                labelText := "ğŸ”¥" + labelText
            if fibConf > 0
                labelText := "ğŸ“" + labelText
            if deltaDiverg
                labelText := "âš " + labelText
            if pivotConf >= 1 and (pivotDisplay == "Icon Only" or pivotDisplay == "Both")
                labelText := "ğŸ¯" + labelText
            if mtfConf > 0 and (mtfDisplay == "Icon Only" or mtfDisplay == "Both")
                labelText := "âš¡" + labelText

            labelBg  = getStarBgColor(math.round(sNow), isBull ? bullColor : bearColor)
            labelTxt = showLabelBackground ? color.new(color.white, starTransp) : color.new(isBull ? bullColor : bearColor, starTransp)

            adjustedY = adjustLabelPosition(midY, 0)
            array.unshift(labelYPositions, adjustedY)

            labelStyle = starPosition == "Left Inside" ? label.style_label_right : label.style_label_left
            labelX     = starPosition == "Left Inside" ? lNew + 5 : rNew

            lbl = label.new(
                 x        = labelX,
                 y        = adjustedY,
                 text     = labelText,
                 style    = labelStyle,
                 color    = labelBg,
                 textcolor= labelTxt,
                 size     = labelSize(starSizeInp),
                 tooltip  = tooltipStr)

            array.unshift(strengthLabels, lbl)
        else
            array.unshift(strengthLabels, na)
            array.unshift(labelYPositions, na)

        midLine = line.new(lNew, midY, rNew, midY, color=color.new(color.white, 0), width=1, style=line.style_dashed)
        array.unshift(gapLines, midLine)
        array.unshift(gapInsideFlags, false)

        if enableVolumeProfile
            vprof     = calculateVolumeProfile(tProp, bProp)
            vpBoxArray = array.new<box>()
            binSize   = (tProp - bProp) / volumeProfileBins

            for k = 0 to volumeProfileBins - 1
                lower = bProp + binSize * k
                upper = lower + binSize
                vpBox = box.new(lNew, upper, lNew, lower, border_width=0)
                array.push(vpBoxArray, vpBox)

            pocLine   = showPOC ? line.new(lNew, (tProp + bProp) / 2.0, rNew, (tProp + bProp) / 2.0, color=color.new(pocColor, pocLineTransparency), width=pocLineWidth) : na
            volSumLbl = showVolumeSum ? label.new(rNew, isBull ? bProp : tProp, "", style=isBull ? label.style_label_up : label.style_label_down, color=color.new(isBull ? bullColor : bearColor, volumeSumTransparency), textcolor=color.new(color.white, 0), size=textSize(volumeSumSize)) : na
            vpDataNew = VolumeProfileData.new(vprof, vpBoxArray, pocLine, volSumLbl)
            array.unshift(volumeProfileData, vpDataNew)
        else
            emptyProfile = array.new_float()
            emptyBoxes   = array.new<box>()
            vpDataNew    = VolumeProfileData.new(emptyProfile, emptyBoxes, na, na)
            array.unshift(volumeProfileData, vpDataNew)

        bullLeft  = cleanMode ? bar_index + cleanModeOffset - 1 : lNew
        bullRight = cleanMode ? bar_index + cleanModeOffset     : lNew + 1

        bbar = box.new(bullLeft, tProp, bullRight, midY, border_width=1, border_color=color.new(bullColor, 90), bgcolor=color.new(bullColor, 70))
        sbar = box.new(bullLeft, midY, bullRight, bProp, border_width=1, border_color=color.new(bearColor, 90), bgcolor=color.new(bearColor, 70))
        array.unshift(bullvolBars, bbar)
        array.unshift(bearvolBars, sbar)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZONE CREATION TRIGGERS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if bullFVG
    create_zone(true, tPropBull, bPropBull, bullStrengthScore, bullPivotConf, bullTouches, bullMTFConf, bullFibConf, bullFibLevels, bullDeltaDiverg, bullTooltip_CONST)
if bearFVG
    create_zone(false, tPropBear, bPropBear, bearStrengthScore, bearPivotConf, bearTouches, bearMTFConf, bearFibConf, bearFibLevels, bearDeltaDiverg, bearTooltip_CONST)

if enableAdaptiveOptimization and bar_index % adaptiveUpdateFreq == 0
    n = math.min(array.size(gapBoxes), array.size(zoneTouchCount), array.size(zoneSuccessRate), array.size(adaptiveWeight))
    if n > 0
        for i = 0 to n - 1
            touches = array.get(zoneTouchCount, i)
            if touches >= minSampleSize
                successRate = array.get(zoneSuccessRate, i)
                newWeight   = 0.5 + (successRate * performanceWeight)
                array.set(adaptiveWeight, i, newWeight)

// Session backgrounds + VWAP
bgcolor(showSessionBackgrounds and isInSession(asianSessionTime)  ? color.new(color.blue,   sessionBgTransparency) : na)
bgcolor(showSessionBackgrounds and isInSession(londonSessionTime) ? color.new(color.yellow, sessionBgTransparency) : na)
bgcolor(showSessionBackgrounds and isInSession(nySessionTime)     ? color.new(color.green,  sessionBgTransparency) : na)

vwapValue = enableVWAPAnalysis ? ta.vwap(vwapSource) : na
plot(showVWAPLine and (not vwapShortForm or bar_index >= last_bar_index - vwapShortBars) ? vwapValue : na, color=color.new(vwapLineColor, vwapLineTransp), linewidth=vwapLineWidth, title="VWAP")
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED INFO TABLE WITH MARKET INTELLIGENCE (STYLED + REBUILD-SAFE)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if showInfoTable and barstate.islast
    tPos = getTablePosition(tablePosition)

    // Keep fixed dimensions to avoid OOB when toggles change
    int tCols = tableLayout == "Vertical" ? 2 : 7
    int tRows = tableLayout == "Vertical" ? 7 : 2

    // â”€â”€â”€â”€â”€ Rebuild when layout/position changes (your old code wouldn't)
    var table infoTable = na
    var string _lastPos = ""
    var string _lastLay = ""
    if na(infoTable) or _lastPos != tablePosition or _lastLay != tableLayout
        if not na(infoTable)
            table.delete(infoTable)
        infoTable := table.new(
             tPos, tCols, tRows,
             bgcolor=color.new(color.black, tableTransparency),
             border_width=1,
             border_color=color.new(color.white, 70)
        )
        _lastPos := tablePosition
        _lastLay := tableLayout

    table.clear(infoTable, 0, 0, tCols - 1, tRows - 1)

    // â”€â”€â”€â”€â”€ Styling (uses your existing tableTransparency)
    color bgBody    = color.new(color.black, tableTransparency)
    color bgKey     = color.new(color.rgb(22,22,22), math.min(100, tableTransparency + 10))   // label strip
    color bgVal     = color.new(color.rgb(10,10,10), math.min(100, tableTransparency + 22))   // value base
    color bgStripe  = color.new(color.rgb(28,28,28), math.min(100, tableTransparency + 14))   // stripe
    color txtKey    = color.white
    color txtVal    = color.white
    color txtAccent = color.rgb(255,204,0) // gold

    // â”€â”€â”€â”€â”€ Stats
    int   activeZones            = array.size(gapBoxes)
    int   bullZones              = 0
    int   bearZones              = 0
    float nearestSupport         = na
    float nearestResistance      = na
    float nearestSupportDist     = 1e10
    float nearestResistanceDist  = 1e10

    // â•â•â• Guarded loop (keeps your safety)
    if activeZones > 0 and array.size(gapTypes) > 0
        for i = 0 to activeZones - 1
            if i < array.size(gapTypes) and i < array.size(gapBoxes)
                int typ = array.get(gapTypes, i)
                box bx  = array.get(gapBoxes, i)
                float zTop = box.get_top(bx)
                float zBot = box.get_bottom(bx)

                if typ == 1
                    bullZones += 1
                    // bullish zone acts as SUPPORT (choose nearest edge)
                    float edgeS = close >= zTop ? zTop : zBot
                    float distS = math.abs(close - edgeS)
                    if distS < nearestSupportDist
                        nearestSupportDist := distS
                        nearestSupport := edgeS
                else
                    bearZones += 1
                    // bearish zone acts as RESISTANCE (choose nearest edge)
                    float edgeR = close <= zBot ? zBot : zTop
                    float distR = math.abs(close - edgeR)
                    if distR < nearestResistanceDist
                        nearestResistanceDist := distR
                        nearestResistance := edgeR

    // â”€â”€â”€â”€â”€ Posture / bias / risk
    string marketPos = "NEUTRAL"
    if not na(nearestSupport) and nearestSupportDist < atr14 * 0.5
        marketPos := "NEAR SUPPORT"
    else if not na(nearestResistance) and nearestResistanceDist < atr14 * 0.5
        marketPos := "NEAR RESISTANCE"
    else if not na(nearestResistance) and close > nearestResistance
        marketPos := "ABOVE RESISTANCE"
    else if not na(nearestSupport) and close < nearestSupport
        marketPos := "BELOW SUPPORT"

    string tradeBias = bullZones > bearZones ? "BULLISH" : bullZones < bearZones ? "BEARISH" : "NEUTRAL"
    color  biasColor = tradeBias == "BULLISH" ? color.lime : tradeBias == "BEARISH" ? color.red : color.gray

    string currentSession = getCurrentSession()
    string sessionName = currentSession == "NONE" ? "OFF" : currentSession

    string riskLevel = "MEDIUM"
    if marketPos == "NEAR SUPPORT" or marketPos == "NEAR RESISTANCE"
        riskLevel := "LOW"
    else if marketPos == "NEUTRAL"
        riskLevel := "MEDIUM"
    else
        riskLevel := "HIGH"
    color riskColor = riskLevel == "LOW" ? color.lime : riskLevel == "MEDIUM" ? color.orange : color.red

    // â”€â”€â”€â”€â”€ Tooltip (your original text, made safe with na guards)
    string strategyTooltip = "â•”â•â•â• REAL-TIME STRATEGY â•â•â•â•—\n"
    strategyTooltip += "Market Position: " + marketPos + "\n"
    strategyTooltip += "Trade Bias: " + tradeBias + "\n"
    strategyTooltip += "Risk Level: " + riskLevel + "\n"
    strategyTooltip += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
    if marketPos == "NEAR SUPPORT" and tradeBias == "BULLISH"
        strategyTooltip += "âœ… FAVORABLE LONG SETUP\n"
        strategyTooltip += "Consider: Buy on bounce\n"
        strategyTooltip += "Stop: Below " + (not na(nearestSupport) ? str.tostring(nearestSupport, format.price) : "-") + "\n"
        if not na(nearestResistance)
            strategyTooltip += "Target: " + str.tostring(nearestResistance, format.price) + "\n"
    else if marketPos == "NEAR RESISTANCE" and tradeBias == "BEARISH"
        strategyTooltip += "âœ… FAVORABLE SHORT SETUP\n"
        strategyTooltip += "Consider: Sell on rejection\n"
        strategyTooltip += "Stop: Above " + (not na(nearestResistance) ? str.tostring(nearestResistance, format.price) : "-") + "\n"
        if not na(nearestSupport)
            strategyTooltip += "Target: " + str.tostring(nearestSupport, format.price) + "\n"
    else if marketPos == "NEUTRAL"
        strategyTooltip += "âš ï¸ NO CLEAR SETUP\n"
        strategyTooltip += "Wait for: Price at zone\n"
        strategyTooltip += "Action: Be patient\n"
    else
        strategyTooltip += "âš ï¸ CONFLICTING SIGNALS\n"
        strategyTooltip += "Position: " + marketPos + "\n"
        strategyTooltip += "Bias: " + tradeBias + "\n"
        strategyTooltip += "Action: Reduce size or wait\n"
    strategyTooltip += "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
    strategyTooltip += "Active Session: " + sessionName + "\n"
    strategyTooltip += "Total Zones: " + str.tostring(activeZones) + "\n"
    strategyTooltip += "Bull: " + str.tostring(bullZones) + " | Bear: " + str.tostring(bearZones) + "\n"
    strategyTooltip += "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    tSize = tableTextSize(tableSize)

    // Soft glow backgrounds for bias/risk cells
    color bgBias = color.new(biasColor, 85)
    color bgRisk = color.new(riskColor, 85)

    int row = 0
    int col = 0

    // â”€â”€â”€â”€â”€ Render
    if tableLayout == "Vertical"
        if showZoneCount
            table.cell(infoTable, 0, row, "Zones", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_left)
            table.cell(infoTable, 1, row, str.tostring(activeZones), text_color=color.yellow, text_size=tSize,
                bgcolor=((row % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_right)
            row += 1
        if showMarketPosition
            table.cell(infoTable, 0, row, "Position", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_left)
            table.cell(infoTable, 1, row, marketPos, text_color=color.aqua, text_size=tSize,
                bgcolor=((row % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_right)
            row += 1
        if showNearestLevels
            string suppText = not na(nearestSupport) ? str.tostring(nearestSupport, format.price) : "-"
            string resText  = not na(nearestResistance) ? str.tostring(nearestResistance, format.price) : "-"
            table.cell(infoTable, 0, row, "S/R", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_left)
            table.cell(infoTable, 1, row, suppText + " / " + resText, text_color=txtVal, text_size=tSize,
                bgcolor=((row % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_right)
            row += 1
        if showTradeBias
            table.cell(infoTable, 0, row, "Bias", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_left)
            table.cell(infoTable, 1, row, tradeBias, text_color=biasColor, text_size=tSize, bgcolor=bgBias, text_halign=text.align_right)
            row += 1
        if showCurrentSession
            table.cell(infoTable, 0, row, "Session", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_left)
            table.cell(infoTable, 1, row, sessionName, text_color=txtAccent, text_size=tSize,
                bgcolor=((row % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_right)
            row += 1
        if showRiskLevel
            table.cell(infoTable, 0, row, "Risk", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_left)
            table.cell(infoTable, 1, row, riskLevel, text_color=riskColor, text_size=tSize, bgcolor=bgRisk, text_halign=text.align_right)

    else
        if showZoneCount
            table.cell(infoTable, col, 0, "Zones", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_center)
            table.cell(infoTable, col, 1, str.tostring(activeZones), text_color=color.yellow, text_size=tSize,
                bgcolor=((col % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_center)
            col += 1
        if showMarketPosition
            string posAbbrev = marketPos == "NEAR SUPPORT" ? "SUP" : marketPos == "NEAR RESISTANCE" ? "RES" : marketPos == "NEUTRAL" ? "NEU" : marketPos == "ABOVE RESISTANCE" ? "ABV" : "BLW"
            table.cell(infoTable, col, 0, "Pos", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_center)
            table.cell(infoTable, col, 1, posAbbrev, text_color=color.aqua, text_size=tSize,
                bgcolor=((col % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_center)
            col += 1
        if showNearestLevels
            string suppText = not na(nearestSupport) ? str.tostring(nearestSupport, "#.##") : "-"
            string resText  = not na(nearestResistance) ? str.tostring(nearestResistance, "#.##") : "-"
            table.cell(infoTable, col, 0, "S/R", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_center)
            table.cell(infoTable, col, 1, suppText + "/" + resText, text_color=txtVal, text_size=tSize,
                bgcolor=((col % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_center)
            col += 1
        if showTradeBias
            string biasAbbrev = tradeBias == "BULLISH" ? "BUL" : tradeBias == "BEARISH" ? "BER" : "NEU"
            table.cell(infoTable, col, 0, "Bias", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_center)
            table.cell(infoTable, col, 1, biasAbbrev, text_color=biasColor, text_size=tSize, bgcolor=bgBias, text_halign=text.align_center)
            col += 1
        if showCurrentSession
            string sessAbbrev = sessionName == "OVERLAP" ? "OVR" : sessionName == "LONDON" ? "LDN" : sessionName == "NY" ? "NY" : sessionName == "ASIAN" ? "ASN" : "OFF"
            table.cell(infoTable, col, 0, "Sess", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_center)
            table.cell(infoTable, col, 1, sessAbbrev, text_color=txtAccent, text_size=tSize,
                bgcolor=((col % 2 == 1) ? bgStripe : bgVal), text_halign=text.align_center)
            col += 1
        if showRiskLevel
            string riskAbbrev = riskLevel == "LOW" ? "LOW" : riskLevel == "MEDIUM" ? "MED" : "HI"
            table.cell(infoTable, col, 0, "Risk", text_color=txtKey, text_size=tSize, bgcolor=bgKey, tooltip=strategyTooltip, text_halign=text.align_center)
            table.cell(infoTable, col, 1, riskAbbrev, text_color=riskColor, text_size=tSize, bgcolor=bgRisk, text_halign=text.align_center)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â• FIXED: Added explicit size guards to prevent index out of bounds â•â•â•
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
magneticPullActive = false
sz = array.size(gapBoxes)

// â•â•â• FIX: Only enter loop if array has elements â•â•â•
if sz > 0 and enableMagneticLevels
    maxIdx = math.min(sz - 1, 10)
    for i = 0 to maxIdx
        if i < sz  // Extra safety check
            bx = array.get(gapBoxes, i)
            zTop = box.get_top(bx)
            zBot = box.get_bottom(bx)
            pull = 0.0
            magneticRangePriceTmp = atr14 * magneticRange
            distanceToZoneTmp = close > zTop ? (close - zTop) : close < zBot ? (zBot - close) : 0.0
            if distanceToZoneTmp < magneticRangePriceTmp and distanceToZoneTmp > 0
                pull := math.pow(1 - (distanceToZoneTmp / magneticRangePriceTmp), magneticDecay) * magneticStrength * 10.0
            if pull > 0.7
                magneticPullActive := true
                break

divTouchAlert = false

// â•â•â• FIX: Only enter loop if array has elements and divergence enabled â•â•â•
if enableRealtimeDivergence and sz > 0 and array.size(hasDivergence) > 0
    maxIdx = math.min(sz - 1, 10)
    for i = 0 to maxIdx
        if i < array.size(hasDivergence) and i < sz  // Extra safety checks
            if array.get(hasDivergence, i)
                bx = array.get(gapBoxes, i)
                t  = box.get_top(bx)
                b  = box.get_bottom(bx)
                if (low <= t and high >= b)
                    divTouchAlert := true
                    break

alertcondition(magneticPullActive and enableMagneticLevels, "Magnetic Zone Pull", "Price entering magnetic field of strong zone")
alertcondition(bullFVG and bullStrengthScore > 80, "Strong Bullish FVG", "High-strength bullish FVG detected")
alertcondition(bearFVG and bearStrengthScore > 80, "Strong Bearish FVG", "High-strength bearish FVG detected")
alertcondition(divTouchAlert, "Divergence at Zone", "Real-time divergence detected as price touches zone")
