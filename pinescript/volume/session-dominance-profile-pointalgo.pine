// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//@version=5
indicator("Session Dominance Profile [Pointalgo]", "Session Profile (pointalgo)", overlay=true, max_lines_count=500)

// ═══════════════════════════════════════════════════════════════
// 1. SETTINGS
// ═══════════════════════════════════════════════════════════════
i_len       = input.int(300, "Lookback", minval=50)
i_bins      = input.int(60, "Resolution", minval=10)
i_fixed_wid = input.int(200, "Fixed Width (Bars)", minval=10) 
i_offset    = input.int(150, "Offset (Bars)", minval=0)
i_direction = input.string("Right to Left", "Profile Direction", options=["Left to Right", "Right to Left"])

// Session Hours (UTC) - Simplified defaults
i_asia_start = 0, i_asia_end = 8
i_lon_start  = 8, i_lon_end  = 13
// NY starts at 13 UTC (approx)

// ═══════════════════════════════════════════════════════════════
// 2. LOGIC
// ═══════════════════════════════════════════════════════════════
float highest_p = ta.highest(high, i_len)
float lowest_p  = ta.lowest(low, i_len)
float range_p   = highest_p - lowest_p

var line[] lines = array.new_line()
var label info   = label.new(na, na, "", style=label.style_label_left, textcolor=color.white)

if barstate.islast
    int sz = array.size(lines)
    if sz > 0
        for i = 0 to sz - 1
            line.delete(array.get(lines, i))
        array.clear(lines)
    label.delete(info)

    float step = range_p / i_bins
    
    // We need 3 buckets per level
    float[] asia_bins  = array.new_float(i_bins, 0.0) 
    float[] lon_bins   = array.new_float(i_bins, 0.0) 
    float[] ny_bins    = array.new_float(i_bins, 0.0) 
    float[] total_bins = array.new_float(i_bins, 0.0)
    
    float max_total = 0.0

    // ─── BINNING BY TIME ───
    for i = 0 to i_len - 1
        float p = close[i]
        float v = volume[i]
        int h   = hour(time[i], "UTC") // Get hour in UTC
        
        if not na(p) and not na(v)
            int bin_idx = math.floor((p - lowest_p) / step)
            bin_idx := bin_idx >= i_bins ? i_bins - 1 : bin_idx < 0 ? 0 : bin_idx
            
            // Add to Total
            float cur_tot = array.get(total_bins, bin_idx) + v
            array.set(total_bins, bin_idx, cur_tot)
            if cur_tot > max_total 
                max_total := cur_tot
            
            // Add to Session Bucket
            if h >= i_asia_start and h < i_asia_end
                array.set(asia_bins, bin_idx, array.get(asia_bins, bin_idx) + v)
            else if h >= i_lon_start and h < i_lon_end
                array.set(lon_bins, bin_idx, array.get(lon_bins, bin_idx) + v)
            else
                array.set(ny_bins, bin_idx, array.get(ny_bins, bin_idx) + v)

    // ─── PLOTTING ───
    if max_total > 0
        int base_x = bar_index + i_offset
        
        for b = 0 to i_bins - 1
            float tot = array.get(total_bins, b)
            float a   = array.get(asia_bins, b)
            float l   = array.get(lon_bins, b)
            float n   = array.get(ny_bins, b)
            
            int w = math.round((tot / max_total) * i_fixed_wid)
            w := w < 1 and tot > 0 ? 1 : w
            
            float p_lvl = lowest_p + (step * b) + (step/2)
            
            // WINNER TAKES ALL COLORING
            color c = color.gray
            if a > l and a > n
                c := #ffeb3b // Asia = Yellow
            else if l > a and l > n
                c := #2962ff // London = Blue
            else
                c := #f50057 // NY = Red/Pink
                
            if w > 0
                // Handle direction based on input
                int x1 = base_x
                int x2 = i_direction == "Left to Right" ? base_x + w : base_x - w
                line.new(x1, p_lvl, x2, p_lvl, color=c, width=2)

        // Legend Label
        string txt = "DOMINANCE\nAggressive Session:\nYellow: Asia\nBlue: London\nRed: NY"
        label.new(base_x, highest_p, txt, color=color.black, style=label.style_label_down, textcolor=color.white, size=size.small)
