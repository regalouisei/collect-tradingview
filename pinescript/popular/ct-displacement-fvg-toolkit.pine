//@version=6
indicator("[CT] Displacement FVG Toolkit", overlay=true,
     max_lines_count=500, max_labels_count=500, max_boxes_count=500)

//==================================================================================================
// CONST COLORS (avoid undeclared identifiers like color.pink)
//==================================================================================================
const color CT_PINK = color.rgb(255, 105, 180)

//==================================================================================================
// INPUTS
//==================================================================================================

//--------------------------- Displacement ---------------------------------
grpDisp = "Displacement"
dispLookback  = input.int(5, "Displacement lookback (avg size)", minval=1, group=grpDisp)
dispFactor    = input.float(1.5, "Displacement factor", minval=0.1, step=0.1, group=grpDisp)
useBodySize   = input.bool(true, "Use body size (true) or full range (false)", group=grpDisp)

colorDispBars = input.bool(true, "Bar Color (displacement bars)", group=grpDisp)
bullBarCol    = input.color(color.new(color.lime, 0), "Color 0 (bull)", group=grpDisp)
bearBarCol    = input.color(color.new(color.red,  0), "Color 1 (bear)", group=grpDisp)

showDispMarks = input.bool(true, "Show displacement markers", group=grpDisp)
bullDispMarkC = input.color(color.new(color.lime, 0), "Bullish displacement", group=grpDisp)
bearDispMarkC = input.color(color.new(color.red,  0), "Bearish displacement", group=grpDisp)

//--------------------------- Structure Break Filter ---------------------------------
grpSB = "Structure Filter"
sbLookback      = input.int(5, "Structure break lookback", minval=1, group=grpSB)
requireStructBr = input.bool(true, "Require structure break?", group=grpSB)
structBreakType = input.string("Close", "Structure break uses", options=["Close","Wick"], group=grpSB)

//--------------------------- FVG ---------------------------------
grpFVG = "FVG"
showFvg       = input.bool(true, "Show 3-candle FVGs", group=grpFVG)
extendFvg     = input.bool(true, "Extend FVGs right", group=grpFVG)
extendBars    = input.int(250, "Extend length (bars)", minval=0, group=grpFVG, tooltip="How far to extend from the current candle. 0 = end on current candle.")
hideMitigated = input.bool(false, "Hide mitigated FVGs", group=grpFVG)
maxFvgs       = input.int(60, "Max FVGs kept", minval=5, maxval=400, group=grpFVG)

bullFvgBorder = input.color(color.new(color.teal, 0), "Bull FVG border", group=grpFVG)
bullFvgBg     = input.color(color.new(color.teal, 85), "Bull FVG background", group=grpFVG)
bearFvgBorder = input.color(color.new(color.red, 0), "Bear FVG border", group=grpFVG)
bearFvgBg     = input.color(color.new(color.red, 85), "Bear FVG background", group=grpFVG)

//--------------------------- Reload Zones (from FVG) ---------------------------------
grpSn = "Reload Zones (FVG)"
showSniper   = input.bool(true, "Show Reload Zones (from FVG)", group=grpSn)
snBorderBull = input.color(color.new(color.orange, 0), "Bull Reload border", group=grpSn)
snBgBull     = input.color(color.new(color.orange, 85), "Bull Reload background", group=grpSn)
snBorderBear = input.color(color.new(color.orange, 0), "Bear Reload border", group=grpSn)
snBgBear     = input.color(color.new(color.orange, 85), "Bear Reload background", group=grpSn)
showSnStop   = input.bool(true, "Show Invalidation line", group=grpSn)
snStopCol    = input.color(color.new(color.gray, 0), "Invalidation line color", group=grpSn)
snStopWidth  = input.int(2, "Invalidation line width", minval=1, maxval=5, group=grpSn)

//--------------------------- Dealing Range (Premium/Discount) ---------------------------------
grpDR = "Dealing Range"
showDR     = input.bool(true, "Show Premium/Discount dealing range", group=grpDR)
drLen      = input.int(50, "Dealing range lookback", minval=5, group=grpDR)
showDRHi   = input.bool(true, "DR High", group=grpDR)
showDRLo   = input.bool(true, "DR Low", group=grpDR)
showDRMid  = input.bool(true, "DR Mid 50%", group=grpDR)
showPD62   = input.bool(false, "PD 62%", group=grpDR)
showPD38   = input.bool(false, "PD 38%", group=grpDR)
drHighCol  = input.color(color.new(color.gray, 0), "DR High color", group=grpDR)
drLowCol   = input.color(color.new(color.gray, 0), "DR Low color", group=grpDR)
drMidCol   = input.color(color.new(color.blue, 0), "DR Mid color", group=grpDR)
pd62Col    = input.color(color.new(CT_PINK, 0), "PD 62% color", group=grpDR)
pd38Col    = input.color(color.new(color.aqua, 0), "PD 38% color", group=grpDR)

fillPD          = input.bool(true, "Fill Premium/Discount", group=grpDR)
premiumFillCol  = input.color(color.new(color.red, 92), "Premium fill", group=grpDR)
discountFillCol = input.color(color.new(color.lime, 92), "Discount fill", group=grpDR)

//--------------------------- BOS / CHOCH ---------------------------------
grpMS = "BOS / CHOCH"
showMS        = input.bool(true, "Show BOS/CHOCH", group=grpMS)
msDisplayMode = input.string("Lines", "Display", options=["Lines","Labels","Both"], group=grpMS)
msSwingLen    = input.int(5, "Swing length", minval=1, group=grpMS)
msBreakType   = input.string("Close", "Break type", options=["Close","Wick"], group=grpMS)
keepBosLines  = input.int(50, "Keep last N structure lines", minval=5, maxval=200, group=grpMS)

msLineWidth   = input.int(2, "Line width", minval=1, maxval=5, group=grpMS)
msLineStyleIn = input.string("Solid", "Line style", options=["Solid","Dashed","Dotted"], group=grpMS)
msBullCol     = input.color(color.new(color.lime, 0), "Bull structure line color", group=grpMS)
msBearCol     = input.color(color.new(color.red,  0), "Bear structure line color", group=grpMS)

msLineStyle = msLineStyleIn == "Solid" ? line.style_solid : msLineStyleIn == "Dotted" ? line.style_dotted : line.style_dashed

//==================================================================================================
// DISPLACEMENT + STRUCTURE FILTER
//==================================================================================================
sz   = useBodySize ? math.abs(close - open) : (high - low)
avgS = ta.sma(sz, dispLookback)

isDisp   = not na(avgS) and sz > avgS * dispFactor
bullDisp = isDisp and close > open
bearDisp = isDisp and close < open

sbHigh = ta.highest(high[1], sbLookback)
sbLow  = ta.lowest(low[1], sbLookback)

bullSB = structBreakType == "Close" ? (close > sbHigh) : (high > sbHigh)
bearSB = structBreakType == "Close" ? (close < sbLow)  : (low  < sbLow)

bullDispOK = requireStructBr ? (bullDisp and bullSB) : bullDisp
bearDispOK = requireStructBr ? (bearDisp and bearSB) : bearDisp

plotshape(showDispMarks and bullDispOK, title="Bullish Displacement", style=shape.triangleup, location=location.belowbar, size=size.tiny, color=bullDispMarkC, text="B")
plotshape(showDispMarks and bearDispOK, title="Bearish Displacement", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=bearDispMarkC, text="S")

barcolor(colorDispBars ? (bullDispOK ? bullBarCol : bearDispOK ? bearBarCol : na) : na)

//==================================================================================================
// DEALING RANGE (PREMIUM / DISCOUNT)
//==================================================================================================
drHigh = ta.highest(high, drLen)
drLow  = ta.lowest(low, drLen)
drMid  = (drHigh + drLow) * 0.5
pd62   = drLow + (drHigh - drLow) * 0.618
pd38   = drLow + (drHigh - drLow) * 0.382

pHi  = plot(showDR and showDRHi  ? drHigh : na, "DR High",    color=drHighCol, style=plot.style_linebr, linewidth=2)
pLo  = plot(showDR and showDRLo  ? drLow  : na, "DR Low",     color=drLowCol,  style=plot.style_linebr, linewidth=2)
pMid = plot(showDR and showDRMid ? drMid  : na, "DR Mid 50%", color=drMidCol,  style=plot.style_linebr, linewidth=2)
_    = plot(showDR and showPD62  ? pd62   : na, "PD 62%",     color=pd62Col,   style=plot.style_linebr, linewidth=1)
_2   = plot(showDR and showPD38  ? pd38   : na, "PD 38%",     color=pd38Col,   style=plot.style_linebr, linewidth=1)

premFill = (showDR and fillPD) ? premiumFillCol : na
discFill = (showDR and fillPD) ? discountFillCol : na
fill(pHi,  pMid, color=premFill)
fill(pMid, pLo,  color=discFill)

//==================================================================================================
// FVG + RELOAD ZONES (BOX OBJECTS)
//==================================================================================================
var array<box>  fvgBoxes  = array.new_box()
var array<bool> fvgIsBull = array.new_bool()
var array<bool> fvgActive = array.new_bool()

var array<box>  snBoxes   = array.new_box()
var array<line> snStops   = array.new_line()
var array<bool> snActive  = array.new_bool()

f_trimFvgs() =>
    while array.size(fvgBoxes) > maxFvgs
        bxOld = array.shift(fvgBoxes)
        _a    = array.shift(fvgIsBull)
        _b    = array.shift(fvgActive)
        if not na(bxOld)
            box.delete(bxOld)

        snbOld = array.shift(snBoxes)
        stpOld = array.shift(snStops)
        _c     = array.shift(snActive)
        if not na(snbOld)
            box.delete(snbOld)
        if not na(stpOld)
            line.delete(stpOld)

// Bull FVG: low > high[2]
// Bear FVG: high < low[2]
bullFvgNew = showFvg and bullDispOK and not na(high[2]) and low > high[2]
bearFvgNew = showFvg and bearDispOK and not na(low[2])  and high < low[2]

if bullFvgNew
    top_ = low
    bot_ = high[2]
    bx = box.new(left=bar_index-2, top=top_, right=bar_index, bottom=bot_, xloc=xloc.bar_index, border_color=bullFvgBorder, bgcolor=bullFvgBg)
    array.push(fvgBoxes, bx), array.push(fvgIsBull, true), array.push(fvgActive, true)

    if showSniper
        mid_ = (top_ + bot_) * 0.5
        snb = box.new(left=bar_index-2, top=top_, right=bar_index, bottom=mid_, xloc=xloc.bar_index, border_color=snBorderBull, bgcolor=snBgBull)
        stp = showSnStop ? line.new(x1=bar_index-2, y1=bot_, x2=bar_index, y2=bot_, xloc=xloc.bar_index, extend=extend.none, color=snStopCol, width=snStopWidth) : na
        array.push(snBoxes, snb), array.push(snStops, stp), array.push(snActive, true)
    else
        array.push(snBoxes, na), array.push(snStops, na), array.push(snActive, false)

    f_trimFvgs()

if bearFvgNew
    top_ = low[2]
    bot_ = high
    bx = box.new(left=bar_index-2, top=top_, right=bar_index, bottom=bot_, xloc=xloc.bar_index, border_color=bearFvgBorder, bgcolor=bearFvgBg)
    array.push(fvgBoxes, bx), array.push(fvgIsBull, false), array.push(fvgActive, true)

    if showSniper
        mid_ = (top_ + bot_) * 0.5
        snb = box.new(left=bar_index-2, top=mid_, right=bar_index, bottom=bot_, xloc=xloc.bar_index, border_color=snBorderBear, bgcolor=snBgBear)
        stp = showSnStop ? line.new(x1=bar_index-2, y1=top_, x2=bar_index, y2=top_, xloc=xloc.bar_index, extend=extend.none, color=snStopCol, width=snStopWidth) : na
        array.push(snBoxes, snb), array.push(snStops, stp), array.push(snActive, true)
    else
        array.push(snBoxes, na), array.push(snStops, na), array.push(snActive, false)

    f_trimFvgs()

// ----- UPDATE EXISTING FVGs / RELOAD OBJECTS (GUARDED: no -1 index) -----
nFvg = array.size(fvgBoxes)
if nFvg > 0
    for i = nFvg - 1 to 0
        bx = array.get(fvgBoxes, i)
        if not na(bx) and array.get(fvgActive, i)
            isBull_  = array.get(fvgIsBull, i)
            newRight = extendFvg ? (bar_index + extendBars) : bar_index
            box.set_right(bx, newRight)

            topv = box.get_top(bx)
            botv = box.get_bottom(bx)
            mitigated = isBull_ ? (low <= botv) : (high >= topv)

            if mitigated
                if hideMitigated
                    box.delete(bx)
                    array.remove(fvgBoxes, i)
                    array.remove(fvgIsBull, i)
                    array.remove(fvgActive, i)

                    snb = array.remove(snBoxes, i)
                    stp = array.remove(snStops, i)
                    _   = array.remove(snActive, i)
                    if not na(snb)
                        box.delete(snb)
                    if not na(stp)
                        line.delete(stp)
                else
                    box.set_right(bx, bar_index)
                    array.set(fvgActive, i, false)

                    snb = array.get(snBoxes, i)
                    stp = array.get(snStops, i)
                    if not na(snb)
                        box.set_right(snb, bar_index)
                    if not na(stp)
                        line.set_x2(stp, bar_index)
                    array.set(snActive, i, false)
            else
                snb = array.get(snBoxes, i)
                stp = array.get(snStops, i)
                if showSniper and array.get(snActive, i)
                    if not na(snb)
                        box.set_right(snb, newRight)
                    if not na(stp)
                        line.set_x2(stp, newRight)

//==================================================================================================
// BOS / CHOCH LINES (STOP AT BREAK) + KEEP LAST N
//==================================================================================================
var array<line> msLines = array.new_line()
var line activeHighLine = na
var line activeLowLine  = na

ph = ta.pivothigh(high, msSwingLen, msSwingLen)
pl = ta.pivotlow(low,  msSwingLen, msSwingLen)
pivotX = bar_index - msSwingLen

var float lastSwingHigh = na
var float lastSwingLow  = na
var int msState = 0

f_pushMSLine(ln) =>
    array.push(msLines, ln)
    while array.size(msLines) > keepBosLines
        oldLn = array.shift(msLines)
        if not na(oldLn)
            line.delete(oldLn)

if showMS and not na(ph)
    lastSwingHigh := ph
    if (msDisplayMode == "Lines" or msDisplayMode == "Both")
        if not na(activeHighLine)
            line.set_x2(activeHighLine, pivotX)
            line.set_extend(activeHighLine, extend.none)
        activeHighLine := line.new(x1=pivotX, y1=ph, x2=bar_index, y2=ph, xloc=xloc.bar_index, extend=extend.right,
             color=msBullCol, style=msLineStyle, width=msLineWidth)
        f_pushMSLine(activeHighLine)

if showMS and not na(pl)
    lastSwingLow := pl
    if (msDisplayMode == "Lines" or msDisplayMode == "Both")
        if not na(activeLowLine)
            line.set_x2(activeLowLine, pivotX)
            line.set_extend(activeLowLine, extend.none)
        activeLowLine := line.new(x1=pivotX, y1=pl, x2=bar_index, y2=pl, xloc=xloc.bar_index, extend=extend.right,
             color=msBearCol, style=msLineStyle, width=msLineWidth)
        f_pushMSLine(activeLowLine)

breakUp   = showMS and not na(lastSwingHigh) and (msBreakType == "Close" ? close > lastSwingHigh : high > lastSwingHigh)
breakDown = showMS and not na(lastSwingLow)  and (msBreakType == "Close" ? close < lastSwingLow  : low  < lastSwingLow)

isChochUp   = breakUp   and msState == -1
isBosUp     = breakUp   and msState != -1
isChochDown = breakDown and msState == 1
isBosDown   = breakDown and msState != 1

if breakUp
    msState := 1
if breakDown
    msState := -1

if (msDisplayMode == "Lines" or msDisplayMode == "Both")
    if breakUp and not na(activeHighLine)
        line.set_x2(activeHighLine, bar_index)
        line.set_extend(activeHighLine, extend.none)
        activeHighLine := na
    if breakDown and not na(activeLowLine)
        line.set_x2(activeLowLine, bar_index)
        line.set_extend(activeLowLine, extend.none)
        activeLowLine := na

//==================================================================================================
// BOS / CHOCH LABELS (GLOBAL SCOPE)
//==================================================================================================
showLabels = showMS and (msDisplayMode == "Labels" or msDisplayMode == "Both")

plotshape(showLabels and isBosUp,     title="BOS Up",     style=shape.labelup,   location=location.belowbar,
     color=color.new(color.lime, 0), text="BOS", textcolor=color.white, size=size.tiny)

plotshape(showLabels and isBosDown,   title="BOS Down",   style=shape.labeldown, location=location.abovebar,
     color=color.new(color.red,  0), text="BOS", textcolor=color.white, size=size.tiny)

plotshape(showLabels and isChochUp,   title="CHOCH Up",   style=shape.labelup,   location=location.belowbar,
     color=color.new(color.lime, 0), text="CH",  textcolor=color.white, size=size.tiny)

plotshape(showLabels and isChochDown, title="CHOCH Down", style=shape.labeldown, location=location.abovebar,
     color=color.new(color.red,  0), text="CH",  textcolor=color.white, size=size.tiny)


//==================================================================================================
// ADD-ON: CISD MTF + Candle coloring option (adds only; no removals above)
//==================================================================================================

//======================== INPUTS ========================
grpCISDCalc = "CISD — Calculations"
cisdEnable = input.bool(true, "Enable CISD", group=grpCISDCalc)

tolerence = input.float(0.7, "Noise Filter", group=grpCISDCalc, tooltip="Determines which levels to use as CISD triggers. A larger setting results in less noise.", maxval=1, minval=0, step=0.1)
len = input.int(12, "Swing Period", group=grpCISDCalc, tooltip="Period used to detect swing points. Larger values detect longer-term swings.", minval=1)
expiry_bars = input.int(100, "Expiry Bars", group=grpCISDCalc, tooltip="Bars after which old liquidity lines stop updating.", minval=1)
liquidity_lookback = input.int(10, "Liquidity Lookback", group=grpCISDCalc, tooltip="Lookback to check if opposing liquidity was wicked before a CISD.", minval=1)

grpCISDAp = "CISD — Appearance"
const color DEF_BULL = #00ffbb
const color DEF_BEAR = #ff1100
green = input.color(DEF_BULL, title="Bullish Colour", group=grpCISDAp, tooltip="Color used for bullish visuals.")
red   = input.color(DEF_BEAR, title="Bearish Colour", group=grpCISDAp, tooltip="Color used for bearish visuals.")
t1 = input.int(90, "Candle Body Transparency", maxval=100, minval=0, group=grpCISDAp)
t2 = input.int(40, "Candle Wick/Border Transparency", maxval=100, minval=0, group=grpCISDAp)
hide_expired_levels = input.bool(true, "Hide Expired Levels", group=grpCISDAp, tooltip="Delete liquidity levels once they exceed the expiry bar threshold.")
hide_mitigated_levels = input.bool(false, "Hide Mitigated Levels", group=grpCISDAp, tooltip="Delete liquidity levels as soon as price mitigates them.")
showLiquidityLines = input.bool(true, "Show Liquidity Lines (swing highs/lows)", group=grpCISDAp)

grpCT = "CISD — Current TF Extensions"
ctExtendOn      = input.bool(true, "Extend MOST RECENT CT CISD levels past current bar", group=grpCT)
ctExtendCount   = input.int(3, "How many MOST RECENT CT CISDs extend", minval=0, maxval=100, group=grpCT)
ctExtendXOffset = input.int(10, "Extend to the RIGHT (bars past last candle)", minval=0, maxval=500, group=grpCT,
     tooltip="For the most recent X CISD levels, the line will end at (bar_index + this offset).\nNo gap, because we extend the original line.")
ctKeepMax       = input.int(120, "How many CT CISD levels to keep total", minval=1, maxval=300, group=grpCT,
     tooltip="Hard cap to prevent hitting TradingView max_lines_count. Increase carefully.")

grpMTF = "CISD — MTF (Higher Timeframe CISD)"
showHTF          = input.bool(false, "Show HTF CISD", group=grpMTF)
htfTf            = input.timeframe("60", "HTF Timeframe", group=grpMTF)
htfConfirmedOnly = input.bool(true, "Confirmed HTF only", group=grpMTF, tooltip="ON: HTF CISD prints only when the HTF candle closes.\nOFF: HTF CISD may update while the HTF candle is building.")
htfMaxLines      = input.int(50, "Max HTF CISD Lines", minval=1, maxval=200, group=grpMTF)
htfLineWidth     = input.int(2, "HTF Line Width", minval=1, maxval=5, group=grpMTF)
useHTFTrendForCandles = input.bool(false, "Use HTF trend for candle coloring", group=grpMTF)
showHTFMarkers   = input.bool(true, "Show HTF markers (▲/▼)", group=grpMTF)
htfLineStyleIn   = input.string("Dashed", "HTF Line Style", options=["Solid","Dashed","Dotted"], group=grpMTF)
htfExtendRight   = input.bool(true, "Extend HTF Lines Right", group=grpMTF)
showHTFLabel     = input.bool(true, "Show HTF Label", group=grpMTF)

htfLabelBg         = input.color(color.new(color.black, 70), "HTF Label Background", group=grpMTF)
useChartText       = input.bool(true, "HTF Label Text = Chart Theme", group=grpMTF)
htfLabelText       = input.color(color.white, "HTF Label Text Color", group=grpMTF)
htfLabelSizeIn     = input.string("Tiny", "HTF Label Size", options=["Tiny","Small","Normal","Large","Huge"], group=grpMTF)
htfLabelXOffsetBars= input.int(15, "HTF Label X-Offset (bars)", minval=0, maxval=500, group=grpMTF,
     tooltip="Moves the HTF label to the right by this many bars.")

grpCandle = "CISD — Candle Coloring"
candleColorMode = input.string("Off", "Candle Coloring", options=["Off","Overlay (plotcandle)","Barcolor (no overlay)"], group=grpCandle,
     tooltip="Overlay draws recolored candles using plotcandle.\nBarcolor recolors the chart candles without drawing an extra candle layer.")

htfLineStyle = htfLineStyleIn == "Solid" ? line.style_solid : htfLineStyleIn == "Dotted" ? line.style_dotted : line.style_dashed
htfLabelSize = switch htfLabelSizeIn
    "Tiny"   => size.tiny
    "Small"  => size.small
    "Normal" => size.normal
    "Large"  => size.large
    => size.huge

f_tfPretty(tfStr) =>
    n = str.tonumber(tfStr)
    if not na(n)
        nInt = int(n)
        if nInt < 60
            str.tostring(nInt) + " min"
        else
            (nInt % 60) == 0 ? (str.tostring(int(nInt / 60)) + " hr") : (str.tostring(nInt) + " min")
    else
        tfStr

//======================== HTF CISD ENGINE (SERIES ONLY) ========================
f_cisd_htf(_tolerence) =>
    var array<float> bear_potential = array.new_float()
    var array<float> bull_potential = array.new_float()
    var int trend_htf = 0

    int cisd_htf = 0
    float origin_lvl_htf = na
    int origin_time_htf = na
    float origin_idx = na

    if close[1] < open[1] and close > open
        array.unshift(bear_potential, float(bar_index))
        array.unshift(bear_potential, open)

    if close[1] > open[1] and close < open
        array.unshift(bull_potential, float(bar_index))
        array.unshift(bull_potential, open)

    if array.size(bear_potential) > 0
        inloop = true
        while inloop
            if close < array.get(bear_potential, 0)
                highest = 0.0
                originIdxTmp = int(array.get(bear_potential, 1))

                for i = 0 to bar_index - originIdxTmp
                    if close[i] > highest
                        highest := close[i]

                running = true
                init = bar_index - originIdxTmp + 1
                top = 0.0

                while running
                    if close[init] < open[init]
                        top := open[init]
                        init += 1
                    else
                        running := false

                if (highest - array.get(bear_potential, 0)) / (top - array.get(bear_potential, 0)) > _tolerence
                    origin_lvl_htf := array.get(bear_potential, 0)
                    origin_idx := float(originIdxTmp)
                    array.clear(bear_potential)
                    cisd_htf := 1
                    inloop := false
                else
                    array.shift(bear_potential)
                    array.shift(bear_potential)
                    if array.size(bear_potential) == 0
                        inloop := false
            else
                inloop := false

    if array.size(bull_potential) > 0
        inloop = true
        while inloop
            if close > array.get(bull_potential, 0)
                lowest = close
                originIdxTmp = int(array.get(bull_potential, 1))

                for i = 0 to bar_index - originIdxTmp
                    if close[i] < lowest
                        lowest := close[i]

                running = true
                init = bar_index - originIdxTmp + 1
                bottom = 0.0

                while running
                    if close[init] > open[init]
                        bottom := open[init]
                        init += 1
                    else
                        running := false

                if (array.get(bull_potential, 0) - lowest) / (array.get(bull_potential, 0) - bottom) > _tolerence
                    origin_lvl_htf := array.get(bull_potential, 0)
                    origin_idx := float(originIdxTmp)
                    array.clear(bull_potential)
                    cisd_htf := 2
                    inloop := false
                else
                    array.shift(bull_potential)
                    array.shift(bull_potential)
                    if array.size(bull_potential) == 0
                        inloop := false
            else
                inloop := false

    if cisd_htf == 1
        trend_htf := -1
    if cisd_htf == 2
        trend_htf := 1

    if not na(origin_idx)
        barsBack = bar_index - int(origin_idx)
        origin_time_htf := time[barsBack]

    [cisd_htf, origin_lvl_htf, origin_time_htf, trend_htf, time, barstate.isconfirmed]

// Pull HTF series to current chart (KEEP ON ONE LINE)
[htfCisd, htfOriginLvl, htfOriginTime, htfTrend, htfBarTime, htfConfirmed] = request.security(syminfo.tickerid, htfTf, f_cisd_htf(tolerence), barmerge.gaps_off, barmerge.lookahead_off)

//======================== CURRENT TF CISD ENGINE ========================
pivlow  = ta.pivotlow(len, len)
pivhigh = ta.pivothigh(len, len)

var array<line> swinghighs = array.new_line()
var array<line> swinglows  = array.new_line()

if cisdEnable and not na(pivhigh)
    swinghighs.unshift(line.new(bar_index-len, high[len], bar_index, high[len], color=color.new(chart.fg_color, 50)))
if cisdEnable and not na(pivlow)
    swinglows.unshift(line.new(bar_index-len, low[len], bar_index, low[len], color=color.new(chart.fg_color, 50)))

var float last_wicked_high_level = na
var float last_wicked_low_level  = na

wicked_high = false
wicked_low  = false

if cisdEnable and array.size(swinghighs) > 0
    for i = array.size(swinghighs) - 1 to 0
        l = array.get(swinghighs, i)
        if bar_index - line.get_x1(l) < expiry_bars
            lvl = line.get_y1(l)
            line.set_x2(l, bar_index)
            if high >= lvl and barstate.isconfirmed
                if hide_mitigated_levels
                    line.delete(l)
                array.remove(swinghighs, i)
                wicked_high := true
                last_wicked_high_level := lvl
        else
            if hide_expired_levels
                line.delete(l)
                array.remove(swinghighs, i)

if cisdEnable and array.size(swinglows) > 0
    for i = array.size(swinglows) - 1 to 0
        l = array.get(swinglows, i)
        if bar_index - line.get_x1(l) < expiry_bars
            lvl = line.get_y1(l)
            line.set_x2(l, bar_index)
            if low <= lvl and barstate.isconfirmed
                if hide_mitigated_levels
                    line.delete(l)
                array.remove(swinglows, i)
                wicked_low := true
                last_wicked_low_level := lvl
        else
            if hide_expired_levels
                line.delete(l)
                array.remove(swinglows, i)

while array.size(swinghighs) > 100
    line.delete(array.pop(swinghighs))

while array.size(swinglows) > 100
    line.delete(array.pop(swinglows))

bars_since_high = ta.barssince(wicked_high)
bars_since_low  = ta.barssince(wicked_low)

var array<float> bear_potential = array.new_float()
var array<float> bull_potential = array.new_float()

if cisdEnable and close[1] < open[1] and close > open
    array.unshift(bear_potential, float(bar_index))
    array.unshift(bear_potential, open)

if cisdEnable and close[1] > open[1] and close < open
    array.unshift(bull_potential, float(bar_index))
    array.unshift(bull_potential, open)

cisd       = 0
origin_lvl = 0.0
origin_idx = 0.0

if cisdEnable and array.size(bear_potential) > 0
    inloop = true
    while inloop
        if close < array.get(bear_potential, 0)
            highest = 0.0
            originIdxTmp = int(array.get(bear_potential, 1))

            for i = 0 to bar_index - originIdxTmp
                if close[i] > highest
                    highest := close[i]

            running = true
            init = bar_index - originIdxTmp + 1
            top = 0.0

            while running
                if close[init] < open[init]
                    top := open[init]
                    init += 1
                else
                    running := false

            if (highest - array.get(bear_potential, 0)) / (top - array.get(bear_potential, 0)) > tolerence
                origin_lvl := array.get(bear_potential, 0)
                origin_idx := array.get(bear_potential, 1)
                array.clear(bear_potential)
                cisd := 1
                inloop := false
            else
                array.shift(bear_potential)
                array.shift(bear_potential)
                if array.size(bear_potential) == 0
                    inloop := false
        else
            inloop := false

if cisdEnable and array.size(bull_potential) > 0
    inloop = true
    while inloop
        if close > array.get(bull_potential, 0)
            lowest = close
            originIdxTmp = int(array.get(bull_potential, 1))

            for i = 0 to bar_index - originIdxTmp
                if close[i] < lowest
                    lowest := close[i]

            running = true
            init = bar_index - originIdxTmp + 1
            bottom = 0.0

            while running
                if close[init] > open[init]
                    bottom := open[init]
                    init += 1
                else
                    running := false

            if (array.get(bull_potential, 0) - lowest) / (array.get(bull_potential, 0) - bottom) > tolerence
                origin_lvl := array.get(bull_potential, 0)
                origin_idx := array.get(bull_potential, 1)
                array.clear(bull_potential)
                cisd := 2
                inloop := false
            else
                array.shift(bull_potential)
                array.shift(bull_potential)
                if array.size(bull_potential) == 0
                    inloop := false
        else
            inloop := false

var int trend = 0
bearish_sweep = false
bullish_sweep = false

//======================== CURRENT TF CISD LINES + EXTENSIONS ========================
var array<line>  ctCisdLines  = array.new_line()
var array<int>   ctCisdX2Orig = array.new_int()

if cisdEnable and cisd == 1
    trend := -1
    ctLn = line.new(x1=int(origin_idx), y1=origin_lvl, x2=bar_index, y2=origin_lvl, xloc=xloc.bar_index, extend=extend.none, color=red, width=3)
    array.unshift(ctCisdLines, ctLn)
    array.unshift(ctCisdX2Orig, bar_index)
    if bars_since_high <= liquidity_lookback and close < last_wicked_high_level
        bearish_sweep := true

if cisdEnable and cisd == 2
    trend := 1
    ctLn = line.new(x1=int(origin_idx), y1=origin_lvl, x2=bar_index, y2=origin_lvl, xloc=xloc.bar_index, extend=extend.none, color=green, width=3)
    array.unshift(ctCisdLines, ctLn)
    array.unshift(ctCisdX2Orig, bar_index)
    if bars_since_low <= liquidity_lookback and close > last_wicked_low_level
        bullish_sweep := true

ctSz = array.size(ctCisdLines)
if cisdEnable and ctSz > 0
    useCount = (ctExtendOn and ctExtendCount > 0) ? math.min(ctExtendCount, ctSz) : 0
    for i = 0 to ctSz - 1
        ln  = array.get(ctCisdLines, i)
        yLv = line.get_y1(ln)
        if ctExtendOn and (i < useCount)
            line.set_x2(ln, bar_index + ctExtendXOffset)
            line.set_y2(ln, yLv)
            line.set_extend(ln, extend.none)
        else
            origX2 = array.get(ctCisdX2Orig, i)
            line.set_x2(ln, origX2)
            line.set_y2(ln, yLv)
            line.set_extend(ln, extend.none)

while array.size(ctCisdLines) > ctKeepMax
    oldLn = array.pop(ctCisdLines)
    line.delete(oldLn)
    if array.size(ctCisdX2Orig) > 0
        array.pop(ctCisdX2Orig)

//======================== VISUALS ========================
plotshape(cisdEnable and bearish_sweep ? high : na, "Bearish CISD with Liquidity Sweep", shape.labeldown, location.abovebar, red, size=size.small, text="▼", textcolor=chart.fg_color)
plotshape(cisdEnable and bullish_sweep ? low  : na, "Bullish CISD with Liquidity Sweep",  shape.labelup,   location.belowbar, green, size=size.small, text="▲", textcolor=chart.fg_color)

plotchar(cisdEnable and not na(pivhigh) ? high[len] : na, "Swing High", "●", location.absolute, red, size=size.tiny, offset=-len)
plotchar(cisdEnable and not na(pivlow)  ? low[len]  : na, "Swing Low",  "●", location.absolute, green, size=size.tiny, offset=-len)

// Optional: visually hide liquidity lines (engine still runs the same)
if cisdEnable and not showLiquidityLines
    if array.size(swinghighs) > 0
        for i = 0 to array.size(swinghighs) - 1
            ln = array.get(swinghighs, i)
            if not na(ln)
                line.set_color(ln, color.new(color.black, 100))
    if array.size(swinglows) > 0
        for i = 0 to array.size(swinglows) - 1
            ln = array.get(swinglows, i)
            if not na(ln)
                line.set_color(ln, color.new(color.black, 100))

//======================== MTF DRAWINGS (OUTSIDE SECURITY) ========================
var array<line>  htfLines  = array.new_line()
var array<label> htfLabels = array.new_label()
var int lastPlottedHtfBarTime = na

htfTriggerBase = cisdEnable and showHTF and (htfCisd == 1 or htfCisd == 2)
htfTrigger = htfConfirmedOnly ? (htfTriggerBase and htfConfirmed) : htfTriggerBase
htfNewEvent = htfTrigger and not na(htfOriginLvl) and not na(htfOriginTime) and (na(lastPlottedHtfBarTime) or htfBarTime != lastPlottedHtfBarTime)

htfText = f_tfPretty(htfTf) + " HTF CISD"
textCol = useChartText ? chart.fg_color : htfLabelText

if htfNewEvent
    htfCol = htfCisd == 1 ? red : green
    ln = line.new(htfOriginTime, htfOriginLvl, time, htfOriginLvl, xloc=xloc.bar_time, extend=htfExtendRight ? extend.right : extend.none, color=htfCol, width=htfLineWidth, style=htfLineStyle)
    array.unshift(htfLines, ln)

    label lb = na
    if showHTFLabel
        lb := label.new(x=bar_index + htfLabelXOffsetBars, y=htfOriginLvl, xloc=xloc.bar_index, style=label.style_label_right, text=htfText, textcolor=textCol, color=htfLabelBg, size=htfLabelSize)
    array.unshift(htfLabels, lb)

    lastPlottedHtfBarTime := htfBarTime

    while array.size(htfLines) > htfMaxLines
        oldLn = array.pop(htfLines)
        line.delete(oldLn)
        if array.size(htfLabels) > 0
            oldLb = array.pop(htfLabels)
            if not na(oldLb)
                label.delete(oldLb)

if cisdEnable and showHTF and array.size(htfLines) > 0 and array.size(htfLabels) > 0
    for i = 0 to array.size(htfLines) - 1
        ln = array.get(htfLines, i)
        if i < array.size(htfLabels)
            lb = array.get(htfLabels, i)
            yLvl = line.get_y1(ln)

            if showHTFLabel
                if na(lb)
                    newLb = label.new(x=bar_index + htfLabelXOffsetBars, y=yLvl, xloc=xloc.bar_index, style=label.style_label_right, text=htfText, textcolor=textCol, color=htfLabelBg, size=htfLabelSize)
                    array.set(htfLabels, i, newLb)
                else
                    label.set_x(lb, bar_index + htfLabelXOffsetBars)
                    label.set_y(lb, yLvl)
                    label.set_text(lb, htfText)
                    label.set_textcolor(lb, textCol)
                    label.set_color(lb, htfLabelBg)
                    label.set_size(lb, htfLabelSize)
            else
                if not na(lb)
                    label.delete(lb)
                    array.set(htfLabels, i, na)

plotshape(cisdEnable and showHTF and showHTFMarkers and htfNewEvent and htfCisd == 1 ? high : na, "HTF Bearish CISD", shape.labeldown, location.abovebar, red, size=size.tiny, text="▼", textcolor=chart.fg_color)
plotshape(cisdEnable and showHTF and showHTFMarkers and htfNewEvent and htfCisd == 2 ? low  : na, "HTF Bullish CISD",  shape.labelup,   location.belowbar, green, size=size.tiny, text="▲", textcolor=chart.fg_color)

//======================== CANDLE COLORING (GLOBAL-SCOPE SAFE) =========================
trendForColor = (useHTFTrendForCandles and cisdEnable and showHTF and not na(htfTrend)) ? htfTrend : trend
candle_body_col = color.from_gradient(t1, 0, 100, trendForColor > 0 ? green : red, chart.bg_color)
candle_wick_col = color.from_gradient(t2, 0, 100, trendForColor > 0 ? green : red, chart.bg_color)

// Overlay candles (plotcandle mode): must be global scope
overlayOn = cisdEnable and candleColorMode == "Overlay (plotcandle)"
o_ = overlayOn ? open  : na
h_ = overlayOn ? high  : na
l_ = overlayOn ? low   : na
c_ = overlayOn ? close : na
plotcandle(o_, h_, l_, c_, "CISD Candles", candle_body_col, candle_wick_col, bordercolor=candle_wick_col)

// Barcolor mode (no extra candles): must be global scope
barModeOn = cisdEnable and candleColorMode == "Barcolor (no overlay)"

// Give displacement barcolor priority (matches existing behavior)
dispCol =
     (colorDispBars and bullDispOK) ? bullBarCol :
     (colorDispBars and bearDispOK) ? bearBarCol :
     na

cisdCol = barModeOn ? (trendForColor > 0 ? green : red) : na
finalCol = not na(dispCol) ? dispCol : cisdCol
barcolor(finalCol)

//======================== ALERTS =========================
alertcondition(cisdEnable and wicked_high, "CISD Swing High Mitigation", "Swing High Mitigated")
alertcondition(cisdEnable and wicked_low,  "CISD Swing Low Mitigation",  "Swing Low Mitigated")
alertcondition(cisdEnable and (cisd == 1), "Bearish Normal CISD", "Bearish Normal CISD Detected")
alertcondition(cisdEnable and (cisd == 2), "Bullish Normal CISD", "Bullish Normal CISD Detected")
alertcondition(cisdEnable and bearish_sweep, "Strong Bearish CISD", "Strong Bearish CISD Detected")
alertcondition(cisdEnable and bullish_sweep, "Strong Bullish CISD", "Strong Bullish CISD Detected")

alertcondition(cisdEnable and showHTF and (not htfConfirmedOnly) and (htfCisd == 1), "HTF Bearish CISD", "HTF Bearish CISD Detected")
alertcondition(cisdEnable and showHTF and (not htfConfirmedOnly) and (htfCisd == 2), "HTF Bullish CISD", "HTF Bullish CISD Detected")
alertcondition(cisdEnable and showHTF and htfConfirmedOnly and htfConfirmed and (htfCisd == 1), "HTF Bearish CISD (Confirmed)", "HTF Bearish CISD Detected (Confirmed)")
alertcondition(cisdEnable and showHTF and htfConfirmedOnly and htfConfirmed and (htfCisd == 2), "HTF Bullish CISD (Confirmed)", "HTF Bullish CISD Detected (Confirmed)")
