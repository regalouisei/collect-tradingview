// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © CodedLevels

//@version=6
indicator("Trend Channels Pro [CodedLevels]", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)


// ─────────────────────────────────────────────────────────────────────────────
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ─────────────────────────────────────────────────────────────────────────────
//  TREND CHANNELS PRO — Multi-Timeframe Trend Structure Engine
//
//  • Regression Trend–style diagonal channels with linefill shading
//  • Full historical channels + live forming channel
//  • Supply & Demand zones with freshness, retests, mitigation
//  • Smart breakout signals from forming channel boundaries
// ─────────────────────────────────────────────────────────────────────────────


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                          INPUTS                                         ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

// ── Essential Trend ─────────────────────────────────────────────────────────
g_ess = "Essential Trend"
i_ess_enable    = input.bool(true, "Enable Essential Trend", group=g_ess)
i_ess_swing     = input.int(30, "Swing Lookback", minval=5, maxval=100, group=g_ess, tooltip="Pivot strength for essential trend legs.")
i_ess_dev_mult  = input.float(2.0, "Channel Width (σ)", minval=0.5, maxval=5.0, step=0.25, group=g_ess)
i_ess_max_ch    = input.int(20, "Max Historical Channels", minval=5, maxval=50, group=g_ess)
i_ess_bull_col  = input.color(color.new(#00C853, 0), "Bullish Channel", group=g_ess)
i_ess_bear_col  = input.color(color.new(#FF1744, 0), "Bearish Channel", group=g_ess)
i_ess_opacity   = input.int(85, "Fill Opacity", minval=60, maxval=96, group=g_ess)
i_ess_line_w    = input.int(1, "Line Width", minval=1, maxval=3, group=g_ess)

// ── Secondary Trend ─────────────────────────────────────────────────────────
g_sec = "Secondary Trend"
i_sec_enable    = input.bool(true, "Enable Secondary Trend", group=g_sec)
i_sec_swing     = input.int(10, "Swing Lookback", minval=3, maxval=50, group=g_sec)
i_sec_dev_mult  = input.float(1.8, "Channel Width (σ)", minval=0.5, maxval=5.0, step=0.25, group=g_sec)
i_sec_max_ch    = input.int(30, "Max Historical Channels", minval=5, maxval=80, group=g_sec)
i_sec_color     = input.color(color.new(#78909C, 0), "Channel Color", group=g_sec)
i_sec_opacity   = input.int(88, "Fill Opacity", minval=60, maxval=96, group=g_sec)
i_sec_line_w    = input.int(1, "Line Width", minval=1, maxval=3, group=g_sec)

// ── Forming Channel ─────────────────────────────────────────────────────────
g_form = "Forming Channel"
i_form_enable   = input.bool(true, "Show Forming Channel", group=g_form)
i_form_ess_col  = input.color(color.new(#FFD600, 0), "Essential Forming Color", group=g_form)
i_form_sec_col  = input.color(color.new(#90A4AE, 0), "Secondary Forming Color", group=g_form)
i_form_opacity  = input.int(90, "Forming Fill Opacity", minval=70, maxval=96, group=g_form)
i_form_style    = input.string("Dashed", "Forming Line Style", options=["Solid", "Dashed", "Dotted"], group=g_form)

// ── Supply & Demand ─────────────────────────────────────────────────────────
g_sd = "Supply & Demand"
i_sd_enable     = input.bool(true, "Enable S&D Zones", group=g_sd)
i_sd_pivot_len  = input.int(15, "Pivot Lookback", minval=5, maxval=50, group=g_sd)
i_sd_merge_atr  = input.float(0.5, "Merge Distance (ATR)", minval=0.1, maxval=3.0, step=0.1, group=g_sd, tooltip="Zones within this ATR distance are merged into a stronger zone.")
i_sd_max_zones  = input.int(8, "Max Zones (per side)", minval=2, maxval=20, group=g_sd)
i_sd_extend     = input.int(50, "Zone Extension (bars)", minval=10, maxval=300, group=g_sd)
i_sd_max_age    = input.int(500, "Max Zone Age (bars)", minval=50, maxval=2000, group=g_sd)
i_sd_max_retests = input.int(3, "Max Retests Before Weak", minval=1, maxval=10, group=g_sd)
i_sd_supply_col = input.color(color.new(#E74C3C, 0), "Supply Color", group=g_sd)
i_sd_demand_col = input.color(color.new(#2ECC71, 0), "Demand Color", group=g_sd)
i_sd_fresh_op   = input.int(82, "Fresh Zone Opacity", minval=50, maxval=95, group=g_sd)
i_sd_tested_op  = input.int(90, "Tested Zone Opacity", minval=70, maxval=97, group=g_sd)

// ── Breakout Signals ────────────────────────────────────────────────────────
g_sig = "Breakout Signals"
i_sig_enable     = input.bool(true, "Enable Breakout Signals", group=g_sig)
i_sig_trend_only = input.bool(true, "With-Trend Only", group=g_sig)
i_sig_min_atr    = input.float(0.1, "Min Penetration (ATR)", minval=0.0, maxval=1.0, step=0.05, group=g_sig, tooltip="Minimum close beyond channel boundary in ATR multiples. Filters marginal breakouts.")
i_sig_vol_filter = input.bool(false, "Volume Confirmation", group=g_sig, tooltip="Require above-average volume on breakout bar.")
i_sig_bull_col   = input.color(color.new(#00E676, 0), "Bullish Signal", group=g_sig)
i_sig_bear_col   = input.color(color.new(#FF5252, 0), "Bearish Signal", group=g_sig)

// ── Visuals ─────────────────────────────────────────────────────────────────
g_vis = "Visuals"
i_show_center  = input.bool(true, "Show Centerlines", group=g_vis)
i_show_info    = input.bool(true, "Show Info Table", group=g_vis)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                    CORE CALCULATIONS                                    ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

atr_val = ta.atr(14)
vol_sma = ta.sma(volume, 20)
vol_ok  = volume > vol_sma

form_line_style = i_form_style == "Dashed" ? line.style_dashed : i_form_style == "Dotted" ? line.style_dotted : line.style_solid


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                REGRESSION CHANNEL DATA TYPE                             ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

type RegChannel
    int     start_bar
    int     end_bar
    float   start_upper
    float   start_mid
    float   start_lower
    float   end_upper
    float   end_mid
    float   end_lower
    float   slope
    float   r_squared
    int     direction
    line    ln_upper
    line    ln_mid
    line    ln_lower
    linefill ch_fill

var array<RegChannel> ess_channels = array.new<RegChannel>()
var array<RegChannel> sec_channels = array.new<RegChannel>()


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║          CHANNEL COMPUTATION — FIXED DIAGONAL REGRESSION                ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

compute_channel(int bar_start, int bar_end, float dev_mult) =>
    int len = bar_end - bar_start + 1
    float sumX = 0.0
    float sumY = 0.0
    float sumXY = 0.0
    float sumX2 = 0.0
    int n = 0
    
    if len > 2
        for j = 0 to len - 1
            int lookback = bar_index - bar_start - j
            if lookback >= 0
                float x = float(j)
                float y = close[lookback]
                sumX  += x
                sumY  += y
                sumXY += x * y
                sumX2 += x * x
                n += 1
    
    float s_mid_start   = na
    float s_mid_end     = na
    float s_upper_start = na
    float s_upper_end   = na
    float s_lower_start = na
    float s_lower_end   = na
    float s_slope       = 0.0
    float s_r2          = 0.0
    
    if n > 2
        float denom = float(n) * sumX2 - sumX * sumX
        if denom != 0
            float b = (float(n) * sumXY - sumX * sumY) / denom
            float a = (sumY - b * sumX) / float(n)
            
            s_slope     := b
            s_mid_start := a
            s_mid_end   := a + b * float(n - 1)
            
            float ss_res = 0.0
            float ss_tot = 0.0
            float mean_y = sumY / float(n)
            
            for j = 0 to len - 1
                int lookback = bar_index - bar_start - j
                if lookback >= 0
                    float x = float(j)
                    float y = close[lookback]
                    float expected = a + b * x
                    ss_res += (y - expected) * (y - expected)
                    ss_tot += (y - mean_y) * (y - mean_y)
            
            float std_dev = math.sqrt(ss_res / float(n))
            float dev = std_dev * dev_mult
            
            s_upper_start := s_mid_start + dev
            s_lower_start := s_mid_start - dev
            s_upper_end   := s_mid_end + dev
            s_lower_end   := s_mid_end - dev
            
            s_r2 := ss_tot != 0 ? math.max(1.0 - ss_res / ss_tot, 0.0) : 0.0
    
    [s_mid_start, s_mid_end, s_upper_start, s_upper_end, s_lower_start, s_lower_end, s_slope, s_r2]


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║               CHANNEL HELPERS                                           ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

delete_channel(RegChannel ch) =>
    if not na(ch.ch_fill)
        linefill.delete(ch.ch_fill)
    if not na(ch.ln_upper)
        line.delete(ch.ln_upper)
    if not na(ch.ln_mid)
        line.delete(ch.ln_mid)
    if not na(ch.ln_lower)
        line.delete(ch.ln_lower)

limit_channels(array<RegChannel> channels, int max_count) =>
    while array.size(channels) > max_count
        RegChannel oldest = array.shift(channels)
        delete_channel(oldest)

draw_channel(RegChannel ch, color col, int opacity, int line_w, bool show_mid) =>
    color line_col = color.new(col, math.max(opacity - 30, 5))
    color fill_col = color.new(col, opacity)
    color mid_col  = color.new(col, math.max(opacity - 15, 10))
    
    if not na(ch.ln_upper)
        line.set_xy1(ch.ln_upper, ch.start_bar, ch.start_upper)
        line.set_xy2(ch.ln_upper, ch.end_bar, ch.end_upper)
        line.set_color(ch.ln_upper, line_col)
        line.set_width(ch.ln_upper, line_w)
    else
        ch.ln_upper := line.new(ch.start_bar, ch.start_upper, ch.end_bar, ch.end_upper, color=line_col, width=line_w)
    
    if not na(ch.ln_lower)
        line.set_xy1(ch.ln_lower, ch.start_bar, ch.start_lower)
        line.set_xy2(ch.ln_lower, ch.end_bar, ch.end_lower)
        line.set_color(ch.ln_lower, line_col)
        line.set_width(ch.ln_lower, line_w)
    else
        ch.ln_lower := line.new(ch.start_bar, ch.start_lower, ch.end_bar, ch.end_lower, color=line_col, width=line_w)
    
    if show_mid
        if not na(ch.ln_mid)
            line.set_xy1(ch.ln_mid, ch.start_bar, ch.start_mid)
            line.set_xy2(ch.ln_mid, ch.end_bar, ch.end_mid)
            line.set_color(ch.ln_mid, mid_col)
            line.set_width(ch.ln_mid, 1)
            line.set_style(ch.ln_mid, line.style_dashed)
        else
            ch.ln_mid := line.new(ch.start_bar, ch.start_mid, ch.end_bar, ch.end_mid, color=mid_col, width=1, style=line.style_dashed)
    
    if not na(ch.ch_fill)
        linefill.delete(ch.ch_fill)
    if not na(ch.ln_upper) and not na(ch.ln_lower)
        ch.ch_fill := linefill.new(ch.ln_upper, ch.ln_lower, fill_col)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║              ESSENTIAL TREND — SWING DETECTION & CHANNELS               ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

ess_ph = ta.pivothigh(high, i_ess_swing, i_ess_swing)
ess_pl = ta.pivotlow(low, i_ess_swing, i_ess_swing)

var int   ess_last_pivot_bar   = na
var int   ess_last_pivot_type  = 0
var int   ess_trend_dir        = 0

// Track pivot prices for structural trend analysis (HH/HL vs LH/LL)
var float ess_prev_high     = na
var float ess_curr_high     = na
var float ess_prev_low      = na
var float ess_curr_low      = na

// Structural trend: compare successive highs and lows
ess_calc_structure() =>
    bool hh = not na(ess_curr_high) and not na(ess_prev_high) and ess_curr_high > ess_prev_high
    bool hl = not na(ess_curr_low) and not na(ess_prev_low) and ess_curr_low > ess_prev_low
    bool lh = not na(ess_curr_high) and not na(ess_prev_high) and ess_curr_high < ess_prev_high
    bool ll = not na(ess_curr_low) and not na(ess_prev_low) and ess_curr_low < ess_prev_low
    
    int dir = 0
    if hh and hl
        dir := 1       // Clear bullish structure
    else if lh and ll
        dir := -1      // Clear bearish structure
    else if hh or hl
        dir := 1       // Leaning bullish
    else if lh or ll
        dir := -1      // Leaning bearish
    dir

if i_ess_enable
    bool new_seg = false
    int seg_start = na
    int seg_end   = na
    int seg_dir   = 0      // Structural leg direction: 1 = low→high, -1 = high→low
    
    if not na(ess_ph)
        int ph_bar = bar_index - i_ess_swing
        float ph_price = high[i_ess_swing]
        
        if not na(ess_last_pivot_bar) and ess_last_pivot_type == -1
            seg_start := ess_last_pivot_bar
            seg_end   := ph_bar
            seg_dir   := 1  // Low → High = bullish leg
            new_seg   := true
        
        // Update pivot high tracking
        ess_prev_high := ess_curr_high
        ess_curr_high := ph_price
        
        ess_last_pivot_bar  := ph_bar
        ess_last_pivot_type := 1
    
    if not na(ess_pl)
        int pl_bar = bar_index - i_ess_swing
        float pl_price = low[i_ess_swing]
        
        if not na(ess_last_pivot_bar) and ess_last_pivot_type == 1
            seg_start := ess_last_pivot_bar
            seg_end   := pl_bar
            seg_dir   := -1  // High → Low = bearish leg
            new_seg   := true
        
        // Update pivot low tracking
        ess_prev_low := ess_curr_low
        ess_curr_low := pl_price
        
        ess_last_pivot_bar  := pl_bar
        ess_last_pivot_type := -1
    
    // Update structural trend direction on any new pivot
    if not na(ess_ph) or not na(ess_pl)
        int ess_struct = ess_calc_structure()
        if ess_struct != 0
            ess_trend_dir := ess_struct
    
    if new_seg and not na(seg_start) and not na(seg_end) and seg_end - seg_start > 5
        [sm_s, sm_e, su_s, su_e, sl_s, sl_e, s_slope, s_r2] = compute_channel(seg_start, seg_end, i_ess_dev_mult)
        
        if not na(sm_s) and not na(sm_e)
            RegChannel ch = RegChannel.new()
            ch.start_bar   := seg_start
            ch.end_bar     := seg_end
            ch.start_mid   := sm_s
            ch.end_mid     := sm_e
            ch.start_upper := su_s
            ch.end_upper   := su_e
            ch.start_lower := sl_s
            ch.end_lower   := sl_e
            ch.slope       := s_slope
            ch.r_squared   := s_r2
            ch.direction   := seg_dir  // Structural direction, not regression slope
            ch.ln_upper    := na
            ch.ln_mid      := na
            ch.ln_lower    := na
            ch.ch_fill     := na
            
            array.push(ess_channels, ch)
            limit_channels(ess_channels, i_ess_max_ch)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║              SECONDARY TREND — SWING DETECTION & CHANNELS               ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

sec_ph = ta.pivothigh(high, i_sec_swing, i_sec_swing)
sec_pl = ta.pivotlow(low, i_sec_swing, i_sec_swing)

var int   sec_last_pivot_bar   = na
var int   sec_last_pivot_type  = 0
var int   sec_trend_dir        = 0

// Track pivot prices for structural trend (HH/HL vs LH/LL)
var float sec_prev_high     = na
var float sec_curr_high     = na
var float sec_prev_low      = na
var float sec_curr_low      = na

sec_calc_structure() =>
    bool hh = not na(sec_curr_high) and not na(sec_prev_high) and sec_curr_high > sec_prev_high
    bool hl = not na(sec_curr_low) and not na(sec_prev_low) and sec_curr_low > sec_prev_low
    bool lh = not na(sec_curr_high) and not na(sec_prev_high) and sec_curr_high < sec_prev_high
    bool ll = not na(sec_curr_low) and not na(sec_prev_low) and sec_curr_low < sec_prev_low
    
    int dir = 0
    if hh and hl
        dir := 1
    else if lh and ll
        dir := -1
    else if hh or hl
        dir := 1
    else if lh or ll
        dir := -1
    dir

if i_sec_enable
    bool new_seg = false
    int seg_start = na
    int seg_end   = na
    int seg_dir   = 0
    
    if not na(sec_ph)
        int ph_bar = bar_index - i_sec_swing
        float ph_price = high[i_sec_swing]
        
        if not na(sec_last_pivot_bar) and sec_last_pivot_type == -1
            seg_start := sec_last_pivot_bar
            seg_end   := ph_bar
            seg_dir   := 1
            new_seg   := true
        
        sec_prev_high := sec_curr_high
        sec_curr_high := ph_price
        
        sec_last_pivot_bar  := ph_bar
        sec_last_pivot_type := 1
    
    if not na(sec_pl)
        int pl_bar = bar_index - i_sec_swing
        float pl_price = low[i_sec_swing]
        
        if not na(sec_last_pivot_bar) and sec_last_pivot_type == 1
            seg_start := sec_last_pivot_bar
            seg_end   := pl_bar
            seg_dir   := -1
            new_seg   := true
        
        sec_prev_low := sec_curr_low
        sec_curr_low := pl_price
        
        sec_last_pivot_bar  := pl_bar
        sec_last_pivot_type := -1
    
    if not na(sec_ph) or not na(sec_pl)
        int sec_struct = sec_calc_structure()
        if sec_struct != 0
            sec_trend_dir := sec_struct
    
    if new_seg and not na(seg_start) and not na(seg_end) and seg_end - seg_start > 3
        [sm_s, sm_e, su_s, su_e, sl_s, sl_e, s_slope, s_r2] = compute_channel(seg_start, seg_end, i_sec_dev_mult)
        
        if not na(sm_s) and not na(sm_e)
            RegChannel ch = RegChannel.new()
            ch.start_bar   := seg_start
            ch.end_bar     := seg_end
            ch.start_mid   := sm_s
            ch.end_mid     := sm_e
            ch.start_upper := su_s
            ch.end_upper   := su_e
            ch.start_lower := sl_s
            ch.end_lower   := sl_e
            ch.slope       := s_slope
            ch.r_squared   := s_r2
            ch.direction   := seg_dir  // Structural direction
            ch.ln_upper    := na
            ch.ln_mid      := na
            ch.ln_lower    := na
            ch.ch_fill     := na
            
            array.push(sec_channels, ch)
            limit_channels(sec_channels, i_sec_max_ch)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                    RENDER HISTORICAL CHANNELS                           ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

if i_ess_enable and array.size(ess_channels) > 0
    for i = 0 to array.size(ess_channels) - 1
        RegChannel ch = array.get(ess_channels, i)
        color ch_col = ch.direction == 1 ? i_ess_bull_col : i_ess_bear_col
        draw_channel(ch, ch_col, i_ess_opacity, i_ess_line_w, i_show_center)

if i_sec_enable and array.size(sec_channels) > 0
    for i = 0 to array.size(sec_channels) - 1
        RegChannel ch = array.get(sec_channels, i)
        draw_channel(ch, i_sec_color, i_sec_opacity, i_sec_line_w, i_show_center)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                  FORMING CHANNEL (LIVE)                                 ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

var line ess_form_upper = na
var line ess_form_mid   = na
var line ess_form_lower = na
var linefill ess_form_fill = na

var line sec_form_upper = na
var line sec_form_mid   = na
var line sec_form_lower = na
var linefill sec_form_fill = na

// Store forming channel boundaries for breakout detection
var float form_sec_upper = na
var float form_sec_lower = na

if i_form_enable and barstate.islast
    // ── Essential forming ───────────────────────────────────────────────
    if i_ess_enable and not na(ess_last_pivot_bar) and bar_index - ess_last_pivot_bar > 5
        [fm_s, fm_e, fu_s, fu_e, fl_s, fl_e, f_slope, f_r2] = compute_channel(ess_last_pivot_bar, bar_index, i_ess_dev_mult)
        
        if not na(fm_s) and not na(fm_e)
            color f_col  = i_form_ess_col
            color f_line = color.new(f_col, math.max(i_form_opacity - 30, 5))
            color f_fill = color.new(f_col, i_form_opacity)
            color f_mid  = color.new(f_col, math.max(i_form_opacity - 15, 10))
            
            if not na(ess_form_fill)
                linefill.delete(ess_form_fill)
            if not na(ess_form_upper)
                line.delete(ess_form_upper)
            if not na(ess_form_lower)
                line.delete(ess_form_lower)
            if not na(ess_form_mid)
                line.delete(ess_form_mid)
            
            ess_form_upper := line.new(ess_last_pivot_bar, fu_s, bar_index, fu_e, color=f_line, width=1, style=form_line_style)
            ess_form_lower := line.new(ess_last_pivot_bar, fl_s, bar_index, fl_e, color=f_line, width=1, style=form_line_style)
            ess_form_fill  := linefill.new(ess_form_upper, ess_form_lower, f_fill)
            
            if i_show_center
                ess_form_mid := line.new(ess_last_pivot_bar, fm_s, bar_index, fm_e, color=f_mid, width=1, style=line.style_dotted)
    
    // ── Secondary forming ───────────────────────────────────────────────
    if i_sec_enable and not na(sec_last_pivot_bar) and bar_index - sec_last_pivot_bar > 3
        [fm_s, fm_e, fu_s, fu_e, fl_s, fl_e, f_slope, f_r2] = compute_channel(sec_last_pivot_bar, bar_index, i_sec_dev_mult)
        
        if not na(fm_s) and not na(fm_e)
            color f_col  = i_form_sec_col
            color f_line = color.new(f_col, math.max(i_form_opacity - 30, 5))
            color f_fill = color.new(f_col, i_form_opacity)
            color f_mid  = color.new(f_col, math.max(i_form_opacity - 15, 10))
            
            if not na(sec_form_fill)
                linefill.delete(sec_form_fill)
            if not na(sec_form_upper)
                line.delete(sec_form_upper)
            if not na(sec_form_lower)
                line.delete(sec_form_lower)
            if not na(sec_form_mid)
                line.delete(sec_form_mid)
            
            sec_form_upper := line.new(sec_last_pivot_bar, fu_s, bar_index, fu_e, color=f_line, width=1, style=form_line_style)
            sec_form_lower := line.new(sec_last_pivot_bar, fl_s, bar_index, fl_e, color=f_line, width=1, style=form_line_style)
            sec_form_fill  := linefill.new(sec_form_upper, sec_form_lower, f_fill)
            
            // Store live boundaries for breakout use
            form_sec_upper := fu_e
            form_sec_lower := fl_e
            
            if i_show_center
                sec_form_mid := line.new(sec_last_pivot_bar, fm_s, bar_index, fm_e, color=f_mid, width=1, style=line.style_dotted)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                 BREAKOUT DETECTION — SMART ENGINE                       ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

// Use the last completed secondary channel for bar-by-bar breakout detection
// (forming channel only updates on last bar, so we interpolate the latest completed)
interp(float vs, float ve, int bs, int be, int cur) =>
    na(vs) or na(ve) or na(bs) or na(be) or be == bs ? na : vs + (ve - vs) * float(cur - bs) / float(be - bs)

// Get latest completed secondary channel boundaries
float last_sec_up = na
float last_sec_lo = na
if array.size(sec_channels) > 0
    RegChannel last_sec = array.get(sec_channels, array.size(sec_channels) - 1)
    last_sec_up := interp(last_sec.start_upper, last_sec.end_upper, last_sec.start_bar, last_sec.end_bar, bar_index)
    last_sec_lo := interp(last_sec.start_lower, last_sec.end_lower, last_sec.start_bar, last_sec.end_bar, bar_index)

// Breakout conditions with penetration filter
float min_pen = atr_val * i_sig_min_atr

bool brk_bull = i_sig_enable and not na(last_sec_up) and close > last_sec_up + min_pen and close[1] <= last_sec_up
bool brk_bear = i_sig_enable and not na(last_sec_lo) and close < last_sec_lo - min_pen and close[1] >= last_sec_lo

// Volume filter
if i_sig_vol_filter
    brk_bull := brk_bull and vol_ok
    brk_bear := brk_bear and vol_ok

// Trend alignment filter
bool sig_bull = brk_bull and (not i_sig_trend_only or ess_trend_dir == 1)
bool sig_bear = brk_bear and (not i_sig_trend_only or ess_trend_dir == -1)

plotshape(sig_bull, title="Bullish Breakout", style=shape.triangleup, location=location.belowbar, color=i_sig_bull_col, size=size.tiny)
plotshape(sig_bear, title="Bearish Breakout", style=shape.triangledown, location=location.abovebar, color=i_sig_bear_col, size=size.tiny)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                   SUPPLY & DEMAND ENGINE                                ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

type SDZone
    float   top
    float   bottom
    int     birth_bar
    int     zone_type       // 1 = demand, -1 = supply
    int     retests
    bool    is_fresh
    bool    is_mitigated
    float   strength
    box     zone_box
    line    zone_mid
    label   zone_lbl

var array<SDZone> sd_zones = array.new<SDZone>()

sd_pivot_high = ta.pivothigh(high, i_sd_pivot_len, i_sd_pivot_len)
sd_pivot_low  = ta.pivotlow(low, i_sd_pivot_len, i_sd_pivot_len)

// ── Departure strength ──────────────────────────────────────────────────────
calc_departure(int idx, int ztype) =>
    float max_move = 0.0
    if idx > 0
        for k = 1 to math.min(5, bar_index - idx)
            int offset = bar_index - idx - k
            if offset >= 0
                if ztype == 1
                    max_move := math.max(max_move, (high[offset] - low[bar_index - idx]) / atr_val)
                else
                    max_move := math.max(max_move, (high[bar_index - idx] - low[offset]) / atr_val)
    max_move

// ── Find nearby zone for merging ────────────────────────────────────────────
find_nearby_zone(float ztop, float zbot, int ztype) =>
    int found = -1
    if array.size(sd_zones) > 0
        float merge_dist = atr_val * i_sd_merge_atr
        float zmid = (ztop + zbot) / 2.0
        for i = 0 to array.size(sd_zones) - 1
            SDZone z = array.get(sd_zones, i)
            if z.zone_type == ztype
                float emid = (z.top + z.bottom) / 2.0
                if math.abs(zmid - emid) <= merge_dist
                    found := i
                    break
    found

// ── Detect DEMAND zones from pivot lows ─────────────────────────────────────
if i_sd_enable and not na(sd_pivot_low)
    int p_bar = bar_index - i_sd_pivot_len
    float z_bot = low[i_sd_pivot_len]
    float z_top = math.max(open[i_sd_pivot_len], close[i_sd_pivot_len])
    float min_h = atr_val * 0.15
    if z_top - z_bot < min_h
        z_top := z_bot + min_h
    
    float dep = calc_departure(p_bar, 1)
    
    if dep >= 0.5
        int nearby = find_nearby_zone(z_top, z_bot, 1)
        if nearby >= 0
            SDZone ex = array.get(sd_zones, nearby)
            ex.top    := math.max(ex.top, z_top)
            ex.bottom := math.min(ex.bottom, z_bot)
            ex.retests += 1
            ex.strength := math.min(ex.strength + 0.15, 1.0)
        else
            SDZone nz = SDZone.new()
            nz.top          := z_top
            nz.bottom       := z_bot
            nz.birth_bar    := p_bar
            nz.zone_type    := 1
            nz.retests      := 0
            nz.is_fresh     := true
            nz.is_mitigated := false
            nz.strength     := math.min(dep / 3.0, 1.0)
            nz.zone_box     := na
            nz.zone_mid     := na
            nz.zone_lbl     := na
            array.push(sd_zones, nz)

// ── Detect SUPPLY zones from pivot highs ────────────────────────────────────
if i_sd_enable and not na(sd_pivot_high)
    int p_bar = bar_index - i_sd_pivot_len
    float z_top = high[i_sd_pivot_len]
    float z_bot = math.min(open[i_sd_pivot_len], close[i_sd_pivot_len])
    float min_h = atr_val * 0.15
    if z_top - z_bot < min_h
        z_bot := z_top - min_h
    
    float dep = calc_departure(p_bar, -1)
    
    if dep >= 0.5
        int nearby = find_nearby_zone(z_top, z_bot, -1)
        if nearby >= 0
            SDZone ex = array.get(sd_zones, nearby)
            ex.top    := math.max(ex.top, z_top)
            ex.bottom := math.min(ex.bottom, z_bot)
            ex.retests += 1
            ex.strength := math.min(ex.strength + 0.15, 1.0)
        else
            SDZone nz = SDZone.new()
            nz.top          := z_top
            nz.bottom       := z_bot
            nz.birth_bar    := p_bar
            nz.zone_type    := -1
            nz.retests      := 0
            nz.is_fresh     := true
            nz.is_mitigated := false
            nz.strength     := math.min(dep / 3.0, 1.0)
            nz.zone_box     := na
            nz.zone_mid     := na
            nz.zone_lbl     := na
            array.push(sd_zones, nz)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║              S&D ZONE MANAGEMENT — RETESTS & INVALIDATION               ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

delete_zone(SDZone z) =>
    if not na(z.zone_box)
        box.delete(z.zone_box)
    if not na(z.zone_mid)
        line.delete(z.zone_mid)
    if not na(z.zone_lbl)
        label.delete(z.zone_lbl)

if array.size(sd_zones) > 0
    for i = array.size(sd_zones) - 1 to 0
        SDZone z = array.get(sd_zones, i)
        
        // Age check
        if bar_index - z.birth_bar > i_sd_max_age
            delete_zone(z)
            array.remove(sd_zones, i)
            continue
        
        // Invalidation & retest tracking
        if z.zone_type == 1  // demand
            if close < z.bottom - atr_val * 0.1
                delete_zone(z)
                array.remove(sd_zones, i)
                continue
            if low <= z.top and low >= z.bottom and close > z.top
                if z.is_fresh
                    z.is_fresh := false
                z.retests += 1
        
        else  // supply
            if close > z.top + atr_val * 0.1
                delete_zone(z)
                array.remove(sd_zones, i)
                continue
            if high >= z.bottom and high <= z.top and close < z.bottom
                if z.is_fresh
                    z.is_fresh := false
                z.retests += 1

// ── Zone count helpers ──────────────────────────────────────────────────────
count_sd(int ztype) =>
    int c = 0
    if array.size(sd_zones) > 0
        for i = 0 to array.size(sd_zones) - 1
            if array.get(sd_zones, i).zone_type == ztype
                c += 1
    c

// ── Limit zones per side ────────────────────────────────────────────────────
while count_sd(-1) > i_sd_max_zones
    float ws = 999.0
    int wi = -1
    if array.size(sd_zones) > 0
        for i = 0 to array.size(sd_zones) - 1
            SDZone z = array.get(sd_zones, i)
            if z.zone_type == -1
                float sc = z.strength - (z.is_fresh ? 0.0 : 0.2) - float(z.retests) * 0.1
                if sc < ws
                    ws := sc
                    wi := i
    if wi >= 0
        delete_zone(array.get(sd_zones, wi))
        array.remove(sd_zones, wi)
    else
        break

while count_sd(1) > i_sd_max_zones
    float ws = 999.0
    int wi = -1
    if array.size(sd_zones) > 0
        for i = 0 to array.size(sd_zones) - 1
            SDZone z = array.get(sd_zones, i)
            if z.zone_type == 1
                float sc = z.strength - (z.is_fresh ? 0.0 : 0.2) - float(z.retests) * 0.1
                if sc < ws
                    ws := sc
                    wi := i
    if wi >= 0
        delete_zone(array.get(sd_zones, wi))
        array.remove(sd_zones, wi)
    else
        break


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                    S&D ZONE RENDERING                                   ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

if i_sd_enable and array.size(sd_zones) > 0
    for i = 0 to array.size(sd_zones) - 1
        SDZone z = array.get(sd_zones, i)
        
        color base_col = z.zone_type == 1 ? i_sd_demand_col : i_sd_supply_col
        int base_op = z.is_fresh ? i_sd_fresh_op : i_sd_tested_op
        if z.retests >= i_sd_max_retests
            base_op := math.min(base_op + 5, 97)
        
        color fill_col   = color.new(base_col, base_op)
        int border_op     = math.max(base_op - 25, 10)
        color border_col  = color.new(base_col, border_op)
        
        int right_bar   = bar_index + i_sd_extend
        float mid_price = (z.top + z.bottom) / 2.0
        int label_bar   = math.round(math.avg(float(z.birth_bar), float(right_bar)))
        
        // Zone label text
        string zt = z.zone_type == -1 ? "SUPPLY" : "DEMAND"
        string ft = z.is_fresh ? " ●" : z.retests >= i_sd_max_retests ? " ○" : ""
        color lbl_col = color.new(base_col, math.max(base_op - 40, 20))
        
        // Box
        if not na(z.zone_box)
            box.set_lefttop(z.zone_box, z.birth_bar, z.top)
            box.set_rightbottom(z.zone_box, right_bar, z.bottom)
            box.set_bgcolor(z.zone_box, fill_col)
            box.set_border_color(z.zone_box, border_col)
        else
            z.zone_box := box.new(z.birth_bar, z.top, right_bar, z.bottom, border_color=border_col, border_width=1, bgcolor=fill_col)
        
        // Midline
        color mid_col = color.new(base_col, math.min(border_op + 15, 90))
        if not na(z.zone_mid)
            line.set_xy1(z.zone_mid, z.birth_bar, mid_price)
            line.set_xy2(z.zone_mid, right_bar, mid_price)
            line.set_color(z.zone_mid, mid_col)
        else
            z.zone_mid := line.new(z.birth_bar, mid_price, right_bar, mid_price, color=mid_col, style=line.style_dotted, width=1)
        
        // Label
        if not na(z.zone_lbl)
            label.set_xy(z.zone_lbl, label_bar, mid_price)
            label.set_text(z.zone_lbl, zt + ft)
            label.set_textcolor(z.zone_lbl, lbl_col)
        else
            z.zone_lbl := label.new(label_bar, mid_price, zt + ft, color=color.new(color.black, 100), style=label.style_label_center, textcolor=lbl_col, size=size.tiny)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                    INFORMATION TABLE                                    ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

var table info_tbl = table.new(position.top_right, 2, 7, bgcolor=color.new(#0D1117, 10), border_color=color.new(#0D1117, 60), border_width=1, frame_color=color.new(#0D1117, 40), frame_width=1)

if barstate.islast and i_show_info
    string et = ess_trend_dir == 1 ? "▲ BULL" : ess_trend_dir == -1 ? "▼ BEAR" : "◆ FLAT"
    color ec = ess_trend_dir == 1 ? i_ess_bull_col : ess_trend_dir == -1 ? i_ess_bear_col : color.gray
    table.cell(info_tbl, 0, 0, "ESSENTIAL", text_color=color.new(#FFFFFF, 40), text_size=size.tiny)
    table.cell(info_tbl, 1, 0, et, text_color=ec, text_size=size.tiny)
    
    string stt = sec_trend_dir == 1 ? "▲ BULL" : sec_trend_dir == -1 ? "▼ BEAR" : "◆ FLAT"
    color scc = sec_trend_dir == 1 ? color.new(#B0BEC5, 0) : sec_trend_dir == -1 ? color.new(#78909C, 0) : color.gray
    table.cell(info_tbl, 0, 1, "SECONDARY", text_color=color.new(#FFFFFF, 40), text_size=size.tiny)
    table.cell(info_tbl, 1, 1, stt, text_color=scc, text_size=size.tiny)
    
    bool al = ess_trend_dir == sec_trend_dir and ess_trend_dir != 0
    string att = al ? "✦ ALIGNED" : ess_trend_dir != sec_trend_dir and ess_trend_dir != 0 and sec_trend_dir != 0 ? "✧ DIVERGENT" : "— NEUTRAL"
    color ac = al ? color.new(#00E676, 0) : color.new(#FF9100, 0)
    table.cell(info_tbl, 0, 2, "SYNC", text_color=color.new(#FFFFFF, 40), text_size=size.tiny)
    table.cell(info_tbl, 1, 2, att, text_color=ac, text_size=size.tiny)
    
    float er2 = array.size(ess_channels) > 0 ? array.get(ess_channels, array.size(ess_channels) - 1).r_squared : 0.0
    table.cell(info_tbl, 0, 3, "ESS R²", text_color=color.new(#FFFFFF, 40), text_size=size.tiny)
    table.cell(info_tbl, 1, 3, str.tostring(er2, "#.##"), text_color=color.new(#FFFFFF, 20), text_size=size.tiny)
    
    float sr2 = array.size(sec_channels) > 0 ? array.get(sec_channels, array.size(sec_channels) - 1).r_squared : 0.0
    table.cell(info_tbl, 0, 4, "SEC R²", text_color=color.new(#FFFFFF, 40), text_size=size.tiny)
    table.cell(info_tbl, 1, 4, str.tostring(sr2, "#.##"), text_color=color.new(#FFFFFF, 20), text_size=size.tiny)
    
    string ch_txt = str.tostring(array.size(ess_channels)) + "E / " + str.tostring(array.size(sec_channels)) + "S"
    table.cell(info_tbl, 0, 5, "CHANNELS", text_color=color.new(#FFFFFF, 40), text_size=size.tiny)
    table.cell(info_tbl, 1, 5, ch_txt, text_color=color.new(#FFFFFF, 20), text_size=size.tiny)
    
    string sd_txt = str.tostring(count_sd(-1)) + "S / " + str.tostring(count_sd(1)) + "D"
    table.cell(info_tbl, 0, 6, "S&D ZONES", text_color=color.new(#FFFFFF, 40), text_size=size.tiny)
    table.cell(info_tbl, 1, 6, sd_txt, text_color=color.new(#FFFFFF, 20), text_size=size.tiny)


// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                          ALERTS                                         ║
// ╚═══════════════════════════════════════════════════════════════════════════╝

alertcondition(sig_bull, title="Bullish Breakout (With Trend)", message="Bullish breakout from secondary channel — aligned with essential trend")
alertcondition(sig_bear, title="Bearish Breakout (With Trend)", message="Bearish breakout from secondary channel — aligned with essential trend")
alertcondition(brk_bull, title="Any Bullish Breakout", message="Price broke above secondary channel")
alertcondition(brk_bear, title="Any Bearish Breakout", message="Price broke below secondary channel")

// S&D zone alerts
bool in_demand = false
bool in_supply = false
if array.size(sd_zones) > 0
    for i = 0 to array.size(sd_zones) - 1
        SDZone z = array.get(sd_zones, i)
        if z.zone_type == 1 and low <= z.top and close >= z.bottom
            in_demand := true
        if z.zone_type == -1 and high >= z.bottom and close <= z.top
            in_supply := true

alertcondition(in_demand, title="Price in Demand Zone", message="Price has entered a demand zone")
alertcondition(in_supply, title="Price in Supply Zone", message="Price has entered a supply zone")
alertcondition(in_demand and sig_bull, title="Demand + Bullish Breakout", message="Bullish breakout near demand zone — high probability setup")
alertcondition(in_supply and sig_bear, title="Supply + Bearish Breakout", message="Bearish breakout near supply zone — high probability setup")


// ─────────────────────────────────────────────────────────────────────────────
// END
// ─────────────────────────────────────────────────────────────────────────────
