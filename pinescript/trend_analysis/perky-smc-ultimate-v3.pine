// This source code is subject to the terms of the Mozilla Public License 2.0 
// © Perkytradess
// Credit: Concept inspired by LuxAlgo (Liquidity Sweeps)
// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo — Enhanced & Merged by Perky (Peak Ventures / perkytradess)
// PERKY SMC ULTIMATE V3
// Combines: Smart Money Concepts + Fair Value Gaps + Liquidity Sweeps + Options-Aware Sweep Entries

//@version=6
indicator('Perky SMC Ultimate V3', 'Perky SMC V3', overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500)

//---------------------------------------------------------------------------------------------------------------------}
// CONSTANTS & STRINGS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG                     = 1
BEARISH_LEG                     = 0

BULLISH                         = +1
BEARISH                         = -1

GREEN                           = #089981
RED                             = #F23645
BLUE                            = #2157f3
GRAY                            = #878b94
MONO_BULLISH                    = #b2b5be
MONO_BEARISH                    = #5d606b

HISTORICAL                      = 'Historical'
PRESENT                         = 'Present'

COLORED                         = 'Colored'
MONOCHROME                      = 'Monochrome'

ALL                             = 'All'
BOS                             = 'BOS'
CHOCH                           = 'CHoCH'

TINY                            = size.tiny
SMALL                           = size.small
NORMAL                          = size.normal

ATR                             = 'Atr'
RANGE                           = 'Cumulative Mean Range'

CLOSE                           = 'Close'
HIGHLOW                         = 'High/Low'

SOLID                           = '⎯⎯⎯'
DASHED                          = '----'
DOTTED                          = '····'

SMART_GROUP                     = 'Smart Money Concepts'
INTERNAL_GROUP                  = 'Real Time Internal Structure'
SWING_GROUP                     = 'Real Time Swing Structure'
BLOCKS_GROUP                    = 'Order Blocks'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'Fair Value Gaps'
LEVELS_GROUP                    = 'Highs & Lows MTF'
ZONES_GROUP                     = 'Premium & Discount Zones'
SWEEPS_GROUP                    = 'Liquidity Sweeps'
ENTRY_GROUP                     = 'Entry & Exit Strategy'

//---------------------------------------------------------------------------------------------------------------------}
// INPUTS — SMART MONEY CONCEPTS
//---------------------------------------------------------------------------------------------------------------------{
modeInput                       = input.string( HISTORICAL, 'Mode',                     group = SMART_GROUP,    options = [HISTORICAL, PRESENT])
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP,    options = [COLORED, MONOCHROME])
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP)

showInternalsInput              = input(        true,       'Show Internal Structure',  group = INTERNAL_GROUP)
showInternalBullInput           = input.string( ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [ALL,BOS,CHOCH])
internalBullColorInput          = input(        GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull')
showInternalBearInput           = input.string( ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [ALL,BOS,CHOCH])
internalBearColorInput          = input(        RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear')
internalFilterConfluenceInput   = input(        false,      'Confluence Filter',        group = INTERNAL_GROUP)
internalStructureSize           = input.string( TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [TINY,SMALL,NORMAL])

showStructureInput              = input(        true,       'Show Swing Structure',     group = SWING_GROUP)
showSwingBullInput              = input.string( ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [ALL,BOS,CHOCH])
swingBullColorInput             = input(        GREEN,      '',                         group = SWING_GROUP,    inline = 'bull')
showSwingBearInput              = input.string( ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [ALL,BOS,CHOCH])
swingBearColorInput             = input(        RED,        '',                         group = SWING_GROUP,    inline = 'bear')
swingStructureSize              = input.string( SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [TINY,SMALL,NORMAL])
showSwingsInput                 = input(        false,      'Show Swings Points',       group = SWING_GROUP,    inline = 'swings')
swingsLengthInput               = input.int(    50,         '',                         group = SWING_GROUP,    minval = 10,        inline = 'swings')
showHighLowSwingsInput          = input(        true,       'Show Strong/Weak High/Low',group = SWING_GROUP)

showInternalOrderBlocksInput    = input(        true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   inline = 'iob')
internalOrderBlocksSizeInput    = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20, inline = 'iob')
showSwingOrderBlocksInput       = input(        false,      'Swing Order Blocks',       group = BLOCKS_GROUP,   inline = 'ob')
swingOrderBlocksSizeInput       = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20, inline = 'ob')
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,   options = [ATR, RANGE])
orderBlockMitigationInput       = input.string( HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,   options = [CLOSE,HIGHLOW])
internalBullishOrderBlockColor  = input.color(color.new(#3179f5, 80), 'Internal Bullish OB',  group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#f77c80, 80), 'Internal Bearish OB',  group = BLOCKS_GROUP)
swingBullishOrderBlockColor     = input.color(color.new(#1848cc, 80), 'Bullish OB',           group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#b22833, 80), 'Bearish OB',           group = BLOCKS_GROUP)

showEqualHighsLowsInput         = input(        true,       'Equal High/Low',           group = EQUAL_GROUP)
equalHighsLowsLengthInput       = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP,    minval = 1)
equalHighsLowsThresholdInput    = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,    minval = 0, maxval = 0.5, step = 0.1)
equalHighsLowsSizeInput         = input.string( TINY,       'Label Size',               group = EQUAL_GROUP,    options = [TINY,SMALL,NORMAL])

showFairValueGapsInput          = input(        true,       'Fair Value Gaps',          group = GAPS_GROUP)
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP)
fairValueGapsBullColorInput     = input.color(color.new(#00ff68, 70), 'Bullish FVG',   group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#ff0008, 70), 'Bearish FVG',   group = GAPS_GROUP)
fairValueGapsExtendInput        = input.int(    1,          'Extend FVG',               group = GAPS_GROUP,     minval = 0)
showFVGLabelsInput              = input(        true,       'Show FVG Labels',          group = GAPS_GROUP)

showDailyLevelsInput            = input(        false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED])
dailyLevelsColorInput           = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input(        false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED])
weeklyLevelsColorInput          = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input(        false,      'Monthly',  group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED])
monthlyLevelsColorInput         = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly')

showPremiumDiscountZonesInput   = input(        false,      'Premium/Discount Zones',   group = ZONES_GROUP)
premiumZoneColorInput           = input.color(  RED,        'Premium Zone',             group = ZONES_GROUP)
equilibriumZoneColorInput       = input.color(  GRAY,       'Equilibrium Zone',         group = ZONES_GROUP)
discountZoneColorInput          = input.color(  GREEN,      'Discount Zone',            group = ZONES_GROUP)

//---------------------------------------------------------------------------------------------------------------------}
// INPUTS — LIQUIDITY SWEEPS
//---------------------------------------------------------------------------------------------------------------------{
sweepLen        = input.int(5,          'Swings',   minval=1,                                               group=SWEEPS_GROUP)
sweepOpt        = input.string('Only Wicks', 'Mode', options=['Only Wicks','Only Outbreaks & Retest','Wicks + Outbreaks & Retest'], group=SWEEPS_GROUP)
sweepBullColor  = input.color(#089981,  'Bull',     group=SWEEPS_GROUP, inline='sc1')
sweepBullColor2 = input.color(#08998180,'',         group=SWEEPS_GROUP, inline='sc1')
sweepBearColor  = input.color(#f23645,  'Bear',     group=SWEEPS_GROUP, inline='sc2')
sweepBearColor2 = input.color(#f2364580,'',         group=SWEEPS_GROUP, inline='sc2')
sweepExtend     = input.bool(true,      'Extend Sweep Area',                                                group=SWEEPS_GROUP)
sweepMaxBars    = input.int(300,        'Max Bars', minval=1, maxval=5000,                                  group=SWEEPS_GROUP)
sweepBullArea   = input.color(#08998141,'Bull Area',group=SWEEPS_GROUP, inline='sa1')
sweepBearArea   = input.color(#f2364541,'Bear Area',group=SWEEPS_GROUP, inline='sa2')
showSweepLabel  = input(true,           'Show Sweep Labels',                                                group=SWEEPS_GROUP)

//---------------------------------------------------------------------------------------------------------------------}
// INPUTS — ENTRY & EXIT STRATEGY
//---------------------------------------------------------------------------------------------------------------------{
showEntryInput          = input(        true,   'Show Entry & Exit Signals',        group = ENTRY_GROUP)
entryBullColorInput     = input.color(  GREEN,  'Long Signal Color',                group = ENTRY_GROUP)
entryBearColorInput     = input.color(  RED,    'Short Signal Color',               group = ENTRY_GROUP)
exitColorInput          = input.color(  GRAY,   'Exit Signal Color',                group = ENTRY_GROUP)
entryLabelSizeInput     = input.string( SMALL,  'Signal Label Size',                group = ENTRY_GROUP, options = [TINY,SMALL,NORMAL])

// Sweep entry settings — all filters OFF by default so every sweep fires
showSweepEntriesInput   = input(        true,   'Sweep-Based Entries (Options)',    group = ENTRY_GROUP)
requireFVGInput         = input(        false,  'Filter: Require FVG Confluence',   group = ENTRY_GROUP)
requireOBInput          = input(        false,  'Filter: Require OB Confluence',    group = ENTRY_GROUP)
requireCHoCHInput       = input(        false,  'Filter: Require CHoCH Confirm',    group = ENTRY_GROUP)
requireSMCBiasInput     = input(        false,  'Filter: Require SMC Bias Align',   group = ENTRY_GROUP)

// Options profit target sizing
tp1MultInput            = input.float(  0.5,    'TP1 ATR Mult (scalp)',             group = ENTRY_GROUP, minval = 0.1, step = 0.05)
tp2MultInput            = input.float(  1.0,    'TP2 ATR Mult (target)',            group = ENTRY_GROUP, minval = 0.1, step = 0.05)
tp3MultInput            = input.float(  2.0,    'TP3 ATR Mult (runner)',            group = ENTRY_GROUP, minval = 0.1, step = 0.05)
slMultInput             = input.float(  0.5,    'Stop Loss ATR Mult',               group = ENTRY_GROUP, minval = 0.1, step = 0.05)
fadeOldLabelsInput      = input.bool(   true,   'Fade Previous Day Labels',         group = ENTRY_GROUP)
fadeDaysInput           = input.int(    1,      'Days Before Fading',               group = ENTRY_GROUP, minval = 1, maxval = 10)

//---------------------------------------------------------------------------------------------------------------------}
// DATA STRUCTURES
//---------------------------------------------------------------------------------------------------------------------{
type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false

type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox
    label fvgLabel

type trend
    int bias

type equalDisplay
    line l_ine      = na
    label l_abel    = na

type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

type orderBlock
    float barHigh
    float barLow
    int barTime
    int bias

// Sweep types
type piv
    float prc
    int   bix
    bool  brk
    bool  mit
    bool  tak
    bool  wic
    line  lin

type boxBr
    box  bx
    line ln
    bool br
    int  dr

//---------------------------------------------------------------------------------------------------------------------}
// VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
var pivot swingHigh                 = pivot.new(na,na,false)
var pivot swingLow                  = pivot.new(na,na,false)
var pivot internalHigh              = pivot.new(na,na,false)
var pivot internalLow               = pivot.new(na,na,false)
var pivot equalHigh                 = pivot.new(na,na,false)
var pivot equalLow                  = pivot.new(na,na,false)
var trend swingTrend                = trend.new(0)
var trend internalTrend             = trend.new(0)
var equalDisplay equalHighDisplay   = equalDisplay.new()
var equalDisplay equalLowDisplay    = equalDisplay.new()
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
var array<float> parsedHighs        = array.new<float>()
var array<float> parsedLows         = array.new<float>()
var array<float> highs              = array.new<float>()
var array<float> lows               = array.new<float>()
var array<int> times                = array.new<int>()
var trailingExtremes trailing       = trailingExtremes.new()
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
var array<box> swingOrderBlocksBoxes        = array.new<box>()
var array<box> internalOrderBlocksBoxes     = array.new<box>()

// Sweep variables
var array<piv>   aPivH  = array.new<piv>(1, piv.new())
var array<piv>   aPivL  = array.new<piv>(1, piv.new())
var array<boxBr> aBoxBr = array.new<boxBr>(1, boxBr.new())

// Entry/Exit tracking
var bool lastBullCHoCH  = false
var bool lastBearCHoCH  = false
var bool inLong         = false
var bool inShort        = false

var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput

varip int currentBarIndex           = bar_index
varip int lastBarIndex              = bar_index
alerts currentAlerts                = alerts.new()
var initialTime                     = time

//---------------------------------------------------------------------------------------------------------------------}
// INITIALIZATION
//---------------------------------------------------------------------------------------------------------------------{
if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))

bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low
atrMeasure                          = ta.atr(200)
volatilityMeasure                   = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr)/bar_index
highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
parsedHigh                          = highVolatilityBar ? low : high
parsedLow                           = highVolatilityBar ? high : low

parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

//---------------------------------------------------------------------------------------------------------------------}
// SMC FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
leg(int size) =>
    var leg     = 0
    newLegHigh  = high[size] > ta.highest(size)
    newLegLow   = low[size]  < ta.lowest(size)
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

startOfNewLeg(int leg)      => ta.change(leg) != 0
startOfBearishLeg(int leg)  => ta.change(leg) == -1
startOfBullishLeg(int leg)  => ta.change(leg) == +1

drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>
    var label l_abel = na
    if modeInput == PRESENT
        l_abel.delete()
    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=color(na),textcolor=labelColor,style=labelStyle,size=size.small)

drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay
    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up
    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down
    if modeInput == PRESENT
        line.delete(e_qualDisplay.l_ine)
        label.delete(e_qualDisplay.l_abel)
    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc=xloc.bar_time, color=equalColor, style=line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color=color(na), textcolor=equalColor, style=labelStyle, size=equalHighsLowsSizeInput)

getCurrentStructure(int size, bool equalHighLow = false, bool internal = false) =>
    currentLeg  = leg(size)
    newPivot    = startOfNewLeg(currentLeg)
    pivotLow    = startOfBullishLeg(currentLeg)
    pivotHigh   = startOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            pivot p_ivot = equalHighLow ? equalLow : internal ? internalLow : swingLow
            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot, low[size], size, false)
                currentAlerts.equalLows := true
            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]
            if not equalHighLow and not internal
                trailing.bottom         := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime
            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh
            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot,high[size],size,true)
                currentAlerts.equalHighs := true
            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]
            if not equalHighLow and not internal
                trailing.top            := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastTopTime    := p_ivot.barTime
            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)

drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>
    var line l_ine   = line.new(na,na,na,na,xloc=xloc.bar_time)
    var label l_abel = label.new(na,na)
    if modeInput == PRESENT
        l_ine.delete()
        l_abel.delete()
    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size=labelSize)

deleteOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    for [index,eachOrderBlock] in orderBlocks
        bool crossedOderBlock = false
        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBearishOrderBlock := true
            else
                currentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBullishOrderBlock := true
            else
                currentAlerts.swingBullishOrderBlock    := true
        if crossedOderBlock
            orderBlocks.remove(index)

storeOrdeBlock(pivot p_ivot, bool internal = false, int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)
        array<float> a_rray = na
        int parsedIndex = na
        if bias == BEARISH
            a_rray      := parsedHighs.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())
        else
            a_rray      := parsedLows.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())
        orderBlock o_rderBlock        = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex),bias)
        array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

drawOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()
    if orderBlocksSize > 0
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes
        for [index,eachOrderBlock] in parsedOrdeBlocks
            orderBlockColor = styleInput == MONOCHROME ? (eachOrderBlock.bias == BEARISH ? color.new(MONO_BEARISH,80) : color.new(MONO_BULLISH,80)) : internal ? (eachOrderBlock.bias == BEARISH ? internalBearishOrderBlockColor : internalBullishOrderBlockColor) : (eachOrderBlock.bias == BEARISH ? swingBearishOrderBlockColor : swingBullishOrderBlockColor)
            box b_ox        = b_oxes.get(index)
            b_ox.set_top_left_point(    chart.point.new(eachOrderBlock.barTime,na,eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,eachOrderBlock.barLow))
            b_ox.set_border_color(      internal ? na : orderBlockColor)
            b_ox.set_bgcolor(           orderBlockColor)

displayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true
    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)

    pivot p_ivot    = internal ? internalHigh : swingHigh
    trend t_rend    = internal ? internalTrend : swingTrend
    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize
    extraCondition  = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    bullishColor    = styleInput == MONOCHROME ? MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput

    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS
        if internal
            currentAlerts.internalBullishCHoCH := tag == CHOCH
            currentAlerts.internalBullishBOS   := tag == BOS
        else
            currentAlerts.swingBullishCHoCH    := tag == CHOCH
            currentAlerts.swingBullishBOS      := tag == BOS
        p_ivot.crossed  := true
        t_rend.bias     := BULLISH
        displayCondition = internal ? showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))
        if displayCondition
            drawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BULLISH)

    p_ivot          := internal ? internalLow : swingLow
    extraCondition  := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    bearishColor    = styleInput == MONOCHROME ? MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput

    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS
        if internal
            currentAlerts.internalBearishCHoCH := tag == CHOCH
            currentAlerts.internalBearishBOS   := tag == BOS
        else
            currentAlerts.swingBearishCHoCH    := tag == CHOCH
            currentAlerts.swingBearishBOS      := tag == BOS
        p_ivot.crossed := true
        t_rend.bias := BEARISH
        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))
        if displayCondition
            drawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BEARISH)

//---------------------------------------------------------------------------------------------------------------------}
// FVG FUNCTIONS (Enhanced with labels)
//---------------------------------------------------------------------------------------------------------------------{
// Draw a single FVG box with optional center label
fairValueGapBox(leftTime, rightTime, topPrice, bottomPrice, boxColor) =>
    box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color=boxColor, bgcolor=boxColor)

deleteFairValueGaps() =>
    for [index,eachFairValueGap] in fairValueGaps
        if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
            eachFairValueGap.topBox.delete()
            eachFairValueGap.bottomBox.delete()
            eachFairValueGap.fvgLabel.delete()
            fairValueGaps.remove(index)

drawFairValueGaps() =>
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]], lookahead=barmerge.lookahead_on)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0

    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe

    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        midPrice    = math.avg(currentLow, last2High)
        topBx       = fairValueGapBox(lastTime, currentTime, currentLow, midPrice, fairValueGapBullishColor)
        botBx       = fairValueGapBox(lastTime, currentTime, midPrice, last2High, fairValueGapBullishColor)
        // Center label inside the FVG box
        fvgLbl      = showFVGLabelsInput ? label.new(chart.point.new(lastTime + math.round((currentTime - lastTime) * 0.5), na, midPrice), 'Bull FVG', xloc=xloc.bar_time, color=color(na), textcolor=color.new(fairValueGapBullishColor, 0), style=label.style_label_center, size=size.tiny) : label.new(na,na)
        fairValueGaps.unshift(fairValueGap.new(currentLow, last2High, BULLISH, topBx, botBx, fvgLbl))

    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        midPrice    = math.avg(currentHigh, last2Low)
        topBx       = fairValueGapBox(lastTime, currentTime, currentHigh, midPrice, fairValueGapBearishColor)
        botBx       = fairValueGapBox(lastTime, currentTime, midPrice, last2Low, fairValueGapBearishColor)
        fvgLbl      = showFVGLabelsInput ? label.new(chart.point.new(lastTime + math.round((currentTime - lastTime) * 0.5), na, midPrice), 'Bear FVG', xloc=xloc.bar_time, color=color(na), textcolor=color.new(fairValueGapBearishColor, 0), style=label.style_label_center, size=size.tiny) : label.new(na,na)
        fairValueGaps.unshift(fairValueGap.new(currentHigh, last2Low, BEARISH, topBx, botBx, fvgLbl))

// Helper: is price currently inside a bullish FVG?
inBullFVG() =>
    result = false
    for fvg in fairValueGaps
        if fvg.bias == BULLISH and close >= fvg.bottom and close <= fvg.top
            result := true
    result

// Helper: is price currently inside a bearish FVG?
inBearFVG() =>
    result = false
    for fvg in fairValueGaps
        if fvg.bias == BEARISH and close <= fvg.top and close >= fvg.bottom
            result := true
    result

// Helper: is there a nearby bullish OB (within 2x ATR below close)?
nearBullOB() =>
    result = false
    for ob in internalOrderBlocks
        if ob.bias == BULLISH and close >= ob.barLow and close <= ob.barHigh + atrMeasure * 2
            result := true
    result

// Helper: is there a nearby bearish OB (within 2x ATR above close)?
nearBearOB() =>
    result = false
    for ob in internalOrderBlocks
        if ob.bias == BEARISH and close <= ob.barHigh and close >= ob.barLow - atrMeasure * 2
            result := true
    result

//---------------------------------------------------------------------------------------------------------------------}
// LIQUIDITY SWEEP FUNCTIONS (Cleaned Up)
//---------------------------------------------------------------------------------------------------------------------{
n_sweep = bar_index

oW_s = sweepOpt == 'Only Wicks'
oO_s = sweepOpt == 'Only Outbreaks & Retest'

method n_piv(float piv_val) => bool out = not na(piv_val)

method p_met(piv p_obj, float val) => float out = (100 / p_obj.prc * val) - 100

method l_met(piv get, color c, string s='sd') =>
    style = switch s
        'dt' => line.style_dotted
        'ds' => line.style_dashed
        =>      line.style_solid
    line.new(get.bix, get.prc, n_sweep, get.prc, color=c, style=style)

method br_met(piv get, color c3, color c, int d) =>
    y1 = d == 1 ? high : get.prc
    y2 = d == 1 ? get.prc : low
    boxBr.new(
     box.new(n_sweep-1, y1, n_sweep+1, y2, border_color=color.new(na,na), bgcolor=c3),
     line.new(n_sweep, y1, n_sweep, y2, color=c, width=2),
     false, d)

lnDot_sweep(y, c) => line.new(n_sweep, y, n_sweep+2, y, color=c, style=line.style_dotted)

// Draw a clean sweep label
drawSweepLabel(float price, bool isBull) =>
    if showSweepLabel
        lc = isBull ? sweepBullColor : sweepBearColor
        ls = isBull ? label.style_label_up : label.style_label_down
        label.new(n_sweep, price, 'Sweep', color=color.new(lc,75), textcolor=lc, style=ls, size=size.tiny)

ph_sweep = ta.pivothigh(sweepLen, sweepLen)
pl_sweep = ta.pivotlow (sweepLen, sweepLen)

if ph_sweep.n_piv()
    aPivH.unshift(piv.new(ph_sweep, n_sweep - sweepLen, false, false, false, false))

if pl_sweep.n_piv()
    aPivL.unshift(piv.new(pl_sweep, n_sweep - sweepLen, false, false, false, false))

// Sweep signal trackers — reset every bar, set true when sweep fires
var bool greenSweepFired  = false
var bool redSweepFired    = false
var float greenSweepPrice = na
var float redSweepPrice   = na
greenSweepFired := false
redSweepFired   := false

for i = aPivH.size() -1 to 0
    get = aPivH.get(i)
    if not get.mit
        if not get.brk
            if close > get.prc
                if not oW_s
                    get.brk := true
                else
                    get.mit := true
            if not oO_s and not get.wic
                if high > get.prc and close < get.prc
                    aBoxBr.unshift(get.br_met(sweepBearArea, sweepBearColor, 1))
                    get.l_met(sweepBearColor2, 'dt'), lnDot_sweep(low, sweepBearColor)
                    drawSweepLabel(high, false)
                    get.wic      := true
                    redSweepFired  := true
                    redSweepPrice  := high
        else
            if close < get.prc
                get.mit := true
            if not oW_s and low < get.prc and close > get.prc
                aBoxBr.unshift(get.br_met(sweepBullArea, sweepBullColor, -1))
                get.l_met(sweepBullColor2, 'ds'), lnDot_sweep(high, sweepBullColor)
                drawSweepLabel(low, true)
                get.tak         := true
                greenSweepFired := true
                greenSweepPrice := low
    if n_sweep - get.bix > 2000 or get.mit or get.tak
        aPivH.remove(i).lin.delete()

for i = aPivL.size() -1 to 0
    get = aPivL.get(i)
    if not get.mit
        if not get.brk
            if close < get.prc
                if not oW_s
                    get.brk := true
                else
                    get.mit := true
            if not oO_s and not get.wic
                if low < get.prc and close > get.prc
                    aBoxBr.unshift(get.br_met(sweepBullArea, sweepBullColor, -1))
                    get.l_met(sweepBullColor2, 'dt'), lnDot_sweep(high, sweepBullColor)
                    drawSweepLabel(low, true)
                    get.wic         := true
                    greenSweepFired := true
                    greenSweepPrice := low
        else
            if close > get.prc
                get.mit := true
            if not oW_s and high > get.prc and close < get.prc
                aBoxBr.unshift(get.br_met(sweepBearArea, sweepBearColor, 1))
                get.l_met(sweepBearColor2, 'ds'), lnDot_sweep(low, sweepBearColor)
                drawSweepLabel(high, false)
                get.tak       := true
                redSweepFired := true
                redSweepPrice := high
    if n_sweep - get.bix > 2000 or get.mit or get.tak
        aPivL.remove(i).lin.delete()

if sweepExtend
    for bx in aBoxBr
        if not bx.br and n_sweep - bx.bx.get_left() -1 <= sweepMaxBars
            bx.bx.set_right(bar_index)
            if bx.dr == -1 and close < bx.bx.get_bottom()
                bx.br := true
            if bx.dr ==  1 and close > bx.bx.get_top()
                bx.br := true

//---------------------------------------------------------------------------------------------------------------------}
// MTF LEVELS FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
getStyle(string style) =>
    switch style
        SOLID  => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

higherTimeframe(string tf_str) => timeframe.in_seconds() > timeframe.in_seconds(tf_str)

drawLevels(string tf_str, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, tf_str, [high[1], low[1], time[1], time], lookahead=barmerge.lookahead_on)
    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel
    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime
    int parsedTopTime       = time
    int parsedBottomTime    = time
    if not sameTimeframe
        int leftIndex               = times.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = times.binary_search_rightmost(parsedRightTime)
        array<int> timeArray        = times.slice(leftIndex,rightIndex)
        array<float> topArray       = highs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = lows.slice(leftIndex,rightIndex)
        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : initialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : initialTime
    var line topLine        = line.new(na, na, na, na, xloc=xloc.bar_time, color=levelColor, style=getStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc=xloc.bar_time, color=levelColor, style=getStyle(style))
    var label topLabel      = label.new(na, na, xloc=xloc.bar_time, text=str.format('P{0}H',tf_str), color=color(na), textcolor=levelColor, size=size.small, style=label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc=xloc.bar_time, text=str.format('P{0}L',tf_str), color=color(na), textcolor=levelColor, size=size.small, style=label.style_label_left)
    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))
    topLabel.set_point(         chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))
    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))
    bottomLine.set_second_point(chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))

//---------------------------------------------------------------------------------------------------------------------}
// HIGH/LOW & PREMIUM DISCOUNT FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
updateTrailingExtremes() =>
    trailing.top            := math.max(high, trailing.top)
    trailing.lastTopTime    := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom         := math.min(low, trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

drawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color=swingBearishColor, xloc=xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color=swingBullishColor, xloc=xloc.bar_time)
    var label topLabel      = label.new(na, na, color=color(na), textcolor=swingBearishColor, xloc=xloc.bar_time, style=label.style_label_down, size=size.tiny)
    var label bottomLabel   = label.new(na, na, color=color(na), textcolor=swingBullishColor, xloc=xloc.bar_time, style=label.style_label_up, size=size.tiny)
    rightTimeBar            = last_bar_time + 20 * (time - time[1])
    topLine.set_first_point(    chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(   chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_point(         chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_text(          swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')
    bottomLine.set_first_point( chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_point(      chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_text(       swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

drawZone(float labelLevel, int labelIndex, float top, float bottom, string tag, color zoneColor, string style) =>
    var label l_abel = label.new(na,na,text=tag, color=color(na),textcolor=zoneColor, style=style, size=size.small)
    var box b_ox     = box.new(na,na,na,na,bgcolor=color.new(zoneColor,80),border_color=color(na), xloc=xloc.bar_time)
    b_ox.set_top_left_point(    chart.point.new(trailing.barTime,na,top))
    b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,bottom))
    l_abel.set_point(           chart.point.new(na,labelIndex,labelLevel))

drawPremiumDiscountZones() =>
    drawZone(trailing.top, math.round(0.5*(trailing.barIndex + last_bar_index)), trailing.top, 0.95*trailing.top + 0.05*trailing.bottom, 'Premium', premiumZoneColor, label.style_label_down)
    equilibriumLevel = math.avg(trailing.top, trailing.bottom)
    drawZone(equilibriumLevel, last_bar_index, 0.525*trailing.top + 0.475*trailing.bottom, 0.525*trailing.bottom + 0.475*trailing.top, 'Equilibrium', equilibriumZoneColorInput, label.style_label_left)
    drawZone(trailing.bottom, math.round(0.5*(trailing.barIndex + last_bar_index)), 0.95*trailing.bottom + 0.05*trailing.top, trailing.bottom, 'Discount', discountZoneColor, label.style_label_up)

//---------------------------------------------------------------------------------------------------------------------}
// EXECUTION — SMC
//---------------------------------------------------------------------------------------------------------------------{
parsedOpen  = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? swingBullishColor : swingBearishColor
plotcandle(parsedOpen,high,low,close,color=candleColor,wickcolor=candleColor,bordercolor=candleColor)

if showHighLowSwingsInput or showPremiumDiscountZonesInput
    updateTrailingExtremes()
    if showHighLowSwingsInput
        drawHighLowSwings()
    if showPremiumDiscountZonesInput
        drawPremiumDiscountZones()

if showFairValueGapsInput
    deleteFairValueGaps()

getCurrentStructure(swingsLengthInput,false)
getCurrentStructure(5,false,true)

if showEqualHighsLowsInput
    getCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)

if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    displayStructure()

if showInternalOrderBlocksInput
    deleteOrderBlocks(true)

if showSwingOrderBlocksInput
    deleteOrderBlocks()

if showFairValueGapsInput
    drawFairValueGaps()

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput
        drawOrderBlocks(true)
    if showSwingOrderBlocksInput
        drawOrderBlocks()

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and newBar)
    if showDailyLevelsInput and not higherTimeframe('D')
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)
    if showWeeklyLevelsInput and not higherTimeframe('W')
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)
    if showMonthlyLevelsInput and not higherTimeframe('M')
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

//---------------------------------------------------------------------------------------------------------------------}
// ENTRY & EXIT STRATEGY
//---------------------------------------------------------------------------------------------------------------------{
bullCHoCH = currentAlerts.internalBullishCHoCH
bearCHoCH = currentAlerts.internalBearishCHoCH
bullBOS   = currentAlerts.internalBullishBOS or currentAlerts.swingBullishBOS
bearBOS   = currentAlerts.internalBearishBOS or currentAlerts.swingBearishBOS

if bullCHoCH
    lastBullCHoCH := true
    lastBearCHoCH := false
if bearCHoCH
    lastBearCHoCH := true
    lastBullCHoCH := false

// FVG & OB confluence (optional filters)
fvgBullConf = requireFVGInput ? inBullFVG() : true
fvgBearConf = requireFVGInput ? inBearFVG() : true
obBullConf  = requireOBInput  ? nearBullOB() : true
obBearConf  = requireOBInput  ? nearBearOB() : true

// CHoCH state tracking — silent, used as optional filter only
longConditionCHoCH  = showEntryInput and lastBullCHoCH and not inLong  and fvgBullConf and obBullConf
shortConditionCHoCH = showEntryInput and lastBearCHoCH and not inShort and fvgBearConf and obBearConf
exitLong            = showEntryInput and inLong  and (bearBOS or bearCHoCH)
exitShort           = showEntryInput and inShort and (bullBOS or bullCHoCH)

if longConditionCHoCH
    inLong  := true
    inShort := false
if shortConditionCHoCH
    inShort := true
    inLong  := false
if exitLong
    inLong := false
if exitShort
    inShort := false

// ── SWEEP-BASED OPTIONS ENTRIES ────────────────────────────────────────────
// Green sweep = wick below pivot low + close back above → CALL
// Red sweep   = wick above pivot high + close back below → PUT
// All filters off by default — every sweep fires a signal

smcBullBias = internalTrend.bias == BULLISH
smcBearBias = internalTrend.bias == BEARISH
biasBullOk  = requireSMCBiasInput ? smcBullBias : true
biasBearOk  = requireSMCBiasInput ? smcBearBias : true
chochBullOk = requireCHoCHInput ? lastBullCHoCH : true
chochBearOk = requireCHoCHInput ? lastBearCHoCH : true

sweepLongEntry  = showSweepEntriesInput and greenSweepFired and biasBullOk and chochBullOk and (requireFVGInput ? fvgBullConf : true)
sweepShortEntry = showSweepEntriesInput and redSweepFired   and biasBearOk and chochBearOk and (requireFVGInput ? fvgBearConf : true)

// Label arrays for fade tracking
var array<label> callLabels   = array.new<label>()
var array<label> putLabels    = array.new<label>()
var array<int>   callDays     = array.new<int>()
var array<int>   putDays      = array.new<int>()

// Rolling trading day counter
var int tradingDayCount = 0
isNewDay = ta.change(dayofmonth) != 0
if isNewDay
    tradingDayCount += 1
    // Fade labels older than fadeDaysInput days
    if fadeOldLabelsInput and callDays.size() > 0
        for i = callDays.size() - 1 to 0
            if tradingDayCount - callDays.get(i) >= fadeDaysInput
                callLabels.get(i).set_textcolor(color.new(GREEN, 78))
                callLabels.get(i).set_color(color.new(GREEN, 85))
                callLabels.remove(i)
                callDays.remove(i)
    if fadeOldLabelsInput and putDays.size() > 0
        for i = putDays.size() - 1 to 0
            if tradingDayCount - putDays.get(i) >= fadeDaysInput
                putLabels.get(i).set_textcolor(color.new(RED, 78))
                putLabels.get(i).set_color(color.new(RED, 85))
                putLabels.remove(i)
                putDays.remove(i)

// Draw CALL — colored box with TP/SL levels listed
if sweepLongEntry
    lbl = label.new(bar_index, low - atrMeasure * 0.3,
     'CALL\nTP1: +' + str.tostring(math.round(atrMeasure * tp1MultInput, 2)) +
     '\nTP2: +' + str.tostring(math.round(atrMeasure * tp2MultInput, 2)) +
     '\nTP3: +' + str.tostring(math.round(atrMeasure * tp3MultInput, 2)) +
     '\nSL:  -' + str.tostring(math.round(atrMeasure * slMultInput, 2)),
     color=color.new(GREEN, 10), textcolor=color.white,
     style=label.style_label_up, size=size.tiny)
    callLabels.push(lbl)
    callDays.push(tradingDayCount)

// Draw PUT — colored box with TP/SL levels listed
if sweepShortEntry
    lbl = label.new(bar_index, high + atrMeasure * 0.3,
     'PUT\nTP1: -' + str.tostring(math.round(atrMeasure * tp1MultInput, 2)) +
     '\nTP2: -' + str.tostring(math.round(atrMeasure * tp2MultInput, 2)) +
     '\nTP3: -' + str.tostring(math.round(atrMeasure * tp3MultInput, 2)) +
     '\nSL:  +' + str.tostring(math.round(atrMeasure * slMultInput, 2)),
     color=color.new(RED, 10), textcolor=color.white,
     style=label.style_label_down, size=size.tiny)
    putLabels.push(lbl)
    putDays.push(tradingDayCount)

//---------------------------------------------------------------------------------------------------------------------}
// BRANDING WATERMARK
//---------------------------------------------------------------------------------------------------------------------{
var table brandingTable = table.new(position.bottom_center, 1, 1)
if barstate.islast
    table.cell(brandingTable, 0, 0,
     '𝔓𝔢𝔞𝔨 𝔙𝔢𝔫𝔱𝔲𝔯𝔢𝔰  ·  𝔭𝔢𝔯𝔨𝔶𝔱𝔯𝔞𝔡𝔢𝔰𝔰',
     text_color = color.new(#b2b5be, 30),
     text_size  = size.normal,
     bgcolor    = color.new(color.black, 100))

//---------------------------------------------------------------------------------------------------------------------}
// ALERTS
//---------------------------------------------------------------------------------------------------------------------{
alertcondition(currentAlerts.internalBullishBOS,        'Internal Bullish BOS',         'Internal Bullish BOS formed')
alertcondition(currentAlerts.internalBullishCHoCH,      'Internal Bullish CHoCH',       'Internal Bullish CHoCH formed')
alertcondition(currentAlerts.internalBearishBOS,        'Internal Bearish BOS',         'Internal Bearish BOS formed')
alertcondition(currentAlerts.internalBearishCHoCH,      'Internal Bearish CHoCH',       'Internal Bearish CHoCH formed')
alertcondition(currentAlerts.swingBullishBOS,           'Bullish BOS',                  'Bullish BOS formed')
alertcondition(currentAlerts.swingBullishCHoCH,         'Bullish CHoCH',                'Bullish CHoCH formed')
alertcondition(currentAlerts.swingBearishBOS,           'Bearish BOS',                  'Bearish BOS formed')
alertcondition(currentAlerts.swingBearishCHoCH,         'Bearish CHoCH',                'Bearish CHoCH formed')
alertcondition(currentAlerts.internalBullishOrderBlock, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(currentAlerts.internalBearishOrderBlock, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')
alertcondition(currentAlerts.swingBullishOrderBlock,    'Bullish Swing OB Breakout',    'Price broke bullish swing OB')
alertcondition(currentAlerts.swingBearishOrderBlock,    'Bearish Swing OB Breakout',    'Price broke bearish swing OB')
alertcondition(currentAlerts.equalHighs,                'Equal Highs',                  'Equal highs detected')
alertcondition(currentAlerts.equalLows,                 'Equal Lows',                   'Equal lows detected')
alertcondition(currentAlerts.bullishFairValueGap,       'Bullish FVG',                  'Bullish FVG formed')
alertcondition(currentAlerts.bearishFairValueGap,       'Bearish FVG',                  'Bearish FVG formed')
alertcondition(sweepLongEntry,                          '🟢 CALL Entry — Green Sweep',  'Bull sweep CALL entry triggered')
alertcondition(sweepShortEntry,                         '🔴 PUT Entry — Red Sweep',     'Bear sweep PUT entry triggered')
alertcondition(exitLong,                                'Exit Long Signal',             'Exit long signal triggered')
alertcondition(exitShort,                               'Exit Short Signal',            'Exit short signal triggered')

//---------------------------------------------------------------------------------------------------------------------}
