// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Ki11a_B

//@version=6
indicator("BK AK-Assassin", shorttitle="ğŸ©¸", overlay=true, behind_chart=false, explicit_plot_zorder=true, max_labels_count=500)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Groups
var GRP_BASE   = "Base"
var GRP_MA     = "Moving Averages"
var GRP_SPEED  = "Speed Mode"
var GRP_HA     = "Cloud Style"
var GRP_ENV    = "Envelope (ATR)"
var GRP_CONFL  = "Confluence & Triggers"
var GRP_MOM    = "Momentum Filter (Optional)"
var GRP_COL    = "Colors"
var GRP_SIG    = "Signals/Alerts"
var GRP_MM     = "Risk & TP"
var GRP_PROTO  = "Proto Signals (Early Cross)"
var GRP_PCONT  = "Proto Continuation"
var GRP_PSWP   = "Proto Sweep (Stop Hunt)"
var GRP_DIR    = "Directional Signals (Official Cross)"
var GRP_TRAP   = "Trap Detection"
var GRP_GRADE  = "Signal Grading"
var GRP_COMP   = "Compression Zone"
var GRP_HTF    = "Higher Timeframe Bias"
var GRP_TRANS  = "Transparency Controls"

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Base
use_heikin  = input.bool(true,  "Use Heikin Ashi", group=GRP_BASE)

// âœ… Adjustable quiet-hours gate (default blocks 18:00â€“07:00)
hideQuietSignals = input.bool(true, "Hide Signals During Quiet Hours", group=GRP_BASE)
quiet_session    = input.session("1800-0700", "Quiet Hours (Session)", group=GRP_BASE)
in_quiet         = not na(time(timeframe.period, quiet_session))
rth              = hideQuietSignals ? not in_quiet : true

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ MA & Speed
ma_type   = input.string("ZLEMA","MA Type", options=["EMA","SMA","WMA","HMA","RMA","ZLEMA","ALMA"], group=GRP_MA)
ma_main   = input.int(9,  "Main/Mid MA", minval=1, group=GRP_MA)
ma_fast   = input.int(7,  "Fast MA", minval=1, group=GRP_MA)
ma_slow   = input.int(18, "Slow MA", minval=1, group=GRP_MA)
alma_off  = input.float(0.85,"ALMA Offset", minval=0, maxval=1, group=GRP_MA)
alma_sig  = input.int(6,     "ALMA Sigma", minval=1, group=GRP_MA)

// âœ… Toggles for MA lines
show_fast_ma_line      = input.bool(false,  "Show Fast MA Line", group=GRP_MA)
show_slow_ma_line      = input.bool(true,  "Show Slow MA Line", group=GRP_MA)
// âœ… Grey overlay toggle (above)
show_main_grey_line    = input.bool(false, "Show Main MA Grey Overlay (Above)", group=GRP_MA)
// âœ… Colored main MA line toggle (directly under grey)
show_main_colored_line = input.bool(true,  "Show Main MA Colored Line (Under)", group=GRP_MA)

// âœ… Optional bull/bear switching for Fast/Slow (default OFF)
fast_ma_color_switch = input.bool(true, "Fast MA Bull/Bear Color Switch", group=GRP_MA)
slow_ma_color_switch = input.bool(true, "Slow MA Bull/Bear Color Switch", group=GRP_MA)

speedFactor = input.float(0.75, "Speed Factor (0.4â€“1.2)", minval=0.4, maxval=1.2, step=0.05, group=GRP_SPEED)
adjLen(x) => math.max(1, math.round(x * speedFactor))

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Cloud Style
cloud_mode      = input.string("Classic AK-13","Cloud Mode", options=["Classic AK-13","Envelope ATR"], group=GRP_HA)
show_body_cloud = input.bool(true,  "Body Cloud", group=GRP_HA)
show_wick_cloud = input.bool(false,  "Wick Clouds", group=GRP_HA)
bg_trend        = input.bool(false,  "Background Trend Color", group=GRP_HA)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Envelope ATR
envLen   = input.int(14, "ATR Length", minval=1, group=GRP_ENV)
envMult  = input.float(0.9, "ATR Multiplier", step=0.1, group=GRP_ENV)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Confluence & Triggers
requireRegimeAgree = input.bool(true, "Require Regime Agreement", group=GRP_CONFL)
pullbackPct        = input.float(0.119, "Pullback into HA body (0â€“1)", minval=0, maxval=1, group=GRP_CONFL)
minBarGap          = input.int(1, "Bars after cross before entry", minval=0, group=GRP_CONFL)
useReversalTrigger = input.bool(true, "Enable Peak/Valley Reversal Trigger", group=GRP_CONFL)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Momentum (optional)
useTMI      = input.bool(false,"Use Momentum Filter (TMI mini)", group=GRP_MOM)
tmiLen      = input.int(12, "TMI Length", minval=5, group=GRP_MOM)
tmiRiseReq  = input.bool(false, "Require TMI rising/falling", group=GRP_MOM)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Colors
// âœ… Main line + cloud defaults
bullCol = input.color(color.new(#37ff0c, 0), "Bull", group=GRP_COL)
bearCol = input.color(color.new(#ff0014, 0), "Bear", group=GRP_COL)
neuCol  = input.color(color.new(#808080, 0), "Neutral", group=GRP_COL)

trans_bull_col    = input.int(0, "Bull Color Transparency", minval=0, maxval=100, group=GRP_COL)
trans_bear_col    = input.int(0, "Bear Color Transparency", minval=0, maxval=100, group=GRP_COL)
trans_neu_col     = input.int(0, "Neutral Color Transparency", minval=0, maxval=100, group=GRP_COL)

// âœ… Separate Fast/Slow colors (NOT tied to main)
// Base colors used when switch is OFF
fast_ma_base_col = input.color(color.new(color.white, 0), "Fast MA Base Color", group=GRP_COL)
slow_ma_base_col = input.color(color.new(#EF5350, 0),      "Slow MA Base Color", group=GRP_COL)
// Bull/Bear colors used when switch is ON
fast_ma_bull_col = input.color(color.new(#00E676, 0), "Fast MA Bull Color (Switch)", group=GRP_COL)
fast_ma_bear_col = input.color(color.new(#FF1744, 0), "Fast MA Bear Color (Switch)", group=GRP_COL)
slow_ma_bull_col = input.color(color.new(#00E676, 0), "Slow MA Bull Color (Switch)", group=GRP_COL)
slow_ma_bear_col = input.color(color.new(#FF1744, 0), "Slow MA Bear Color (Switch)", group=GRP_COL)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Signals & Risk
alertOn     = input.bool(true, "Enable Alerts", group=GRP_SIG)
useSwingSL  = input.bool(true, "SL: last swing (structure)", group=GRP_MM)
tpRR        = input.float(1.5, "TP Risk Multiple", minval=0.5, step=0.25, group=GRP_MM)

// âœ… Max icons on chart (default 11)
max_icons = input.int(22, "Max Signal Icons on Chart", minval=1, maxval=500, group=GRP_SIG)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRANSPARENCY CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
trans_body_cloud  = input.int(83, "Body Cloud", minval=0, maxval=100, group=GRP_TRANS)
trans_wick_cloud  = input.int(85, "Wick Cloud", minval=0, maxval=100, group=GRP_TRANS)
trans_background  = input.int(92, "Background", minval=0, maxval=100, group=GRP_TRANS)
trans_fast_ma     = input.int(0,  "Fast MA", minval=0, maxval=100, group=GRP_TRANS)
trans_slow_ma     = input.int(0,  "Slow MA", minval=0, maxval=100, group=GRP_TRANS)
trans_main_ma     = input.int(0,  "Main MA", minval=0, maxval=100, group=GRP_TRANS)
trans_envelope    = input.int(0,  "Envelope Lines", minval=0, maxval=100, group=GRP_TRANS)
trans_env_fill    = input.int(85, "Envelope Fill", minval=0, maxval=100, group=GRP_TRANS)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROTO SIGNALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_proto            = input.bool(false, "Show Proto Signals", group=GRP_PROTO)
proto_realtime_preview= input.bool(true, "Proto Realtime Preview (remove if unconfirmed)", group=GRP_PROTO)

proto_fast_len   = input.int(7, "Proto Fast MA", minval=1, group=GRP_PROTO)
proto_slow_len   = input.int(9, "Proto Slow MA", minval=1, group=GRP_PROTO)
proto_ma_type    = input.string("ZLEMA", "Proto MA Type", options=["EMA","SMA","WMA","HMA","RMA","ZLEMA","ALMA"], group=GRP_PROTO)
proto_size       = input.string("tiny", "Proto Size", options=["tiny","small","normal","large"], group=GRP_PROTO)
proto_style_bull = input.string("â—†", "Proto Bull Icon", options=["ğŸ”¸","â—†","âš¡","ğŸ¯","ğŸ’¢","â–ª","â—","â¬¥"], group=GRP_PROTO)
proto_style_bear = input.string("ğŸ”¸", "Proto Bear Icon", options=["ğŸ”¸","â—†","âš¡","ğŸ¯","ğŸ’¢","â–ª","â—","â¬¥"], group=GRP_PROTO)
proto_bull_col   = input.color(color.new(#26A69A, 0), "Proto Bull Color", group=GRP_PROTO)
proto_bear_col   = input.color(color.new(#EF5350, 0), "Proto Bear Color", group=GRP_PROTO)
proto_trans      = input.int(29, "Proto Transparency", minval=0, maxval=100, group=GRP_PROTO)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROTO CONTINUATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_proto_cont    = input.bool(true, "Show Proto Continuation", group=GRP_PCONT)
pcont_bars         = input.int(3, "Bars to Confirm Continuation", minval=1, maxval=5, group=GRP_PCONT)
pcont_size         = input.string("tiny", "Continuation Size", options=["tiny","small","normal","large"], group=GRP_PCONT)
pcont_icon_bull    = input.string("ğŸ”¥", "Continuation Bull Icon", options=["ğŸ”¥","ğŸ’¨","â–¶","Â»","âš¡","â¤","âœ","âœ“"], group=GRP_PCONT)
pcont_icon_bear    = input.string("ğŸ’¨", "Continuation Bear Icon", options=["ğŸ”¥","ğŸ’¨","â—€","Â«","âš¡","â¤","âœ","âœ“"], group=GRP_PCONT)
pcont_bull_col     = input.color(color.new(#4CAF50, 0), "Continuation Bull Color", group=GRP_PCONT)
pcont_bear_col     = input.color(color.new(#F44336, 0), "Continuation Bear Color", group=GRP_PCONT)
pcont_trans        = input.int(21, "Continuation Transparency", minval=0, maxval=100, group=GRP_PCONT)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROTO SWEEP (Stop Hunt)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_proto_sweep   = input.bool(true, "Show Proto Sweep", group=GRP_PSWP)
pswp_window        = input.int(3, "Bars After Proto to Watch", minval=1, maxval=10, group=GRP_PSWP)
pswp_reclaim       = input.float(0.5, "Reclaim Level (0=low, 0.5=mid, 1=high)", minval=0, maxval=1, step=0.1, group=GRP_PSWP)
pswp_size          = input.string("small", "Sweep Size", options=["tiny","small","normal","large"], group=GRP_PSWP)
pswp_icon_bull     = input.string("âš”", "Sweep Bull Icon", options=["ğŸ’€","â˜ ","ğŸ—¡","âš”","ğŸ’£","ğŸ¯","â—ˆ","â˜…"], group=GRP_PSWP)
pswp_icon_bear     = input.string("ğŸ’€", "Sweep Bear Icon", options=["ğŸ’€","â˜ ","ğŸ—¡","âš”","ğŸ’£","ğŸ¯","â—ˆ","â˜…"], group=GRP_PSWP)
pswp_bull_col      = input.color(color.new(#00BCD4, 0), "Sweep Bull Color", group=GRP_PSWP)
pswp_bear_col      = input.color(color.new(#FF9800, 0), "Sweep Bear Color", group=GRP_PSWP)
pswp_trans         = input.int(0, "Sweep Transparency", minval=0, maxval=100, group=GRP_PSWP)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIRECTIONAL SIGNALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_dir              = input.bool(true, "Show Directional Signals", group=GRP_DIR)
dir_realtime_preview  = input.bool(true, "Directional Realtime Preview (remove if unconfirmed)", group=GRP_DIR)

dir_fast_len     = input.int(7, "Directional Fast MA", minval=1, group=GRP_DIR)
dir_slow_len     = input.int(18, "Directional Slow MA", minval=1, group=GRP_DIR)
dir_ma_type      = input.string("ZLEMA", "Directional MA Type", options=["EMA","SMA","WMA","HMA","RMA","ZLEMA","ALMA"], group=GRP_DIR)
dir_size         = input.string("normal", "Directional Size", options=["tiny","small","normal","large"], group=GRP_DIR)
dir_style_bull   = input.string("â–²", "Directional Bull Icon", options=["ğŸš€","â¬†","â–²","â–³","â†‘","ğŸ”º","ğŸ‘‘","ğŸ’°"], group=GRP_DIR)
dir_style_bear   = input.string("ğŸ”»", "Directional Bear Icon", options=["ğŸ’","â¬‡","â–¼","â–½","â†“","ğŸ”»","ğŸ‘‘","ğŸ’°"], group=GRP_DIR)
dir_bull_col     = input.color(color.new(#00E676, 0), "Directional Bull Color", group=GRP_DIR)
dir_bear_col     = input.color(color.new(#FF1744, 0), "Directional Bear Color", group=GRP_DIR)
dir_trans        = input.int(0, "Directional Transparency", minval=0, maxval=100, group=GRP_DIR)
dir_show_sltp    = input.bool(false, "Show SL/TP on Directional", group=GRP_DIR)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRAP DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_traps           = input.bool(false, "Show Trap Warnings", group=GRP_TRAP)
trap_ma_compress     = input.float(0.15, "MA Compression % (ATR)", minval=0.05, maxval=0.5, step=0.05, group=GRP_TRAP)
trap_require_cloud   = input.bool(true, "Require Cloud Alignment", group=GRP_TRAP)
trap_require_mid_slow= input.bool(true, "Require Mid/Slow Cross", group=GRP_TRAP)
trap_fail_bars       = input.int(2, "Bars to Confirm Failed Follow-Through", minval=1, maxval=5, group=GRP_TRAP)

// legacy single icon input:
trap_icon            = input.string("ğŸš«", "Trap Icon", options=["ğŸš«","âŒ","â›”","âœ–","ğŸ’€","â˜ ","ğŸª¤","âš "], group=GRP_TRAP)

// separate bull/bear trap icons
trap_icon_bull       = input.string("Use trap_icon", "Bull Trap Icon", options=[
    "Use trap_icon",
    "ğŸš«","âŒ","â›”","âœ–","âš ","ğŸª¤","ğŸ’€","â˜ ",
    "ğŸš¨","ğŸ›‘","ğŸ§¨","ğŸ’£","â˜¢ï¸","â˜£ï¸",
    "ğŸ©¸","ğŸ•·ï¸","ğŸ¦‚","ğŸ¦ˆ",
    "ğŸ—¡ï¸","ğŸ”ª","ğŸª“","âš”ï¸",
    "ğŸ˜ˆ","ğŸ‘¹","ğŸ¤¡","ğŸ‘º",
    "ğŸ§Ÿ","ğŸ§Ÿâ€â™‚ï¸","ğŸ§Ÿâ€â™€ï¸",
    "ğŸ§ª","ğŸ§¬","ğŸ§¿","ğŸ‘ï¸","ğŸ•³ï¸",
    "ğŸ”¥","âš¡"
], group=GRP_TRAP)

trap_icon_bear       = input.string("Use trap_icon", "Bear Trap Icon", options=[
    "Use trap_icon",
    "ğŸš«","âŒ","â›”","âœ–","âš ","ğŸª¤","ğŸ’€","â˜ ",
    "ğŸš¨","ğŸ›‘","ğŸ§¨","ğŸ’£","â˜¢ï¸","â˜£ï¸",
    "ğŸ©¸","ğŸ•·ï¸","ğŸ¦‚","ğŸ¦ˆ",
    "ğŸ—¡ï¸","ğŸ”ª","ğŸª“","âš”ï¸",
    "ğŸ˜ˆ","ğŸ‘¹","ğŸ¤¡","ğŸ‘º",
    "ğŸ§Ÿ","ğŸ§Ÿâ€â™‚ï¸","ğŸ§Ÿâ€â™€ï¸",
    "ğŸ§ª","ğŸ§¬","ğŸ§¿","ğŸ‘ï¸","ğŸ•³ï¸",
    "ğŸ”¥","âš¡"
], group=GRP_TRAP)

trapIconBull = trap_icon_bull == "Use trap_icon" ? trap_icon : trap_icon_bull
trapIconBear = trap_icon_bear == "Use trap_icon" ? trap_icon : trap_icon_bear

trap_col             = input.color(color.new(#FF5722, 0), "Trap Color", group=GRP_TRAP)
trap_trans           = input.int(0, "Trap Transparency", minval=0, maxval=100, group=GRP_TRAP)
trap_size            = input.string("small", "Trap Size", options=["tiny","small","normal","large"], group=GRP_TRAP)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL GRADING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_grade          = input.bool(false, "Show Signal Grade", group=GRP_GRADE)
grade_size          = input.string("tiny", "Grade Label Size", options=["tiny","small","normal","large"], group=GRP_GRADE)
grade_a_col         = input.color(color.new(#00E676, 0), "Grade A Color", group=GRP_GRADE)
grade_b_col         = input.color(color.new(#FFC107, 0), "Grade B Color", group=GRP_GRADE)
grade_c_col         = input.color(color.new(#FF5722, 0), "Grade C Color", group=GRP_GRADE)
grade_trans         = input.int(0, "Grade Transparency", minval=0, maxval=100, group=GRP_GRADE)
grade_htf_weight    = input.int(2, "HTF Alignment Weight", minval=0, maxval=3, group=GRP_GRADE)
grade_expand_weight = input.int(2, "MA Expansion Weight", minval=0, maxval=3, group=GRP_GRADE)
grade_cloud_weight  = input.int(1, "Cloud Alignment Weight", minval=0, maxval=3, group=GRP_GRADE)
grade_sweep_weight  = input.int(2, "Proto Sweep Weight", minval=0, maxval=3, group=GRP_GRADE)
grade_a_threshold   = input.int(5, "Grade A Min Score", minval=1, maxval=10, group=GRP_GRADE)
grade_b_threshold   = input.int(3, "Grade B Min Score", minval=1, maxval=10, group=GRP_GRADE)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPRESSION ZONE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_compression     = input.bool(false, "Show Compression Zone", group=GRP_COMP)
comp_threshold       = input.float(0.15, "Compression Threshold (ATR %)", minval=0.05, maxval=0.5, step=0.05, group=GRP_COMP)
comp_col             = input.color(color.new(#9C27B0, 0), "Compression Color", group=GRP_COMP)
comp_trans           = input.int(85, "Compression Transparency", minval=0, maxval=100, group=GRP_COMP)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIGHER TIMEFRAME BIAS + HTF PROTO FILTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
use_htf_bias      = input.bool(true, "Enable HTF Bias Filter", group=GRP_HTF)
htf_timeframe     = input.timeframe("60", "HTF Timeframe", group=GRP_HTF)

// bias-pair dropdown + Custom lengths
htf_bias_pair     = input.string("Custom", "HTF Bias Pair", options=["Custom","Fast vs Slow","Fast vs Main","Main vs Slow"], group=GRP_HTF)
htf_ma_fast       = input.int(7,  "HTF Fast MA (Custom)", minval=1, group=GRP_HTF)
htf_ma_slow       = input.int(18, "HTF Slow MA (Custom)", minval=1, group=GRP_HTF)

htf_filter_mode   = input.string("Warn Only", "HTF Bias Filter Mode", options=["Direction Only", "Block Counter-Trend", "Warn Only"], group=GRP_HTF)
show_htf_status   = input.bool(false, "Show HTF Status Label", group=GRP_HTF)
htf_label_pos     = input.string("Top Right", "HTF Label Position", options=["Top Right","Top Left","Bottom Right","Bottom Left"], group=GRP_HTF)

// HTF Proto Filter Module
use_htf_proto         = input.bool(false, "Enable HTF Proto Filter", group=GRP_HTF)
htf_proto_mode        = input.string("Warn Only", "HTF Proto Mode", options=["Off","Warn Only","Block Counter-Trend","Require Alignment"], group=GRP_HTF)
htf_proto_use_bias_tf = input.bool(true, "HTF Proto Uses HTF Timeframe", group=GRP_HTF)
htf_proto_timeframe   = input.timeframe("240", "HTF Proto Timeframe", group=GRP_HTF)
htf_proto_pair        = input.string("Fast vs Main", "HTF Proto Pair", options=["Custom","Fast vs Slow","Fast vs Main","Main vs Slow"], group=GRP_HTF)
htf_proto_fast_len    = input.int(7, "HTF Proto Fast MA (Custom)", minval=1, group=GRP_HTF)
htf_proto_slow_len    = input.int(9, "HTF Proto Slow MA (Custom)", minval=1, group=GRP_HTF)
htf_proto_ma_type     = input.string("ZLEMA", "HTF Proto MA Type", options=["EMA","SMA","WMA","HMA","RMA","ZLEMA","ALMA"], group=GRP_HTF)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… HTF STATUS TABLE (ADDITION â€” separate controls from HTF status LABEL)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
show_htf_table  = input.bool(false, "Show HTF Status Table", group=GRP_HTF)
htf_table_pos   = input.string("Top Right", "HTF Table Position",
     options=["Top Right","Top Left","Bottom Right","Bottom Left"], group=GRP_HTF)
htf_table_trans = input.int(70, "HTF Table BG Transparency", minval=0, maxval=100, group=GRP_HTF)

f_tblPos(_s) =>
    switch _s
        "Top Right"    => position.top_right
        "Top Left"     => position.top_left
        "Bottom Right" => position.bottom_right
        => position.bottom_left

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ Helpers
getSize(s) => s=="tiny" ? size.tiny : s=="small" ? size.small : s=="normal" ? size.normal : size.large
applyTrans(col, trans) => color.new(col, trans)

bullColAdj = applyTrans(bullCol, trans_bull_col)
bearColAdj = applyTrans(bearCol, trans_bear_col)
neuColAdj  = applyTrans(neuCol,  trans_neu_col)

// label limiter (keeps only last N signal labels)
var label[] sigLabels = array.new<label>()

trackLabel(label lbl) =>
    if not na(lbl)
        array.push(sigLabels, lbl)
        while array.size(sigLabels) > max_icons
            label old = array.shift(sigLabels)
            if not na(old)
                label.delete(old)

untrackLabel(label lbl) =>
    bool found = false
    if not na(lbl)
        int sz = array.size(sigLabels)
        if sz > 0
            for i = 0 to sz - 1
                if array.get(sigLabels, i) == lbl
                    array.remove(sigLabels, i)
                    found := true
                    break
    found

deleteTrackedLabel(label lbl) =>
    if not na(lbl)
        bool wasTracked = untrackLabel(lbl)
        if wasTracked
            label.delete(lbl)

maFun(x, p, maType) =>
    ip = adjLen(p)
    switch maType
        "SMA"   => ta.sma(x, ip)
        "EMA"   => ta.ema(x, ip)
        "WMA"   => ta.wma(x, ip)
        "HMA"   => ta.hma(x, ip)
        "RMA"   => ta.rma(x, ip)
        "ZLEMA" =>
            lag = math.max(0, math.floor((ip - 1) / 2))
            ta.ema(x + (x - x[lag]), ip)
        "ALMA"  => ta.alma(x, ip, alma_off, alma_sig)
        => ta.ema(x, ip)

maFunOrig(x, p) => maFun(x, p, ma_type)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€ HA Calculation
var float haO = na, var float haC = na, var float haH = na, var float haL = na
if use_heikin
    haC := (open + high + low + close) / 4
    haO := na(haO[1]) ? (open + close) / 2 : (nz(haO[1]) + nz(haC[1])) / 2
    haH := math.max(high, math.max(haO, haC))
    haL := math.min(low,  math.min(haO, haC))
else
    haO := open
    haC := close
    haH := high
    haL := low

haOpen = haO, haClose = haC, haHigh = haH, haLow = haL

// AK-13 MAs
maOpen  = maFunOrig(haOpen,  ma_main)
maClose = maFunOrig(haClose, ma_main)
maHighH = maFunOrig(haHigh,  ma_main)
maLowL  = maFunOrig(haLow,   ma_main)

bodyHi = math.max(maOpen, maClose)
bodyLo = math.min(maOpen, maClose)
bodyHt = math.max(bodyHi - bodyLo, syminfo.mintick)

maFast = maFunOrig(haClose, ma_fast)
maMid  = maFunOrig(haClose, ma_main)
maSlow = maFunOrig(haClose, ma_slow)

atrVal = ta.atr(adjLen(envLen))

// Proto & Directional MAs
proto_fast_ma = maFun(haClose, proto_fast_len, proto_ma_type)
proto_slow_ma = maFun(haClose, proto_slow_len, proto_ma_type)
dir_fast_ma   = maFun(haClose, dir_fast_len,   dir_ma_type)
dir_slow_ma   = maFun(haClose, dir_slow_len,   dir_ma_type)

proto_bull_cross = proto_fast_ma > proto_slow_ma and proto_fast_ma[1] <= proto_slow_ma[1]
proto_bear_cross = proto_fast_ma < proto_slow_ma and proto_fast_ma[1] >= proto_slow_ma[1]
dir_bull_cross   = dir_fast_ma   > dir_slow_ma   and dir_fast_ma[1]   <= dir_slow_ma[1]
dir_bear_cross   = dir_fast_ma   < dir_slow_ma   and dir_fast_ma[1]   >= dir_slow_ma[1]

mid_above_slow = maMid > maSlow
mid_below_slow = maMid < maSlow

// Compression/Expansion
ma_range = math.max(maFast, maMid, maSlow) - math.min(maFast, maMid, maSlow)
ma_compressed      = ma_range < (atrVal * comp_threshold)       // for zone/alerts
ma_compressed_trap = ma_range < (atrVal * trap_ma_compress)     // for trap logic
ma_expanding = ma_range > ma_range[1] and ma_range[1] > ma_range[2]

// Proto tracking
var float proto_cross_high = na
var float proto_cross_low  = na
var float proto_cross_mid  = na
var int   proto_cross_bar  = na
var int   proto_cross_type = 0

if proto_bull_cross
    proto_cross_high := high
    proto_cross_low  := low
    proto_cross_mid  := low + (high - low) * pswp_reclaim
    proto_cross_bar  := bar_index
    proto_cross_type := 1

if proto_bear_cross
    proto_cross_high := high
    proto_cross_low  := low
    proto_cross_mid  := high - (high - low) * pswp_reclaim
    proto_cross_bar  := bar_index
    proto_cross_type := -1

bars_since_proto = bar_index - nz(proto_cross_bar, bar_index - 999)

// Proto Continuation
var bool proto_cont_bull_fired = false
var bool proto_cont_bear_fired = false
if proto_bull_cross
    proto_cont_bull_fired := false
if proto_bear_cross
    proto_cont_bear_fired := false

in_pcont_window = bars_since_proto > 0 and bars_since_proto <= pcont_bars
proto_cont_bull = in_pcont_window and proto_cross_type == 1  and high > proto_cross_high and not proto_cont_bull_fired
proto_cont_bear = in_pcont_window and proto_cross_type == -1 and low  < proto_cross_low  and not proto_cont_bear_fired

if proto_cont_bull
    proto_cont_bull_fired := true
if proto_cont_bear
    proto_cont_bear_fired := true

// Proto Sweep
var bool proto_broke_low  = false
var bool proto_broke_high = false
var bool proto_sweep_bull_fired = false
var bool proto_sweep_bear_fired = false

if proto_bull_cross
    proto_broke_low := false
    proto_sweep_bull_fired := false
if proto_bear_cross
    proto_broke_high := false
    proto_sweep_bear_fired := false

in_pswp_window = bars_since_proto > 0 and bars_since_proto <= pswp_window

if in_pswp_window and proto_cross_type == 1 and low < proto_cross_low
    proto_broke_low := true
if in_pswp_window and proto_cross_type == -1 and high > proto_cross_high
    proto_broke_high := true

proto_sweep_bull = in_pswp_window and proto_cross_type == 1  and proto_broke_low  and close > proto_cross_mid and not proto_sweep_bull_fired
proto_sweep_bear = in_pswp_window and proto_cross_type == -1 and proto_broke_high and close < proto_cross_mid and not proto_sweep_bear_fired

if proto_sweep_bull
    proto_sweep_bull_fired := true
if proto_sweep_bear
    proto_sweep_bear_fired := true

// Trap Detection
cloud_bull = maClose > maOpen
cloud_bear = maClose < maOpen

var float dir_bull_high_at_cross = na
var float dir_bear_low_at_cross  = na
var int   dir_bull_cross_bar = na
var int   dir_bear_cross_bar = na

if dir_bull_cross
    dir_bull_high_at_cross := high
    dir_bull_cross_bar := bar_index
if dir_bear_cross
    dir_bear_low_at_cross := low
    dir_bear_cross_bar := bar_index

bars_since_bull_dir = bar_index - nz(dir_bull_cross_bar, bar_index - 999)
bars_since_bear_dir = bar_index - nz(dir_bear_cross_bar, bar_index - 999)

made_new_high_bull = ta.highest(high, trap_fail_bars + 1) > nz(dir_bull_high_at_cross, high)
broke_below_bull   = low < nz(dir_bull_high_at_cross, 0) - atrVal * 0.5
made_new_low_bear  = ta.lowest(low, trap_fail_bars + 1) < nz(dir_bear_low_at_cross, low)
broke_above_bear   = high > nz(dir_bear_low_at_cross, 99999999) + atrVal * 0.5

trap_condition_bull = bars_since_bull_dir == trap_fail_bars and (
     (trap_require_cloud and not cloud_bull) or
     (trap_require_mid_slow and not mid_above_slow) or
     ma_compressed_trap or (not made_new_high_bull and broke_below_bull))

trap_condition_bear = bars_since_bear_dir == trap_fail_bars and (
     (trap_require_cloud and not cloud_bear) or
     (trap_require_mid_slow and not mid_below_slow) or
     ma_compressed_trap or (not made_new_low_bear and broke_above_bear))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTF BIAS + HTF PROTO STATE (rewritten to avoid multiline ternary errors)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HTF Bias: resolve which two lengths we compare (A vs B)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int htf_len_a = na
int htf_len_b = na

if htf_bias_pair == "Custom"
    htf_len_a := htf_ma_fast
    htf_len_b := htf_ma_slow
else if htf_bias_pair == "Fast vs Slow"
    htf_len_a := ma_fast
    htf_len_b := ma_slow
else if htf_bias_pair == "Fast vs Main"
    htf_len_a := ma_fast
    htf_len_b := ma_main
else  // "Main vs Slow"
    htf_len_a := ma_main
    htf_len_b := ma_slow

float htf_a_val = request.security(syminfo.tickerid, htf_timeframe, maFunOrig(haClose, htf_len_a), lookahead=barmerge.lookahead_off)
float htf_b_val = request.security(syminfo.tickerid, htf_timeframe, maFunOrig(haClose, htf_len_b), lookahead=barmerge.lookahead_off)

bool htf_bull = htf_a_val > htf_b_val
bool htf_bear = htf_a_val < htf_b_val

bool htf_allows_long  = (not use_htf_bias) or (htf_filter_mode == "Warn Only") or htf_bull
bool htf_allows_short = (not use_htf_bias) or (htf_filter_mode == "Warn Only") or htf_bear
bool htf_warn_long    = use_htf_bias and (htf_filter_mode == "Warn Only") and (not htf_bull)
bool htf_warn_short   = use_htf_bias and (htf_filter_mode == "Warn Only") and (not htf_bear)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HTF Proto: timeframe + resolve which two lengths we compare (A vs B)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string htf_proto_tf = htf_proto_use_bias_tf ? htf_timeframe : htf_proto_timeframe

int htf_p_len_a = na
int htf_p_len_b = na

if htf_proto_pair == "Custom"
    htf_p_len_a := htf_proto_fast_len
    htf_p_len_b := htf_proto_slow_len
else if htf_proto_pair == "Fast vs Slow"
    htf_p_len_a := ma_fast
    htf_p_len_b := ma_slow
else if htf_proto_pair == "Fast vs Main"
    htf_p_len_a := ma_fast
    htf_p_len_b := ma_main
else  // "Main vs Slow"
    htf_p_len_a := ma_main
    htf_p_len_b := ma_slow

float htf_proto_a_val = request.security(syminfo.tickerid, htf_proto_tf, maFun(haClose, htf_p_len_a, htf_proto_ma_type), lookahead=barmerge.lookahead_off)
float htf_proto_b_val = request.security(syminfo.tickerid, htf_proto_tf, maFun(haClose, htf_p_len_b, htf_proto_ma_type), lookahead=barmerge.lookahead_off)

bool htf_proto_bull = htf_proto_a_val > htf_proto_b_val
bool htf_proto_bear = htf_proto_a_val < htf_proto_b_val
bool htf_proto_on   = use_htf_proto and (htf_proto_mode != "Off")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HTF Proto allow/warn logic (no multiline ternaries)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool htfproto_allows_long  = true
bool htfproto_allows_short = true
bool htfproto_warn_long    = false
bool htfproto_warn_short   = false

if htf_proto_on
    if htf_proto_mode == "Warn Only"
        htfproto_allows_long  := true
        htfproto_allows_short := true
        htfproto_warn_long    := not htf_proto_bull
        htfproto_warn_short   := not htf_proto_bear
    else if htf_proto_mode == "Block Counter-Trend"
        htfproto_allows_long  := not htf_proto_bear
        htfproto_allows_short := not htf_proto_bull
    else  // "Require Alignment"
        htfproto_allows_long  := htf_proto_bull
        htfproto_allows_short := htf_proto_bear

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Final directional allow/warn (HTF Bias + HTF Proto combined)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool dir_allows_long  = htf_allows_long  and htfproto_allows_long
bool dir_allows_short = htf_allows_short and htfproto_allows_short
bool dir_warn_long    = htf_warn_long  or htfproto_warn_long
bool dir_warn_short   = htf_warn_short or htfproto_warn_short

// Grading
calcGrade(isBull) =>
    score = 0
    if use_htf_bias
        score += (isBull ? htf_bull : htf_bear) ? grade_htf_weight : 0
    else
        score += grade_htf_weight
    score += ma_expanding ? grade_expand_weight : 0
    score += (isBull ? cloud_bull : cloud_bear) ? grade_cloud_weight : 0
    score += (isBull ? proto_sweep_bull_fired : proto_sweep_bear_fired) ? grade_sweep_weight : 0
    score

getGradeLabel(score) => score >= grade_a_threshold ? "A" : score >= grade_b_threshold ? "B" : "C"
getGradeColor(score) => score >= grade_a_threshold ? grade_a_col : score >= grade_b_threshold ? grade_b_col : grade_c_col

// Trend Logic
fast = maFunOrig(haClose, ma_fast)
slow = maFunOrig(haClose, ma_slow)
ak13Trend = bodyHi == bodyLo ? 0.0 : 100.0 * (maClose - maOpen) / bodyHt
alphaReg  = fast > slow ? 1 : fast < slow ? -1 : 0

bullOK = requireRegimeAgree ? (ak13Trend > 0 and alphaReg == 1) : ak13Trend > 0
bearOK = requireRegimeAgree ? (ak13Trend < 0 and alphaReg == -1) : ak13Trend < 0

upperEn = maClose + envMult * atrVal
lowerEn = maClose - envMult * atrVal

// SL/TP
swingH = ta.pivothigh(high, 3, 3)
swingL = ta.pivotlow(low, 3, 3)
longSL  = useSwingSL ? nz(swingL, low) : bodyLo
shortSL = useSwingSL ? nz(swingH, high) : bodyHi
longRisk  = math.max(close - longSL, syminfo.mintick)
shortRisk = math.max(shortSL - close, syminfo.mintick)
longTP  = close + tpRR * longRisk
shortTP = close - tpRR * shortRisk

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
cloudCol = bullOK ? bullColAdj : bearOK ? bearColAdj : neuColAdj

bgcolor(show_compression and ma_compressed ? applyTrans(comp_col, comp_trans) : na, title="Compression Zone")

// Classic AK-13 cloud
pOpen       = plot(cloud_mode=="Classic AK-13" and show_body_cloud ? maOpen  : na, color=na)
pClose_fill = plot(cloud_mode=="Classic AK-13" and show_body_cloud ? maClose : na, color=na, display=display.none)

// Colored main MA line (linewidth=3)
plot(cloud_mode=="Classic AK-13" and show_body_cloud and show_main_colored_line ? maClose : na,
     color=applyTrans(cloudCol, trans_main_ma), linewidth=2, title="Main MA (Color)")

pHigh = plot(cloud_mode=="Classic AK-13" and show_wick_cloud ? maHighH : na, color=applyTrans(neuColAdj, trans_main_ma))
pLow  = plot(cloud_mode=="Classic AK-13" and show_wick_cloud ? maLowL  : na, color=applyTrans(neuColAdj, trans_main_ma))

fill(pOpen, pClose_fill, color=cloud_mode=="Classic AK-13" and show_body_cloud ? applyTrans(cloudCol, trans_body_cloud) : na)
fill(pHigh, pOpen,       color=cloud_mode=="Classic AK-13" and show_wick_cloud ? applyTrans(neuColAdj, trans_wick_cloud) : na)
fill(pClose_fill, pLow,  color=cloud_mode=="Classic AK-13" and show_wick_cloud ? applyTrans(neuColAdj, trans_wick_cloud) : na)

// Envelope ATR cloud
pU       = plot(cloud_mode=="Envelope ATR" ? upperEn : na, color=applyTrans(neuColAdj, trans_envelope))
pM_fill  = plot(cloud_mode=="Envelope ATR" ? maClose : na, color=na, display=display.none)
plot(cloud_mode=="Envelope ATR" and show_main_colored_line ? maClose : na, color=applyTrans(cloudCol, trans_envelope), title="Envelope Mid (Color)")
pL       = plot(cloud_mode=="Envelope ATR" ? lowerEn : na, color=applyTrans(neuColAdj, trans_envelope))

fill(pU, pM_fill, color=cloud_mode=="Envelope ATR" ? applyTrans(bullOK ? bullColAdj : neuColAdj, trans_env_fill) : na)
fill(pM_fill, pL, color=cloud_mode=="Envelope ATR" ? applyTrans(bearOK ? bearColAdj : neuColAdj, trans_env_fill) : na)

bgCol = bullOK ? bullColAdj : bearOK ? bearColAdj : neuColAdj
bgcolor(bg_trend and not (show_compression and ma_compressed) ? applyTrans(bgCol, trans_background) : na)

// Fast/Slow colors independent
fast_base = fast_ma_color_switch ? (alphaReg == 1 ? fast_ma_bull_col : alphaReg == -1 ? fast_ma_bear_col : neuCol) : fast_ma_base_col
slow_base = slow_ma_color_switch ? (alphaReg == 1 ? slow_ma_bull_col : alphaReg == -1 ? slow_ma_bear_col : neuCol) : slow_ma_base_col

plot(show_fast_ma_line ? fast : na, color=applyTrans(fast_base, trans_fast_ma), title="Fast MA")
plot(show_slow_ma_line ? slow : na, color=applyTrans(slow_base, trans_slow_ma), title="Slow MA", linewidth=1)

// Grey overlay plotted LAST so it sits ABOVE the colored main line (toggle off by default)
plot(show_main_grey_line ? maMid : na, color=applyTrans(neuColAdj, trans_main_ma), title="Main MA (Grey Overlay)", linewidth=2)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOOLTIP BUILDERS (FULL / RESTORED)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
protoTipBull() =>
    t1 = "â”â”â” PROTO SIGNAL (LONG) â”â”â”\nğŸ“ Cross: " + str.tostring(proto_fast_len) + "/" + str.tostring(proto_slow_len) + " " + proto_ma_type + "\n\n"
    t2 = "âš¡ WHAT IT IS:\nEarly momentum shift. Fast MA crossed above Slow MA. This is the SCOUT - first sign the tide may turn.\n\n"
    t3 = "ğŸ¯ WHAT TO WATCH:\nâ€¢ Continuation ğŸ”¥: Next bars make higher highs = LEGIT\nâ€¢ Sweep ğŸ’€: Price dips below this bar then reclaims = KILLER ENTRY\nâ€¢ No follow-through + breakdown = TRAP\n\n"
    t4 = "ğŸ“Š CONTEXT:\nâ€¢ Bar High: " + str.tostring(high, format.mintick) + " | Low: " + str.tostring(low, format.mintick) + "\n"
    t5 = "â€¢ MAs Compressed: " + (ma_compressed ? "YES âš ï¸" : "NO âœ“") + " | Cloud: " + (cloud_bull ? "BULL âœ“" : "NOT BULL") + "\n\n"
    t6 = "ğŸ’¡ EDGE: Proto fires BEFORE the herd sees it. Smart money positioning. Wait for confirmation."
    t1 + t2 + t3 + t4 + t5 + t6

protoTipBear() =>
    t1 = "â”â”â” PROTO SIGNAL (SHORT) â”â”â”\nğŸ“ Cross: " + str.tostring(proto_fast_len) + "/" + str.tostring(proto_slow_len) + " " + proto_ma_type + "\n\n"
    t2 = "âš¡ WHAT IT IS:\nEarly momentum shift. Fast MA crossed below Slow MA. This is the SCOUT - first sign the tide may turn.\n\n"
    t3 = "ğŸ¯ WHAT TO WATCH:\nâ€¢ Continuation ğŸ”¥: Next bars make lower lows = LEGIT\nâ€¢ Sweep ğŸ’€: Price spikes above this bar then dumps = KILLER ENTRY\nâ€¢ No follow-through + breakout = TRAP\n\n"
    t4 = "ğŸ“Š CONTEXT:\nâ€¢ Bar High: " + str.tostring(high, format.mintick) + " | Low: " + str.tostring(low, format.mintick) + "\n"
    t5 = "â€¢ MAs Compressed: " + (ma_compressed ? "YES âš ï¸" : "NO âœ“") + " | Cloud: " + (cloud_bear ? "BEAR âœ“" : "NOT BEAR") + "\n\n"
    t6 = "ğŸ’¡ EDGE: Proto fires BEFORE the herd sees it. Smart money positioning. Wait for confirmation."
    t1 + t2 + t3 + t4 + t5 + t6

contTipBull() =>
    t1 = "â”â”â” PROTO CONTINUATION (LONG) ğŸ”¥ â”â”â”\nğŸ“ Bars Since Proto: " + str.tostring(bars_since_proto) + "/" + str.tostring(pcont_bars) + "\n\n"
    t2 = "ğŸ”¥ WHAT IT IS:\nProto CONFIRMED. Price made HIGHER HIGH. The move is REAL.\n\n"
    t3 = "ğŸ¯ STRATEGY:\nâ€¢ Already in? HOLD. This confirms your position.\nâ€¢ Not in? Look for pullback to proto bar mid/low.\nâ€¢ Trail stop below proto bar low.\n\n"
    t4 = "ğŸ“Š NUMBERS:\nâ€¢ Proto High (broken): " + str.tostring(proto_cross_high, format.mintick) + "\nâ€¢ Current High: " + str.tostring(high, format.mintick) + "\n"
    t5 = "â€¢ Breakout: " + str.tostring(high - proto_cross_high, format.mintick) + "\n\n"
    t6 = "ğŸ’¡ Failed follow-through = TRAP. Successful = TREND. MMs can't hold price down when real buyers step in."
    t1 + t2 + t3 + t4 + t5 + t6

contTipBear() =>
    t1 = "â”â”â” PROTO CONTINUATION (SHORT) ğŸ”¥ â”â”â”\nğŸ“ Bars Since Proto: " + str.tostring(bars_since_proto) + "/" + str.tostring(pcont_bars) + "\n\n"
    t2 = "ğŸ”¥ WHAT IT IS:\nProto CONFIRMED. Price made LOWER LOW. The move is REAL.\n\n"
    t3 = "ğŸ¯ STRATEGY:\nâ€¢ Already in? HOLD. This confirms your position.\nâ€¢ Not in? Look for pullback to proto bar mid/high.\nâ€¢ Trail stop above proto bar high.\n\n"
    t4 = "ğŸ“Š NUMBERS:\nâ€¢ Proto Low (broken): " + str.tostring(proto_cross_low, format.mintick) + "\nâ€¢ Current Low: " + str.tostring(low, format.mintick) + "\n"
    t5 = "â€¢ Breakdown: " + str.tostring(proto_cross_low - low, format.mintick) + "\n\n"
    t6 = "ğŸ’¡ Failed follow-through = TRAP. Successful = TREND. MMs can't hold price up when real sellers step in."
    t1 + t2 + t3 + t4 + t5 + t6

sweepTipBull() =>
    t1 = "â”â”â” ğŸ’€ PROTO SWEEP - KILLER ENTRY (LONG) ğŸ’€ â”â”â”\nğŸ“ Bars Since Proto: " + str.tostring(bars_since_proto) + "/" + str.tostring(pswp_window) + "\n\n"
    t2 = "â˜ ï¸ WHAT HAPPENED:\n1. Proto BULL cross fired\n2. Price SWEPT below proto bar low (stop hunt)\n3. Price RECLAIMED above " + str.tostring(pswp_reclaim * 100, "#") + "% level\n\n"
    t3 = "THIS IS THE PLAY. MMs hunted stops and FAILED.\n\n"
    t4 = "ğŸ¯ EXECUTION:\nâ€¢ ENTRY: NOW or slight pullback\nâ€¢ STOP: Below sweep low (they tried there)\nâ€¢ TARGET: Swing high or 2-3R\n\n"
    t5 = "ğŸ“Š NUMBERS:\nâ€¢ Swept Level: " + str.tostring(proto_cross_low, format.mintick) + "\nâ€¢ Reclaim: " + str.tostring(proto_cross_mid, format.mintick) + "\nâ€¢ Close: " + str.tostring(close, format.mintick) + "\n\n"
    t6 = "ğŸ’¡ MMs need liquidity. They triggered stops, absorbed selling, now have fuel to drive higher. You're WITH smart money."
    t1 + t2 + t3 + t4 + t5 + t6

sweepTipBear() =>
    t1 = "â”â”â” ğŸ’€ PROTO SWEEP - KILLER ENTRY (SHORT) ğŸ’€ â”â”â”\nğŸ“ Bars Since Proto: " + str.tostring(bars_since_proto) + "/" + str.tostring(pswp_window) + "\n\n"
    t2 = "â˜ ï¸ WHAT HAPPENED:\n1. Proto BEAR cross fired\n2. Price SWEPT above proto bar high (stop hunt)\n3. Price RECLAIMED below " + str.tostring(pswp_reclaim * 100, "#") + "% level\n\n"
    t3 = "THIS IS THE PLAY. MMs hunted stops and FAILED.\n\n"
    t4 = "ğŸ¯ EXECUTION:\nâ€¢ ENTRY: NOW or slight pullback\nâ€¢ STOP: Above sweep high (they tried there)\nâ€¢ TARGET: Swing low or 2-3R\n\n"
    t5 = "ğŸ“Š NUMBERS:\nâ€¢ Swept Level: " + str.tostring(proto_cross_high, format.mintick) + "\nâ€¢ Reclaim: " + str.tostring(proto_cross_mid, format.mintick) + "\nâ€¢ Close: " + str.tostring(close, format.mintick) + "\n\n"
    t6 = "ğŸ’¡ MMs need liquidity. They triggered stops, absorbed buying, now have fuel to drive lower. You're WITH smart money."
    t1 + t2 + t3 + t4 + t5 + t6
//============================== PART 2/2 ==============================
dirTipBull(grade) =>
    t1 = "â”â”â” ğŸš€ DIRECTIONAL (LONG) â”â”â”\nğŸ“ Cross: " + str.tostring(dir_fast_len) + "/" + str.tostring(dir_slow_len) + " | Grade: " + grade + "\n\n"
    t2 = "âš¡ OFFICIAL direction change. Slower cross confirms momentum shift.\n\n"
    t3 = "ğŸ¯ BY GRADE:\nâ€¢ A: Full size, aggressive targets, hold\nâ€¢ B: Standard size, watch weakness\nâ€¢ C: Reduce or skip\n\n"
    t4 = "ğŸ“Š GRADE BREAKDOWN:\nâ€¢ HTF: " + (htf_bull or not use_htf_bias ? "âœ“+" + str.tostring(grade_htf_weight) : "âœ—+0")
    t5 = " | Expanding: " + (ma_expanding ? "âœ“+" + str.tostring(grade_expand_weight) : "âœ—+0")
    t6 = " | Cloud: " + (cloud_bull ? "âœ“+" + str.tostring(grade_cloud_weight) : "âœ—+0")
    t7 = " | Sweep: " + (proto_sweep_bull_fired ? "âœ“+" + str.tostring(grade_sweep_weight) : "âœ—+0") + "\n\n"
    t8 = "ğŸ“ SL: " + str.tostring(longSL, format.mintick) + " | TP: " + str.tostring(longTP, format.mintick) + " | Risk: " + str.tostring(longRisk, format.mintick)
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8

dirTipBear(grade) =>
    t1 = "â”â”â” ğŸ’ DIRECTIONAL (SHORT) â”â”â”\nğŸ“ Cross: " + str.tostring(dir_fast_len) + "/" + str.tostring(dir_slow_len) + " | Grade: " + grade + "\n\n"
    t2 = "âš¡ OFFICIAL direction change. Slower cross confirms momentum shift.\n\n"
    t3 = "ğŸ¯ BY GRADE:\nâ€¢ A: Full size, aggressive targets, hold\nâ€¢ B: Standard size, watch weakness\nâ€¢ C: Reduce or skip\n\n"
    t4 = "ğŸ“Š GRADE BREAKDOWN:\nâ€¢ HTF: " + (htf_bear or not use_htf_bias ? "âœ“+" + str.tostring(grade_htf_weight) : "âœ—+0")
    t5 = " | Expanding: " + (ma_expanding ? "âœ“+" + str.tostring(grade_expand_weight) : "âœ—+0")
    t6 = " | Cloud: " + (cloud_bear ? "âœ“+" + str.tostring(grade_cloud_weight) : "âœ—+0")
    t7 = " | Sweep: " + (proto_sweep_bear_fired ? "âœ“+" + str.tostring(grade_sweep_weight) : "âœ—+0") + "\n\n"
    t8 = "ğŸ“ SL: " + str.tostring(shortSL, format.mintick) + " | TP: " + str.tostring(shortTP, format.mintick) + " | Risk: " + str.tostring(shortRisk, format.mintick)
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8

trapTipBull() =>
    t1 = "â”â”â” ğŸš« TRAP - BULL FAILING ğŸš« â”â”â”\nğŸ“ Bars Since Cross: " + str.tostring(bars_since_bull_dir) + "\n\n"
    t2 = "âš ï¸ Bull directional cross is FAILING.\n\n"
    t3 = "ğŸ“Š FAILURE CONDITIONS:\nâ€¢ Compressed: " + (ma_compressed_trap ? "YES âš ï¸" : "NO")
    t4 = " | Cloud: " + (not cloud_bull ? "NOT BULL âš ï¸" : "OK")
    t5 = " | Mid>Slow: " + (not mid_above_slow ? "NO âš ï¸" : "OK") + "\n"
    t6 = "â€¢ Failed Follow-Through: " + (not made_new_high_bull and broke_below_bull ? "YES âš ï¸" : "NO") + "\n\n"
    t7 = "ğŸ¯ ACTION:\nâ€¢ IN LONG? Reduce or exit.\nâ€¢ NOT IN? DO NOT ENTER.\n\n"
    t8 = "ğŸ’¡ MMs trigger entries then reverse to hunt stops. Compressed MAs = chop = death by 1000 cuts. PATIENCE."
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8

trapTipBear() =>
    t1 = "â”â”â” ğŸš« TRAP - BEAR FAILING ğŸš« â”â”â”\nğŸ“ Bars Since Cross: " + str.tostring(bars_since_bear_dir) + "\n\n"
    t2 = "âš ï¸ Bear directional cross is FAILING.\n\n"
    t3 = "ğŸ“Š FAILURE CONDITIONS:\nâ€¢ Compressed: " + (ma_compressed_trap ? "YES âš ï¸" : "NO")
    t4 = " | Cloud: " + (not cloud_bear ? "NOT BEAR âš ï¸" : "OK")
    t5 = " | Mid<Slow: " + (not mid_below_slow ? "NO âš ï¸" : "OK") + "\n"
    t6 = "â€¢ Failed Follow-Through: " + (not made_new_low_bear and broke_above_bear ? "YES âš ï¸" : "NO") + "\n\n"
    t7 = "ğŸ¯ ACTION:\nâ€¢ IN SHORT? Reduce or exit.\nâ€¢ NOT IN? DO NOT ENTER.\n\n"
    t8 = "ğŸ’¡ MMs trigger entries then reverse to hunt stops. Compressed MAs = chop = death by 1000 cuts. PATIENCE."
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL LABELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
protoSz  = getSize(proto_size)
pcontSz  = getSize(pcont_size)
pswpSz   = getSize(pswp_size)
dirSz    = getSize(dir_size)
trapSz   = getSize(trap_size)
gradeSz  = getSize(grade_size)

// Realtime proto preview state
var label protoPreviewLbl = na
var int   protoPreviewBar = na
var int   protoPreviewDir = 0

// Realtime directional preview state
var label dirPreviewLbl = na
var int   dirPreviewBar = na
var int   dirPreviewDir = 0

if barstate.isnew
    protoPreviewLbl := na
    protoPreviewBar := na
    protoPreviewDir := 0
    dirPreviewLbl := na
    dirPreviewBar := na
    dirPreviewDir := 0

// Proto realtime preview
if proto_realtime_preview and show_proto and rth and not barstate.isconfirmed
    if na(protoPreviewLbl)
        if proto_bull_cross
            protoPreviewDir := 1
            protoPreviewBar := bar_index
            protoPreviewLbl := label.new(bar_index, low, proto_style_bull, style=label.style_label_up, color=color.new(color.black, 100),
                 textcolor=applyTrans(proto_bull_col, proto_trans), size=protoSz, yloc=yloc.belowbar, tooltip=protoTipBull())
            trackLabel(protoPreviewLbl)
        if proto_bear_cross
            protoPreviewDir := -1
            protoPreviewBar := bar_index
            protoPreviewLbl := label.new(bar_index, high, proto_style_bear, style=label.style_label_down, color=color.new(color.black, 100),
                 textcolor=applyTrans(proto_bear_col, proto_trans), size=protoSz, yloc=yloc.abovebar, tooltip=protoTipBear())
            trackLabel(protoPreviewLbl)

skip_proto_create = proto_realtime_preview and not na(protoPreviewLbl) and protoPreviewBar == bar_index

// Proto confirmed creation (when no preview exists)
if show_proto and rth and (not proto_realtime_preview or (barstate.isconfirmed and not skip_proto_create))
    if proto_bull_cross
        lblp = label.new(bar_index, low, proto_style_bull, style=label.style_label_up, color=color.new(color.black, 100),
             textcolor=applyTrans(proto_bull_col, proto_trans), size=protoSz, yloc=yloc.belowbar, tooltip=protoTipBull())
        trackLabel(lblp)
    if proto_bear_cross
        lblp = label.new(bar_index, high, proto_style_bear, style=label.style_label_down, color=color.new(color.black, 100),
             textcolor=applyTrans(proto_bear_col, proto_trans), size=protoSz, yloc=yloc.abovebar, tooltip=protoTipBear())
        trackLabel(lblp)

// Proto preview cleanup at confirmation
if proto_realtime_preview and barstate.isconfirmed and skip_proto_create
    if (protoPreviewDir == 1 and not proto_bull_cross) or (protoPreviewDir == -1 and not proto_bear_cross)
        deleteTrackedLabel(protoPreviewLbl)
    protoPreviewLbl := na
    protoPreviewBar := na
    protoPreviewDir := 0

// Continuation
if show_proto_cont and proto_cont_bull and rth
    lblc = label.new(bar_index, low, pcont_icon_bull, style=label.style_label_up, color=color.new(color.black, 100),
         textcolor=applyTrans(pcont_bull_col, pcont_trans), size=pcontSz, yloc=yloc.belowbar, tooltip=contTipBull())
    trackLabel(lblc)

if show_proto_cont and proto_cont_bear and rth
    lblc = label.new(bar_index, high, pcont_icon_bear, style=label.style_label_down, color=color.new(color.black, 100),
         textcolor=applyTrans(pcont_bear_col, pcont_trans), size=pcontSz, yloc=yloc.abovebar, tooltip=contTipBear())
    trackLabel(lblc)

// Sweep
if show_proto_sweep and proto_sweep_bull and rth
    lbls = label.new(bar_index, low, pswp_icon_bull, style=label.style_label_up, color=color.new(color.black, 100),
         textcolor=applyTrans(pswp_bull_col, pswp_trans), size=pswpSz, yloc=yloc.belowbar, tooltip=sweepTipBull())
    trackLabel(lbls)

if show_proto_sweep and proto_sweep_bear and rth
    lbls = label.new(bar_index, high, pswp_icon_bear, style=label.style_label_down, color=color.new(color.black, 100),
         textcolor=applyTrans(pswp_bear_col, pswp_trans), size=pswpSz, yloc=yloc.abovebar, tooltip=sweepTipBear())
    trackLabel(lbls)

// Directional realtime preview
if dir_realtime_preview and show_dir and rth and not barstate.isconfirmed
    if na(dirPreviewLbl)
        if dir_bull_cross and dir_allows_long
            bullScoreP = calcGrade(true)
            bullGradeP = getGradeLabel(bullScoreP)
            dirPreviewDir := 1
            dirPreviewBar := bar_index
            txtP = dir_style_bull + (dir_warn_long ? " âš " : "")
            dirPreviewLbl := label.new(bar_index, low, txtP, style=label.style_label_up, color=color.new(color.black, 100),
                 textcolor=applyTrans(dir_bull_col, dir_trans), size=dirSz, yloc=yloc.belowbar, tooltip=dirTipBull(bullGradeP))
            trackLabel(dirPreviewLbl)

        if dir_bear_cross and dir_allows_short
            bearScoreP = calcGrade(false)
            bearGradeP = getGradeLabel(bearScoreP)
            dirPreviewDir := -1
            dirPreviewBar := bar_index
            txtP = dir_style_bear + (dir_warn_short ? " âš " : "")
            dirPreviewLbl := label.new(bar_index, high, txtP, style=label.style_label_down, color=color.new(color.black, 100),
                 textcolor=applyTrans(dir_bear_col, dir_trans), size=dirSz, yloc=yloc.abovebar, tooltip=dirTipBear(bearGradeP))
            trackLabel(dirPreviewLbl)

skip_dir_create = dir_realtime_preview and not na(dirPreviewLbl) and dirPreviewBar == bar_index

// Directional confirmed creation (when no preview exists)
if show_dir and rth and (not dir_realtime_preview or (barstate.isconfirmed and not skip_dir_create))
    if dir_bull_cross and dir_allows_long
        bullScore = calcGrade(true)
        bullGrade = getGradeLabel(bullScore)
        txt = dir_style_bull + (dir_warn_long ? " âš " : "")
        lbld = label.new(bar_index, low, txt, style=label.style_label_up, color=color.new(color.black, 100),
             textcolor=applyTrans(dir_bull_col, dir_trans), size=dirSz, yloc=yloc.belowbar, tooltip=dirTipBull(bullGrade))
        trackLabel(lbld)

    if dir_bear_cross and dir_allows_short
        bearScore = calcGrade(false)
        bearGrade = getGradeLabel(bearScore)
        txt = dir_style_bear + (dir_warn_short ? " âš " : "")
        lbld = label.new(bar_index, high, txt, style=label.style_label_down, color=color.new(color.black, 100),
             textcolor=applyTrans(dir_bear_col, dir_trans), size=dirSz, yloc=yloc.abovebar, tooltip=dirTipBear(bearGrade))
        trackLabel(lbld)

// Directional preview cleanup/update at confirmation
if dir_realtime_preview and barstate.isconfirmed and skip_dir_create
    if (dirPreviewDir == 1 and not dir_bull_cross) or (dirPreviewDir == -1 and not dir_bear_cross)
        deleteTrackedLabel(dirPreviewLbl)
    else
        if dirPreviewDir == 1 and dir_bull_cross and dir_allows_long
            bullScoreC = calcGrade(true)
            bullGradeC = getGradeLabel(bullScoreC)
            txtC = dir_style_bull + (dir_warn_long ? " âš " : "")
            label.set_text(dirPreviewLbl, txtC)
            label.set_textcolor(dirPreviewLbl, applyTrans(dir_bull_col, dir_trans))
            label.set_tooltip(dirPreviewLbl, dirTipBull(bullGradeC))

        if dirPreviewDir == -1 and dir_bear_cross and dir_allows_short
            bearScoreC = calcGrade(false)
            bearGradeC = getGradeLabel(bearScoreC)
            txtC = dir_style_bear + (dir_warn_short ? " âš " : "")
            label.set_text(dirPreviewLbl, txtC)
            label.set_textcolor(dirPreviewLbl, applyTrans(dir_bear_col, dir_trans))
            label.set_tooltip(dirPreviewLbl, dirTipBear(bearGradeC))

    dirPreviewLbl := na
    dirPreviewBar := na
    dirPreviewDir := 0

// Directional SL/TP + Grade labels (confirmed only)
if show_dir and rth and barstate.isconfirmed
    if dir_bull_cross and dir_allows_long
        bullScoreX = calcGrade(true)
        bullGradeX = getGradeLabel(bullScoreX)
        if dir_show_sltp
            lblsl = label.new(bar_index, low, "SL:" + str.tostring(longSL, format.mintick) + " TP:" + str.tostring(longTP, format.mintick),
                 style=label.style_label_up, color=applyTrans(dir_bull_col, 85), textcolor=color.white, size=size.tiny, yloc=yloc.belowbar)
            trackLabel(lblsl)
        if show_grade
            lblg = label.new(bar_index, low, bullGradeX, style=label.style_label_up, color=applyTrans(getGradeColor(bullScoreX), 70),
                 textcolor=color.white, size=gradeSz, yloc=yloc.belowbar)
            trackLabel(lblg)

    if dir_bear_cross and dir_allows_short
        bearScoreX = calcGrade(false)
        bearGradeX = getGradeLabel(bearScoreX)
        if dir_show_sltp
            lblsl = label.new(bar_index, high, "SL:" + str.tostring(shortSL, format.mintick) + " TP:" + str.tostring(shortTP, format.mintick),
                 style=label.style_label_down, color=applyTrans(dir_bear_col, 85), textcolor=color.white, size=size.tiny, yloc=yloc.abovebar)
            trackLabel(lblsl)
        if show_grade
            lblg = label.new(bar_index, high, bearGradeX, style=label.style_label_down, color=applyTrans(getGradeColor(bearScoreX), 70),
                 textcolor=color.white, size=gradeSz, yloc=yloc.abovebar)
            trackLabel(lblg)

// Traps
if show_traps and trap_condition_bull
    lblt = label.new(bar_index, high, trapIconBull, style=label.style_label_down, color=color.new(color.black, 100),
         textcolor=applyTrans(trap_col, trap_trans), size=trapSz, yloc=yloc.abovebar, tooltip=trapTipBull())
    trackLabel(lblt)

if show_traps and trap_condition_bear
    lblt = label.new(bar_index, low, trapIconBear, style=label.style_label_up, color=color.new(color.black, 100),
         textcolor=applyTrans(trap_col, trap_trans), size=trapSz, yloc=yloc.belowbar, tooltip=trapTipBear())
    trackLabel(lblt)

// HTF Label (not counted in Max Signal Icons)
var label htfLabel = na
if show_htf_status and (use_htf_bias or use_htf_proto) and barstate.islast
    label.delete(htfLabel)

    biasTxt  = use_htf_bias ? (htf_bull ? "BULL ğŸ”¥" : htf_bear ? "BEAR ğŸ’€" : "FLAT âšª") : "OFF"
    protoTxt = (use_htf_proto and htf_proto_mode != "Off") ? (htf_proto_bull ? "BULL ğŸ”¸" : htf_proto_bear ? "BEAR ğŸ”¸" : "FLAT âšª") : "OFF"

    htf_text = "HTF " + htf_timeframe + " Bias: " + biasTxt + " | Proto: " + protoTxt

    htf_tip = "â”â”â” HTF MODULES â”â”â”\n" +
              "Bias TF: " + htf_timeframe + " | Pair: " + htf_bias_pair + " (" + str.tostring(htf_len_a) + " vs " + str.tostring(htf_len_b) + ")\n" +
              "Bias Values: " + str.tostring(htf_a_val, format.mintick) + " vs " + str.tostring(htf_b_val, format.mintick) + "\n\n" +
              "Proto TF: " + (htf_proto_use_bias_tf ? htf_timeframe : htf_proto_timeframe) + " | Mode: " + htf_proto_mode + " | Pair: " + htf_proto_pair + "\n" +
              "Proto Values: " + str.tostring(htf_proto_a_val, format.mintick) + " vs " + str.tostring(htf_proto_b_val, format.mintick) + "\n\n" +
              "ğŸ’¡ Bias = overall direction filter.\n" +
              "ğŸ’¡ Proto = earlier HTF tilt (warn/block/require alignment)."

    htf_x = htf_label_pos == "Top Right" or htf_label_pos == "Bottom Right" ? bar_index + 5 : bar_index - 50
    htf_y = htf_label_pos == "Top Right" or htf_label_pos == "Top Left" ? yloc.abovebar : yloc.belowbar

    lblCol = use_htf_bias ? (htf_bull ? bullColAdj : htf_bear ? bearColAdj : neuColAdj) : (htf_proto_bull ? bullColAdj : htf_proto_bear ? bearColAdj : neuColAdj)
    htfLabel := label.new(htf_x, close, htf_text, style=label.style_label_left, color=applyTrans(lblCol, 70),
         textcolor=color.white, size=size.small, yloc=htf_y, tooltip=htf_tip)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… HTF STATUS TABLE RENDER (ADDITION) â€” fixed table.clear signature
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var table htfTbl = table.new(position.top_right, 2, 8, border_width=1)

tblSz = size.tiny  // âœ… force ALL table text to tiny

if barstate.islast
    // hide table when off or when both modules are off
    if not show_htf_table or not (use_htf_bias or use_htf_proto)
        table.clear(htfTbl, 0, 0)
    else
        table.set_position(htfTbl, f_tblPos(htf_table_pos))
        table.clear(htfTbl, 0, 0)

        bg = color.new(color.black, htf_table_trans)

        // Header
        table.cell(htfTbl, 0, 0, "HTF",    text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 0, "Status", text_color=color.white, bgcolor=bg, text_size=tblSz)

        // Bias status
        biasState = use_htf_bias ? (htf_bull ? "BULL ğŸ”¥" : htf_bear ? "BEAR ğŸ’€" : "FLAT âšª") : "OFF"
        table.cell(htfTbl, 0, 1, "Bias (" + htf_timeframe + ")", text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 1, biasState, text_color=color.white, bgcolor=bg, text_size=tblSz)

        // Bias pair + lens
        table.cell(htfTbl, 0, 2, "Bias Pair", text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 2, htf_bias_pair + " (" + str.tostring(htf_len_a) + " vs " + str.tostring(htf_len_b) + ")",
             text_color=color.white, bgcolor=bg, text_size=tblSz)

        // Bias values
        table.cell(htfTbl, 0, 3, "Bias MAs", text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 3, str.tostring(htf_a_val, format.mintick) + " / " + str.tostring(htf_b_val, format.mintick),
             text_color=color.white, bgcolor=bg, text_size=tblSz)

        // Bias mode
        table.cell(htfTbl, 0, 4, "Bias Mode", text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 4, use_htf_bias ? htf_filter_mode : "OFF", text_color=color.white, bgcolor=bg, text_size=tblSz)

        // Proto status
        protoTFtxt  = htf_proto_use_bias_tf ? htf_timeframe : htf_proto_timeframe
        protoState  = (use_htf_proto and (htf_proto_mode != "Off")) ? (htf_proto_bull ? "BULL ğŸ”¸" : htf_proto_bear ? "BEAR ğŸ”¸" : "FLAT âšª") : "OFF"

        table.cell(htfTbl, 0, 5, "Proto (" + protoTFtxt + ")", text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 5, protoState, text_color=color.white, bgcolor=bg, text_size=tblSz)

        // Proto mode
        table.cell(htfTbl, 0, 6, "Proto Mode", text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 6, use_htf_proto ? htf_proto_mode : "OFF", text_color=color.white, bgcolor=bg, text_size=tblSz)

        // Directional gate result (combined)
        gateTxt = "L:" + (dir_allows_long ? "âœ…" : "â›”") + (dir_warn_long ? "âš " : "") +
                  "  S:" + (dir_allows_short ? "âœ…" : "â›”") + (dir_warn_short ? "âš " : "")
        table.cell(htfTbl, 0, 7, "Dir Gate", text_color=color.white, bgcolor=bg, text_size=tblSz)
        table.cell(htfTbl, 1, 7, gateTxt, text_color=color.white, bgcolor=bg, text_size=tblSz)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS (respect alertOn toggle)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(alertOn and proto_bull_cross and rth, "Proto LONG", "Proto LONG on {{ticker}}")
alertcondition(alertOn and proto_bear_cross and rth, "Proto SHORT", "Proto SHORT on {{ticker}}")
alertcondition(alertOn and proto_cont_bull and rth, "Proto Continuation LONG", "Proto Continuation LONG on {{ticker}}")
alertcondition(alertOn and proto_cont_bear and rth, "Proto Continuation SHORT", "Proto Continuation SHORT on {{ticker}}")
alertcondition(alertOn and proto_sweep_bull and rth, "Proto Sweep LONG", "ğŸ’€ SWEEP: GO LONG on {{ticker}}")
alertcondition(alertOn and proto_sweep_bear and rth, "Proto Sweep SHORT", "ğŸ’€ SWEEP: GO SHORT on {{ticker}}")
alertcondition(alertOn and dir_bull_cross and rth, "Directional LONG", "Directional LONG on {{ticker}}")
alertcondition(alertOn and dir_bear_cross and rth, "Directional SHORT", "Directional SHORT on {{ticker}}")
alertcondition(alertOn and trap_condition_bull, "Trap BULL", "ğŸš« TRAP: Bull failing on {{ticker}}")
alertcondition(alertOn and trap_condition_bear, "Trap BEAR", "ğŸš« TRAP: Bear failing on {{ticker}}")
alertcondition(alertOn and ma_compressed, "Compression", "âš  Compression Zone on {{ticker}}")
