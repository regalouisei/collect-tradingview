// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © sekumar2

//@version=6

indicator("SMART SCALPING - Renko Heikenashi VWAP Overlay", overlay=true, max_lines_count=500)
// This script is designed for scalping using a combination of indicators, including Renko, Heikenashi candles, and VWAP (Volume Weighted Average Price).
// The purpose of this approach is to filter out noise from price movements and provide traders with a clearer view of the prevailing market trend.

// By using Renko Overlay (Non-Repainting) to avoid noices, Heikenashi for trending, VWAP to identify the direction
// Avoid Scalping when green and red, both the VWAP lines are visible in 1 min chart.
// Wait for the breakout and enter the trade as per the direction.
// Direction - Using VWAP line color - RED : DOWNTREND, GREEN : UPTREND, RED & GREEN together - SIDEWAYS
// During sideways buy near green & sell near Red line
// It is recommended to keep side by side 15min and 1min chart.
// For winning trade, enter the trade as per the 15min "Trend" direction or at the time of 1 and 15 min trends are the same.

// ─────────────────── INPUTS ───────────────────
mode = input.string("AUTO", "Brick Size Mode", options=["AUTO", "FIXED", "ATR", "PERCENT", "VOLATILITY"])
fixedSize = input.float(10.0, "Fixed Brick Size", step=0.1)
atrLen = input.int(14, "ATR Length")
atrMult = input.float(1.0, "ATR Multiplier (Manual)")
pctSize = input.float(0.1, "Percent Brick Size (%)", step=0.01)
highlighting = input(title='Highlighter On/Off ?', defval=true)
entryexitlabling = input(title='SCALPING ENTRY/EXIT on/off', defval=true)

// ─────────────────── SYMBOL DETECTION ───────────────────
symbol = str.upper(syminfo.ticker)
isNIFTY = str.contains(symbol, "NIFTY") and not str.contains(symbol, "BANK")
isBANKNIFTY = str.contains(symbol, "BANKNIFTY")
isSENSEX = str.contains(symbol, "SENSEX")
isCRUDE = str.contains(symbol, "CRUDE")
isNATGAS = str.contains(symbol, "NATURAL") or str.contains(symbol, "GAS")

// ─────────────────── PRESET MULTIPLIERS ───────────────────
presetMult = isNATGAS ? 2.5 : isCRUDE ? 1.8 : isBANKNIFTY ? 1.3 : isSENSEX ? 1.1 : isNIFTY ? 1.0 : 1.0

// ─────────────────── BRICK SIZE LOGIC ───────────────────
atr = ta.atr(atrLen)
brickSize = mode == "FIXED" ? fixedSize : mode == "ATR" ? atr * atrMult : mode == "PERCENT" ? close * pctSize / 100 : mode == "VOLATILITY" ? atr * presetMult : atr * presetMult
brickSize := math.max(brickSize, syminfo.mintick)

// ─────────────────── RENKO STATE ───────────────────
var float lastRenko = na
var float prevRenko = na
var int lastBar = na
var int trend = 0 // 1 = up, -1 = down

if barstate.isfirst
    lastRenko := close
    prevRenko := close
    lastBar := bar_index

price = close
diff = price - lastRenko

newUp = false
newDown = false

// ─────────────────── UP BRICKS ───────────────────
while diff >= brickSize
    prevRenko := lastRenko
    lastRenko := lastRenko + brickSize
    newUp := true
    trend := 1

    line.new(
        x1=lastBar,
        y1=lastRenko,
        x2=bar_index,
        y2=lastRenko,
        color=color.lime,
        width=2
    )

    lastBar := bar_index[1]
    diff := price - lastRenko

// ─────────────────── DOWN BRICKS ───────────────────
while diff <= -brickSize
    prevRenko := lastRenko
    lastRenko := lastRenko - brickSize
    newDown := true
    trend := -1

    line.new(
        x1=lastBar,
        y1=lastRenko,
        x2=bar_index,
        y2=lastRenko,
        color=color.red,
        width=2
    )

    lastBar := bar_index[1]
    diff := price - lastRenko

// ─────────────────── ALERTS ───────────────────
alertcondition(newUp, "Renko Up Brick", "New UP Renko brick formed")
alertcondition(newDown, "Renko Down Brick", "New DOWN Renko brick formed")
alertcondition(ta.change(trend) != 0, "Renko Trend Change", "Renko trend changed")

// ─────────────────── TABLE ───────────────────
var table t = table.new(position.bottom_left, 2, 6, border_width=1)

if barstate.islast
    table.cell(t, 0, 0, "Symbol", bgcolor=color.gray)
    table.cell(t, 1, 0, symbol)
    table.cell(t, 0, 1, "Brick Size", bgcolor=color.gray)
    table.cell(t, 1, 1, str.tostring(brickSize, format.mintick), bgcolor=color.yellow)
    table.cell(t, 0, 2, "Mode", bgcolor=color.gray)
    table.cell(t, 1, 2, mode)
    table.cell(t, 0, 3, "Preset Mult", bgcolor=color.gray)
    table.cell(t, 1, 3, str.tostring(presetMult))
    table.cell(t, 0, 4, "ATR", bgcolor=color.gray)
    table.cell(t, 1, 4, str.tostring(atr, format.mintick))
    table.cell(
        t, 0, 5, "Trend",
        bgcolor=trend == 1 ? color.green : trend == -1 ? color.red : color.gray
    )
    table.cell(t, 1, 5, trend == 1 ? "UPTREND" : trend == -1 ? "DOWNTREND" : "NEUTRAL")

// ─────────────────── HEIKEN ASHI ───────────────────
lastRenkosma = ta.sma(lastRenko, atrLen / 2)
lastRenkosmasma = ta.sma(lastRenkosma, atrLen / 2)

isHA = input(true, 'HA Candles')
heikenashi_1 = ticker.heikinashi(syminfo.tickerid)
data = isHA ? heikenashi_1 : syminfo.tickerid

o = request.security(data, timeframe.period, open)
h = request.security(data, timeframe.period, high)
l = request.security(data, timeframe.period, low)
c = request.security(data, timeframe.period, close)
col = c > o ? color.green : color.red

plotcandle(o, h, l, c, 'Heiken Ashi', col, color.black)

wma1 = ta.wma(c, atrLen / 3)
wma2 = ta.wma(c, atrLen)
wma3 = ta.wma(c, atrLen * 3)
hma = ta.wma(2 * wma1 - wma2, math.round(math.sqrt(atrLen)))
hmaslow = ta.wma(2 * wma2 - wma3, math.round(math.sqrt(atrLen)))

Avg = (lastRenkosma + lastRenkosmasma + hma + hmaslow) / 4
Avgema = ta.ema(Avg, atrLen / 7)
AvgemaCol = Avg > Avg[1] ? color.green : color.red
AVGEMA = plot(Avgema, "AVGEMA", color=AvgemaCol, linewidth=2)
Avgsma = ta.sma(Avg, atrLen / 2)
AvgsmaCol = Avgsma > Avgsma[1] ? color.green : color.red
AVGSMA = plot(Avgsma, "AVGSMA", color=AvgsmaCol, linewidth=1)

// ─────────────────── VWAP PRICE CHANNEL ───────────────────
tf = input.timeframe("", title="Timeframe")

get_vpc(_atrLen) =>
    var float h_vwap = high
    var float l_vwap = low
    float upper = na
    float lower = na

    hst = ta.highest(_atrLen)
    lst = ta.lowest(_atrLen)

    new_high = high == hst
    new_low = low == lst

    h_vwap := ta.vwap(high, new_high)
    l_vwap := ta.vwap(low, new_low)

    h_change = ta.change(h_vwap)
    l_change = ta.change(l_vwap)

    upper := new_high ? hst : (hst == hst[1] ? upper[1] + h_change : math.min(hst, upper[1] + h_change))
    lower := new_low ? lst : (lst == lst[1] ? lower[1] + l_change : math.max(lst, lower[1] + l_change))

    _avg = math.avg(upper, lower)

    // Trend Detection & Coloring
    var int dir = 0
    var int dir2 = 0

    dir := new_high ? 1 : new_low ? -1 : 0
    dir2 := new_high ? 1 : new_low ? -1 : dir2[1]

    [upper, lower, _avg, hst, lst, dir, dir2]

// Calling Function
[upper, lower, mid, hst, lst, dir, dir2] = request.security("", tf, get_vpc(atrLen / 2))

// ─────────────────── DISPLAY ───────────────────
up = plot(upper, title="Upper", color=dir == 1 ? color.rgb(0, 0, 0, 100) : color.rgb(255, 3, 62), style=plot.style_linebr)
md = plot(mid, title="Mid", color=dir == 1 ? color.rgb(0, 0, 0, 100) : color.rgb(255, 3, 62), display=display.none)
lo = plot(lower, title="Lower", color=dir == -1 ? color.rgb(0, 0, 0, 100) : color.rgb(26, 172, 35), style=plot.style_linebr)
cl = plot(close, display=display.none, editable=false)

fill(up, md, dir2 == 1 ? color.rgb(0, 0, 0, 100) : color.rgb(255, 3, 62, 90), title="Fill")
fill(lo, md, dir2 == -1 ? color.rgb(0, 0, 0, 100) : color.rgb(23, 188, 34, 80), title="Fill")

dch = plot(hst, title="DCUpper", color=#004d92, display=display.none)
dcl = plot(lst, title="DCLower", color=#004d92, display=display.none)

color1 = close > Avgema[2] ? #00FFFF : close < Avgsma[1] ? #FF00FF : na
barcolor(color1)
alertcondition(ta.crossover(close, Avgema[2]), title='Price Crossover Alarm', message='PRICE OVER EMA - BUY SIGNAL!')
alertcondition(ta.crossunder(close, Avgsma[2]), title='Price Crossunder Alarm', message='PRICE UNDER SMA - SELL SIGNAL!')

// ─────────────────── OPTIMIZATION SETTINGS ───────────────────
percent = input.float(0.6, 'OTT Optimization Coeff', step=0.1, minval=0)
MAvg = Avgema
fark = MAvg * percent * 0.01
longStop = MAvg - fark
longStopPrev = nz(longStop[1], longStop)
longStop := MAvg > longStopPrev ? math.max(longStop, longStopPrev) : longStop
shortStop = MAvg + fark
shortStopPrev = nz(shortStop[1], shortStop)
shortStop := MAvg < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop
Ddir = 1
Ddir := nz(Ddir[1], Ddir)
Ddir := Ddir == -1 and MAvg > shortStopPrev ? 1 : Ddir == 1 and MAvg < longStopPrev ? -1 : Ddir
MT = Ddir == 1 ? longStop : shortStop
HOTT = MAvg > MT ? MT * (200 + percent) / 200 : MT * (200 - percent) / 200
HOTTC = color.blue

MAvgl = Avgsma
farkl = MAvgl * percent * 0.01
longStopl = MAvgl - farkl
longStopPrevl = nz(longStopl[1], longStopl)
longStopl := MAvgl > longStopPrevl ? math.max(longStopl, longStopPrevl) : longStopl
shortStopl = MAvgl + farkl
shortStopPrevl = nz(shortStopl[1], shortStopl)
shortStopl := MAvgl < shortStopPrevl ? math.min(shortStopl, shortStopPrevl) : shortStopl
dirl = 1
dirl := nz(dirl[1], dirl)
dirl := dirl == -1 and MAvgl > shortStopPrevl ? 1 : dirl == 1 and MAvgl < longStopPrevl ? -1 : dirl
MTl = dirl == 1 ? longStopl : shortStopl
LOTT = MAvgl > MTl ? MTl * (200 + percent) / 200 : MTl * (200 - percent) / 200
LOTTC = color.red

HOTTLine = plot(nz(HOTT[2]), title='HOTT', color=color.new(HOTTC, 0), linewidth=2, style=plot.style_line)
LOTTLine = plot(nz(LOTT[2]), title='LOTT', color=color.new(LOTTC, 0), linewidth=2, style=plot.style_line)

FillColor = highlighting ? HOTT > LOTT ? color.new(#0400ff, 56) : color.new(#e815ff, 80) : na
fill(HOTTLine, LOTTLine, title='Highlighter', color=FillColor)

fillcol3 = highlighting ? Avgema > Avgsma ? #00ff00 : #ff0000 : color.white
fill(AVGEMA, AVGSMA, color=color.new(fillcol3, 45))

fillcol2 = highlighting ? lower > lst ? color.rgb(75, 208, 208, 39) : #ff0000 : color.white
fill(lo, dcl, color=color.new(fillcol2, 45))

fillcol1 = highlighting ? hst > upper ? color.new(#d17ad1, 85) : #00ff00 : color.white
fill(dch, up, color=color.new(fillcol1, 45))

// ─────────────────── SIGNALS ───────────────────
entrySignal = entryexitlabling ? ta.crossover(Avgema, Avgsma) : na(0) // HMA crosses above the previous value
exitSignal = entryexitlabling ? ta.crossunder(Avgema, Avgsma) : na(0) // HMA crosses below the previous value

// Plot ENTRY signal
if entrySignal
    label.new(bar_index, na, "BUY", style=label.style_label_up, color=color.green, textcolor=color.white, size=size.normal, yloc=yloc.belowbar)

// Plot EXIT signal
if exitSignal
    label.new(bar_index, na, "SELL", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.normal, yloc=yloc.abovebar)
