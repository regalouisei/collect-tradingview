//@version=6
//        _            _          _         _                        _          _      _          _      _               _                      _           _        
//       / /\         / /\       /\ \     /\ \                      /\ \       /\ \   /\ \    _ / /\   / /\             /\ \                   /\ \       / /\       
//      / /  \       / /  \      \_\ \   /  \ \                    /  \ \     /  \ \__\ \ \  /_/ / /__/ /  \           /  \ \                  \_\ \   __/ /  \      
//     / / /\ \__   / / /\ \     /\__ \ / /\ \ \     ____         / /\ \ \   / /\ \___\\ \ \ \___\//___/ /\ \         / /\ \ \                 /\__ \ /___/ /\ \     
//    / / /\ \___\ / / /\_\/    / /_ \ \\/_/\ \ \  /\____/\      / / /\ \_\ / / /\/___// / /  \ \ \\___\/\ \ \       / / /\ \_\               / /_ \ \\___\/\ \ \    
//    \ \ \ \/___// / /        / / /\ \ \    \ \ \ \/____\/     / /_/_ \/_// / /       \ \ \   \_\ \      \ \ \     / /_/_ \/_/              / / /\ \ \      \ \ \   
//     \ \ \      \ \ \   _   / / /  \/_/_   / / / /\____/\    / /____/\  / / /         \ \ \  / / /       \ \ \   / /____/\                / / /  \/_/       \ \ \  
// _    \ \ \      \ \ \/ /\ / / /      /\ \/ / /  \/____\/   / /\____\/ / / /           \ \ \/ / /         \ \ \ / /\____\/___________    / / /               \ \ \ 
///_/\__/ / /       \ \ \/ // / /       \ \/ / /             / / /______ \ \ \__          \ \ \/ /        __/ / // / /  ___/__________/\  / / /              __/ / / 
//\ \/___/ /         \ \  //_/ /         \  / /             / / /_______\ \ \___\          \ \  /        /___/ // / /  /__________    \ \/_/ /              /___/ /  
// \_____\/           \_\/ \_\/           \/_/              \/__________/  \/___/           \_\/         \___\/ \/_/   \____\/    \____\/\_\/               \___\/   

// Â© Steversteves

indicator("Price Accumulation Profile [SS]", max_bars_back = 1000, overlay = true)

// Inputs and groups 
group_set   = "Anchor Settings"
anchor_res  = input.string("Daily", "Profile Anchor", options = ["Daily", "Weekly", "Monthly"], group = group_set)

group_vis   = "Visual Style"
bins_input  = input.int(40, "Density (Number of Bins)", minval = 10, maxval = 100, group = group_vis)
width_mult  = input.float(3.0, "Profile Width", minval = 0.5, group = group_vis)
neon_main   = input.color(#00ffbb, "POC Color", group = group_vis)
neon_nodes  = input.color(#ff00ff, "Sub-Node Color", group = group_vis)

// session anchoring 
t_string = anchor_res == "Daily" ? "D" : anchor_res == "Weekly" ? "W" : "M"
is_new_period = timeframe.change(t_string)

var float[] price_history = array.new_float()
var int start_bar = bar_index

if is_new_period
    array.clear(price_history)
    start_bar := bar_index

array.push(price_history, close)

// calcs
if barstate.islast and array.size(price_history) > 0
    float max_p = array.max(price_history)
    float min_p = array.min(price_history)
    float range_p = max_p - min_p
    float bin_size = range_p / bins_input

    int[] bin_counts = array.new_int(bins_input, 0)
    for price in price_history
        int bin_idx = math.min(bins_input - 1, math.floor((price - min_p) / bin_size))
        if bin_idx >= 0
            array.set(bin_counts, bin_idx, array.get(bin_counts, bin_idx) + 1)

    // ranks
    int total_samples = array.size(price_history)
    int max_freq = array.max(bin_counts)
    
    // bin to identify 4 clusters
    int[] sorted_counts = array.copy(bin_counts)
    array.sort(sorted_counts, order.descending)

    // Visuals
    var box[] profile_boxes = array.new_box()
    var line[] node_lines = array.new_line()
    var label[] node_labels = array.new_label()

    // reset
    if array.size(profile_boxes) > 0
        for b in profile_boxes
            box.delete(b)
        array.clear(profile_boxes)
    if array.size(node_lines) > 0
        for l in node_lines
            line.delete(l)
        array.clear(node_lines)
    if array.size(node_labels) > 0
        for lb in node_labels
            label.delete(lb)
        array.clear(node_labels)

    // Drawing the profiler 
    for i = 0 to bins_input - 1
        int count = array.get(bin_counts, i)
        if count > 0
            float bin_bottom = min_p + (i * bin_size)
            float bin_top = bin_bottom + bin_size
            float mid_p = bin_bottom + (bin_size / 2)
            
            // Check if this bin is in the top 4
            int rank = -1
            for r = 0 to 3
                if count == array.get(sorted_counts, r) and count > 0
                    rank := r
                    break
            
            bool is_top_node = rank != -1
            color current_color = rank == 0 ? neon_main : is_top_node ? neon_nodes : neon_main
            int box_width = math.round((count / max_freq) * (20 * width_mult))
            
            // Draw Box
            array.push(profile_boxes, box.new(
                 bar_index + 2, bin_top, bar_index + 2 + box_width, bin_bottom, 
                 border_color = color.new(current_color, is_top_node ? 0 : 40), 
                 border_width = is_top_node ? 2 : 1,
                 bgcolor = color.new(current_color, is_top_node ? 70 : 90),
                 extend = extend.none
                 ))

            // Draw node for top 4 
            if is_top_node
                float perc = (count / total_samples) * 100
                string rank_text = rank == 0 ? "POC" : "Node " + str.tostring(rank + 1)
                
                array.push(node_lines, line.new(
                     start_bar, mid_p, bar_index + 2, mid_p, 
                     color = color.new(current_color, 20), 
                     style = rank == 0 ? line.style_solid : line.style_dotted,
                     width = rank == 0 ? 2 : 1
                     ))
                
                array.push(node_labels, label.new(
                     bar_index + 5 + box_width, mid_p, 
                     rank_text + " (" + str.tostring(math.round(perc, 1)) + "%)", 
                     color = color.new(color.black, 100), 
                     textcolor = current_color, 
                     style = label.style_label_left, 
                     size = size.small
                     ))
