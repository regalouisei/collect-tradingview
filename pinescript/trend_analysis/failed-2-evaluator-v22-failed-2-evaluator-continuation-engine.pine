//@version=6
indicator("Failed 2 Evaluator v2.3", overlay=true, max_lines_count=500, max_labels_count=500)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INPUTS: LEVEL SOURCE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpLevels = "Levels"
lvlMode   = input.string("Auto (Pivots)", "Level Source", options=["Manual Only", "Auto (Pivots)"], group=grpLevels)

manualHigh = input.float(0.0, "Manual Range High", group=grpLevels)
manualLow  = input.float(0.0, "Manual Range Low", group=grpLevels)

pLeft  = input.int(5, "Pivot Left Bars", minval=1, group=grpLevels)
pRight = input.int(2, "Pivot Right Bars", minval=1, group=grpLevels)

lvlExt      = input.int(50, "Level Line Extension (Bars)", minval=0, group=grpLevels)
lvlHist     = input.int(3, "Level History", minval=0, group=grpLevels)
lvlStyleIn  = input.string("Dashed", "Level Line Style", options=["Solid","Dashed","Dotted"], group=grpLevels)
lvlWidth    = input.int(1, "Level Line Width", minval=1, group=grpLevels)
lvlHighCol  = input.color(color.yellow, "High Level Color", group=grpLevels)
lvlLowCol   = input.color(color.aqua, "Low Level Color", group=grpLevels)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INPUTS: STATS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpStats      = "Session Statistics"
statsLookback = input.int(200, "Stats Lookback (Bars)", minval=1, maxval=500, group=grpStats)
contBars      = input.int(3, "Continuation Check (Bars)", minval=1, group=grpStats, tooltip="Number of bars after a Failed 2 OR Breakout to check if the move continued.")
trendSens     = input.float(1.0, "Trend Dot Sensitivity (%)", minval=0.0, step=0.5, group=grpStats, tooltip="Only change Green/Red dots if the percentage moves by at least this amount.")
timeDisplay   = input.string("Trading Time (Bar Sum)", "Stats Time Mode", options=["Calendar Time","Trading Time (Bar Sum)"], group=grpStats)

showLbLine    = input.bool(true, "Show Lookback Start Line", group=grpStats)
lbLineCol     = input.color(color.new(color.gray, 50), "Lookback Line Color", group=grpStats)
lbLineStyleIn = input.string("Dotted", "Lookback Line Style", options=["Solid","Dashed","Dotted"], group=grpStats)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INPUTS: MARKERS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpMarks        = "Markers"
markerShape     = input.string("Labels", "Marker Shape", options=["Triangles","Arrows","Diamonds","Labels"], group=grpMarks)
lvlMarkOffTicks = input.int(2, "Level Marker Offset (Ticks)", minval=0, group=grpMarks)

breakMarkPlacement = input.string("Break Candle (Recommended)", "Break Marker Placement", options=["Break Candle (Recommended)","Pivot Origin (Auto Pivots)"], group=grpMarks)
breakAnchorMode = input.string("Above/Below Candle (Fixed)", "Break Marker Anchor", options=["Above/Below Candle (Fixed)","On Level (Price)"], group=grpMarks)
breakSizeIn   = input.string("Small", "Break Marker Size", options=["Tiny","Small","Normal","Large","Huge"], group=grpMarks)

reclaimMarkFilter = input.string("Strict Failed 2s Only", "Show (âœ–) Markers For", options=["Strict Failed 2s Only", "All Reclaims (Includes Wrong Colors)"], group=grpMarks)

showReclaimMark = input.bool(true, "Show Reclaim Marker", group=grpMarks)
reclaimShapeIn  = input.string("Label (Text)", "Reclaim Marker Shape", options=["X Cross", "Circle with X", "Triangle", "Arrow", "Diamond", "Label (Text)"], group=grpMarks)
reclaimSizeIn   = input.string("Small", "Reclaim Marker Size", options=["Tiny","Small","Normal","Large","Huge"], group=grpMarks)

outcomePlace    = input.string("Below Candle (Price)", "Outcome Marker Placement", options=["Below Candle (Price)","Above Candle (Price)"], group=grpMarks)
outcomeOffTicks = input.int(2, "Outcome Marker Offset (Ticks)", minval=0, group=grpMarks)

colBreakUp   = input.color(color.lime, "Break Up Color", group=grpMarks)
colBreakDown = input.color(color.red, "Break Down Color", group=grpMarks)
colReclaim   = input.color(color.red, "Fail + Reclaim Color", group=grpMarks)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INPUTS: ALERTS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpAlerts = "Alerts"
useAlerts = input.bool(true, "Enable Alerts", group=grpAlerts)
msgBreakUp   = input.string("Break Up", "Alert: Break Up", group=grpAlerts)
msgBreakDown = input.string("Break Down", "Alert: Break Down", group=grpAlerts)
msgReclaim   = input.string("Fail + Reclaim (Close)", "Alert: Reclaim", group=grpAlerts)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INPUTS: TABLE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpTable  = "Table Settings"
showTable = input.bool(true, "Show Table", group=grpTable)
tablePos  = input.string("Top Right", "Table Position", options=["Top Right","Top Left","Bottom Right","Bottom Left"], group=grpTable)
tableSize = input.string("Small", "Table Text Size", options=["Tiny","Small","Normal","Large"], group=grpTable)

tabBg         = input.color(color.new(color.black, 50), "Table Background", group=grpTable)
tabFrame      = input.color(color.gray, "Table Border", group=grpTable)
tabHeadBg     = input.color(color.new(color.gray, 20), "Header Background", group=grpTable)
tabHeadTxt    = input.color(color.white, "Header Text", group=grpTable)
tabLabel      = input.color(color.gray, "Row Labels", group=grpTable)
tabVal        = input.color(color.white, "Row Values (General)", group=grpTable)

// NEW COLOR GROUP FOR DATA
grpTabCols    = "Table Data Colors"
tabNeutralVal = input.color(color.silver, "Breakout/Hold Data Color", group=grpTabCols)
colChop       = input.color(color.gray, "Chop/Weak Reclaim Color", group=grpTabCols)
colLowStat    = input.color(color.gray, "Low/Neutral Stat Color", group=grpTabCols, tooltip="Color for Continuation % when it is not high enough to be green.")

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CORE VALUES
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
tickSize = syminfo.mintick

lvlLineStyle = line.style_dashed
if lvlStyleIn == "Solid"
    lvlLineStyle := line.style_solid
else if lvlStyleIn == "Dotted"
    lvlLineStyle := line.style_dotted

f_sz(_s) =>
    out = size.small
    if _s == "Tiny"
        out := size.tiny
    else if _s == "Small"
        out := size.small
    else if _s == "Normal"
        out := size.normal
    else if _s == "Large"
        out := size.large
    else
        out := size.huge
    out

szBreak  = f_sz(breakSizeIn)
szRecl   = f_sz(reclaimSizeIn)

styleUp = label.style_triangleup
styleDn = label.style_triangledown
if markerShape == "Triangles"
    styleUp := label.style_triangleup
    styleDn := label.style_triangledown
else if markerShape == "Arrows"
    styleUp := label.style_arrowup
    styleDn := label.style_arrowdown
else if markerShape == "Diamonds"
    styleUp := label.style_diamond
    styleDn := label.style_diamond
else
    styleUp := label.style_label_up
    styleDn := label.style_label_down

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LABEL QUEUE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var label[] allLbls = array.new_label()
lblCap = 450

f_keepLbl(_id) =>
    array.push(allLbls, _id)
    if array.size(allLbls) > lblCap
        label.delete(array.shift(allLbls))

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LEVEL DETECTION
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ph = ta.pivothigh(high, pLeft, pRight)
pl = ta.pivotlow(low, pLeft, pRight)

var float lastPH = na
var float lastPL = na
var int lastPHBar = na
var int lastPLBar = na

if not na(ph)
    lastPH := ph
    lastPHBar := bar_index - pRight

if not na(pl)
    lastPL := pl
    lastPLBar := bar_index - pRight

var float lvlHigh = na
var float lvlLow  = na

if lvlMode == "Manual Only"
    lvlHigh := manualHigh
    lvlLow  := manualLow
else
    lvlHigh := nz(lastPH, high)
    lvlLow  := nz(lastPL, low)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LINE MANAGEMENT
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var line curHighLine = na
var line curLowLine  = na
var line[] pastHighLines = array.new_line()
var line[] pastLowLines  = array.new_line()

newHighLevel = (lvlHigh != lvlHigh[1])
newLowLevel  = (lvlLow  != lvlLow[1])

if barstate.isfirst
    curHighLine := line.new(bar_index, lvlHigh, bar_index + lvlExt, lvlHigh, xloc=xloc.bar_index, color=lvlHighCol, style=lvlLineStyle, width=lvlWidth)
    curLowLine  := line.new(bar_index, lvlLow,  bar_index + lvlExt, lvlLow,  xloc=xloc.bar_index, color=lvlLowCol,  style=lvlLineStyle, width=lvlWidth)

if lvlMode == "Auto (Pivots)"
    if newHighLevel and not barstate.isfirst
        line.set_xy2(curHighLine, bar_index, lvlHigh[1])
        array.push(pastHighLines, curHighLine)
        if array.size(pastHighLines) > lvlHist
            line.delete(array.shift(pastHighLines))
        curHighLine := line.new(bar_index, lvlHigh, bar_index + lvlExt, lvlHigh, xloc=xloc.bar_index, color=lvlHighCol, style=lvlLineStyle, width=lvlWidth)

    if newLowLevel and not barstate.isfirst
        line.set_xy2(curLowLine, bar_index, lvlLow[1])
        array.push(pastLowLines, curLowLine)
        if array.size(pastLowLines) > lvlHist
            line.delete(array.shift(pastLowLines))
        curLowLine := line.new(bar_index, lvlLow, bar_index + lvlExt, lvlLow, xloc=xloc.bar_index, color=lvlLowCol, style=lvlLineStyle, width=lvlWidth)

if lvlMode == "Manual Only"
    line.set_xy1(curHighLine, bar_index - 1, lvlHigh)
    line.set_xy2(curHighLine, bar_index + 1, lvlHigh)
    line.set_extend(curHighLine, extend.both)
    
    line.set_xy1(curLowLine, bar_index - 1, lvlLow)
    line.set_xy2(curLowLine, bar_index + 1, lvlLow)
    line.set_extend(curLowLine, extend.both)
else
    line.set_xy1(curHighLine, line.get_x1(curHighLine), lvlHigh)
    line.set_xy2(curHighLine, bar_index + lvlExt, lvlHigh)
    line.set_extend(curHighLine, extend.none)
    
    line.set_xy1(curLowLine,  line.get_x1(curLowLine),  lvlLow)
    line.set_xy2(curLowLine,  bar_index + lvlExt, lvlLow)
    line.set_extend(curLowLine, extend.none)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATS ARRAYS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var int[] bounceIdx  = array.new_int()
var int[] reclaimIdx = array.new_int()

var int[] bounceUpIdx   = array.new_int()
var int[] bounceDnIdx   = array.new_int()
var int[] reclaimUpIdx  = array.new_int()
var int[] reclaimDnIdx  = array.new_int()

var int[] oReclaimIdx   = array.new_int()
var int[] oReclaimUpIdx = array.new_int()
var int[] oReclaimDnIdx = array.new_int()

// CONTINUATION TRACKING: Failed 2 (Reversals)
var int[] pendingF2U_idx = array.new_int()
var float[] pendingF2U_price = array.new_float()
var int[] successF2U_idx = array.new_int()
var int[] evalF2U_idx = array.new_int()

var int[] pendingF2D_idx = array.new_int()
var float[] pendingF2D_price = array.new_float()
var int[] successF2D_idx = array.new_int()
var int[] evalF2D_idx = array.new_int()

// CONTINUATION TRACKING: Breakouts (Holds)
var int[] pendingBrkU_idx = array.new_int()
var float[] pendingBrkU_price = array.new_float()
var int[] successBrkU_idx = array.new_int()
var int[] evalBrkU_idx = array.new_int()

var int[] pendingBrkD_idx = array.new_int()
var float[] pendingBrkD_price = array.new_float()
var int[] successBrkD_idx = array.new_int()
var int[] evalBrkD_idx = array.new_int()


f_cleanOld(_arr, _maxAge) =>
    if array.size(_arr) > 0
        if array.get(_arr, 0) < bar_index - _maxAge
            array.shift(_arr)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EVALUATION VARIABLES
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var float brokenLevel = na
var string brokenWhich = "â€”"
var string brokenDir   = "â€”"
var string outcome = "â€”"

var string activeState = "Idle: Waiting for Break..."
var color activeColor = color.gray

brokeUp = false
brokeDn = false

// STRAT LOGIC DEFINITIONS
is3Bar = bar_index > 0 ? (high > high[1] and low < low[1]) : false
is2U   = bar_index > 0 ? (high > high[1]) : false
is2D   = bar_index > 0 ? (low < low[1]) : false

// TRIGGER: Candle must physically intersect the level to be evaluated
if not na(lvlHigh)
    brokeUp := (high > lvlHigh) and (low <= lvlHigh)

if not na(lvlLow)
    brokeDn := (low < lvlLow) and (high >= lvlLow)

plotReclaim = false
var int breakMarkX = na
var float breakMarkY = na
var string breakMarkTxt = ""

// 1. LIVE WATCH (Updates every tick, gives heads up)
if brokeUp
    activeState := "2U: WATCH FOR CONT / F2U"
    activeColor := color.orange
else if brokeDn
    activeState := "2D: WATCH FOR CONT / F2D"
    activeColor := color.orange
else
    activeState := "Idle: Waiting for Break..."
    activeColor := color.gray

// 2. IMMEDIATE FINAL EVALUATION (Only fires on confirmation)
if barstate.isconfirmed
    if brokeUp
        brokenLevel := lvlHigh
        brokenWhich := "High"
        brokenDir := "UP"
        
        breakMarkX := breakMarkPlacement == "Break Candle (Recommended)" ? bar_index : nz(lastPHBar, bar_index)
        breakMarkY := lvlHigh
        breakMarkTxt := "Bâ†‘"

        if useAlerts
            alert(msgBreakUp + " | Level: " + str.tostring(brokenLevel, format.mintick), alert.freq_once_per_bar_close)

        // Strict Logic: Close must be below Level AND below Open
        if close < lvlHigh
            if close < open and is2U
                outcome := "Failed 2 Up (F2U)"
                array.push(reclaimIdx, bar_index)
                array.push(reclaimUpIdx, bar_index)
                
                // Add to F2U Continuation Watchlist (Expect Down)
                array.push(pendingF2U_idx, bar_index)
                array.push(pendingF2U_price, close)
                
                if useAlerts
                    alert(msgReclaim + " (F2U) | Dir: UP", alert.freq_once_per_bar_close)
            else
                outcome := "Reclaim (Chop)"
                array.push(oReclaimIdx, bar_index)
                array.push(oReclaimUpIdx, bar_index)
                
            if reclaimMarkFilter == "All Reclaims (Includes Wrong Colors)" or outcome == "Failed 2 Up (F2U)"
                plotReclaim := true
        else
            outcome := "Breakout Hold"
            array.push(bounceIdx, bar_index)
            array.push(bounceUpIdx, bar_index)
            
            // Add to Breakout Up Continuation Watchlist (Expect Up)
            array.push(pendingBrkU_idx, bar_index)
            array.push(pendingBrkU_price, close)

    else if brokeDn
        brokenLevel := lvlLow
        brokenWhich := "Low"
        brokenDir := "DOWN"
        
        breakMarkX := breakMarkPlacement == "Break Candle (Recommended)" ? bar_index : nz(lastPLBar, bar_index)
        breakMarkY := lvlLow
        breakMarkTxt := "Bâ†“"

        if useAlerts
            alert(msgBreakDown + " | Level: " + str.tostring(brokenLevel, format.mintick), alert.freq_once_per_bar_close)

        // Strict Logic: Close must be above Level AND above Open
        if close > lvlLow
            if close > open and is2D
                outcome := "Failed 2 Down (F2D)"
                array.push(reclaimIdx, bar_index)
                array.push(reclaimDnIdx, bar_index)
                
                // Add to F2D Continuation Watchlist (Expect Up)
                array.push(pendingF2D_idx, bar_index)
                array.push(pendingF2D_price, close)
                
                if useAlerts
                    alert(msgReclaim + " (F2D) | Dir: DOWN", alert.freq_once_per_bar_close)
            else
                outcome := "Reclaim (Chop)"
                array.push(oReclaimIdx, bar_index)
                array.push(oReclaimDnIdx, bar_index)
                
            if reclaimMarkFilter == "All Reclaims (Includes Wrong Colors)" or outcome == "Failed 2 Down (F2D)"
                plotReclaim := true
        else
            outcome := "Breakdown Hold"
            array.push(bounceIdx, bar_index)
            array.push(bounceDnIdx, bar_index)
            
            // Add to Breakout Down Continuation Watchlist (Expect Down)
            array.push(pendingBrkD_idx, bar_index)
            array.push(pendingBrkD_price, close)

    // PROCESS PENDING CONTINUATIONS (FAILED 2s)
    if array.size(pendingF2U_idx) > 0
        for i = array.size(pendingF2U_idx) - 1 to 0
            if bar_index >= array.get(pendingF2U_idx, i) + contBars
                origPrice = array.get(pendingF2U_price, i)
                origIdx = array.get(pendingF2U_idx, i)
                array.push(evalF2U_idx, origIdx)
                if close < origPrice // Bearish continuation check
                    array.push(successF2U_idx, origIdx)
                array.remove(pendingF2U_idx, i)
                array.remove(pendingF2U_price, i)

    if array.size(pendingF2D_idx) > 0
        for i = array.size(pendingF2D_idx) - 1 to 0
            if bar_index >= array.get(pendingF2D_idx, i) + contBars
                origPrice = array.get(pendingF2D_price, i)
                origIdx = array.get(pendingF2D_idx, i)
                array.push(evalF2D_idx, origIdx)
                if close > origPrice // Bullish continuation check
                    array.push(successF2D_idx, origIdx)
                array.remove(pendingF2D_idx, i)
                array.remove(pendingF2D_price, i)

    // PROCESS PENDING CONTINUATIONS (BREAKOUTS)
    if array.size(pendingBrkU_idx) > 0
        for i = array.size(pendingBrkU_idx) - 1 to 0
            if bar_index >= array.get(pendingBrkU_idx, i) + contBars
                origPrice = array.get(pendingBrkU_price, i)
                origIdx = array.get(pendingBrkU_idx, i)
                array.push(evalBrkU_idx, origIdx)
                if close > origPrice // Bullish continuation check for Breakout UP
                    array.push(successBrkU_idx, origIdx)
                array.remove(pendingBrkU_idx, i)
                array.remove(pendingBrkU_price, i)

    if array.size(pendingBrkD_idx) > 0
        for i = array.size(pendingBrkD_idx) - 1 to 0
            if bar_index >= array.get(pendingBrkD_idx, i) + contBars
                origPrice = array.get(pendingBrkD_price, i)
                origIdx = array.get(pendingBrkD_idx, i)
                array.push(evalBrkD_idx, origIdx)
                if close < origPrice // Bearish continuation check for Breakout DOWN
                    array.push(successBrkD_idx, origIdx)
                array.remove(pendingBrkD_idx, i)
                array.remove(pendingBrkD_price, i)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CLEAN OLD STATS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
f_cleanOld(bounceIdx, 600)
f_cleanOld(reclaimIdx, 600)
f_cleanOld(bounceUpIdx, 600)
f_cleanOld(bounceDnIdx, 600)
f_cleanOld(reclaimUpIdx, 600)
f_cleanOld(reclaimDnIdx, 600)
f_cleanOld(oReclaimIdx, 600)
f_cleanOld(oReclaimUpIdx, 600)
f_cleanOld(oReclaimDnIdx, 600)
f_cleanOld(evalF2U_idx, 600)
f_cleanOld(successF2U_idx, 600)
f_cleanOld(evalF2D_idx, 600)
f_cleanOld(successF2D_idx, 600)
f_cleanOld(evalBrkU_idx, 600)
f_cleanOld(successBrkU_idx, 600)
f_cleanOld(evalBrkD_idx, 600)
f_cleanOld(successBrkD_idx, 600)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COMPUTE STATS FOR LOOKBACK
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bounces = 0, reclaims = 0, otherRecs = 0
bUp = 0, bDn = 0, rUp = 0, rDn = 0, oUp = 0, oDn = 0
evalU = 0, succU = 0, evalD = 0, succD = 0
evalBU = 0, succBU = 0, evalBD = 0, succBD = 0

if array.size(bounceIdx) > 0
    for i = 0 to array.size(bounceIdx) - 1
        if array.get(bounceIdx, i) >= bar_index - statsLookback
            bounces += 1

if array.size(reclaimIdx) > 0
    for i = 0 to array.size(reclaimIdx) - 1
        if array.get(reclaimIdx, i) >= bar_index - statsLookback
            reclaims += 1

if array.size(oReclaimIdx) > 0
    for i = 0 to array.size(oReclaimIdx) - 1
        if array.get(oReclaimIdx, i) >= bar_index - statsLookback
            otherRecs += 1

if array.size(bounceUpIdx) > 0
    for i = 0 to array.size(bounceUpIdx) - 1
        if array.get(bounceUpIdx, i) >= bar_index - statsLookback
            bUp += 1

if array.size(bounceDnIdx) > 0
    for i = 0 to array.size(bounceDnIdx) - 1
        if array.get(bounceDnIdx, i) >= bar_index - statsLookback
            bDn += 1

if array.size(reclaimUpIdx) > 0
    for i = 0 to array.size(reclaimUpIdx) - 1
        if array.get(reclaimUpIdx, i) >= bar_index - statsLookback
            rUp += 1

if array.size(reclaimDnIdx) > 0
    for i = 0 to array.size(reclaimDnIdx) - 1
        if array.get(reclaimDnIdx, i) >= bar_index - statsLookback
            rDn += 1

if array.size(oReclaimUpIdx) > 0
    for i = 0 to array.size(oReclaimUpIdx) - 1
        if array.get(oReclaimUpIdx, i) >= bar_index - statsLookback
            oUp += 1

if array.size(oReclaimDnIdx) > 0
    for i = 0 to array.size(oReclaimDnIdx) - 1
        if array.get(oReclaimDnIdx, i) >= bar_index - statsLookback
            oDn += 1

// CONTINUATION MATH: FAILED 2s
if array.size(evalF2U_idx) > 0
    for i = 0 to array.size(evalF2U_idx) - 1
        if array.get(evalF2U_idx, i) >= bar_index - statsLookback
            evalU += 1

if array.size(successF2U_idx) > 0
    for i = 0 to array.size(successF2U_idx) - 1
        if array.get(successF2U_idx, i) >= bar_index - statsLookback
            succU += 1

if array.size(evalF2D_idx) > 0
    for i = 0 to array.size(evalF2D_idx) - 1
        if array.get(evalF2D_idx, i) >= bar_index - statsLookback
            evalD += 1

if array.size(successF2D_idx) > 0
    for i = 0 to array.size(successF2D_idx) - 1
        if array.get(successF2D_idx, i) >= bar_index - statsLookback
            succD += 1

// CONTINUATION MATH: BREAKOUTS
if array.size(evalBrkU_idx) > 0
    for i = 0 to array.size(evalBrkU_idx) - 1
        if array.get(evalBrkU_idx, i) >= bar_index - statsLookback
            evalBU += 1

if array.size(successBrkU_idx) > 0
    for i = 0 to array.size(successBrkU_idx) - 1
        if array.get(successBrkU_idx, i) >= bar_index - statsLookback
            succBU += 1

if array.size(evalBrkD_idx) > 0
    for i = 0 to array.size(evalBrkD_idx) - 1
        if array.get(evalBrkD_idx, i) >= bar_index - statsLookback
            evalBD += 1

if array.size(successBrkD_idx) > 0
    for i = 0 to array.size(successBrkD_idx) - 1
        if array.get(successBrkD_idx, i) >= bar_index - statsLookback
            succBD += 1

totalOutcomes = bounces + reclaims + otherRecs
bouncePct  = totalOutcomes > 0 ? (bounces / totalOutcomes) * 100.0 : 0.0
reclaimPct = totalOutcomes > 0 ? (reclaims / totalOutcomes) * 100.0 : 0.0
otherPct   = totalOutcomes > 0 ? (otherRecs / totalOutcomes) * 100.0 : 0.0

upTotal = bUp + rUp + oUp
dnTotal = bDn + rDn + oDn

upBouncePct  = upTotal > 0 ? (bUp / upTotal) * 100.0 : 0.0
upReclaimPct = upTotal > 0 ? (rUp / upTotal) * 100.0 : 0.0
upOtherPct   = upTotal > 0 ? (oUp / upTotal) * 100.0 : 0.0

dnBouncePct  = dnTotal > 0 ? (bDn / dnTotal) * 100.0 : 0.0
dnReclaimPct = dnTotal > 0 ? (rDn / dnTotal) * 100.0 : 0.0
dnOtherPct   = dnTotal > 0 ? (oDn / dnTotal) * 100.0 : 0.0

f2uContPct = evalU > 0 ? (succU / evalU) * 100.0 : 0.0
f2dContPct = evalD > 0 ? (succD / evalD) * 100.0 : 0.0
brkUContPct = evalBU > 0 ? (succBU / evalBU) * 100.0 : 0.0
brkDContPct = evalBD > 0 ? (succBD / evalBD) * 100.0 : 0.0

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TREND CIRCLE LOGIC (Updated to include Breakout Trends)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// 1. Up Breakout Trend
var float p_ubPct = na
var string arr_ubPct = ""
if na(p_ubPct)
    p_ubPct := upBouncePct
if (upBouncePct - p_ubPct) >= trendSens
    arr_ubPct := " ðŸŸ¢"
    p_ubPct := upBouncePct
else if (p_ubPct - upBouncePct) >= trendSens
    arr_ubPct := " ðŸ”´"
    p_ubPct := upBouncePct

// 2. Down Breakout Trend
var float p_dbPct = na
var string arr_dbPct = ""
if na(p_dbPct)
    p_dbPct := dnBouncePct
if (dnBouncePct - p_dbPct) >= trendSens
    arr_dbPct := " ðŸŸ¢"
    p_dbPct := dnBouncePct
else if (p_dbPct - dnBouncePct) >= trendSens
    arr_dbPct := " ðŸ”´"
    p_dbPct := dnBouncePct

// 3. Up Reclaim Trend
var float p_urPct = na
var string arr_urPct = ""
if na(p_urPct)
    p_urPct := upReclaimPct
if (upReclaimPct - p_urPct) >= trendSens
    arr_urPct := " ðŸŸ¢"
    p_urPct := upReclaimPct
else if (p_urPct - upReclaimPct) >= trendSens
    arr_urPct := " ðŸ”´"
    p_urPct := upReclaimPct

// 4. Down Reclaim Trend
var float p_drPct = na
var string arr_drPct = ""
if na(p_drPct)
    p_drPct := dnReclaimPct
if (dnReclaimPct - p_drPct) >= trendSens
    arr_drPct := " ðŸŸ¢"
    p_drPct := dnReclaimPct
else if (p_drPct - dnReclaimPct) >= trendSens
    arr_drPct := " ðŸ”´"
    p_drPct := dnReclaimPct

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LOOKBACK DURATION STRING & VERTICAL LINE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
actualLookback = math.min(statsLookback, bar_index)
var int timeInMs = timeframe.in_seconds("") * 1000

int durMs = 0
if timeDisplay == "Calendar Time"
    durMs := int(time - nz(time[actualLookback], time))
else
    durMs := timeInMs * actualLookback

d = math.floor(durMs / 86400000)
h = math.floor((durMs % 86400000) / 3600000)
m = math.floor((durMs % 3600000) / 60000)
durStr = str.tostring(d) + "d " + str.tostring(h) + "h " + str.tostring(m) + "m"

var line lookbackLine = na
lbStyle = line.style_dotted
if lbLineStyleIn == "Solid"
    lbStyle := line.style_solid
else if lbLineStyleIn == "Dashed"
    lbStyle := line.style_dashed

if showLbLine
    lbX = bar_index - actualLookback
    if na(lookbackLine)
        lookbackLine := line.new(lbX, low, lbX, high, xloc=xloc.bar_index, extend=extend.both, color=lbLineCol, style=lbStyle, width=1)
    else
        line.set_xy1(lookbackLine, lbX, low)
        line.set_xy2(lookbackLine, lbX, high)
else
    if not na(lookbackLine)
        line.delete(lookbackLine)
        lookbackLine := na

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PLOTTING MARKERS
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
outOff = outcomeOffTicks * tickSize

if breakMarkTxt != ""
    if breakAnchorMode == "On Level (Price)"
        lb = label.new(breakMarkX, breakMarkY, breakMarkTxt, xloc=xloc.bar_index, yloc=yloc.price, style=(breakMarkTxt=="Bâ†‘" ? styleUp : styleDn), color=(breakMarkTxt=="Bâ†‘" ? colBreakUp : colBreakDown), textcolor=color.white, size=szBreak)
        f_keepLbl(lb)
    else
        if breakMarkTxt == "Bâ†‘"
            lb = label.new(breakMarkX, close, breakMarkTxt, xloc=xloc.bar_index, yloc=yloc.belowbar, style=styleUp, color=colBreakUp, textcolor=color.white, size=szBreak)
            f_keepLbl(lb)
        else
            lb = label.new(breakMarkX, close, breakMarkTxt, xloc=xloc.bar_index, yloc=yloc.abovebar, style=styleDn, color=colBreakDown, textcolor=color.white, size=szBreak)
            f_keepLbl(lb)
    breakMarkTxt := ""

if plotReclaim and showReclaimMark
    yR = low - outOff
    if outcomePlace == "Above Candle (Price)"
        yR := high + outOff
        
    string lblTxt = ""
    lblStyle = label.style_xcross
    isF2U = str.contains(outcome, "Up")
    
    if reclaimShapeIn == "Circle with X"
        lblStyle := label.style_circle
        lblTxt := "âœ–"
    else if reclaimShapeIn == "Triangle"
        lblStyle := (brokenDir == "UP") ? label.style_triangledown : label.style_triangleup
    else if reclaimShapeIn == "Arrow"
        lblStyle := (brokenDir == "UP") ? label.style_arrowdown : label.style_arrowup
    else if reclaimShapeIn == "Diamond"
        lblStyle := label.style_diamond
    else if reclaimShapeIn == "Label (Text)"
        lblStyle := (brokenDir == "UP") ? label.style_label_down : label.style_label_up
        if outcome == "Failed 2 Up (F2U)"
            lblTxt := "F2U"
        else if outcome == "Failed 2 Down (F2D)"
            lblTxt := "F2D"
        else
            lblTxt := "Rec"
    else
        lblStyle := label.style_xcross

    lb = label.new(bar_index, yR, lblTxt, xloc=xloc.bar_index, yloc=yloc.price, style=lblStyle, color=colReclaim, textcolor=color.white, size=szRecl)
    f_keepLbl(lb)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DASHBOARD TABLE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
posVal = position.top_right
if tablePos == "Top Right"
    posVal := position.top_right
else if tablePos == "Top Left"
    posVal := position.top_left
else if tablePos == "Bottom Right"
    posVal := position.bottom_right
else
    posVal := position.bottom_left

txtSz = size.small
if tableSize == "Tiny"
    txtSz := size.tiny
else if tableSize == "Small"
    txtSz := size.small
else if tableSize == "Normal"
    txtSz := size.normal
else
    txtSz := size.large

var table t = na

// INCREASED ROW COUNT TO FIT NEW STATS
rowCount = 20

if showTable
    needRebuild = false
    if na(t)
        needRebuild := true

    if needRebuild
        if not na(t)
            table.delete(t)
            t := na
        t := table.new(posVal, 2, rowCount, bgcolor=tabBg, frame_color=tabFrame, frame_width=1)

    table.cell(t, 0, 0, "Break/Failed 2 Evaluator", text_color=tabHeadTxt, text_size=txtSz, bgcolor=tabHeadBg)
    table.merge_cells(t, 0, 0, 1, 0)

    table.cell(t, 0, 1, "Level High", text_color=lvlHighCol, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 1, str.tostring(lvlHigh, format.mintick), text_color=tabVal, text_size=txtSz, text_halign=text.align_right)

    table.cell(t, 0, 2, "Level Low", text_color=lvlLowCol, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 2, str.tostring(lvlLow, format.mintick), text_color=tabVal, text_size=txtSz, text_halign=text.align_right)

    lastBrokenTxt = "â€”"
    if brokenWhich != "â€”"
        lastBrokenTxt := brokenWhich + " (" + brokenDir + ")"

    table.cell(t, 0, 3, "Last Broken", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 3, lastBrokenTxt, text_color=tabVal, text_size=txtSz, text_halign=text.align_right)

    brokenLevelTxt = "â€”"
    if not na(brokenLevel)
        brokenLevelTxt := str.tostring(brokenLevel, format.mintick)

    table.cell(t, 0, 4, "Current Broken Level", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 4, brokenLevelTxt, text_color=tabVal, text_size=txtSz, text_halign=text.align_right)

    table.cell(t, 0, 5, "Current Watch", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 5, activeState, text_color=activeColor, text_size=txtSz, text_halign=text.align_right)

    outCol = tabNeutralVal
    if str.contains(outcome, "Failed 2")
        outCol := color.lime
    else if str.contains(outcome, "Hold")
        outCol := color.red

    table.cell(t, 0, 6, "Last Action", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 6, outcome, text_color=outCol, text_size=txtSz, text_halign=text.align_right)

    table.cell(t, 0, 7, "Lookback", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 7, str.tostring(statsLookback) + " bars (" + durStr + ")", text_color=tabVal, text_size=txtSz, text_halign=text.align_right)

    //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // UPSIDE STATS SECTION
    //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    table.cell(t, 0, 8, "Upside Breaks (" + str.tostring(upTotal) + ")", text_color=tabHeadTxt, text_size=txtSz, bgcolor=tabHeadBg)
    table.merge_cells(t, 0, 8, 1, 8)

    // 1. Breakout Hold (UP)
    upBreakTxt = str.tostring(upBouncePct, "#.##") + "%" + arr_ubPct + " (" + str.tostring(bUp) + "/" + str.tostring(upTotal) + ")"
    table.cell(t, 1, 9, upBreakTxt, text_color=tabNeutralVal, text_size=txtSz, text_halign=text.align_right)
    table.cell(t, 0, 9, "Breakout Hold (Trend)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    
    // 1a. Breakout Continuation
    brkUContTxt = str.tostring(brkUContPct, "#.##") + "% (" + str.tostring(succBU) + "/" + str.tostring(evalBU) + ")"
    table.cell(t, 0, 10, " â†³ Cont. (" + str.tostring(contBars) + " bars)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 10, brkUContTxt, text_color=(brkUContPct > 50 ? color.lime : colLowStat), text_size=txtSz, text_halign=text.align_right)

    // 2. Failed 2 Up (Reversal)
    upReclaimTxt  = str.tostring(upReclaimPct, "#.##") + "%" + arr_urPct + " (" + str.tostring(rUp) + "/" + str.tostring(upTotal) + ")"
    table.cell(t, 0, 11, "Failed 2 Up (Bear)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 11, upReclaimTxt, text_color=(upReclaimPct < 50 ? color.lime : color.red), text_size=txtSz, text_halign=text.align_right)
    
    // 2a. Failed 2 Continuation
    f2uContTxt = str.tostring(f2uContPct, "#.##") + "% (" + str.tostring(succU) + "/" + str.tostring(evalU) + ")"
    table.cell(t, 0, 12, " â†³ Cont. (" + str.tostring(contBars) + " bars)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 12, f2uContTxt, text_color=(f2uContPct > 50 ? color.lime : colLowStat), text_size=txtSz, text_halign=text.align_right)

    // 3. Chop Reclaims
    upOtherTxt = str.tostring(upOtherPct, "#.##") + "% (" + str.tostring(oUp) + "/" + str.tostring(upTotal) + ")"
    table.cell(t, 0, 13, "Chop/Weak Reclaim", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 13, upOtherTxt, text_color=colChop, text_size=txtSz, text_halign=text.align_right)

    //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DOWNSIDE STATS SECTION
    //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    table.cell(t, 0, 14, "Downside Breaks (" + str.tostring(dnTotal) + ")", text_color=tabHeadTxt, text_size=txtSz, bgcolor=tabHeadBg)
    table.merge_cells(t, 0, 14, 1, 14)

    // 1. Breakout Hold (DOWN)
    dnBreakTxt = str.tostring(dnBouncePct, "#.##") + "%" + arr_dbPct + " (" + str.tostring(bDn) + "/" + str.tostring(dnTotal) + ")"
    table.cell(t, 0, 15, "Breakdown Hold (Trend)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 15, dnBreakTxt, text_color=tabNeutralVal, text_size=txtSz, text_halign=text.align_right)

    // 1a. Breakout Continuation
    brkDContTxt = str.tostring(brkDContPct, "#.##") + "% (" + str.tostring(succBD) + "/" + str.tostring(evalBD) + ")"
    table.cell(t, 0, 16, " â†³ Cont. (" + str.tostring(contBars) + " bars)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 16, brkDContTxt, text_color=(brkDContPct > 50 ? color.lime : colLowStat), text_size=txtSz, text_halign=text.align_right)

    // 2. Failed 2 Down (Reversal)
    dnReclaimTxt  = str.tostring(dnReclaimPct, "#.##") + "%" + arr_drPct + " (" + str.tostring(rDn) + "/" + str.tostring(dnTotal) + ")"
    table.cell(t, 0, 17, "Failed 2 Down (Bull)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 17, dnReclaimTxt, text_color=(dnReclaimPct < 50 ? color.lime : color.red), text_size=txtSz, text_halign=text.align_right)

    // 2a. Failed 2 Continuation
    f2dContTxt = str.tostring(f2dContPct, "#.##") + "% (" + str.tostring(succD) + "/" + str.tostring(evalD) + ")"
    table.cell(t, 0, 18, " â†³ Cont. (" + str.tostring(contBars) + " bars)", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 18, f2dContTxt, text_color=(f2dContPct > 50 ? color.lime : colLowStat), text_size=txtSz, text_halign=text.align_right)

    // 3. Chop Reclaims
    dnOtherTxt = str.tostring(dnOtherPct, "#.##") + "% (" + str.tostring(oDn) + "/" + str.tostring(dnTotal) + ")"
    table.cell(t, 0, 19, "Chop/Weak Reclaim", text_color=tabLabel, text_size=txtSz, text_halign=text.align_left)
    table.cell(t, 1, 19, dnOtherTxt, text_color=colChop, text_size=txtSz, text_halign=text.align_right)
