//@version=6
// The_lurker Fawaz Al-Enezi ÙÙˆØ§Ø² Ø§Ù„Ø¹Ù†Ø²ÙŠ

indicator("Adaptive Flag Patterns [The_lurker]", shorttitle="AFP [The_lurker]", overlay=true, max_lines_count=500, max_labels_count=500, max_polylines_count=100, max_boxes_count=100)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 1: Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ø®ØµØµØ© (UDT)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type Pivot
    bool   is_high
    float  price
    int    bar_idx

type FlagData
    bool     is_bullish
    Pivot    p1
    Pivot    p2
    Pivot    p3
    Pivot    p4
    Pivot    p5
    float    flagpole_height
    float    quality
    bool     broken
    bool     cancelled
    bool     target_hit
    bool     target_hit_2
    int      breakout_bar
    float    breakout_price
    float    target_price
    float    target_price_2
    int      achieved_bar
    int      achieved_bar_2

type FlagVisuals
    line     line_pole
    line     line_23
    line     line_34
    line     line_45
    line     line_upper
    line     line_lower
    line     line_upper_ext
    line     line_lower_ext
    polyline fill_channel
    polyline fill_channel_2
    polyline poly_top_face
    polyline poly_side_face
    polyline poly_bottom_edge
    label    lbl_1
    label    lbl_2
    label    lbl_3
    label    lbl_4
    label    lbl_5
    label    lbl_quality
    label    lbl_name
    line     target_vline
    box      target_box
    polyline target_top_face
    polyline target_side_face
    label    target_label
    line     target_vline_2
    box      target_box_2
    polyline target_top_face_2
    polyline target_side_face_2
    label    target_label_2

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 2: Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string G_LANG = "ğŸŒ Language | Ø§Ù„Ù„ØºØ©"
string i_lang = input.string("English", "Interface Language | Ù„ØºØ© Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©", options=["English", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"], group=G_LANG, tooltip="Select display language\nØ§Ø®ØªØ± Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¶")
bool isAr = i_lang == "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"

string G_PAT = "ğŸ“Š Pattern Selection | Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£Ù†Ù…Ø§Ø·"
bool i_show_bull = input.bool(true, "Bullish Flag | Ø§Ù„Ø¹Ù„Ù… Ø§Ù„ØµØ§Ø¹Ø¯", group=G_PAT, tooltip="Bullish continuation pattern\nÙ†Ù…ÙˆØ°Ø¬ Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠ ØµØ¹ÙˆØ¯ÙŠ")
bool i_show_bear = input.bool(true, "Bearish Flag | Ø§Ù„Ø¹Ù„Ù… Ø§Ù„Ù‡Ø¨ÙˆØ·ÙŠ", group=G_PAT, tooltip="Bearish continuation pattern\nÙ†Ù…ÙˆØ°Ø¬ Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠ Ù‡Ø¨ÙˆØ·ÙŠ")

string G_PIV = "ğŸ§  Pivot System | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆØ±"
int   i_piv_min   = input.int(5, "Min Left Bars | Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰", minval=3, maxval=15, group=G_PIV, tooltip="Minimum bars for pivot detection\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ø´Ù…ÙˆØ¹ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù…Ø­ÙˆØ±")
int   i_piv_max   = input.int(15, "Max Left Bars | Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰", minval=8, maxval=30, group=G_PIV, tooltip="Maximum bars for pivot detection\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø´Ù…ÙˆØ¹ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù…Ø­ÙˆØ±")
int   i_piv_right = input.int(2, "Right Confirm | Ø´Ù…ÙˆØ¹ Ø§Ù„ØªØ£ÙƒÙŠØ¯", minval=1, maxval=5, group=G_PIV, tooltip="Bars to confirm pivot\nØ¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ù„ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…Ø­ÙˆØ±")

string G_DET = "âœ“ Detection Rules | Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ÙƒØ´Ù"
int   i_min_bars   = input.int(5, "Min Bars Between Points | Ø£Ù‚Ù„ Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø·", minval=2, maxval=20, group=G_DET, tooltip="Minimum bars between consecutive points\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ø¨ÙŠÙ† ÙƒÙ„ Ù†Ù‚Ø·ØªÙŠÙ†")
int   i_min_width  = input.int(15, "Min Channel Width | Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø£Ø¯Ù†Ù‰", minval=5, maxval=80, group=G_DET, tooltip="Minimum bars from P2 to P5\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ù†Ø§Ø©")
int   i_max_width  = input.int(200, "Max Pattern Width | Ø¹Ø±Ø¶ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø£Ù‚ØµÙ‰", minval=50, maxval=500, group=G_DET, tooltip="Maximum bars from P1 to P5\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† P1 Ø¥Ù„Ù‰ P5")
int   i_lookback   = input.int(300, "Lookback Bars | Ø´Ù…ÙˆØ¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©", minval=50, maxval=600, group=G_DET, tooltip="How far back to search\nÙ…Ø¯Ù‰ Ø§Ù„Ø¨Ø­Ø« Ù„Ù„Ø®Ù„Ù")
int   i_max_wait   = input.int(50, "Max Wait Bars | Ø£Ù‚ØµÙ‰ Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù„ÙƒØ³Ø±", minval=10, maxval=200, group=G_DET, tooltip="Cancel pattern if no breakout\nØ¥Ù„ØºØ§Ø¡ Ø¥Ø°Ø§ Ù„Ù… ÙŠØ­Ø¯Ø« ÙƒØ³Ø±")
float i_parallel   = input.float(0.60, "Parallelism Ratio | Ù†Ø³Ø¨Ø© Ø§Ù„ØªÙˆØ§Ø²ÙŠ", minval=0.3, maxval=0.95, step=0.05, group=G_DET, tooltip="Min slope similarity (1.0 = perfect)\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„ØªØ´Ø§Ø¨Ù‡ Ø§Ù„Ù…ÙŠÙ„")
float i_max_retrace = input.float(0.65, "Max Channel/Pole Ratio | Ù†Ø³Ø¨Ø© Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ø³Ø§Ø±ÙŠØ©", minval=0.2, maxval=0.85, step=0.05, group=G_DET, tooltip="Max channel height vs flagpole\nØ£Ù‚ØµÙ‰ Ø§Ø±ØªÙØ§Ø¹ Ù„Ù„Ù‚Ù†Ø§Ø© Ù†Ø³Ø¨Ø© Ù„Ù„Ø³Ø§Ø±ÙŠØ©")
bool  i_strict     = input.bool(true, "Strict Channel | Ù‚Ù†Ø§Ø© ØµØ§Ø±Ù…Ø©", group=G_DET, tooltip="ON = close + tolerance margin\nOFF = close only (no margin)\nÙƒÙ„Ø§Ù‡Ù…Ø§ ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ÙÙ‚Ø·")
float i_tolerance  = input.float(0.1, "Channel Tolerance % | Ù†Ø³Ø¨Ø© Ø§Ù„ØªØ³Ø§Ù…Ø­", minval=0.0, maxval=5.0, step=0.05, group=G_DET, tooltip="Allow small breaches (% of price)\nØ§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªØ¬Ø§ÙˆØ²Ø§Øª ØµØºÙŠØ±Ø© (% Ù…Ù† Ø§Ù„Ø³Ø¹Ø±)")

string G_GATE = "ğŸ” Behavior Gate | Ø§Ù„Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ©"
bool  i_use_gate    = input.bool(true, "Enable | ØªÙØ¹ÙŠÙ„", group=G_GATE, tooltip="Pre-filter: only search when market shows impulse+contraction\nÙÙ„ØªØ± Ù…Ø³Ø¨Ù‚: Ø¨Ø­Ø« ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø§Ù†ÙØ¬Ø§Ø±+ØªÙ‚Ù„Øµ")
int   i_gate_scan   = input.int(50, "Scan Window | Ù†Ø§ÙØ°Ø© Ø§Ù„ÙØ­Øµ", minval=10, maxval=100, group=G_GATE, tooltip="Bars to scan for impulse\nØ´Ù…ÙˆØ¹ ÙØ­Øµ Ø§Ù„Ø§Ù†Ø¯ÙØ§Ø¹")
float i_gate_atr    = input.float(1.5, "Min Pole ATR | Ù‚ÙˆØ© Ø§Ù„Ø³Ø§Ø±ÙŠØ©", minval=0.5, maxval=6.0, step=0.5, group=G_GATE, tooltip="Min displacement / ATR\nØ£Ù‚Ù„ Ø¥Ø²Ø§Ø­Ø© / ATR")
float i_gate_dir    = input.float(0.55, "Min Directional % | Ù†Ø³Ø¨Ø© Ø§ØªØ¬Ø§Ù‡ÙŠØ©", minval=0.4, maxval=0.8, step=0.05, group=G_GATE, tooltip="Min % of directional candles in impulse\nØ£Ù‚Ù„ Ù†Ø³Ø¨Ø© Ø´Ù…ÙˆØ¹ Ø§ØªØ¬Ø§Ù‡ÙŠØ©")
float i_gate_adx    = input.float(18.0, "Min ADX | Ø£Ù‚Ù„ ADX", minval=10, maxval=40, step=2, group=G_GATE, tooltip="Minimum ADX for trending market\nØ£Ù‚Ù„ ADX Ù„Ø³ÙˆÙ‚ Ø§ØªØ¬Ø§Ù‡ÙŠ")
float i_gate_contract = input.float(0.75, "Contraction Ratio | Ù†Ø³Ø¨Ø© Ø§Ù„ØªÙ‚Ù„Øµ", minval=0.4, maxval=0.95, step=0.05, group=G_GATE, tooltip="ATR recent / ATR impulse must be below\nATR Ø§Ù„Ø­Ø§Ù„ÙŠ / ATR Ø§Ù„Ø§Ù†Ø¯ÙØ§Ø¹")
float i_gate_ctx    = input.float(0.75, "Context Min | Ø³ÙŠØ§Ù‚ Ø§Ù„Ø³ÙˆÙ‚", minval=0.5, maxval=1.0, step=0.05, group=G_GATE, tooltip="ATR / SMA(ATR,200) minimum\nØ£Ù‚Ù„ Ù†Ø³Ø¨Ø© Ù†Ø´Ø§Ø· Ø§Ù„Ø³ÙˆÙ‚")
float i_gate_score  = input.float(40.0, "Min Score | Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰", minval=10, maxval=90, step=5, group=G_GATE, tooltip="Minimum behavior score 0-100\nØ£Ù‚Ù„ Ø¯Ø±Ø¬Ø© Ø³Ù„ÙˆÙƒÙŠØ©")

string G_QUA = "â­ Quality Filter | ÙÙ„ØªØ± Ø§Ù„Ø¬ÙˆØ¯Ø©"
bool  i_use_quality  = input.bool(true, "Enable | ØªÙØ¹ÙŠÙ„", group=G_QUA)
float i_min_quality  = input.float(50.0, "Min Score | Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰", minval=20, maxval=90, step=5, group=G_QUA, tooltip="Minimum quality score 0-100\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¬ÙˆØ¯Ø©")
bool  i_show_quality = input.bool(true, "Show on Chart | Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ù…", group=G_QUA)

string G_TGT = "ğŸ¯ Target Settings | Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ù‡Ø¯Ø§Ù"
bool  i_show_t2 = input.bool(true, "Show Official Target T2 | Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø±Ø³Ù…ÙŠ", group=G_TGT, tooltip="Show second target (100% pole)\nØ¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø«Ø§Ù†ÙŠ (100% Ø³Ø§Ø±ÙŠØ©)")
float i_target_zone_pct = input.float(2.0, "Target Zone % | Ù†Ø³Ø¨Ø© Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù‡Ø¯Ù", minval=1.0, maxval=10.0, step=0.5, group=G_TGT, tooltip="Target zone height %\nÙ†Ø³Ø¨Ø© Ø§Ø±ØªÙØ§Ø¹ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù‡Ø¯Ù")
int   i_target_3d_depth = input.int(2, "Target 3D Depth | Ø¹Ù…Ù‚ Ø§Ù„Ù‡Ø¯Ù", minval=1, maxval=5, group=G_TGT, tooltip="3D depth for target zone\nØ¹Ù…Ù‚ 3D Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù‡Ø¯Ù")

string G_3D = "ğŸ¨ 3D Effects | Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯"
bool  i_enable_3d     = input.bool(true, "Enable 3D | ØªÙØ¹ÙŠÙ„", group=G_3D)
int   i_depth_bars    = input.int(2, "Depth Bars | Ø¹Ù…Ù‚ Ø§Ù„Ø´Ù…ÙˆØ¹", minval=1, maxval=5, group=G_3D)
float i_depth_pct     = input.float(3.0, "Height % | Ù†Ø³Ø¨Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹", minval=1.0, maxval=10.0, step=0.5, group=G_3D)
int   i_3d_transp     = input.int(55, "Transparency | Ø§Ù„Ø´ÙØ§ÙÙŠØ©", minval=30, maxval=80, group=G_3D)

string G_DSP = "ğŸ–¼ Display | Ø§Ù„Ø¹Ø±Ø¶"
bool i_show_old    = input.bool(false, "Previous Patterns | Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©", group=G_DSP, tooltip="Show completed patterns\nØ¹Ø±Ø¶ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©")
bool i_show_old_tgt = input.bool(false, "Historical Targets | Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©", group=G_DSP, tooltip="Show targets for old patterns\nØ¹Ø±Ø¶ Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©")
bool i_show_name   = input.bool(true, "Pattern Name | Ø§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬", group=G_DSP, tooltip="Show pattern name inside channel\nØ¹Ø±Ø¶ Ø§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ù†Ø§Ø©")
bool i_show_points = input.bool(true, "Point Labels | ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ù†Ù‚Ø§Ø·", group=G_DSP, tooltip="Show 1-2-3-4-5 labels\nØ¹Ø±Ø¶ Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù†Ù‚Ø§Ø·")
bool i_show_pole   = input.bool(true, "Flagpole Line | Ø®Ø· Ø§Ù„Ø³Ø§Ø±ÙŠØ©", group=G_DSP, tooltip="Show flagpole line\nØ¹Ø±Ø¶ Ø®Ø· Ø§Ù„Ø³Ø§Ø±ÙŠØ©")
bool i_log_scale   = input.bool(true, "Logarithmic Scale | Ù…Ù‚ÙŠØ§Ø³ Ù„ÙˆØºØ§Ø±ÙŠØªÙ…ÙŠ", group=G_DSP)
string i_lbl_size  = input.string("Small", "Label Size | Ø­Ø¬Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª", options=["Small", "Normal", "Large"], group=G_DSP)

string G_COL = "ğŸ¨ Colors | Ø§Ù„Ø£Ù„ÙˆØ§Ù†"
color i_bull_color     = input.color(color.new(#7B1FA2, 0), "Bullish Flag | Ø§Ù„Ø¹Ù„Ù… Ø§Ù„ØµØ§Ø¹Ø¯", group=G_COL)
color i_bear_color     = input.color(color.new(#00BCD4, 0), "Bearish Flag | Ø§Ù„Ø¹Ù„Ù… Ø§Ù„Ù‡Ø¨ÙˆØ·ÙŠ", group=G_COL)
color i_bull_blend     = input.color(color.new(#E1BEE7, 0), "Bull Blend | Ù…Ø²Ø¬ ØµØ§Ø¹Ø¯", group=G_COL, tooltip="Second fill layer for depth\nØ·Ø¨Ù‚Ø© Ø«Ø§Ù†ÙŠØ© Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¹Ù…Ù‚")
color i_bear_blend     = input.color(color.new(#B2EBF2, 0), "Bear Blend | Ù…Ø²Ø¬ Ù‡Ø¨ÙˆØ·ÙŠ", group=G_COL, tooltip="Second fill layer for depth\nØ·Ø¨Ù‚Ø© Ø«Ø§Ù†ÙŠØ© Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¹Ù…Ù‚")
color i_target_color   = input.color(color.new(#2196F3, 0), "Target Line | Ø®Ø· Ø§Ù„Ù‡Ø¯Ù", group=G_COL)
color i_achieved_color = input.color(color.new(#4CAF50, 0), "Target Hit | ØªØ­Ù‚Ù‚ Ø§Ù„Ù‡Ø¯Ù", group=G_COL)
color i_quality_high   = input.color(color.new(#4CAF50, 0), "Quality High â‰¥70 | Ø¬ÙˆØ¯Ø© Ø¹Ø§Ù„ÙŠØ©", group=G_COL)
color i_quality_med    = input.color(color.new(#FF9800, 0), "Quality 50-70 | Ø¬ÙˆØ¯Ø© Ù…ØªÙˆØ³Ø·Ø©", group=G_COL)
color i_quality_low    = input.color(color.new(#F44336, 0), "Quality <50 | Ø¬ÙˆØ¯Ø© Ù…Ù†Ø®ÙØ¶Ø©", group=G_COL)
color i_text_color     = input.color(color.new(#FFFFFF, 0), "Text Color | Ù„ÙˆÙ† Ø§Ù„Ù†Øµ", group=G_COL)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 3: Ø®Ø±Ø§Ø¦Ø· Ø§Ù„ØªØ±Ø¬Ù…Ø©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var map<string, string> TXT_AR = map.new<string, string>()
var map<string, string> TXT_EN = map.new<string, string>()

if barstate.isfirst
    TXT_AR.put("bull_flag", "Ø¹Ù„Ù… ØµØ§Ø¹Ø¯")
    TXT_AR.put("bear_flag", "Ø¹Ù„Ù… Ù‡Ø¨ÙˆØ·ÙŠ")
    TXT_EN.put("bull_flag", "Bull Flag")
    TXT_EN.put("bear_flag", "Bear Flag")

txt(string key) =>
    isAr ? TXT_AR.get(key) : TXT_EN.get(key)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 4: Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆØ± Ø§Ù„ØªÙƒÙŠÙÙŠØ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float atr_fast = ta.atr(10)
float atr_slow = ta.atr(50)
float atr_14   = ta.atr(14)
float vol_sma5 = ta.sma(volume, 5)

calc_adx(int len) =>
    float up = ta.change(high)
    float dn = -ta.change(low)
    float plus_dm  = na(up) ? na : (up > dn and up > 0 ? up : 0)
    float minus_dm = na(dn) ? na : (dn > up and dn > 0 ? dn : 0)
    float tr_rma   = ta.rma(ta.tr, len)
    float plus_di  = fixnan(100 * ta.rma(plus_dm, len) / tr_rma)
    float minus_di = fixnan(100 * ta.rma(minus_dm, len) / tr_rma)
    float dx = math.abs(plus_di - minus_di) / math.max(plus_di + minus_di, 1) * 100
    ta.rma(dx, len)

float adx_val = calc_adx(14)

calc_adaptive_pivot() =>
    float vol_score = math.min(nz(atr_fast / atr_slow, 1.0), 2.0) / 2.0
    float trend_score = math.min(adx_val / 50, 1.0)
    float atr_std = ta.stdev(atr_fast, 20)
    float atr_mean = ta.sma(atr_fast, 20)
    float stability_score = math.min(nz(atr_std / atr_mean, 0.5) * 2, 1.0)
    int pct_len = math.max(20, math.min(200, bar_index))
    float atr_pct = ta.percentile_nearest_rank(atr_fast, pct_len, 50)
    float context_norm = math.min(nz(atr_fast / atr_pct, 1.0), 2.0) / 2.0
    float avg_range = ta.sma(high - low, 10)
    float range_score = math.min(nz((high - low) / avg_range, 1.0), 2.0) / 2.0
    float final_score = (vol_score * 0.30) + (trend_score * 0.25) + (stability_score * 0.20) + (context_norm * 0.15) + (range_score * 0.10)
    math.max(i_piv_min, math.min(i_piv_max, i_piv_min + int((i_piv_max - i_piv_min) * final_score)))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 5: Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

calc_line_at(float p1, int b1, float p2, int b2, int target) =>
    if b2 == b1 or p1 <= 0 or p2 <= 0
        p2
    else if i_log_scale
        p2 * math.exp((math.log(p2) - math.log(p1)) / (b2 - b1) * (target - b2))
    else
        p2 + (p2 - p1) / (b2 - b1) * (target - b2)

get_lbl_size() =>
    switch i_lbl_size
        "Small" => size.small
        "Normal" => size.normal
        => size.large

calc_quality(float parallel_ratio, float pole_atr_ratio, float retrace_ratio, float vol_ratio) =>
    float para_score  = math.min(parallel_ratio, 1.0) * 100
    float pole_score  = math.min(pole_atr_ratio / 5, 1.0) * 100
    float retr_score  = (1 - retrace_ratio) * 100
    float vol_score   = math.max(0.0, math.min(1.0, 1.0 - vol_ratio)) * 100
    (para_score * 0.30) + (pole_score * 0.30) + (retr_score * 0.25) + (vol_score * 0.15)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 6: Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ­Ù‚Ù‚
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

check_channel_close(float up1, int ub1, float up2, int ub2, float lp1, int lb1, float lp2, int lb2, int start_b, int end_b) =>
    bool ok = true
    for b = start_b to end_b
        int off = bar_index - b
        if off >= 0 and off < bar_index
            float u = calc_line_at(up1, ub1, up2, ub2, b)
            float l = calc_line_at(lp1, lb1, lp2, lb2, b)
            if close[off] > u or close[off] < l
                ok := false
                break
    ok

check_channel_strict(float up1, int ub1, float up2, int ub2, float lp1, int lb1, float lp2, int lb2, int start_b, int end_b) =>
    bool ok = true
    float d = i_tolerance / 100.0
    for b = start_b to end_b
        int off = bar_index - b
        if off >= 0 and off < bar_index and not na(close[off])
            float u = calc_line_at(up1, ub1, up2, ub2, b)
            float l = calc_line_at(lp1, lb1, lp2, lb2, b)
            if close[off] > u * (1 + d) or close[off] < l * (1 - d)
                ok := false
                break
    ok

check_after_p5(float up1, int ub1, float up2, int ub2, float lp1, int lb1, float lp2, int lb2, int p5_bar, bool is_bull) =>
    bool ok = true
    if p5_bar < bar_index
        for b = p5_bar + 1 to bar_index
            int off = bar_index - b
            if off >= 0 and off < bar_index and not na(close[off])
                float u = calc_line_at(up1, ub1, up2, ub2, b)
                float l = calc_line_at(lp1, lb1, lp2, lb2, b)
                if is_bull and close[off] < l
                    ok := false
                    break
                if not is_bull and close[off] > u
                    ok := false
                    break
    ok

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 7: Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ØµØ±ÙŠ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

create_3d_face(array<chart.point> points, color edge_col, color fill_col) =>
    polyline.new(points, closed=true, line_color=edge_col, fill_color=fill_col, line_width=1)

method clear_all(FlagVisuals v) =>
    if not na(v)
        line.delete(v.line_pole)
        line.delete(v.line_23)
        line.delete(v.line_34)
        line.delete(v.line_45)
        line.delete(v.line_upper)
        line.delete(v.line_lower)
        line.delete(v.line_upper_ext)
        line.delete(v.line_lower_ext)
        polyline.delete(v.fill_channel)
        polyline.delete(v.fill_channel_2)
        polyline.delete(v.poly_top_face)
        polyline.delete(v.poly_side_face)
        polyline.delete(v.poly_bottom_edge)
        label.delete(v.lbl_1)
        label.delete(v.lbl_2)
        label.delete(v.lbl_3)
        label.delete(v.lbl_4)
        label.delete(v.lbl_5)
        label.delete(v.lbl_quality)
        label.delete(v.lbl_name)
        line.delete(v.target_vline)
        box.delete(v.target_box)
        polyline.delete(v.target_top_face)
        polyline.delete(v.target_side_face)
        label.delete(v.target_label)
        line.delete(v.target_vline_2)
        box.delete(v.target_box_2)
        polyline.delete(v.target_top_face_2)
        polyline.delete(v.target_side_face_2)
        label.delete(v.target_label_2)

method clear_targets(FlagVisuals v) =>
    if not na(v)
        line.delete(v.target_vline)
        box.delete(v.target_box)
        polyline.delete(v.target_top_face)
        polyline.delete(v.target_side_face)
        label.delete(v.target_label)
        line.delete(v.target_vline_2)
        box.delete(v.target_box_2)
        polyline.delete(v.target_top_face_2)
        polyline.delete(v.target_side_face_2)
        label.delete(v.target_label_2)

method draw_flag(FlagData this, FlagVisuals vis, int end_bar, color col) =>
    line.delete(vis.line_pole)
    line.delete(vis.line_23)
    line.delete(vis.line_34)
    line.delete(vis.line_45)
    line.delete(vis.line_upper)
    line.delete(vis.line_lower)
    line.delete(vis.line_upper_ext)
    line.delete(vis.line_lower_ext)
    polyline.delete(vis.fill_channel)
    polyline.delete(vis.fill_channel_2)
    polyline.delete(vis.poly_top_face)
    polyline.delete(vis.poly_side_face)
    polyline.delete(vis.poly_bottom_edge)
    label.delete(vis.lbl_1)
    label.delete(vis.lbl_2)
    label.delete(vis.lbl_3)
    label.delete(vis.lbl_4)
    label.delete(vis.lbl_5)
    label.delete(vis.lbl_quality)
    label.delete(vis.lbl_name)

    color line_col = color.new(col, 15)
    color fill_col = color.new(col, 80)

    int ub1 = na
    float up1 = na
    int ub2 = na
    float up2 = na
    int lb1 = na
    float lp1 = na
    int lb2 = na
    float lp2 = na

    if this.is_bullish
        ub1 := this.p2.bar_idx
        up1 := this.p2.price
        ub2 := this.p4.bar_idx
        up2 := this.p4.price
        lb1 := this.p3.bar_idx
        lp1 := this.p3.price
        lb2 := this.p5.bar_idx
        lp2 := this.p5.price
    else
        ub1 := this.p3.bar_idx
        up1 := this.p3.price
        ub2 := this.p5.bar_idx
        up2 := this.p5.price
        lb1 := this.p2.bar_idx
        lp1 := this.p2.price
        lb2 := this.p4.bar_idx
        lp2 := this.p4.price

    float upper_end = calc_line_at(up1, ub1, up2, ub2, end_bar)
    float lower_end = calc_line_at(lp1, lb1, lp2, lb2, end_bar)

    if upper_end > lower_end and lower_end > 0
        if i_show_pole
            vis.line_pole := line.new(this.p1.bar_idx, this.p1.price, this.p2.bar_idx, this.p2.price, color=line_col, width=3)

        vis.line_23 := line.new(this.p2.bar_idx, this.p2.price, this.p3.bar_idx, this.p3.price, color=line_col, width=2)
        vis.line_34 := line.new(this.p3.bar_idx, this.p3.price, this.p4.bar_idx, this.p4.price, color=line_col, width=2)
        vis.line_45 := line.new(this.p4.bar_idx, this.p4.price, this.p5.bar_idx, this.p5.price, color=line_col, width=2)

        vis.line_upper := line.new(ub1, up1, ub2, up2, color=line_col, width=2)
        vis.line_lower := line.new(lb1, lp1, lb2, lp2, color=line_col, width=2)

        vis.line_upper_ext := line.new(ub2, up2, end_bar, upper_end, color=line_col, width=1, style=line.style_dotted)
        vis.line_lower_ext := line.new(lb2, lp2, end_bar, lower_end, color=line_col, width=1, style=line.style_dotted)

        vis.fill_channel := polyline.new(array.from(chart.point.from_index(ub1, up1), chart.point.from_index(end_bar, upper_end), chart.point.from_index(end_bar, lower_end), chart.point.from_index(lb1, lp1)), closed=true, fill_color=fill_col, line_color=na)
        color blend_col = color.new(this.is_bullish ? i_bull_blend : i_bear_blend, 82)
        vis.fill_channel_2 := polyline.new(array.from(chart.point.from_index(ub1, up1), chart.point.from_index(end_bar, upper_end), chart.point.from_index(end_bar, lower_end), chart.point.from_index(lb1, lp1)), closed=true, fill_color=blend_col, line_color=na)

        if i_enable_3d
            float ch_height = math.abs(upper_end - lower_end)
            float depth_3d  = ch_height * (i_depth_pct / 100) * 3
            int transp = i_3d_transp
            color edge_c = color.new(col, transp - 10)
            color face_c = color.new(col, transp + 10)

            vis.poly_top_face := create_3d_face(array.from(chart.point.from_index(ub1, up1), chart.point.from_index(ub1 + i_depth_bars, up1 + depth_3d), chart.point.from_index(end_bar + i_depth_bars, upper_end + depth_3d), chart.point.from_index(end_bar, upper_end)), edge_c, face_c)
            vis.poly_side_face := create_3d_face(array.from(chart.point.from_index(end_bar, upper_end), chart.point.from_index(end_bar + i_depth_bars, upper_end + depth_3d), chart.point.from_index(end_bar + i_depth_bars, lower_end + depth_3d), chart.point.from_index(end_bar, lower_end)), edge_c, face_c)
            vis.poly_bottom_edge := create_3d_face(array.from(chart.point.from_index(lb1, lp1), chart.point.from_index(lb1 + i_depth_bars, lp1 + depth_3d), chart.point.from_index(end_bar + i_depth_bars, lower_end + depth_3d), chart.point.from_index(end_bar, lower_end)), edge_c, face_c)

    if i_show_points
        string sz = get_lbl_size()
        color trans = color.new(col, 100)
        vis.lbl_1 := label.new(this.p1.bar_idx, this.p1.price, "1", style=this.is_bullish ? label.style_label_up : label.style_label_down, color=trans, textcolor=col, size=sz)
        vis.lbl_2 := label.new(this.p2.bar_idx, this.p2.price, "2", style=this.is_bullish ? label.style_label_down : label.style_label_up, color=trans, textcolor=col, size=sz)
        vis.lbl_3 := label.new(this.p3.bar_idx, this.p3.price, "3", style=this.is_bullish ? label.style_label_up : label.style_label_down, color=trans, textcolor=col, size=sz)
        vis.lbl_4 := label.new(this.p4.bar_idx, this.p4.price, "4", style=this.is_bullish ? label.style_label_down : label.style_label_up, color=trans, textcolor=col, size=sz)
        vis.lbl_5 := label.new(this.p5.bar_idx, this.p5.price, "5", style=this.is_bullish ? label.style_label_up : label.style_label_down, color=trans, textcolor=col, size=sz)

    if i_show_quality and i_use_quality
        color q_col = this.quality >= 70 ? i_quality_high : this.quality >= 50 ? i_quality_med : i_quality_low
        int q_bar = ub1 + (end_bar - ub1) / 3
        float q_upper = calc_line_at(up1, ub1, up2, ub2, q_bar)
        float q_lower = calc_line_at(lp1, lb1, lp2, lb2, q_bar)
        float q_price = (q_upper + q_lower) / 2
        vis.lbl_quality := label.new(q_bar, q_price, str.tostring(this.quality, "#") + "%", color=color.new(q_col, 30), textcolor=i_text_color, style=label.style_label_center, size=size.small)

    if i_show_name
        string name = this.is_bullish ? txt("bull_flag") : txt("bear_flag")
        int name_bar = ub1 + (end_bar - ub1) * 2 / 3
        float name_upper = calc_line_at(up1, ub1, up2, ub2, name_bar)
        float name_lower = calc_line_at(lp1, lb1, lp2, lb2, name_bar)
        float name_price = (name_upper + name_lower) / 2
        vis.lbl_name := label.new(name_bar, name_price, name, color=color.new(col, 100), textcolor=color.new(i_text_color, 30), style=label.style_label_center, size=size.normal)
    this

method draw_target(FlagData this, FlagVisuals vis, color base_col) =>
    line.delete(vis.target_vline)
    box.delete(vis.target_box)
    polyline.delete(vis.target_top_face)
    polyline.delete(vis.target_side_face)
    label.delete(vis.target_label)
    line.delete(vis.target_vline_2)
    box.delete(vis.target_box_2)
    polyline.delete(vis.target_top_face_2)
    polyline.delete(vis.target_side_face_2)
    label.delete(vis.target_label_2)

    if this.broken and not na(this.breakout_bar) and not na(this.target_price)
        float zone_height = this.flagpole_height * (i_target_zone_pct / 100)
        float depth_3d = zone_height * 0.5
        string t1_tag = isAr ? "ØªØ­ÙØ¸ÙŠ" : "T1"
        string t2_tag = isAr ? "Ø±Ø³Ù…ÙŠ" : "T2"

        float z1_top = this.target_price + zone_height / 2
        float z1_bot = this.target_price - zone_height / 2
        int z1_right = this.target_hit ? this.achieved_bar : bar_index
        color c1 = this.target_hit ? i_achieved_color : base_col
        int tr1 = this.target_hit ? 65 : 75

        vis.target_box := box.new(this.breakout_bar, z1_top, z1_right, z1_bot, border_color=color.new(c1, 30), border_width=1, border_style=line.style_solid, bgcolor=color.new(c1, tr1))
        if i_enable_3d
            vis.target_top_face := create_3d_face(array.from(chart.point.from_index(this.breakout_bar, z1_top), chart.point.from_index(this.breakout_bar + i_target_3d_depth, z1_top + depth_3d), chart.point.from_index(z1_right + i_target_3d_depth, z1_top + depth_3d), chart.point.from_index(z1_right, z1_top)), color.new(c1, 40), color.new(c1, tr1 - 5))
            vis.target_side_face := create_3d_face(array.from(chart.point.from_index(z1_right, z1_top), chart.point.from_index(z1_right + i_target_3d_depth, z1_top + depth_3d), chart.point.from_index(z1_right + i_target_3d_depth, z1_bot + depth_3d), chart.point.from_index(z1_right, z1_bot)), color.new(c1, 40), color.new(c1, tr1 - 3))
        vis.target_vline := line.new(this.breakout_bar, this.breakout_price, this.breakout_bar, this.target_price, color=c1, style=line.style_dotted, width=2)
        string p1_txt = str.tostring(this.target_price, format.mintick)
        string l1_txt = (this.target_hit ? p1_txt + " âœ“ " : p1_txt + " ") + t1_tag
        vis.target_label := label.new(z1_right + 2, this.target_price, l1_txt, color=color.new(c1, 100), textcolor=c1, style=label.style_label_left, size=size.small)

        if i_show_t2 and not na(this.target_price_2)
            float z2_top = this.target_price_2 + zone_height / 2
            float z2_bot = this.target_price_2 - zone_height / 2
            int z2_right = this.target_hit_2 ? this.achieved_bar_2 : bar_index
            color c2 = this.target_hit_2 ? i_achieved_color : base_col
            int tr2 = this.target_hit_2 ? 65 : 75

            vis.target_box_2 := box.new(this.breakout_bar, z2_top, z2_right, z2_bot, border_color=color.new(c2, 30), border_width=1, border_style=line.style_dashed, bgcolor=color.new(c2, tr2))
            if i_enable_3d
                vis.target_top_face_2 := create_3d_face(array.from(chart.point.from_index(this.breakout_bar, z2_top), chart.point.from_index(this.breakout_bar + i_target_3d_depth, z2_top + depth_3d), chart.point.from_index(z2_right + i_target_3d_depth, z2_top + depth_3d), chart.point.from_index(z2_right, z2_top)), color.new(c2, 40), color.new(c2, tr2 - 5))
                vis.target_side_face_2 := create_3d_face(array.from(chart.point.from_index(z2_right, z2_top), chart.point.from_index(z2_right + i_target_3d_depth, z2_top + depth_3d), chart.point.from_index(z2_right + i_target_3d_depth, z2_bot + depth_3d), chart.point.from_index(z2_right, z2_bot)), color.new(c2, 40), color.new(c2, tr2 - 3))
            vis.target_vline_2 := line.new(this.breakout_bar, this.breakout_price, this.breakout_bar, this.target_price_2, color=c2, style=line.style_dotted, width=1)
            string p2_txt = str.tostring(this.target_price_2, format.mintick)
            string l2_txt = (this.target_hit_2 ? p2_txt + " âœ“ " : p2_txt + " ") + t2_tag
            vis.target_label_2 := label.new(z2_right + 2, this.target_price_2, l2_txt, color=color.new(c2, 100), textcolor=c2, style=label.style_label_left, size=size.small)
    this

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 8: Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© ÙˆØ¬Ù…Ø¹ Ø§Ù„Ù…Ø­Ø§ÙˆØ±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var array<Pivot> pivots = array.new<Pivot>()
var array<FlagData> patterns_hist = array.new<FlagData>()
var array<FlagVisuals> visuals_hist = array.new<FlagVisuals>()

var FlagData active_bull    = na
var FlagVisuals vis_bull    = FlagVisuals.new()
var FlagData active_bear    = na
var FlagVisuals vis_bear    = FlagVisuals.new()
var FlagData broken_bull    = na
var FlagVisuals vis_brk_bull = FlagVisuals.new()
var FlagData broken_bear    = na
var FlagVisuals vis_brk_bear = FlagVisuals.new()
var bool bull_brk_sig = false
var bool bear_brk_sig = false

var int last_draw_bull_bar = na
var int last_draw_bear_bar = na
var bool last_bull_broken  = false
var bool last_bear_broken  = false

int eff_left = calc_adaptive_pivot()

float ph = ta.pivothigh(high, eff_left, i_piv_right)
float pl = ta.pivotlow(low, eff_left, i_piv_right)
int pbar = bar_index - i_piv_right

if not na(ph)
    pivots.push(Pivot.new(true, ph, pbar))
if not na(pl)
    pivots.push(Pivot.new(false, pl, pbar))

while pivots.size() > 0 and bar_index - pivots.first().bar_idx > i_lookback
    pivots.shift()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 8.5: Ø§Ù„Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ© (Behavior Gate)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool new_pivot = not na(ph) or not na(pl)
float gate_atr_recent = ta.sma(atr_14, 10)
float gate_atr_long   = ta.sma(atr_14, 200)

calc_gate(bool is_bull, float atr_recent, float atr_long) =>
    if not i_use_gate
        [100.0, 0, 0]
    else
        int scan = math.min(i_gate_scan, bar_index)

        float best_disp = 0.0
        int imp_start = 0
        int imp_end = 0
        float run_min = close[scan]
        int run_min_off = scan
        float run_max = close[scan]
        int run_max_off = scan

        for i = scan - 1 to 0
            if is_bull
                if close[i] < run_min
                    run_min := close[i]
                    run_min_off := i
                float disp = close[i] - run_min
                if disp > best_disp
                    best_disp := disp
                    imp_start := run_min_off
                    imp_end := i
            else
                if close[i] > run_max
                    run_max := close[i]
                    run_max_off := i
                float disp = run_max - close[i]
                if disp > best_disp
                    best_disp := disp
                    imp_start := run_max_off
                    imp_end := i

        if imp_start <= imp_end or best_disp <= 0
            [0.0, 0, 0]
        else
            float atr_at = nz(atr_14[imp_end], atr_14)
            float pole_str = atr_at > 0 ? best_disp / atr_at : 0.0

            int pole_len = imp_start - imp_end
            int dir_cnt = 0
            float atr_impulse = 0.0
            for i = imp_end to imp_start - 1
                bool dir = is_bull ? (close[i] > open[i]) : (close[i] < open[i])
                if dir
                    dir_cnt += 1
                atr_impulse += nz(atr_14[i], 0)
            float dir_ratio = pole_len > 0 ? (dir_cnt * 1.0) / pole_len : 0.0
            atr_impulse := pole_len > 0 ? atr_impulse / pole_len : atr_14

            float contraction = atr_impulse > 0 ? nz(atr_recent / atr_impulse, 1.0) : 1.0
            float ctx_ratio = atr_long > 0 ? nz(atr_14 / atr_long, 1.0) : 1.0

            float s_pole = math.min(pole_str / math.max(i_gate_atr, 0.1), 1.0) * 100
            float s_dir = math.min(dir_ratio / math.max(i_gate_dir, 0.1), 1.0) * 100
            float s_adx = math.min(adx_val / math.max(i_gate_adx, 1.0), 1.0) * 100
            float s_contract = contraction <= i_gate_contract ? 100.0 : math.max(0.0, (1.0 - ((contraction - i_gate_contract) / (1.0 - i_gate_contract)))) * 100
            float s_ctx = ctx_ratio >= i_gate_ctx ? 100.0 : (ctx_ratio / math.max(i_gate_ctx, 0.1)) * 100

            float score = (s_pole * 0.25) + (s_dir * 0.15) + (s_adx * 0.15) + (s_contract * 0.25) + (s_ctx * 0.20)

            int imp_bar_start = bar_index - imp_start
            int imp_bar_end = bar_index - imp_end
            [score, imp_bar_start, imp_bar_end]

var int gate_bull_start = na
var int gate_bull_end = na
var int gate_bear_start = na
var int gate_bear_end = na

float gate_bull = 0.0
float gate_bear = 0.0

if new_pivot
    [gb, gbs, gbe] = calc_gate(true, gate_atr_recent, gate_atr_long)
    gate_bull := gb
    gate_bull_start := gbs
    gate_bull_end := gbe
    [gs, gss, gse] = calc_gate(false, gate_atr_recent, gate_atr_long)
    gate_bear := gs
    gate_bear_start := gss
    gate_bear_end := gse

bool gate_bull_ok = gate_bull >= i_gate_score
bool gate_bear_ok = gate_bear >= i_gate_score

validate_gate_overlap(FlagData pat, int imp_start, int imp_end) =>
    if na(pat) or na(imp_start) or na(imp_end) or not i_use_gate
        true
    else
        int margin = math.max(20, (imp_end - imp_start) / 2)
        int p1b = pat.p1.bar_idx
        int p2b = pat.p2.bar_idx
        bool p1_near = p1b >= (imp_start - margin) and p1b <= (imp_end + margin)
        bool p2_near = p2b >= (imp_start - margin) and p2b <= (imp_end + margin)
        p1_near or p2_near

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 9: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¹Ù„Ù…
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

find_flag(bool is_bull, float gate_score) =>
    FlagData result = na
    float best_quality = 0.0
    int n = pivots.size()
    int iter_count = 0
    int MAX_ITER = 8000

    if n >= 5
        array<int> highs = array.new<int>()
        array<int> lows  = array.new<int>()
        for i = 0 to n - 1
            if pivots.get(i).is_high
                highs.push(i)
            else
                lows.push(i)

        array<int> arr_135 = is_bull ? lows : highs
        array<int> arr_24  = is_bull ? highs : lows
        int n135 = arr_135.size()
        int n24  = arr_24.size()

        if n135 >= 3 and n24 >= 2
            float min_pole = atr_14 * 2
            bool done = false

            for i5 = n135 - 1 to 2
                if done
                    break
                Pivot p5 = pivots.get(arr_135.get(i5))

                for i4 = n24 - 1 to 1
                    if done
                        break
                    Pivot p4 = pivots.get(arr_24.get(i4))
                    if p4.bar_idx >= p5.bar_idx or p5.bar_idx - p4.bar_idx < i_min_bars
                        continue

                    for i3 = i5 - 1 to 1
                        if done
                            break
                        Pivot p3 = pivots.get(arr_135.get(i3))
                        if p3.bar_idx >= p4.bar_idx or p4.bar_idx - p3.bar_idx < i_min_bars
                            continue

                        for i2 = i4 - 1 to 0
                            if done
                                break
                            Pivot p2 = pivots.get(arr_24.get(i2))
                            if p2.bar_idx >= p3.bar_idx or p3.bar_idx - p2.bar_idx < i_min_bars
                                continue

                            iter_count += 1
                            if iter_count > MAX_ITER
                                done := true
                                break

                            int ch_width = p5.bar_idx - p2.bar_idx
                            if ch_width < i_min_width
                                continue

                            int ub1 = na
                            float up1 = na
                            int ub2 = na
                            float up2 = na
                            int lb1 = na
                            float lp1 = na
                            int lb2 = na
                            float lp2 = na

                            if is_bull
                                ub1 := p2.bar_idx
                                up1 := p2.price
                                ub2 := p4.bar_idx
                                up2 := p4.price
                                lb1 := p3.bar_idx
                                lp1 := p3.price
                                lb2 := p5.bar_idx
                                lp2 := p5.price
                            else
                                ub1 := p3.bar_idx
                                up1 := p3.price
                                ub2 := p5.bar_idx
                                up2 := p5.price
                                lb1 := p2.bar_idx
                                lp1 := p2.price
                                lb2 := p4.bar_idx
                                lp2 := p4.price

                            int du = math.max(ub2 - ub1, 1)
                            int dl = math.max(lb2 - lb1, 1)
                            float upper_sl = (up2 - up1) / du
                            float lower_sl = (lp2 - lp1) / dl

                            if is_bull
                                if upper_sl >= 0 or lower_sl >= 0
                                    continue
                            else
                                if upper_sl <= 0 or lower_sl <= 0
                                    continue

                            float max_sl = math.max(math.abs(upper_sl), math.abs(lower_sl))
                            float min_sl = math.min(math.abs(upper_sl), math.abs(lower_sl))
                            float para_ratio = max_sl > 0 ? min_sl / max_sl : 0.0
                            if para_ratio < i_parallel
                                continue

                            for i1 = i3 - 1 to 0
                                if done
                                    break
                                Pivot p1 = pivots.get(arr_135.get(i1))
                                if p1.bar_idx >= p2.bar_idx
                                    continue

                                int full_width = p5.bar_idx - p1.bar_idx
                                if full_width > i_max_width
                                    continue

                                float pole_h = math.abs(p2.price - p1.price)
                                if pole_h < min_pole
                                    continue

                                if is_bull and p2.price <= p1.price
                                    continue
                                if not is_bull and p2.price >= p1.price
                                    continue

                                float pole_speed = pole_h / math.max(p2.bar_idx - p1.bar_idx, 1)
                                if pole_speed < atr_14 * 0.3
                                    continue

                                float ch_height = is_bull ? p2.price - math.min(p3.price, p5.price) : math.max(p3.price, p5.price) - p2.price
                                float retrace_r = ch_height / pole_h
                                if retrace_r > i_max_retrace
                                    continue

                                bool ch_ok = i_strict ? check_channel_strict(up1, ub1, up2, ub2, lp1, lb1, lp2, lb2, p2.bar_idx, p5.bar_idx) : check_channel_close(up1, ub1, up2, ub2, lp1, lb1, lp2, lb2, p2.bar_idx, p5.bar_idx)
                                if not ch_ok
                                    continue

                                if not check_after_p5(up1, ub1, up2, ub2, lp1, lb1, lp2, lb2, p5.bar_idx, is_bull)
                                    continue

                                float vol_ratio = 1.0
                                int off_p1 = bar_index - p1.bar_idx
                                int off_p5 = bar_index - p5.bar_idx
                                if off_p1 < 5000 and off_p5 < 5000 and off_p1 > off_p5
                                    float vp = nz(vol_sma5[off_p1], 0)
                                    float vc = nz(vol_sma5[off_p5], 0)
                                    vol_ratio := vp > 0 ? vc / vp : 1.0

                                float pole_atr_r = atr_14 > 0 ? pole_h / atr_14 : 3.0
                                float quality = calc_quality(para_ratio, pole_atr_r, retrace_r, vol_ratio)
                                float gate_mult = 0.6 + (math.max(gate_score, 1.0) / 250)
                                float final_q = quality * math.min(gate_mult, 1.0)

                                if i_use_quality and final_q < i_min_quality
                                    continue

                                if final_q > best_quality
                                    best_quality := final_q
                                    result := FlagData.new(is_bull, p1, p2, p3, p4, p5, pole_h, final_q, false, false, false, false, na, na, na, na, na, na)
                                    if best_quality >= 85
                                        done := true
    result

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 10: Ù…Ø¹Ø§Ù„Ø¬Ø© ÙˆØ¯ÙˆØ±Ø© Ø­ÙŠØ§Ø© Ø§Ù„Ù†Ù…Ø·
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

process_flag(FlagData active, FlagVisuals vis, FlagData new_pat, color col) =>
    FlagData out = active
    FlagData to_archive = na
    if not na(new_pat)
        bool overlap = not na(active) and not (new_pat.p5.bar_idx < active.p1.bar_idx or new_pat.p1.bar_idx > active.p5.bar_idx)
        bool dominated = not na(active) and overlap and new_pat.quality <= active.quality
        if not dominated
            if not na(active)
                if not overlap and active.broken
                    to_archive := active
                else
                    vis.clear_all()
            out := new_pat
            out.draw_flag(vis, bar_index, col)
    [out, to_archive]

track_targets(FlagData pat, FlagVisuals vis) =>
    bool changed = false
    if not na(pat) and pat.broken and (not pat.target_hit or (i_show_t2 and not pat.target_hit_2))
        float zone_height = pat.flagpole_height * (i_target_zone_pct / 100)
        if not pat.target_hit
            float z1_bot = pat.target_price - zone_height / 2
            float z1_top = pat.target_price + zone_height / 2
            bool hit1 = pat.is_bullish ? high >= z1_bot : low <= z1_top
            if hit1
                pat.target_hit := true
                pat.achieved_bar := bar_index
                changed := true
        if i_show_t2 and not pat.target_hit_2 and not na(pat.target_price_2)
            float z2_bot = pat.target_price_2 - zone_height / 2
            float z2_top = pat.target_price_2 + zone_height / 2
            bool hit2 = pat.is_bullish ? high >= z2_bot : low <= z2_top
            if hit2
                pat.target_hit_2 := true
                pat.achieved_bar_2 := bar_index
                changed := true
        if changed or barstate.isconfirmed
            pat.draw_target(vis, i_target_color)
    changed

lifecycle_flag(FlagData pat, FlagVisuals vis, color col, int last_bar, bool last_brk) =>
    FlagData out = pat
    bool brk_sig = false

    if not na(pat) and not pat.broken and not pat.cancelled
        int bars_since = bar_index - pat.p5.bar_idx

        int ub1 = na
        float up1 = na
        int ub2 = na
        float up2 = na
        int lb1 = na
        float lp1 = na
        int lb2 = na
        float lp2 = na

        if pat.is_bullish
            ub1 := pat.p2.bar_idx
            up1 := pat.p2.price
            ub2 := pat.p4.bar_idx
            up2 := pat.p4.price
            lb1 := pat.p3.bar_idx
            lp1 := pat.p3.price
            lb2 := pat.p5.bar_idx
            lp2 := pat.p5.price
        else
            ub1 := pat.p3.bar_idx
            up1 := pat.p3.price
            ub2 := pat.p5.bar_idx
            up2 := pat.p5.price
            lb1 := pat.p2.bar_idx
            lp1 := pat.p2.price
            lb2 := pat.p4.bar_idx
            lp2 := pat.p4.price

        float u_now = calc_line_at(up1, ub1, up2, ub2, bar_index)
        float l_now = calc_line_at(lp1, lb1, lp2, lb2, bar_index)

        bool brk = pat.is_bullish ? close > u_now : close < l_now
        bool cancel_reverse = pat.is_bullish ? close < l_now : close > u_now
        int ch_width = pat.p5.bar_idx - pat.p2.bar_idx
        int adaptive_wait = math.min(i_max_wait, math.max(ch_width, 10))
        bool cancel = cancel_reverse or bars_since > adaptive_wait

        if brk and barstate.isconfirmed
            pat.broken := true
            pat.breakout_bar := bar_index
            pat.breakout_price := pat.is_bullish ? u_now : l_now
            float pole_ratio = pat.p2.price / pat.p1.price
            pat.target_price := pat.breakout_price * math.pow(pole_ratio, 0.618)
            pat.target_price_2 := pat.breakout_price * math.pow(pole_ratio, 1.0)
            pat.draw_flag(vis, bar_index, col).draw_target(vis, i_target_color)
            brk_sig := true
        else if cancel and barstate.isconfirmed
            pat.cancelled := true
            vis.clear_all()
            out := na
        else
            bool need_redraw = barstate.isconfirmed or na(last_bar) or (last_brk != pat.broken)
            if need_redraw
                pat.draw_flag(vis, bar_index, col)

    track_targets(pat, vis)

    [out, brk_sig]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 11: Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

build_alert_json(FlagData pat) =>
    string dir = pat.is_bullish ? "BULL" : "BEAR"
    string q = str.tostring(pat.quality, "#.#")
    string bp = str.tostring(pat.breakout_price, format.mintick)
    string t1 = str.tostring(pat.target_price, format.mintick)
    string t2 = not na(pat.target_price_2) ? str.tostring(pat.target_price_2, format.mintick) : "N/A"
    '{"type":"' + dir + '","quality":' + q + ',"breakout":"' + bp + '","T1":"' + t1 + '","T2":"' + t2 + '","ticker":"' + syminfo.ticker + '","tf":"' + timeframe.period + '"}'

bull_brk_sig := false
bear_brk_sig := false

if i_show_bull
    FlagData new_bull = na
    if new_pivot and gate_bull_ok
        new_bull := find_flag(true, gate_bull)
        if not na(new_bull) and not validate_gate_overlap(new_bull, gate_bull_start, gate_bull_end)
            new_bull := na
    [upd, arch] = process_flag(active_bull, vis_bull, new_bull, i_bull_color)
    active_bull := upd

    if not na(arch)
        if not na(broken_bull)
            if i_show_old
                if not i_show_old_tgt
                    vis_brk_bull.clear_targets()
                patterns_hist.push(broken_bull)
                visuals_hist.push(vis_brk_bull)
                vis_brk_bull := FlagVisuals.new()
            else
                vis_brk_bull.clear_all()
        broken_bull := arch
        int brk_end = not na(broken_bull.breakout_bar) ? broken_bull.breakout_bar : bar_index
        broken_bull.draw_flag(vis_brk_bull, brk_end, i_bull_color)
        if broken_bull.broken
            broken_bull.draw_target(vis_brk_bull, i_target_color)

    [upd2, sig] = lifecycle_flag(active_bull, vis_bull, i_bull_color, last_draw_bull_bar, last_bull_broken)
    active_bull := upd2
    bull_brk_sig := sig

    if bull_brk_sig and not na(active_bull)
        alert(build_alert_json(active_bull), alert.freq_once_per_bar_close)

    last_draw_bull_bar := bar_index
    last_bull_broken := not na(active_bull) ? active_bull.broken : false

    if not na(broken_bull) and broken_bull.broken
        if not i_show_old_tgt
            vis_brk_bull.clear_targets()
        else
            track_targets(broken_bull, vis_brk_bull)

if i_show_bear
    FlagData new_bear = na
    if new_pivot and gate_bear_ok
        new_bear := find_flag(false, gate_bear)
        if not na(new_bear) and not validate_gate_overlap(new_bear, gate_bear_start, gate_bear_end)
            new_bear := na
    [upd, arch] = process_flag(active_bear, vis_bear, new_bear, i_bear_color)
    active_bear := upd

    if not na(arch)
        if not na(broken_bear)
            if i_show_old
                if not i_show_old_tgt
                    vis_brk_bear.clear_targets()
                patterns_hist.push(broken_bear)
                visuals_hist.push(vis_brk_bear)
                vis_brk_bear := FlagVisuals.new()
            else
                vis_brk_bear.clear_all()
        broken_bear := arch
        int brk_end = not na(broken_bear.breakout_bar) ? broken_bear.breakout_bar : bar_index
        broken_bear.draw_flag(vis_brk_bear, brk_end, i_bear_color)
        if broken_bear.broken
            broken_bear.draw_target(vis_brk_bear, i_target_color)

    [upd2, sig] = lifecycle_flag(active_bear, vis_bear, i_bear_color, last_draw_bear_bar, last_bear_broken)
    active_bear := upd2
    bear_brk_sig := sig

    if bear_brk_sig and not na(active_bear)
        alert(build_alert_json(active_bear), alert.freq_once_per_bar_close)

    last_draw_bear_bar := bar_index
    last_bear_broken := not na(active_bear) ? active_bear.broken : false

    if not na(broken_bear) and broken_bear.broken
        if not i_show_old_tgt
            vis_brk_bear.clear_targets()
        else
            track_targets(broken_bear, vis_brk_bear)

if patterns_hist.size() > 30
    patterns_hist.shift()
    FlagVisuals old_vis = visuals_hist.shift()
    old_vis.clear_all()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Œ Ø§Ù„Ù‚Ø³Ù… 12: Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(bull_brk_sig, "Bullish Flag Breakout", "ğŸŸ¢ Bullish Breakout - Bull Flag | ÙƒØ³Ø± ØµØ¹ÙˆØ¯ÙŠ - Ø¹Ù„Ù… ØµØ§Ø¹Ø¯ {{ticker}} {{interval}}")
alertcondition(bear_brk_sig, "Bearish Flag Breakout", "ğŸ”´ Bearish Breakout - Bear Flag | ÙƒØ³Ø± Ù‡Ø¨ÙˆØ·ÙŠ - Ø¹Ù„Ù… Ù‡Ø¨ÙˆØ·ÙŠ {{ticker}} {{interval}}")
alertcondition(bull_brk_sig or bear_brk_sig, "Any Flag Breakout", "âš¡ Flag Breakout | ÙƒØ³Ø± Ø¹Ù„Ù… {{ticker}} {{interval}}")
