//@version=6
// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SeerQuant

import TradingView/ta/9 as ta

indicator(
 title      = "Entropy-Scaled RSI [SeerQuant]",
 shorttitle = "ð„ð‘ð’ðˆ [SeerQuant]",
 overlay    = false
)

// ----------------- ï¼³ï¼´ï¼¡ï¼´ï¼©ï¼£ ï¼¶ï¼¡ï¼²ï¼©ï¼¡ï¼¢ï¼¬ï¼¥ï¼³ ----------------- //

const string g1 = "Calculation Settings"
const string g2 = "Style Settings"
const string g3 = "Stability"

int upper_limit = 90
int lower_limit = 10
int mid_line    = 50

// ----------------- ï¼©ï¼®ï¼°ï¼µï¼´ ï¼¶ï¼¡ï¼²ï¼©ï¼¡ï¼¢ï¼¬ï¼¥ï¼³ ----------------- //

// Style
string colScheme = input.string(defval = "Default", title = "Colour Choice",
     options = ["Default", "Modern", "Cool", "Monochrome"], group = g2)

string colcMode  = input.string(defval = "ERSI", title = "Candle Color Mode",
     options = ["ERSI", "Smoothed ERSI"], group = g2)

bool colc = input.bool(defval = false, title = "Color Candles?", group = g2)
bool cust = input.bool(defval = false, title = "Use Custom Colors?", group = g2)

color bullc    = input.color(defval = #00ff00, title = "Bull Colour",    group = g2)
color bearc    = input.color(defval = #ff0000, title = "Bear Colour",    group = g2)
color neutralc = input.color(defval = #6c6c6c, title = "Neutral Colour", group = g2)

// Core
float source = input.source(defval = close, title = "Calculation Source", group = g1)

int length      = input.int(defval = 14, title = "Calculation Length",    group = g1, minval = 2)
int emaLen      = input.int(defval = 8,  title = "Moving Average Length", group = g1, minval = 1)
int entropyLen  = input.int(defval = 20, title = "Entropy Lookback",      group = g1, minval = 5)
int neutralZone = input.int(defval = 5,  title = "Neutral Zone Range",    group = g1, minval = 0, maxval = 25)

string emaChoice = input.string(defval = "RMA", title = "Moving Average Type",
     options = ["SMA","EMA","SMMA","WMA","VWMA","LSMA","HMA","ALMA","RMA","DEMA","TEMA"], group = g1)

// Entropy mode only (bins are fixed internally)
string entMode = input.string(defval = "Returns (Binned)", title = "Entropy Mode",
     options = ["Direction (Up/Down)", "Returns (Binned)"], group = g1)

// Single stability control (0 = fastest/least filtered, 1 = smoothest/most stable)
float stability = input.float(defval = 0.60, title = "Stability (0..1)", group = g3, minval = 0.0, maxval = 1.0, step = 0.05)

// ----------------- ï¼£ï¼¯ï¼¬ï¼¯ï¼² ï¼³ï¼£ï¼¨ï¼¥ï¼­ï¼¥ ----------------- //

[bulld, beard] = switch colScheme
    "Default"    => [#00ff00, #ff0000]
    "Modern"     => [#23d7e4, #e11179]
    "Cool"       => [#00ffcc, #4e4f75]
    "Monochrome" => [#ffffff, #4e4e4e]

[bull, bear] = switch cust
    false => [bulld, beard]
    true  => [bullc, bearc]

// ----------------- ï¼¦ï¼µï¼®ï¼£ï¼´ï¼©ï¼¯ï¼®ï¼³ ----------------- //

ma(src, len, type) =>
    switch type
        "SMA"  => ta.sma(src, len)
        "EMA"  => ta.ema(src, len)
        "SMMA" => ta.rma(src, len)
        "WMA"  => ta.wma(src, len)
        "VWMA" => ta.vwma(src, len)
        "LSMA" => ta.linreg(src, len, 0)
        "ALMA" => ta.alma(src, len, 0.85, 6)
        "RMA"  => ta.rma(src, len)
        "HMA"  => ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.floor(math.sqrt(len)))
        "DEMA" =>
            ema1 = ta.ema(src, len)
            ema2 = ta.ema(ema1, len)
            2 * ema1 - ema2
        "TEMA" =>
            ema1 = ta.ema(src, len)
            ema2 = ta.ema(ema1, len)
            ema3 = ta.ema(ema2, len)
            3 * (ema1 - ema2) + ema3

clamp(x, lo, hi) =>
    math.min(math.max(x, lo), hi)

log2(x) =>
    math.log(x) / math.log(2)

// ----------------- ï¼³ï¼´ï¼¡ï¼¢ï¼©ï¼¬ï¼©ï¼´ï¼¹  (internal mapping) ----------------- //
//
// Higher stability:
// - stronger ATR shock clamp (lower cap)
// - more smoothing on entropy and alpha (reduces â€œjumpingâ€)
// Defaults chosen to damp single-bar reversal whipsaw without killing sustained trends.

int   atrLen          = 14
float atrMult         = 3.0 - 2.0 * stability         // 0->3.0 (lo clamp), 1->1.0 (tight clamp)
int   entropySmoothLen = int(math.round(1 + stability * 6)) // 1..7
int   alphaSmoothLen   = int(math.round(1 + stability * 6)) // 1..7

// Returns entropy bin count fixed internally (keeps compute bounded)
int bins = 12

// ----------------- ï¼£ï¼¡ï¼¬ï¼£ï¼µï¼¬ï¼¡ï¼´ï¼©ï¼¯ï¼®ï¼³ ----------------- //

// â”€â”€ Entropy â”€â”€
float chg = ta.change(source)

// Direction entropy (Up/Down/Zero)
float upCount_dir = math.sum(chg > 0 ? 1.0 : 0.0, entropyLen)
float dnCount_dir = math.sum(chg < 0 ? 1.0 : 0.0, entropyLen)
float zCount_dir  = math.sum(chg == 0 ? 1.0 : 0.0, entropyLen)
float total_dir   = upCount_dir + dnCount_dir + zCount_dir

float pUp_dir = total_dir > 0 ? upCount_dir / total_dir : 0.0
float pDn_dir = total_dir > 0 ? dnCount_dir / total_dir : 0.0
float pZ_dir  = total_dir > 0 ? zCount_dir  / total_dir : 0.0

float h_dir =
 (pUp_dir > 0 ? -pUp_dir * log2(pUp_dir) : 0.0) +
 (pDn_dir > 0 ? -pDn_dir * log2(pDn_dir) : 0.0) +
 (pZ_dir  > 0 ? -pZ_dir  * log2(pZ_dir)  : 0.0)

float entropy_dir = clamp(h_dir / log2(3.0), 0.0, 1.0)

// Returns entropy (Binned)
float ret   = ta.change(source) / source[1]
float retLo = ta.lowest(ret, entropyLen)
float retHi = ta.highest(ret, entropyLen)
float span  = retHi - retLo

float entropy_ret = 0.0
if not na(ret) and span > 0
    float h = 0.0
    for i = 0 to 31
        if i < bins
            float lo = retLo + span * (i / bins)
            float hi = retLo + span * ((i + 1) / bins)
            float c = 0.0
            for j = 0 to entropyLen - 1
                float rj = ret[j]
                bool inBin = i == bins - 1 ? (rj >= lo and rj <= hi) : (rj >= lo and rj < hi)
                c += inBin ? 1.0 : 0.0
            float p = c / entropyLen
            h += p > 0 ? -p * log2(p) : 0.0
    entropy_ret := clamp(h / log2(bins), 0.0, 1.0)
else
    entropy_ret := 0.0

float entropyRaw = entMode == "Direction (Up/Down)" ? entropy_dir : entropy_ret
float entropy    = clamp(ta.rma(entropyRaw, entropySmoothLen), 0.0, 1.0)

// â”€â”€ Adaptive Alpha from Entropy â”€â”€
float fastAlpha = 2.0 / (math.max(length / 2.0, 2.0) + 1.0)
float slowAlpha = 2.0 / (length * 2.0 + 1.0)
float alphaRaw  = fastAlpha + entropy * (slowAlpha - fastAlpha)
float alpha     = ta.rma(alphaRaw, alphaSmoothLen)

// â”€â”€ Shock limiter on delta (ATR clamp) â”€â”€
float atr   = ta.atr(atrLen)
float cap   = atrMult * atr
float dRaw  = ta.change(source)
float delta = not na(atr) ? clamp(dRaw, -cap, cap) : dRaw

// â”€â”€ RSI core with adaptive smoothing â”€â”€
float gainRaw = math.max(delta, 0)
float lossRaw = math.abs(math.min(delta, 0))

float seedGain = ta.sma(gainRaw, length)
float seedLoss = ta.sma(lossRaw, length)

var float avgGain = na
var float avgLoss = na
var bool  seeded  = false

if not seeded and not na(seedGain) and not na(seedLoss)
    avgGain := seedGain
    avgLoss := seedLoss
    seeded  := true
else if seeded
    avgGain := alpha * gainRaw + (1.0 - alpha) * avgGain
    avgLoss := alpha * lossRaw + (1.0 - alpha) * avgLoss

float ersi = na
if seeded
    if avgLoss == 0 and avgGain == 0
        ersi := 50.0
    else if avgLoss == 0
        ersi := 100.0
    else if avgGain == 0
        ersi := 0.0
    else
        float rs = avgGain / avgLoss
        ersi := 100.0 - (100.0 / (1.0 + rs))

float smoothed = ma(ersi, emaLen, emaChoice)

// ----------------- ï¼°ï¼¬ï¼¯ï¼´ï¼´ï¼©ï¼®ï¼§ ----------------- //

// Thresholds
f1  = plot(upper_limit, color = color.new(bear, 50))
f2  = plot(lower_limit, color = color.new(bull, 50))
mid = plot(mid_line,    color = color.new(chart.fg_color, 50))

// OB/OS gradient fills
fill(mid, f1, top_value = 90, bottom_value = 80, bottom_color = na,
     top_color = color.from_gradient(ersi, 20, 90, color.new(bear, 100), color.new(bear, 40)))

fill(mid, f2, top_value = 20, bottom_value = 10,
     bottom_color = color.from_gradient(ersi, 20, 90, color.new(bull, 40), color.new(bull, 100)),
     top_color = na)

// Neutral zone boundaries
float neutral_low  = 50 - neutralZone
float neutral_high = 50 + neutralZone

// RSI line
color plotColor = na(ersi) ? color.new(chart.fg_color, 70) : (ersi > neutral_high ? bull : ersi < neutral_low ? bear : neutralc)
p = plot(ersi, color = plotColor, linewidth = 1)

// Smoothed line
plot(smoothed, color = color.gray, linewidth = 1)

// Inner fill (cloud + gradient overlay, restored)
fill(p, mid, color = na(ersi) ? na : (ersi > neutral_high ? color.new(bull, 90) : (ersi < neutral_low ? color.new(bear, 90) : color.new(neutralc, 90))))
fill(p, mid, ersi, 50, color.new(chart.bg_color, 100), ersi > neutral_high ? bull : (ersi < neutral_low ? bear : neutralc))

// Candle coloring
float colorSrc = colcMode == "ERSI" ? ersi : smoothed
color col = na(colorSrc) ? na : (colorSrc > neutral_high ? bull : colorSrc < neutral_low ? bear : neutralc)

plotcandle(open, high, low, close,
     color         = colc ? col : na,
     wickcolor     = colc ? col : na,
     bordercolor   = colc ? col : na,
     force_overlay = true
)

// OB/OS Xâ€™s
bool cond1 = ersi > 90
bool cond2 = ersi < 20
plotshape(cond1 ? 100 : na, color = bear, force_overlay = false, location = location.absolute, style = shape.xcross)
plotshape(cond2 ? 0   : na, color = bull, force_overlay = false, location = location.absolute, style = shape.xcross)

// ----------------- ï¼¡ï¼¬ï¼¥ï¼²ï¼´ï¼³ ----------------- //

alertcondition(ersi > 50, title = "ERSI Positive Trend",       message = "ERSI Bullish Signal on: {{exchange}}:{{ticker}}")
alertcondition(ersi < 50, title = "ERSI Negative Trend",       message = "ERSI Bearish Signal on: {{exchange}}:{{ticker}}")
alertcondition(ersi < 20, title = "ERSI Oversold Condition",   message = "ERSI Oversold Signal on: {{exchange}}:{{ticker}}")
alertcondition(ersi > 90, title = "ERSI Overbought Condition", message = "ERSI Overbought Signal on: {{exchange}}:{{ticker}}")

// ---------------------------------------------------------------------------------------------------------------- //
// -------------------------------------------- ï¼£ï¼²ï¼¥ï¼¡ï¼´ï¼¥ï¼¤ ï¼¢ï¼¹ ------------------------------------------------- //
// ---------------------------------------------------------------------------------------------------------------- //
