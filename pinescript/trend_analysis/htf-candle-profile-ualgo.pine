// This Pine Script™ code is subject to the terms of the Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © UAlgo

//@version=6
indicator("HTF Candle Profile [UAlgo]", overlay = true, max_boxes_count = 500, max_lines_count = 500)

tf = input.timeframe("D", "Timeframe")
binCount = input.int(20, "Profile Bins")
colorUp = input.color(#089981, "Bullish")
colorDown = input.color(#F23645, "Bearish")

colorProfLow = input.color(color.new(#F23645, 60), "Profile Low Vol")
colorProfHigh = input.color(color.new(#089981, 10), "Profile High Vol")

showPoc = input.bool(true, "Show POC")
colorPoc = input.color(#FFD600, "POC")

type LtfBar
    float h
    float l
    float v

type ProfileData
    float minP
    float maxP
    float vol
    box b

type HtfCandle
    int st
    int et
    float o
    float h
    float l
    float c
    array<LtfBar> ltfData
    array<ProfileData> bins
    box bBody
    line lWick
    line lPoc
    line lStart
    line lEnd

method addLtf(HtfCandle this, float h, float l, float c, float v) =>
    this.ltfData.push(LtfBar.new(h, l, v))
    this.h := math.max(this.h, h)
    this.l := math.min(this.l, l)
    this.c := c

method clearDrawings(HtfCandle this) =>
    if not na(this.bBody)
        this.bBody.delete()
    if not na(this.lWick)
        this.lWick.delete()
    if not na(this.lPoc)
        this.lPoc.delete()
    if not na(this.lStart)
        this.lStart.delete()
    if not na(this.lEnd)
        this.lEnd.delete()
    if this.bins.size() > 0
        for b in this.bins
            if not na(b.b)
                b.b.delete()
    this.bins.clear()

method draw(HtfCandle this, color cUp, color cDn, color cLow, color cHigh, int bCount, bool sPoc, color cPoc) =>
    this.clearDrawings()
    color c = this.c >= this.o ? cUp : cDn
    
    int midTime = int(math.avg(this.st, this.et))
    float topP = math.max(this.o, this.c)
    float botP = math.min(this.o, this.c)
    
    float step = (this.h - this.l) / bCount
    if step > 0
        for i = 0 to bCount - 1
            this.bins.push(ProfileData.new(this.l + i * step, this.l + (i + 1) * step, 0.0, na))
        
        for ltf in this.ltfData
            int startIdx = int((ltf.l - this.l) / step)
            int endIdx = int((ltf.h - this.l) / step)
            startIdx := math.max(0, math.min(startIdx, bCount - 1))
            endIdx := math.max(0, math.min(endIdx, bCount - 1))
            
            int spanned = endIdx - startIdx + 1
            float vPerBin = ltf.v / spanned
            
            for j = startIdx to endIdx
                ProfileData b = this.bins.get(j)
                b.vol += vPerBin
                
        float maxVol = 0.0
        float pocP = na
        
        for b in this.bins
            if b.vol > maxVol
                maxVol := b.vol
                pocP := math.avg(b.minP, b.maxP)
        
        int duration = math.max(this.et - this.st, 1)
        
        for b in this.bins
            if b.vol > 0
                int volWidth = int((duration * 0.40) * (b.vol / maxVol))
                int boxRight = this.st + volWidth
                
                color gradColor = color.from_gradient(b.vol, 0, maxVol, cLow, cHigh)
                color borderColor = color.new(gradColor, 20)
                
                b.b := box.new(left=this.st, top=b.maxP, right=boxRight, bottom=b.minP, border_color=borderColor, border_width=1, border_style=line.style_solid, xloc=xloc.bar_time, bgcolor=gradColor)
                
        if sPoc and not na(pocP)
            this.lPoc := line.new(x1=this.st, y1=pocP, x2=this.et, y2=pocP, xloc=xloc.bar_time, color=cPoc, style=line.style_dashed, width=2)

    this.bBody := box.new(left=this.st, top=topP, right=this.et, bottom=botP, border_color=color.new(c, 20), border_width=1, border_style=line.style_solid, xloc=xloc.bar_time, bgcolor=color.new(c, 85))
    this.lWick := line.new(x1=midTime, y1=this.h, x2=midTime, y2=this.l, xloc=xloc.bar_time, color=color.new(c, 30), style=line.style_solid, width=2)
    
    this.lStart := line.new(x1=this.st, y1=this.h, x2=this.st, y2=this.l, xloc=xloc.bar_time, color=color.new(c, 60), style=line.style_dotted, width=1)
    this.lEnd := line.new(x1=this.et, y1=this.h, x2=this.et, y2=this.l, xloc=xloc.bar_time, color=color.new(c, 60), style=line.style_dotted, width=1)

var array<HtfCandle> candles = array.new<HtfCandle>()

isNew = timeframe.change(tf)

if isNew
    if candles.size() > 0
        HtfCandle lastC = candles.last()
        lastC.et := time
        lastC.draw(colorUp, colorDown, colorProfLow, colorProfHigh, binCount, showPoc, colorPoc)
    candles.push(HtfCandle.new(time, time, open, high, low, close, array.new<LtfBar>(), array.new<ProfileData>(), na, na, na, na, na))
    if candles.size() > 5
        HtfCandle old = candles.shift()
        old.clearDrawings()

if candles.size() > 0
    HtfCandle current = candles.last()
    current.addLtf(high, low, close, nz(volume, 1))
    current.et := time_close
    if barstate.islast
        current.draw(colorUp, colorDown, colorProfLow, colorProfHigh, binCount, showPoc, colorPoc)
