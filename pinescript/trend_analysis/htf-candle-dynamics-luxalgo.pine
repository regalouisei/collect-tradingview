// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=6
indicator("HTF Candle Dynamics [LuxAlgo]", "LuxAlgo - HTF Candle Dynamics", overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, max_polylines_count = 100)

//---------------------------------------------------------------------------------------------------------------------}
// Constants
//---------------------------------------------------------------------------------------------------------------------{

color BULL_COLOR    = #089981
color BEAR_COLOR    = #f23645
color NEUTRAL_COLOR = #9598a1
color POC_COLOR     = #ff9800

// Dashboard Styling
DATA                = #DBDBDB
HEADERS             = #808080
BACKGROUND          = #161616
BORDERS             = #2E2E2E

TINY                = 'Tiny'
SMALL               = 'Small'
NORMAL              = 'Normal'
LARGE               = 'Large'
HUGE                = 'Huge'

//---------------------------------------------------------------------------------------------------------------------}
// Inputs
//---------------------------------------------------------------------------------------------------------------------{

string timeframeInput    = input.timeframe("D", "HTF Setting")
int    offsetInput       = input.int(50, "Right Offset", minval = 1)
int    paddingInput      = input.int(5, "Element Padding", minval = 0)

// Visuals
color  bullColorInput    = input.color(BULL_COLOR,    "Bullish Color", inline = "colors", group = "Visuals")
color  bearColorInput    = input.color(BEAR_COLOR,    "Bearish Color", inline = "colors", group = "Visuals")
color  openColorInput    = input.color(NEUTRAL_COLOR, "Open Level Color", group = "Visuals")
color  pocColorInput     = input.color(POC_COLOR,     "POC Color", group = "Visuals")

// Volume Profile
bool   showVPInput       = input.bool(true,  "Show Volume Profile", group = "Volume Profile")
int    vpRowsInput       = input.int(20,     "Profile Rows", minval = 5, maxval = 100, group = "Volume Profile")
int    vpWidthInput      = input.int(25,     "Max Width (Bars)", minval = 5, maxval = 100, group = "Volume Profile")
color  vpColorInput      = input.color(color.new(NEUTRAL_COLOR, 70), "Profile Color", group = "Volume Profile")

// History Dashboard
bool   showHistoryInput  = input.bool(true,  "Show History Dashboard", group = "Dashboard")
string histPosInput      = input.string("Bottom Right", "Position", options = ["Bottom Right", "Bottom Left", "Top Right"], group = "Dashboard")
string dashboardSizeInput = input.string(SMALL, "Dashboard Size", options = [TINY, SMALL, NORMAL, LARGE, HUGE], group = "Dashboard")

//---------------------------------------------------------------------------------------------------------------------}
// User Defined Functions (Global)
//---------------------------------------------------------------------------------------------------------------------{

formatDelta(float val) => 
    (val >= 0 ? "+" : "") + str.format("{0,number,#.#}K", val / 1000)

cell(table t, int c, int r, string d, color col = #FFFFFF, align = text.align_right, color bg = na, string sz = size.small) => 
    t.cell(c, r, d, text_color = col, text_size = sz, text_halign = align, bgcolor = bg)

//---------------------------------------------------------------------------------------------------------------------}
// Calculations
//---------------------------------------------------------------------------------------------------------------------{

// Delta Calculation Approximation (Sum of volume * sign of candle)
var float currentDelta = 0.0
bool isNewPeriod = timeframe.change(timeframeInput)

if isNewPeriod
    currentDelta := volume * math.sign(close - open)
else
    currentDelta += volume * math.sign(close - open)

// Fetch HTF OHLC & Delta History
[h1, h2, h3] = request.security(syminfo.tickerid, timeframeInput, [high[1], high[2], high[3]], lookahead = barmerge.lookahead_on)
[l1, l2, l3] = request.security(syminfo.tickerid, timeframeInput, [low[1], low[2], low[3]], lookahead = barmerge.lookahead_on)
[o1, o2, o3] = request.security(syminfo.tickerid, timeframeInput, [open[1], open[2], open[3]], lookahead = barmerge.lookahead_on)
[c1, c2, c3] = request.security(syminfo.tickerid, timeframeInput, [close[1], close[2], close[3]], lookahead = barmerge.lookahead_on)
[d1, d2, d3] = request.security(syminfo.tickerid, timeframeInput, [currentDelta[1], currentDelta[2], currentDelta[3]], lookahead = barmerge.lookahead_on)

// Track HTF OHLC Source Indices
var float htfOpen   = open
var float htfHigh   = high
var float htfLow    = low
var float htfClose  = close
var int   openBar   = bar_index
var int   highBar   = bar_index
var int   lowBar    = bar_index
var int   startBar  = bar_index

var map<float, float> volProfile = map.new<float, float>()
var chart.point[] pocPoints = array.new<chart.point>()

if isNewPeriod
    htfOpen     := open
    htfHigh     := high
    htfLow      := low
    openBar     := bar_index
    highBar     := bar_index
    lowBar      := bar_index
    startBar    := bar_index
    volProfile.clear()
    pocPoints.clear()
else
    if high > htfHigh
        htfHigh := high
        highBar := bar_index
    if low < htfLow
        htfLow  := low
        lowBar  := bar_index

htfClose := close

// Volume Accumulation
float tickSize = syminfo.mintick
float htfRange = math.max(tickSize, htfHigh - htfLow)
float rowSize  = math.max(tickSize, htfRange / vpRowsInput)
float rowPrice = math.round(close / rowSize) * rowSize
volProfile.put(rowPrice, nz(volProfile.get(rowPrice)) + volume)

// POC Calculation
float devPocPrice = na
float maxVol   = 0.0
float[] prices = volProfile.keys()
for p in prices
    v = volProfile.get(p)
    if v > maxVol
        maxVol := v
        devPocPrice := p
if not na(devPocPrice)
    pocPoints.push(chart.point.from_index(bar_index, devPocPrice))

// Dashboard Size Parsing
var parsedDashboardSize = switch dashboardSizeInput
    TINY    => size.tiny
    SMALL   => size.small
    NORMAL  => size.normal
    LARGE   => size.large
    HUGE    => size.huge

//---------------------------------------------------------------------------------------------------------------------}
// Visualization Logic
//---------------------------------------------------------------------------------------------------------------------{

var box      bodyBox   = box.new(na, na, na, na, xloc = xloc.bar_index, border_style = line.style_solid)
var line     wickLine  = line.new(na, na, na, na, xloc = xloc.bar_index)
var line     highLine  = line.new(na, na, na, na, xloc = xloc.bar_index, style = line.style_dashed)
var line     lowLine   = line.new(na, na, na, na, xloc = xloc.bar_index, style = line.style_dashed)
var line     openLine  = line.new(na, na, na, na, xloc = xloc.bar_index, style = line.style_dashed)
var line     closeLine = line.new(na, na, na, na, xloc = xloc.bar_index, style = line.style_dashed)
var line     pocProj   = line.new(na, na, na, na, xloc = xloc.bar_index, style = line.style_dashed)
var polyline pLine     = na

var label    highLabel = label.new(na, na, xloc = xloc.bar_index, style = label.style_none, textalign = text.align_left)
var label    lowLabel  = label.new(na, na, xloc = xloc.bar_index, style = label.style_none, textalign = text.align_left)

var box[]    vpBoxes     = array.new<box>()

if barstate.islast
    int targetX      = bar_index + math.max(offsetInput, vpWidthInput + paddingInput + 10)
    int labelX       = targetX + 4 + paddingInput
    int profileEndX  = targetX - 4 - paddingInput
    float lOffset    = htfRange * 0.05
    color themeColor = htfClose >= htfOpen ? bullColorInput : bearColorInput
    
    // --- Projection ---
    box.set_lefttop(bodyBox, targetX - 4, math.max(htfOpen, htfClose))
    box.set_rightbottom(bodyBox, targetX + 4, math.min(htfOpen, htfClose))
    box.set_bgcolor(bodyBox, themeColor)
    box.set_border_color(bodyBox, themeColor)
    line.set_xy1(wickLine, targetX, htfHigh), line.set_xy2(wickLine, targetX, htfLow), line.set_color(wickLine, themeColor)
    
    line.set_xy1(highLine, highBar, htfHigh), line.set_xy2(highLine, labelX + 2, htfHigh), line.set_color(highLine, themeColor)
    line.set_xy1(lowLine, lowBar, htfLow), line.set_xy2(lowLine, labelX + 2, htfLow), line.set_color(lowLine, bearColorInput)
    line.set_xy1(openLine, openBar, htfOpen), line.set_xy2(openLine, targetX + 4, htfOpen), line.set_color(openLine, openColorInput)
    line.set_xy1(closeLine, bar_index, htfClose), line.set_xy2(closeLine, targetX + 4, htfClose), line.set_color(closeLine, themeColor)
    
    polyline.delete(pLine)
    if pocPoints.size() > 1
        pLine := polyline.new(pocPoints, xloc = xloc.bar_index, line_color = pocColorInput, line_width = 2)
    if not na(devPocPrice)
        line.set_xy1(pocProj, bar_index, devPocPrice), line.set_xy2(pocProj, targetX + 4, devPocPrice), line.set_color(pocProj, pocColorInput)

    label.set_xy(highLabel, labelX, htfHigh + lOffset), label.set_text(highLabel, "High: " + str.tostring(htfHigh, format.mintick)), label.set_textcolor(highLabel, themeColor)
    label.set_xy(lowLabel, labelX, htfLow - lOffset), label.set_text(lowLabel, "Low: " + str.tostring(htfLow, format.mintick)), label.set_textcolor(lowLabel, bearColorInput)

    if showVPInput and volProfile.size() > 0
        for b in vpBoxes
            box.delete(b)
        vpBoxes.clear()
        for p in prices
            int barWidth = math.round((volProfile.get(p) / maxVol) * vpWidthInput)
            box b = box.new(profileEndX - barWidth, p + (rowSize/2), profileEndX, p - (rowSize / 2), bgcolor = vpColorInput, border_color = na)
            vpBoxes.push(b)

//---------------------------------------------------------------------------------------------------------------------}
// Dashboards
//---------------------------------------------------------------------------------------------------------------------{

if barstate.islast
    // Status Dashboard (Top Right)
    var table statusTable = table.new(position.top_right, 2, 2, bgcolor = BACKGROUND, frame_color = BORDERS, frame_width = 1)
    bool isTfValid = timeframe.in_seconds() <= timeframe.in_seconds(timeframeInput)
    cell(statusTable, 0, 0, "HTF Setting:", HEADERS, text.align_left, sz = parsedDashboardSize)
    cell(statusTable, 1, 0, timeframeInput, DATA, sz = parsedDashboardSize)
    cell(statusTable, 0, 1, "Status:", HEADERS, text.align_left, sz = parsedDashboardSize)
    cell(statusTable, 1, 1, isTfValid ? "OK" : "Error - Use Lower TF", isTfValid ? bullColorInput : bearColorInput, sz = parsedDashboardSize)

    // History Dashboard
    if showHistoryInput
        pos = histPosInput == "Bottom Right" ? position.bottom_right : histPosInput == "Bottom Left" ? position.bottom_left : position.top_right
        var table histTable = table.new(pos, 3, 7, bgcolor = BACKGROUND, frame_color = BORDERS, frame_width = 1)
        
        // Col 0 (T-3)
        cell(histTable, 0, 0, "T-3", HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 0, 1, str.tostring(h3, format.mintick), HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 0, 2, "╷", c3 >= o3 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 0, 3, "█", c3 >= o3 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 0, 4, "╵", c3 >= o3 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 0, 5, str.tostring(l3, format.mintick), HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 0, 6, formatDelta(d3), d3 >= 0 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        
        // Col 1 (T-2)
        cell(histTable, 1, 0, "T-2", HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 1, 1, str.tostring(h2, format.mintick), HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 1, 2, "╷", c2 >= o2 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 1, 3, "█", c2 >= o2 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 1, 4, "╵", c2 >= o2 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 1, 5, str.tostring(l2, format.mintick), HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 1, 6, formatDelta(d2), d2 >= 0 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)

        // Col 2 (T-1)
        cell(histTable, 2, 0, "T-1", HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 2, 1, str.tostring(h1, format.mintick), HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 2, 2, "╷", c1 >= o1 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 2, 3, "█", c1 >= o1 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 2, 4, "╵", c1 >= o1 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 2, 5, str.tostring(l1, format.mintick), HEADERS, text.align_center, sz = parsedDashboardSize)
        cell(histTable, 2, 6, formatDelta(d1), d1 >= 0 ? bullColorInput : bearColorInput, text.align_center, sz = parsedDashboardSize)

//---------------------------------------------------------------------------------------------------------------------}
