// This Pine Script™ code is subject to the terms of the Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © UAlgo

//@version=6
indicator("KNN Trend Forecaster [UAlgo]", overlay = true, max_bars_back = 2000, max_boxes_count = 500, max_lines_count = 500, max_labels_count = 100, max_polylines_count = 100)

// -----------------------------------------------------------------------------
//  THEME COLORS
// -----------------------------------------------------------------------------
color THEME_UP      = #00FFBB  
color THEME_DN      = #FF0055  
color THEME_MID     = #787B86  

group_ml = "Forecaster Intelligence"
int   k_neighbors   = input.int(12, "Model Sensitivity", minval=1, group=group_ml)
int   forecast_len  = input.int(18, "Forecast Horizon", minval=5, maxval=40, group=group_ml)
float expansion     = input.float(3.0, "Tunnel Volatility", minval=0.1, step=0.1, group=group_ml)

group_vis = "Visual Experience"
bool  show_ghost    = input.bool(true, "Elite Ghost Structures", group=group_vis)
bool  show_tunnel   = input.bool(true, "Multi-Layer Tunnel", group=group_vis)
bool  show_glow     = input.bool(true, "Neon Glow Path", group=group_vis)

// -----------------------------------------------------------------------------
// ML ENGINE
// -----------------------------------------------------------------------------
type FeatureSet
    float f1
    float f2
    float f3

type TrainingPoint
    FeatureSet features
    float      change

method distance(FeatureSet v1, FeatureSet v2) =>
    math.sqrt(math.pow(v1.f1 - v2.f1, 2) + math.pow(v1.f2 - v2.f2, 2) + math.pow(v1.f3 - v2.f3, 2))

normalize(float src, int len) =>
    float mn = ta.lowest(src, len)
    float mx = ta.highest(src, len)
    (src - mn) / (math.max(mx - mn, 0.000001)) * 100

// Analytics
float f_rsi = ta.rsi(close, 14)
float f_roc = normalize(ta.roc(close, 10), 100)
float f_atr = normalize(ta.atr(14), 100)

FeatureSet current_f = FeatureSet.new(f_rsi, f_roc, f_atr)
var array<TrainingPoint> memory = array.new<TrainingPoint>()

if barstate.isconfirmed
    float outcome = (close - close[10]) / close[10] * 100
    memory.push(TrainingPoint.new(FeatureSet.new(f_rsi[10], f_roc[10], f_atr[10]), outcome))
    if memory.size() > 1000 
        memory.shift()

var float pred = 0.0
if memory.size() >= k_neighbors
    array<float> dists = array.new<float>()
    array<float> changes = array.new<float>()
    for i = 0 to memory.size() - 1
        TrainingPoint p = memory.get(i)
        dists.push(current_f.distance(p.features))
        changes.push(p.change)
    
    float twc = 0.0, float ws = 0.0
    array<float> td = dists.copy(), array<float> tc = changes.copy()
    for k = 1 to k_neighbors
        int idx = td.indexof(td.min())
        if idx != -1
            float w = 1.0 / math.max(td.get(idx), 0.0001)
            twc += tc.get(idx) * w, ws += w
            td.remove(idx), tc.remove(idx)
    pred := twc / ws

// -----------------------------------------------------------------------------
// RENDERER
// -----------------------------------------------------------------------------
var array<box>      ghost_objs = array.new<box>()
var array<line>     tunnel_lines = array.new<line>()
var array<linefill> tunnel_fills = array.new<linefill>()
var polyline        path_main = na
var polyline        path_glow = na
var label           target_tag = na

color sig_col = pred > 0.005 ? THEME_UP : pred < -0.005 ? THEME_DN : THEME_MID

if barstate.islast
    for b in ghost_objs 
        box.delete(b)
    for l in tunnel_lines 
        line.delete(l)
    for f in tunnel_fills 
        linefill.delete(f)
    if not na(path_main) 
        polyline.delete(path_main)
    if not na(path_glow) 
        polyline.delete(path_glow)
    if not na(target_tag) 
        label.delete(target_tag)
    array.clear(ghost_objs), array.clear(tunnel_lines), array.clear(tunnel_fills)

    if pred != 0
        float cur_c = close, float atr = ta.atr(14), float step = (pred / 10.0) * 0.01
        float cur_h = close + (atr * 0.05), float cur_l = close - (atr * 0.05)
        
        array<chart.point> pts = array.new<chart.point>()
        array.push(pts, chart.point.from_index(bar_index, close))

        for i = 1 to forecast_len
            float next_c = cur_c * (1 + step * (1.0 / math.sqrt(i)))
            float v_outer = (atr * expansion * 0.3 * math.sqrt(i))
            float v_inner = v_outer * 0.5
            
            float h_out = next_c + v_outer, float l_out = next_c - v_outer
            float h_in  = next_c + v_inner, float l_in  = next_c - v_inner
            
            int x1 = bar_index + i - 1, int x2 = bar_index + i

            if show_tunnel
                line lo_t = line.new(x1, cur_h, x2, h_out, color=color.new(sig_col, 80), width=1)
                line lo_b = line.new(x1, cur_l, x2, l_out, color=color.new(sig_col, 80), width=1)
                array.push(tunnel_lines, lo_t), array.push(tunnel_lines, lo_b)
                array.push(tunnel_fills, linefill.new(lo_t, lo_b, color.new(sig_col, 92)))
                line li_t = line.new(x1, cur_h, x2, h_in, color=na)
                line li_b = line.new(x1, cur_l, x2, l_in, color=na)
                array.push(tunnel_lines, li_t), array.push(tunnel_lines, li_b)
                array.push(tunnel_fills, linefill.new(li_t, li_b, color.new(sig_col, 85)))
                cur_h := h_out, cur_l := l_out

            array.push(pts, chart.point.from_index(x2, next_c))

            if show_ghost
                color g_col = next_c >= cur_c ? color.new(THEME_UP, 40) : color.new(THEME_DN, 40)
                box b = box.new(x1, math.max(cur_c, next_c), x2, math.min(cur_c, next_c), border_color=color.new(g_col, 20), bgcolor=g_col, border_width=1)
                array.push(ghost_objs, b)
            
            cur_c := next_c

        if show_glow
            path_glow := polyline.new(pts, curved=true, line_color=color.new(sig_col, 70), line_width=8)
            path_main := polyline.new(pts, curved=true, line_color=sig_col, line_width=2)
        
        target_tag := label.new(bar_index + forecast_len, cur_c, "TARGET: " + str.tostring(pred, "#.##") + "%", 
          color=color.new(sig_col, 100), textcolor=sig_col, style=label.style_label_left, size=size.small)

// UI
plot(ta.ema(close, 21), title="Projection Basis", color=sig_col, linewidth=2)

var table ui = table.new(position.top_right, 2, 2, border_width=1, border_color=#434651, bgcolor=#131722)
if barstate.islast
    table.cell(ui, 0, 0, "PROJECTION", text_color=color.white, text_size=size.small)
    table.cell(ui, 1, 0, (pred > 0 ? "▲ " : "▼ ") + str.tostring(pred, "#.##") + "%", text_color=sig_col, text_size=size.small)
    table.cell(ui, 0, 1, "SENTIMENT", text_color=color.white, text_size=size.small)
    table.cell(ui, 1, 1, pred > 0.01 ? "BULLISH" : pred < -0.01 ? "BEARISH" : "NEUTRAL", text_color=sig_col, text_size=size.small)
