// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ChartPrime

//@version=6
indicator('Polynomial Regression Moving Average (PRMA)', overlay = true)

// --------------------------------------------------------------------------------------------------------------------}
// ğŸ“Œ ğ™ğ™ğ™€ğ™ ğ™„ğ™‰ğ™‹ğ™ğ™ğ™
// --------------------------------------------------------------------------------------------------------------------{

source      = input.source(close, 'Source')
length      = input.int(100, 'Period', 2)
degree      = input.float(4.0, 'Degree', minval = 1.0, step = 0.1) 
colorUp     = input.color(color.rgb(36, 223, 23), "Up", inline = "col")
colorDn     = input.color(color.fuchsia, "Down", inline = "col")

grp_smooth  = "Smoothing"
smoothType  = input.string("EMA", "Smoothing Method", options = ["None", "SMA", "EMA", "WMA", "RMA", "HMA", "DEMA", "TEMA", "VWMA", "Gaussian"], group = grp_smooth)
smoothLen   = input.int(5, "Smoothing Length", minval = 1, group = grp_smooth)
smoothIter  = input.int(1, "Smoothing Iterations", minval = 1, maxval = 10, group = grp_smooth, tooltip = "Number of times smoothing is applied. Higher values = smoother result with more lag.")

grp_sig     = "Signals"
showSig     = input.bool(true, "Show Signals", group = grp_sig)

// --------------------------------------------------------------------------------------------------------------------}
// ğŸ“Œ ğ™ˆğ˜¼ğ™ğ™ğ™„ğ™“ ğ™ƒğ™€ğ™‡ğ™‹ğ™€ğ™ğ™
// --------------------------------------------------------------------------------------------------------------------{

mat_add(matrix<float> m1, matrix<float> m2) =>
    r = m1.rows()
    c = m1.columns()
    res = matrix.new<float>(r, c, 0.0)
    for i = 0 to r - 1
        for j = 0 to c - 1
            res.set(i, j, m1.get(i, j) + m2.get(i, j))
    res

mat_scale(matrix<float> m, float scalar) =>
    r = m.rows()
    c = m.columns()
    res = matrix.new<float>(r, c, 0.0)
    for i = 0 to r - 1
        for j = 0 to c - 1
            res.set(i, j, m.get(i, j) * scalar)
    res

// --------------------------------------------------------------------------------------------------------------------}
// ğŸ“Œ ğ™Šğ™‡ğ™ ğ™†ğ™€ğ™ğ™‰ğ™€ğ™‡
// --------------------------------------------------------------------------------------------------------------------{

get_ols_weights(int length, int deg) =>
    X = matrix.new<float>(length, deg + 1, 0.0)
    for i = 0 to length - 1
        for j = 0 to deg
            X.set(i, j, math.pow(i, j))
    
    Xt      = X.transpose()
    XtX     = Xt.mult(X)
    XtX_inv = XtX.inv()
    H_full  = XtX_inv.mult(Xt)

    x_last = matrix.new<float>(1, deg + 1, 0.0)
    for j = 0 to deg
        x_last.set(0, j, math.pow(length - 1, j))
    
    x_last.mult(H_full) 

// --------------------------------------------------------------------------------------------------------------------}
// ğŸ“Œ ğ™ğ™ˆğ™Šğ™Šğ™ğ™ƒğ™„ğ™‰ğ™‚ ğ™ğ™ğ™‰ğ˜¾ğ™ğ™„ğ™Šğ™‰ğ™
// --------------------------------------------------------------------------------------------------------------------{

// Gaussian smoothing kernel approximation
gaussian_smooth(float src, int len) =>
    float sum = 0.0
    float wsum = 0.0
    float sigma = len / 3.0
    for i = 0 to len - 1
        float w = math.exp(-0.5 * math.pow(i / sigma, 2))
        sum += nz(src[i]) * w
        wsum += w
    sum / wsum

// DEMA
dema(float src, int len) =>
    e1 = ta.ema(src, len)
    e2 = ta.ema(e1, len)
    2 * e1 - e2

// TEMA
tema(float src, int len) =>
    e1 = ta.ema(src, len)
    e2 = ta.ema(e1, len)
    e3 = ta.ema(e2, len)
    3 * (e1 - e2) + e3

// HMA (Hull Moving Average)
hma(float src, int len) =>
    halfLen = math.max(int(len / 2), 1)
    sqrtLen = math.max(int(math.sqrt(len)), 1)
    ta.wma(2 * ta.wma(src, halfLen) - ta.wma(src, len), sqrtLen)

// Single-pass smoothing selector
apply_smooth_once(float src, int len) =>
    switch smoothType
        "SMA"      => ta.sma(src, len)
        "EMA"      => ta.ema(src, len)
        "WMA"      => ta.wma(src, len)
        "RMA"      => ta.rma(src, len)
        "HMA"      => hma(src, len)
        "DEMA"     => dema(src, len)
        "TEMA"     => tema(src, len)
        "VWMA"     => ta.vwma(src, len)
        "Gaussian" => gaussian_smooth(src, len)
        => src

// Multi-iteration smoothing
apply_smoothing(float src) =>
    if smoothType == "None"
        src
    else
        // Iteration 1
        float s1 = apply_smooth_once(src, smoothLen)
        result = s1
        // Iteration 2
        if smoothIter >= 2
            result := apply_smooth_once(result, smoothLen)
        // Iteration 3
        if smoothIter >= 3
            result := apply_smooth_once(result, smoothLen)
        // Iteration 4
        if smoothIter >= 4
            result := apply_smooth_once(result, smoothLen)
        // Iteration 5
        if smoothIter >= 5
            result := apply_smooth_once(result, smoothLen)
        // Iteration 6
        if smoothIter >= 6
            result := apply_smooth_once(result, smoothLen)
        // Iteration 7
        if smoothIter >= 7
            result := apply_smooth_once(result, smoothLen)
        // Iteration 8
        if smoothIter >= 8
            result := apply_smooth_once(result, smoothLen)
        // Iteration 9
        if smoothIter >= 9
            result := apply_smooth_once(result, smoothLen)
        // Iteration 10
        if smoothIter >= 10
            result := apply_smooth_once(result, smoothLen)
        result

// --------------------------------------------------------------------------------------------------------------------}
// ğŸ“Œ ğ™‰ğ™Šğ™‰-ğ™ğ™€ğ™‹ğ˜¼ğ™„ğ™‰ğ™ğ™„ğ™‰ğ™‚ ğ˜¾ğ˜¼ğ™‡ğ˜¾ğ™ğ™‡ğ˜¼ğ™ğ™„ğ™Šğ™‰
// --------------------------------------------------------------------------------------------------------------------{

var matrix<float> kernel = na

if barstate.isfirst
    deg_f = math.floor(degree)
    deg_c = math.ceil(degree)
    weight = degree - deg_f
    
    k_floor = get_ols_weights(length, int(deg_f))
    
    if deg_f == deg_c
        kernel := k_floor
    else
        k_ceil = get_ols_weights(length, int(deg_c))
        m1 = mat_scale(k_floor, 1.0 - weight)
        m2 = mat_scale(k_ceil, weight)
        kernel := mat_add(m1, m2)

float nr_pred = 0.0
if not na(source[length])
    for i = 0 to length - 1
        w = kernel.get(0, i) 
        p = source[length - 1 - i]
        nr_pred += w * p

// --------------------------------------------------------------------------------------------------------------------}
// ğŸ“Œ ğ˜¼ğ™‹ğ™‹ğ™‡ğ™” ğ™ğ™ˆğ™Šğ™Šğ™ğ™ƒğ™„ğ™‰ğ™‚
// --------------------------------------------------------------------------------------------------------------------{

float prma = apply_smoothing(nr_pred)

// --------------------------------------------------------------------------------------------------------------------}
// ğŸ“Œ ğ™ğ™„ğ™‚ğ™‰ğ˜¼ğ™‡ğ™
// --------------------------------------------------------------------------------------------------------------------{

bool prma_up  = prma > prma[1]
bool prma_dn  = prma < prma[1]
bool sig_buy  = prma_up and prma_dn[1]
bool sig_sell = prma_dn and prma_up[1]

plot(prma, "PRMA", color = prma_up ? colorUp : colorDn, linewidth = 2)

plotshape(showSig and sig_buy and close > prma,  "Long",  shape.labelup,   location.belowbar, colorUp, text = "L", textcolor = color.white, size = size.tiny)
plotshape(showSig and sig_sell and close < prma, "Short", shape.labeldown, location.abovebar, colorDn, text = "S", textcolor = color.white, size = size.tiny)
