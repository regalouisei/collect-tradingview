//@version=5
indicator("Multi-Factor Consensus", shorttitle="ğŸ§ MFC", overlay=true, max_bars_back=5000, max_lines_count=500, max_labels_count=500, max_boxes_count=100)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-FACTOR CONSENSUS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 
// Components:
// â€¢ Tabular Q-Learning (Reinforcement Learning)
// â€¢ Differential Geometry (Curvature Analysis)
// â€¢ Market Pressure Index (Volume-Weighted Flow)
// â€¢ Adaptive Volatility Channel
// â€¢ Pivot-Based Key Levels
// â€¢ Performance Tracking
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 1: INPUTS - CONSENSUS ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_cons = "âš™ï¸ CONSENSUS ENGINE"
string tt_mode = "SIGNAL STRICTNESS LEVEL\n\n" +
     "Controls how many systems must agree before a signal fires.\n\n" +
     "â–¸ LOOSE (1/3)\n" +
     "   Triggers when ANY single system fires.\n" +
     "   â€¢ Use for: Scalping, 1-5 minute charts\n" +
     "   â€¢ Best on: Crypto, volatile small-caps\n" +
     "   â€¢ Risk: More signals, more false positives\n\n" +
     "â–¸ MODERATE (2/3)\n" +
     "   Requires 2 systems to agree.\n" +
     "   â€¢ Use for: Day trading, 15m-1H charts\n" +
     "   â€¢ Best on: Futures, Forex, large-cap stocks\n" +
     "   â€¢ Risk: Balanced signal quality\n\n" +
     "â–¸ STRICT (3/3)\n" +
     "   ALL 3 systems must align.\n" +
     "   â€¢ Use for: Swing trading, 4H-Daily charts\n" +
     "   â€¢ Best on: Indices, ETFs, position trades\n" +
     "   â€¢ Risk: Fewer signals, higher conviction"
i_mode = input.string("Moderate (2/3)", "Signal Mode", 
     options=["Loose (1/3)", "Moderate (2/3)", "Strict (3/3)"], 
     group=grp_cons, tooltip=tt_mode)
string tt_align = "ALIGNMENT WINDOW\n\n" +
     "Number of bars within which systems must agree.\n" +
     "Systems rarely fire on the exact same bar.\n\n" +
     "â–¸ TIMEFRAME GUIDE:\n" +
     "   â€¢ 1-5 min: 2-3 bars\n" +
     "   â€¢ 15-60 min: 3-5 bars\n" +
     "   â€¢ 4H-Daily: 5-8 bars\n\n" +
     "â–¸ ASSET GUIDE:\n" +
     "   â€¢ Crypto: 2-4 bars (fast moves)\n" +
     "   â€¢ Forex: 3-5 bars (moderate)\n" +
     "   â€¢ Stocks: 4-6 bars (slower)"
i_align = input.int(5, "Alignment Window", minval=1, maxval=20, 
     group=grp_cons, tooltip=tt_align)
string tt_cool = "MINIMUM BARS BETWEEN SIGNALS\n\n" +
     "Prevents signal spam during volatile conditions.\n\n" +
     "â–¸ TIMEFRAME GUIDE:\n" +
     "   â€¢ Scalping (1-5m): 5-15 bars\n" +
     "   â€¢ Day Trading (15m-1H): 15-30 bars\n" +
     "   â€¢ Swing (4H-Daily): 3-10 bars\n\n" +
     "â–¸ TIP: Increase during ranging/choppy markets."
i_cooldown = input.int(20, "Min Bars Between Signals", minval=1, maxval=200, 
     group=grp_cons, tooltip=tt_cool)
string tt_conflict = "SIGNAL CONFLICT RESOLUTION\n\n" +
     "What to do when both bull and bear conditions are met.\n\n" +
     "â–¸ Higher Score: Stronger consensus wins\n" +
     "â–¸ Bullish Priority: Bulls win ties\n" +
     "â–¸ Bearish Priority: Bears win ties\n" +
     "â–¸ No Signal: Skip conflicting bars"
i_conflict = input.string("Higher Score", "Conflict Resolution",
     options=["Higher Score", "Bullish Priority", "Bearish Priority", "No Signal"],
     group=grp_cons, tooltip=tt_conflict)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 2: INPUTS - Q-LEARNING ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ql = "ğŸ§  Q-LEARNING (Reinforcement Learning)"
string tt_ql = "TABULAR Q-LEARNING ENGINE\n\n" +
     "A reinforcement learning algorithm that learns optimal\n" +
     "trading actions from historical price behavior.\n\n" +
     "â–¸ HOW IT WORKS:\n" +
     "   â€¢ Divides market into 27 states\n" +
     "     (3 trend Ã— 3 volatility Ã— 3 momentum)\n" +
     "   â€¢ Learns value of LONG/SHORT/HOLD actions\n" +
     "   â€¢ Updates based on realized price changes\n\n" +
     "â–¸ SPECIFICATIONS:\n" +
     "   â€¢ State Space: 27 discrete states\n" +
     "   â€¢ Action Space: 3 actions\n" +
     "   â€¢ Q-Table: 81 learnable values\n\n" +
     "âš ï¸ NOTE: Requires 500+ bars to stabilize."
i_ql_on = input.bool(true, "Enable Q-Learning", group=grp_ql, tooltip=tt_ql)
string tt_ql_lr = "LEARNING RATE (Î±)\n\n" +
     "Controls how fast the algorithm adapts.\n\n" +
     "â–¸ 0.01-0.05: Slow learner (stable)\n" +
     "â–¸ 0.05-0.15: Balanced (recommended)\n" +
     "â–¸ 0.15-0.30: Fast learner (reactive)"
i_ql_lr = input.float(0.08, "Learning Rate (Î±)", minval=0.01, maxval=0.5, step=0.01, 
     group=grp_ql, tooltip=tt_ql_lr)
string tt_ql_gamma = "DISCOUNT FACTOR (Î³)\n\n" +
     "How much future rewards matter.\n\n" +
     "â–¸ 0.80-0.90: Short-term focus (scalping)\n" +
     "â–¸ 0.90-0.95: Balanced\n" +
     "â–¸ 0.95-0.99: Long-term focus (swing)"
i_ql_gamma = input.float(0.92, "Discount Factor (Î³)", minval=0.5, maxval=0.99, step=0.01, 
     group=grp_ql, tooltip=tt_ql_gamma)
string tt_ql_eps = "EXPLORATION RATE (Îµ)\n\n" +
     "Probability of trying random actions.\n\n" +
     "â–¸ 0.05-0.10: Mostly exploits learned behavior\n" +
     "â–¸ 0.10-0.20: Balanced exploration\n" +
     "â–¸ 0.20-0.40: High exploration (learning phase)"
i_ql_eps = input.float(0.12, "Exploration Rate (Îµ)", minval=0.01, maxval=0.5, step=0.01, 
     group=grp_ql, tooltip=tt_ql_eps)
string tt_ql_look = "STATE CALCULATION LOOKBACK\n\n" +
     "Period for calculating trend/vol/momentum states.\n\n" +
     "â–¸ 20-40: Faster state transitions\n" +
     "â–¸ 40-60: Balanced (recommended)\n" +
     "â–¸ 60-100: Slower, more stable states"
i_ql_look = input.int(50, "State Lookback", minval=20, maxval=200, 
     group=grp_ql, tooltip=tt_ql_look)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 3: INPUTS - CURVATURE ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_geo = "ğŸ“ CURVATURE ANALYSIS (Geometry)"
string tt_geo = "DIFFERENTIAL GEOMETRY ENGINE\n\n" +
     "Measures the curvature (Îº) of the price curve:\n" +
     "   Îº = y'' / (1 + y'Â²)^(3/2)\n\n" +
     "â–¸ LOW curvature: Price moving straight (trending)\n" +
     "â–¸ HIGH curvature: Price bending (reversal zone)\n\n" +
     "Signals fire when curvature is low AND velocity confirms direction."
i_geo_on = input.bool(true, "Enable Curvature", group=grp_geo, tooltip=tt_geo)
string tt_geo_look = "CURVATURE LOOKBACK\n\n" +
     "â–¸ TIMEFRAME GUIDE:\n" +
     "   â€¢ 1-5 min: 10-15 bars\n" +
     "   â€¢ 15-60 min: 15-25 bars\n" +
     "   â€¢ 4H-Daily: 20-35 bars\n\n" +
     "â–¸ ASSET GUIDE:\n" +
     "   â€¢ Crypto/Volatile: 12-18 bars\n" +
     "   â€¢ Forex: 18-25 bars\n" +
     "   â€¢ Stocks: 20-30 bars"
i_geo_look = input.int(20, "Lookback", minval=5, maxval=50, group=grp_geo, tooltip=tt_geo_look)
string tt_geo_smooth = "CURVATURE SMOOTHING\n\n" +
     "EMA smoothing on raw curvature.\n\n" +
     "â–¸ 1-2: Minimal (more noise)\n" +
     "â–¸ 3-5: Balanced\n" +
     "â–¸ 5-10: Heavy (more lag)"
i_geo_smooth = input.int(3, "Smoothing", minval=1, maxval=10, group=grp_geo, tooltip=tt_geo_smooth)
string tt_geo_thresh = "FLOW THRESHOLD\n\n" +
     "Z-score threshold for detecting 'flow' states.\n\n" +
     "â–¸ 0.8-1.0: Strict (fewer signals)\n" +
     "â–¸ 1.0-1.5: Balanced\n" +
     "â–¸ 1.5-2.0: Loose (more signals)"
i_geo_thresh = input.float(1.2, "Flow Threshold", minval=0.5, maxval=3.0, step=0.1, 
     group=grp_geo, tooltip=tt_geo_thresh)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 4: INPUTS - MARKET PRESSURE INDEX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_mpi = "ğŸŒŠ MARKET PRESSURE INDEX (Flow)"
string tt_mpi = "VOLUME-WEIGHTED PRESSURE ESTIMATION\n\n" +
     "Approximates order flow from OHLCV data.\n\n" +
     "â–¸ Buy Pressure = Vol Ã— (Close - Low) / Range\n" +
     "â–¸ Sell Pressure = Vol Ã— (High - Close) / Range\n" +
     "â–¸ MPI = Normalized(Buy - Sell)\n\n" +
     "Includes: Strong flow detection, liquidity sweeps, divergence."
i_mpi_on = input.bool(true, "Enable MPI", group=grp_mpi, tooltip=tt_mpi)
string tt_mpi_period = "MPI SMOOTHING PERIOD\n\n" +
     "â–¸ 1-5 min: 8-12 bars\n" +
     "â–¸ 15-60 min: 12-16 bars\n" +
     "â–¸ 4H-Daily: 14-20 bars"
i_mpi_period = input.int(14, "Period", minval=5, maxval=50, group=grp_mpi, tooltip=tt_mpi_period)
string tt_mpi_sens = "MPI SENSITIVITY\n\n" +
     "â–¸ 1.0-1.3: Less sensitive\n" +
     "â–¸ 1.3-1.7: Balanced\n" +
     "â–¸ 1.7-2.5: More sensitive"
i_mpi_sens = input.float(1.5, "Sensitivity", minval=0.5, maxval=3.0, step=0.1, 
     group=grp_mpi, tooltip=tt_mpi_sens)
string tt_mpi_ext = "EXTREME THRESHOLD\n\n" +
     "MPI level for 'extreme' readings.\n\n" +
     "â–¸ 0.5-0.6: More extreme signals\n" +
     "â–¸ 0.6-0.8: Balanced\n" +
     "â–¸ 0.8-0.9: Only very extreme"
i_mpi_extreme = input.float(0.7, "Extreme Threshold", minval=0.5, maxval=0.95, step=0.05, 
     group=grp_mpi, tooltip=tt_mpi_ext)
string tt_agg = "AGGRESSIVE ORDER THRESHOLD\n\n" +
     "Candle close position indicating aggressive orders.\n\n" +
     "â–¸ 0.70: 30% zones (more signals)\n" +
     "â–¸ 0.75-0.80: 20-25% zones (balanced)\n" +
     "â–¸ 0.85: 15% zones (strict)"
i_agg_ratio = input.float(0.75, "Aggressive Ratio", minval=0.6, maxval=0.9, step=0.05, 
     group=grp_mpi, tooltip=tt_agg)
string tt_vol_spike = "VOLUME SPIKE MULTIPLIER\n\n" +
     "Volume spike = current > average Ã— this value.\n\n" +
     "â–¸ 1.2-1.4: More spikes\n" +
     "â–¸ 1.5-1.8: Balanced\n" +
     "â–¸ 2.0+: Only major events"
i_vol_spike = input.float(1.5, "Volume Spike Multiple", minval=1.2, maxval=3.0, step=0.1, 
     group=grp_mpi, tooltip=tt_vol_spike)
string tt_div = "DIVERGENCE DETECTION\n\n" +
     "Identifies when price and MPI diverge.\n\n" +
     "â–¸ Bullish: Lower price low + higher MPI low\n" +
     "â–¸ Bearish: Higher price high + lower MPI high"
i_div_on = input.bool(true, "Enable Divergence", group=grp_mpi, tooltip=tt_div)
string tt_sweep = "LIQUIDITY SWEEP DETECTION\n\n" +
     "Identifies stop hunts / liquidity grabs.\n\n" +
     "Pattern: Price breaks swing level, quickly reverses.\n" +
     "These are high-probability reversal zones."
i_sweep_on = input.bool(true, "Enable Sweeps", group=grp_mpi, tooltip=tt_sweep)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 5: INPUTS - ADAPTIVE CHANNEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_chan = "ğŸ“Š ADAPTIVE CHANNEL"
string tt_chan = "SELF-ADJUSTING VOLATILITY BANDS\n\n" +
     "Channel expands/contracts to contain target % of price.\n\n" +
     "â–¸ Mean reversion: Trade band touches\n" +
     "â–¸ Trend following: Trade breakouts\n" +
     "â–¸ Volatility gauge: Width indicates regime"
i_chan_on = input.bool(true, "Enable Channel", group=grp_chan, tooltip=tt_chan)
string tt_chan_src = "CENTER LINE SOURCE\n\n" +
     "â–¸ Kernel: Nadaraya-Watson estimator (smooth, adaptive)\n" +
     "â–¸ ZLEMA: Zero-Lag EMA (fast response)\n" +
     "â–¸ WMA: Weighted MA (linear decay)\n" +
     "â–¸ EMA: Exponential MA (classic)"
i_chan_src = input.string("Kernel", "Center Source", 
     options=["Kernel", "ZLEMA", "WMA", "EMA"], group=grp_chan, tooltip=tt_chan_src)
string tt_chan_k = "BASE CHANNEL WIDTH (K)\n\n" +
     "Initial width in standard deviations.\n\n" +
     "â–¸ 1.5-1.8: Tighter bands\n" +
     "â–¸ 2.0: Standard\n" +
     "â–¸ 2.2-2.5: Wider bands"
i_chan_k = input.float(2.0, "Base Width (K)", minval=1.0, maxval=4.0, step=0.1, 
     group=grp_chan, tooltip=tt_chan_k)
string tt_chan_target = "TARGET CONTAINMENT %\n\n" +
     "Channel adjusts to keep this % inside.\n\n" +
     "â–¸ 0.85: Tighter (more touches)\n" +
     "â–¸ 0.90: Balanced\n" +
     "â–¸ 0.95: Wider (fewer touches)"
i_chan_target = input.float(0.90, "Target Inside %", minval=0.80, maxval=0.98, step=0.01, 
     group=grp_chan, tooltip=tt_chan_target)
string tt_chan_adapt = "ADAPTATION LENGTH\n\n" +
     "Lookback for measuring containment.\n\n" +
     "â–¸ 100-150: Faster adaptation\n" +
     "â–¸ 150-250: Balanced\n" +
     "â–¸ 250-400: Slower, more stable"
i_chan_adapt = input.int(200, "Adaptation Length", minval=50, maxval=500, 
     group=grp_chan, tooltip=tt_chan_adapt)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 6: INPUTS - KEY LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_lvl = "ğŸ¯ KEY LEVELS"
string tt_lvl = "PIVOT-BASED SUPPORT/RESISTANCE\n\n" +
     "Auto-identifies swing highs/lows as key levels.\n" +
     "Levels extend right and cleanup when old."
i_lvl_on = input.bool(true, "Enable Pivot Levels", group=grp_lvl, tooltip=tt_lvl)
string tt_piv = "PIVOT STRENGTH\n\n" +
     "Bars required on each side to confirm.\n\n" +
     "â–¸ 2-3: More levels (noisy)\n" +
     "â–¸ 4-6: Balanced\n" +
     "â–¸ 7-10: Fewer, stronger levels"
i_piv_str = input.int(5, "Pivot Strength", minval=2, maxval=20, group=grp_lvl, tooltip=tt_piv)
i_max_lvl = input.int(3, "Max Levels Each Side", minval=1, maxval=8, group=grp_lvl)
i_lvl_extend = input.int(30, "Extend Bars", minval=5, maxval=100, group=grp_lvl)
i_lvl_style = input.string("Dashed", "Line Style", options=["Solid", "Dashed", "Dotted"], group=grp_lvl)
string tt_daily = "PREVIOUS DAY HIGH/LOW\n\n" +
     "Shows the prior session's high and low levels.\n" +
     "Useful for intraday trading."
i_daily_on = input.bool(false, "Show Previous Day H/L", group=grp_lvl, tooltip=tt_daily)
string tt_fib = "AUTO FIBONACCI\n\n" +
     "Draws Fib retracements from recent swing range.\n" +
     "Key levels: 38.2%, 50%, 61.8%"
i_fib_on = input.bool(false, "Show Fibonacci", group=grp_lvl, tooltip=tt_fib)
i_fib_look = input.int(50, "Fibonacci Lookback", minval=20, maxval=200, group=grp_lvl)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 7: INPUTS - PERFORMANCE TRACKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_perf = "ğŸ“ˆ PERFORMANCE TRACKING"
string tt_perf = "HYPOTHETICAL PERFORMANCE\n\n" +
     "Tracks what would have happened if you traded every signal.\n\n" +
     "â–¸ Metrics: Win Rate, Profit Factor, Equity, MaxDD, Expectancy\n\n" +
     "âš ï¸ DISCLAIMER:\n" +
     "   â€¢ Does NOT include slippage/commissions\n" +
     "   â€¢ Past performance â‰  future results\n" +
     "   â€¢ For ANALYSIS ONLY"
i_perf_on = input.bool(true, "Track Performance", group=grp_perf, tooltip=tt_perf)
string tt_exit = "EXIT METHOD\n\n" +
     "â–¸ Opposite Signal: Exit when reverse signal fires\n" +
     "â–¸ Fixed Bars: Exit after X bars\n" +
     "â–¸ ATR Target: Exit at ATR-based target"
i_exit = input.string("Opposite Signal", "Exit Method", 
     options=["Opposite Signal", "Fixed Bars", "ATR Target"], group=grp_perf, tooltip=tt_exit)
i_exit_bars = input.int(10, "Exit After Bars", minval=1, maxval=100, group=grp_perf)
i_exit_atr = input.float(2.0, "ATR Exit Multiple", minval=0.5, maxval=5.0, step=0.5, group=grp_perf)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 8: INPUTS - SIGNAL VISUALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_sig = "ğŸ”º SIGNAL VISUALS"
i_show_sig = input.bool(true, "Show Buy/Sell Signals", group=grp_sig)
string tt_sig_size = "SIGNAL SIZE\n\n" +
     "Size of buy/sell triangles.\n" +
     "Larger = more visible, but takes more chart space."
i_sig_size = input.string("Small", "Signal Size", 
     options=["Tiny", "Small", "Normal", "Large"], group=grp_sig, tooltip=tt_sig_size)
i_col_buy = input.color(#00FF00, "Buy Color", group=grp_sig)
i_col_sell = input.color(#FF0000, "Sell Color", group=grp_sig)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 9: INPUTS - SYSTEM DOT VISUALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_dots = "â— SYSTEM DOT VISUALS"
string tt_dots = "SYSTEM INDICATOR DOTS\n\n" +
     "Shows when individual systems fire.\n" +
     "Each system has bull/bear color pair.\n" +
     "Dots appear at different vertical offsets."
i_show_dots = input.bool(true, "Show System Dots", group=grp_dots, tooltip=tt_dots)
string tt_dot_size = "DOT SIZE\n\n" +
     "Size of the system indicator dots."
i_dot_size = input.string("Small", "Dot Size", 
     options=["Tiny", "Small", "Normal", "Large"], group=grp_dots, tooltip=tt_dot_size)
i_col_ql_b = input.color(#00FFFF, "Q-Learning Bull", group=grp_dots)
i_col_ql_s = input.color(#008888, "Q-Learning Bear", group=grp_dots)
i_col_geo_b = input.color(#FFD700, "Curvature Bull", group=grp_dots)
i_col_geo_s = input.color(#AA8C00, "Curvature Bear", group=grp_dots)
i_col_mpi_b = input.color(#FF6B00, "MPI Bull", group=grp_dots)
i_col_mpi_s = input.color(#AA4700, "MPI Bear", group=grp_dots)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 10: INPUTS - CHANNEL VISUALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_chan_vis = "ğŸ“Š CHANNEL VISUALS"
i_show_chan = input.bool(true, "Show Channel Bands", group=grp_chan_vis)
string tt_spine = "CENTER SPINE LINE\n\n" +
     "The adaptive center line of the channel.\n" +
     "Color gradient shows Q-Learning bias:\n" +
     "Bull color = bullish, Bear color = bearish"
i_show_spine = input.bool(true, "Show Center Spine", group=grp_chan_vis, tooltip=tt_spine)
i_spine_width = input.int(2, "Spine Width", minval=1, maxval=5, group=grp_chan_vis)
i_show_halo = input.bool(true, "Show Flex Zones", group=grp_chan_vis)
i_col_spine_b = input.color(#00FFAA, "Spine Bull Color", group=grp_chan_vis)
i_col_spine_s = input.color(#FF0080, "Spine Bear Color", group=grp_chan_vis)
i_col_upper = input.color(#FF0080, "Upper Band Color", group=grp_chan_vis)
i_col_lower = input.color(#00FFAA, "Lower Band Color", group=grp_chan_vis)
i_chan_trans = input.int(50, "Band Transparency", minval=0, maxval=90, group=grp_chan_vis)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 11: INPUTS - BACKGROUND VISUALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_bg = "ğŸ¨ BACKGROUND VISUALS"
string tt_bg = "CURVATURE BACKGROUND\n\n" +
     "Colors chart background based on curvature state.\n" +
     "Flow color = low curvature (trending)\n" +
     "Turn color = high curvature (reversing)"
i_show_bg = input.bool(true, "Show Curvature Background", group=grp_bg, tooltip=tt_bg)
i_bg_trans = input.int(95, "Background Transparency", minval=85, maxval=99, group=grp_bg)
i_col_bg_flow = input.color(#00FFAA, "Flow Background", group=grp_bg)
i_col_bg_turn = input.color(#FF0080, "Turn Background", group=grp_bg)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 12: INPUTS - LEVEL VISUALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_lvl_vis = "ğŸ¯ LEVEL VISUALS"
i_col_res = input.color(#FF5555, "Resistance Color", group=grp_lvl_vis)
i_col_sup = input.color(#55FF55, "Support Color", group=grp_lvl_vis)
i_col_daily = input.color(#FFFF00, "Daily H/L Color", group=grp_lvl_vis)
i_col_fib = input.color(#888888, "Fibonacci Color", group=grp_lvl_vis)
i_col_fib_key = input.color(#FFD700, "Fib Key Levels (50/61.8)", group=grp_lvl_vis)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 13: INPUTS - VECTOR FIELD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_vec = "ğŸ§­ VECTOR FIELD"
string tt_vec = "MOMENTUM VECTOR ARROWS\n\n" +
     "Visual representation of price momentum.\n" +
     "Arrows point in direction of movement.\n" +
     "Color indicates curvature state."
i_show_vec = input.bool(false, "Show Vector Field", group=grp_vec, tooltip=tt_vec)
i_vec_count = input.int(15, "Vector Count", minval=5, maxval=30, group=grp_vec)
i_vec_spacing = input.int(3, "Vector Spacing", minval=2, maxval=10, group=grp_vec)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 14: INPUTS - DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_dash = "ğŸ“‹ DASHBOARD"
i_dash_on = input.bool(true, "Show Dashboard", group=grp_dash)
i_dash_pos = input.string("Top Right", "Position", 
     options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=grp_dash)
i_dash_size = input.string("Small", "Size", options=["Tiny", "Small", "Normal"], group=grp_dash)
i_show_perf_dash = input.bool(true, "Show Performance Stats", group=grp_dash)
i_show_ql_dash = input.bool(true, "Show Q-Learning Stats", group=grp_dash)
i_show_mpi_dash = input.bool(true, "Show MPI Stats", group=grp_dash)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 15: UTILITY FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_tanh(float x) =>
    float cx = math.max(-10, math.min(10, x))
    (math.exp(2 * cx) - 1) / (math.exp(2 * cx) + 1)
f_kernel(float src, float bw) =>
    int l1 = math.max(2, math.round(bw))
    int l2 = math.max(2, math.round(bw * 0.7))
    int l3 = math.max(2, math.round(bw * 0.5))
    float e1 = ta.ema(src, l1)
    float e2 = ta.ema(e1, l2)
    float e3 = ta.ema(e2, l3)
    e1 * 0.5 + e2 * 0.3 + e3 * 0.2
f_zlema(float src, int len) =>
    int lag = math.floor((len - 1) / 2)
    float z = src + (src - nz(src[lag], src))
    ta.ema(z, len)
f_fmt(float v, int d) => str.tostring(v, "#." + str.repeat("#", d))
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 16: CORE CALCULATIONS - ATR & VOLATILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float atr = ta.atr(14)
float avg_vol = ta.sma(volume, 20)
bool vol_spike = volume > avg_vol * i_vol_spike
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 17: Q-LEARNING ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float ema_f = ta.ema(close, 8)
float ema_s = ta.ema(close, 21)
float tr_diff = (ema_f - ema_s) / atr
int tr_st = tr_diff < -0.5 ? 0 : tr_diff > 0.5 ? 2 : 1
float vol_now = ta.stdev(close, 20)
float vol_avg = ta.sma(vol_now, 50)
float vol_rat = nz(vol_now / vol_avg, 1)
int vol_st = vol_rat < 0.7 ? 0 : vol_rat > 1.3 ? 2 : 1
float rsi = ta.rsi(close, 14)
int mom_st = rsi < 35 ? 0 : rsi > 65 ? 2 : 1
int state = tr_st * 9 + vol_st * 3 + mom_st
var matrix<float> Q = matrix.new<float>(27, 3, 0.0)
var int prev_st = 0
var int prev_act = 2
var float prev_px = na
var int sel_act = 2
float px_chg = nz((close - prev_px) / prev_px * 100, 0)
float rew = prev_act == 0 ? px_chg * 10 : prev_act == 1 ? -px_chg * 10 : -math.abs(px_chg) * 0.5
float pseudo_rand = math.abs(close * volume) % 1000 / 1000
if i_ql_on and barstate.isconfirmed and bar_index > i_ql_look
    float ql = matrix.get(Q, state, 0)
    float qs = matrix.get(Q, state, 1)
    float qh = matrix.get(Q, state, 2)
    bool should_explore = pseudo_rand < i_ql_eps
    if should_explore
        float action_seed = (close + high + low) % 3
        sel_act := action_seed < 1 ? 0 : action_seed < 2 ? 1 : 2
    else
        sel_act := ql >= qs and ql >= qh ? 0 : qs >= ql and qs >= qh ? 1 : 2
    if not na(prev_px)
        float old_q = matrix.get(Q, prev_st, prev_act)
        float max_nxt = math.max(ql, math.max(qs, qh))
        float new_q = old_q + i_ql_lr * (rew + i_ql_gamma * max_nxt - old_q)
        matrix.set(Q, prev_st, prev_act, math.max(-100, math.min(100, new_q)))
    prev_st := state
    prev_act := sel_act
    prev_px := close
float ql_v = matrix.get(Q, state, 0)
float qs_v = matrix.get(Q, state, 1)
float qh_v = matrix.get(Q, state, 2)
float ql_conf = f_tanh((ql_v - qs_v) / 10)
bool ql_bull = i_ql_on and sel_act == 0 and nz(sel_act[1]) != 0
bool ql_bear = i_ql_on and sel_act == 1 and nz(sel_act[1]) != 1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 18: CURVATURE ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float dy = (close - close[2]) / 2
float d2y = close - 2 * close[1] + close[2]
float met = math.pow(1 + math.pow(dy / atr, 2), 1.5)
float curv_raw = (d2y / atr) / (met + 0.0001)
float curv = ta.ema(curv_raw, i_geo_smooth)
float curv_m = ta.sma(curv, i_geo_look * 2)
float curv_s = ta.stdev(curv, i_geo_look * 2)
float curv_z = nz((curv - curv_m) / (curv_s + 0.0001))
bool is_flow = math.abs(curv_z) < i_geo_thresh
bool is_turn = math.abs(curv_z) > 1.8
bool vel_up = dy > atr * 0.15
bool vel_dn = dy < -atr * 0.15
bool geo_bull = i_geo_on and is_flow and vel_up
bool geo_bear = i_geo_on and is_flow and vel_dn
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 19: MARKET PRESSURE INDEX ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float rng = high - low
float buy_p = rng > 0 ? volume * (close - low) / rng : 0
float sell_p = rng > 0 ? volume * (high - close) / rng : 0
float net_p = buy_p - sell_p
float smooth_p = ta.ema(net_p, i_mpi_period)
float avg_abs = ta.sma(math.abs(net_p), i_mpi_period * 2)
float MPI = math.max(-1, math.min(1, (avg_abs > 0 ? smooth_p / avg_abs : 0) * i_mpi_sens))
float cl_pos = rng > 0 ? (close - low) / rng : 0.5
float agg_b = cl_pos > i_agg_ratio ? volume : 0
float agg_s = cl_pos < (1 - i_agg_ratio) ? volume : 0
float flow_imb = ta.ema(agg_b, 5) - ta.ema(agg_s, 5)
float avg_imb = ta.sma(math.abs(flow_imb), 20)
bool str_buy = flow_imb > avg_imb * 1.5
bool str_sell = flow_imb < -avg_imb * 1.5
bool mpi_overbought = MPI > i_mpi_extreme
bool mpi_oversold = MPI < -i_mpi_extreme
float piv_hi = ta.pivothigh(high, i_piv_str, i_piv_str)
float piv_lo = ta.pivotlow(low, i_piv_str, i_piv_str)
var float sw_hi = na
var float sw_lo = na
var int sw_hi_bar = na
var int sw_lo_bar = na
if not na(piv_hi)
    sw_hi := piv_hi
    sw_hi_bar := bar_index - i_piv_str
if not na(piv_lo)
    sw_lo := piv_lo
    sw_lo_bar := bar_index - i_piv_str
float sw_tol = atr * 0.3
bool fresh_hi = not na(sw_hi_bar) and (bar_index - sw_hi_bar) < 100
bool fresh_lo = not na(sw_lo_bar) and (bar_index - sw_lo_bar) < 100
bool sweep_hi = i_sweep_on and fresh_hi and high > sw_hi and high < sw_hi + sw_tol and close < sw_hi
bool sweep_lo = i_sweep_on and fresh_lo and low < sw_lo and low > sw_lo - sw_tol and close > sw_lo
var float ph1 = na, var float ph2 = na, var float pl1 = na, var float pl2 = na
var float mh1 = na, var float mh2 = na, var float ml1 = na, var float ml2 = na
var int bh1 = na, var int bh2 = na, var int bl1 = na, var int bl2 = na
float cp_hi = ta.pivothigh(close, i_piv_str, i_piv_str)
float cp_lo = ta.pivotlow(close, i_piv_str, i_piv_str)
if not na(cp_hi)
    ph2 := ph1, mh2 := mh1, bh2 := bh1
    ph1 := cp_hi, mh1 := MPI[i_piv_str], bh1 := bar_index - i_piv_str
if not na(cp_lo)
    pl2 := pl1, ml2 := ml1, bl2 := bl1
    pl1 := cp_lo, ml1 := MPI[i_piv_str], bl1 := bar_index - i_piv_str
bool bear_div = i_div_on and not na(ph1) and not na(ph2) and not na(bh1) and not na(bh2) and 
               (bar_index - bh1) < 50 and (bh1 - bh2) < 50 and ph1 > ph2 and mh1 < mh2 - 0.1
bool bull_div = i_div_on and not na(pl1) and not na(pl2) and not na(bl1) and not na(bl2) and 
               (bar_index - bl1) < 50 and (bl1 - bl2) < 50 and pl1 < pl2 and ml1 > ml2 + 0.1
bool mpi_bull = i_mpi_on and (str_buy or sweep_lo or bull_div)
bool mpi_bear = i_mpi_on and (str_sell or sweep_hi or bear_div)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 20: ADAPTIVE CHANNEL ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float center = switch i_chan_src
    "Kernel" => f_kernel(close, 8)
    "ZLEMA" => f_zlema(close, 50)
    "WMA" => ta.wma(close, 50)
    "EMA" => ta.ema(close, 50)
    => f_kernel(close, 8)
float dev = ta.ema(math.abs(close - center), 20) * (1 + math.abs(MPI) * 0.15)
var float k = 2.0
bool is_outside = math.abs(close - center) > (dev * k)
float out_pct = ta.sma(is_outside ? 1.0 : 0.0, i_chan_adapt)
if bar_index > i_chan_adapt and i_chan_on
    float err = i_chan_target - (1.0 - nz(out_pct))
    k := math.max(1.0, math.min(4.0, k + 0.02 * err))
float upper = center + dev * k
float lower = center - dev * k
float flex = dev * 0.15
float upper_f = upper - flex
float lower_f = lower + flex
bool near_up = high >= upper - flex
bool near_lo = low <= lower + flex
bool chan_bull = i_chan_on and near_lo and close > open
bool chan_bear = i_chan_on and near_up and close < open
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 21: CONSENSUS ENGINE WITH CONFLICT RESOLUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool ql_act_b = i_ql_on and ta.barssince(ql_bull) <= i_align
bool ql_act_s = i_ql_on and ta.barssince(ql_bear) <= i_align
bool geo_act_b = i_geo_on and ta.barssince(geo_bull) <= i_align
bool geo_act_s = i_geo_on and ta.barssince(geo_bear) <= i_align
bool mpi_act_b = i_mpi_on and ta.barssince(mpi_bull) <= i_align
bool mpi_act_s = i_mpi_on and ta.barssince(mpi_bear) <= i_align
int bull_sc = (ql_act_b ? 1 : 0) + (geo_act_b ? 1 : 0) + (mpi_act_b ? 1 : 0)
int bear_sc = (ql_act_s ? 1 : 0) + (geo_act_s ? 1 : 0) + (mpi_act_s ? 1 : 0)
int req = i_mode == "Loose (1/3)" ? 1 : i_mode == "Moderate (2/3)" ? 2 : 3
bool raw_bull = bull_sc >= req
bool raw_bear = bear_sc >= req
bool final_bull = false
bool final_bear = false
if raw_bull and raw_bear
    if i_conflict == "Higher Score"
        final_bull := bull_sc > bear_sc
        final_bear := bear_sc > bull_sc
    else if i_conflict == "Bullish Priority"
        final_bull := true
        final_bear := false
    else if i_conflict == "Bearish Priority"
        final_bull := false
        final_bear := true
    else 
        final_bull := false
        final_bear := false
else
    final_bull := raw_bull
    final_bear := raw_bear
var int last_bar = -9999
bool cd_ok = (bar_index - last_bar) >= i_cooldown
bool sig_long = final_bull and cd_ok and barstate.isconfirmed
bool sig_short = final_bear and cd_ok and barstate.isconfirmed
if sig_long or sig_short
    last_bar := bar_index
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 22: PERFORMANCE TRACKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var int trades = 0
var int wins = 0
var int losses = 0
var float gp = 0.0
var float gl = 0.0
var float eq = 0.0
var float peak = 0.0
var float dd = 0.0
var int pos_dir = 0
var float ent = na
var int ent_bar = 0
if i_perf_on and barstate.isconfirmed
    bool should_exit = false
    if pos_dir == 1
        should_exit := (i_exit == "Opposite Signal" and sig_short) or 
                       (i_exit == "Fixed Bars" and bar_index - ent_bar >= i_exit_bars) or
                       (i_exit == "ATR Target" and (close >= ent + atr * i_exit_atr or close <= ent - atr * i_exit_atr))
    else if pos_dir == -1
        should_exit := (i_exit == "Opposite Signal" and sig_long) or 
                       (i_exit == "Fixed Bars" and bar_index - ent_bar >= i_exit_bars) or
                       (i_exit == "ATR Target" and (close <= ent - atr * i_exit_atr or close >= ent + atr * i_exit_atr)) 
    if should_exit and pos_dir != 0
        float pnl = pos_dir == 1 ? (close - ent) / ent * 100 : (ent - close) / ent * 100
        trades += 1
        eq += pnl
        if pnl > 0
            wins += 1
            gp += pnl
        else
            losses += 1
            gl += math.abs(pnl)
        peak := math.max(peak, eq)
        dd := math.max(dd, peak - eq)
        pos_dir := 0
        ent := na
    if pos_dir == 0
        if sig_long
            pos_dir := 1
            ent := close
            ent_bar := bar_index
        else if sig_short
            pos_dir := -1
            ent := close
            ent_bar := bar_index
float wr = trades > 0 ? wins / trades * 100 : 0
float pf = gl > 0 ? gp / gl : gp > 0 ? 999 : 0
float exp_val = trades > 0 ? eq / trades : 0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 23: KEY LEVELS DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var float[] res_arr = array.new_float(0)
var float[] sup_arr = array.new_float(0)
var int[] res_bar = array.new_int(0)
var int[] sup_bar = array.new_int(0)
if i_lvl_on and not na(piv_hi)
    if array.size(res_arr) >= i_max_lvl
        array.pop(res_arr)
        array.pop(res_bar)
    array.unshift(res_arr, piv_hi)
    array.unshift(res_bar, bar_index - i_piv_str)
if i_lvl_on and not na(piv_lo)
    if array.size(sup_arr) >= i_max_lvl
        array.pop(sup_arr)
        array.pop(sup_bar)
    array.unshift(sup_arr, piv_lo)
    array.unshift(sup_bar, bar_index - i_piv_str)
float daily_h = request.security(syminfo.tickerid, "D", high[1], barmerge.gaps_off, barmerge.lookahead_on)
float daily_l = request.security(syminfo.tickerid, "D", low[1], barmerge.gaps_off, barmerge.lookahead_on)
float fib_h = ta.highest(high, i_fib_look)
float fib_l = ta.lowest(low, i_fib_look)
float fib_rng = fib_h - fib_l
bool fib_up = close > (fib_h + fib_l) / 2
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 24: VISUALS - BACKGROUND
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
color geo_bg = na
if i_geo_on and i_show_bg
    if is_turn
        geo_bg := color.new(i_col_bg_turn, i_bg_trans)
    else if is_flow
        geo_bg := color.new(i_col_bg_flow, i_bg_trans)
bgcolor(geo_bg, title="Curvature BG")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 25: VISUALS - CHANNEL & SPINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
color spine_col = color.from_gradient(ql_conf, -0.6, 0.6, i_col_spine_s, i_col_spine_b)
p_upper = plot(i_chan_on and i_show_chan ? upper : na, "Upper Band", 
     color=color.new(i_col_upper, i_chan_trans), linewidth=1)
p_lower = plot(i_chan_on and i_show_chan ? lower : na, "Lower Band", 
     color=color.new(i_col_lower, i_chan_trans), linewidth=1)
plot(i_chan_on and i_show_spine ? center : na, "Center Spine", 
     color=spine_col, linewidth=i_spine_width)
p_uf = plot(i_chan_on and i_show_chan and i_show_halo ? upper_f : na, "Upper Flex", 
     color=color.new(i_col_upper, i_chan_trans + 30), linewidth=1)
p_lf = plot(i_chan_on and i_show_chan and i_show_halo ? lower_f : na, "Lower Flex", 
     color=color.new(i_col_lower, i_chan_trans + 30), linewidth=1)
fill(p_upper, p_uf, color=color.new(i_col_upper, 90), title="Upper Zone")
fill(p_lower, p_lf, color=color.new(i_col_lower, 90), title="Lower Zone")
fill(p_uf, p_lf, color=color.new(ql_conf > 0.2 ? i_col_spine_b : ql_conf < -0.2 ? i_col_spine_s : color.gray, 95), title="Center Zone")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 26: VISUALS - SYSTEM DOTS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if i_show_dots and ql_bull
    label.new(bar_index, low - atr * 0.25, ".", 
         color=color.new(color.black, 100), textcolor=i_col_ql_b, 
         style=label.style_label_up, 
         size=i_dot_size == "Tiny" ? size.tiny : i_dot_size == "Small" ? size.small : 
              i_dot_size == "Normal" ? size.normal : size.large)
if i_show_dots and ql_bear
    label.new(bar_index, high + atr * 0.25, ".", 
         color=color.new(color.black, 100), textcolor=i_col_ql_s, 
         style=label.style_label_down, 
         size=i_dot_size == "Tiny" ? size.tiny : i_dot_size == "Small" ? size.small : 
              i_dot_size == "Normal" ? size.normal : size.large)
if i_show_dots and geo_bull
    label.new(bar_index, low - atr * 0.45, ".", 
         color=color.new(color.black, 100), textcolor=i_col_geo_b, 
         style=label.style_label_up, 
         size=i_dot_size == "Tiny" ? size.tiny : i_dot_size == "Small" ? size.small : 
              i_dot_size == "Normal" ? size.normal : size.large)
if i_show_dots and geo_bear
    label.new(bar_index, high + atr * 0.45, ".", 
         color=color.new(color.black, 100), textcolor=i_col_geo_s, 
         style=label.style_label_down, 
         size=i_dot_size == "Tiny" ? size.tiny : i_dot_size == "Small" ? size.small : 
              i_dot_size == "Normal" ? size.normal : size.large)
if i_show_dots and mpi_bull
    label.new(bar_index, low - atr * 0.65, ".", 
         color=color.new(color.black, 100), textcolor=i_col_mpi_b, 
         style=label.style_label_up, 
         size=i_dot_size == "Tiny" ? size.tiny : i_dot_size == "Small" ? size.small : 
              i_dot_size == "Normal" ? size.normal : size.large)
if i_show_dots and mpi_bear
    label.new(bar_index, high + atr * 0.65, ".", 
         color=color.new(color.black, 100), textcolor=i_col_mpi_s, 
         style=label.style_label_down, 
         size=i_dot_size == "Tiny" ? size.tiny : i_dot_size == "Small" ? size.small : 
              i_dot_size == "Normal" ? size.normal : size.large)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 27: VISUALS - BUY/SELL SIGNALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool sz_tiny = i_sig_size == "Tiny"
bool sz_small = i_sig_size == "Small"
bool sz_norm = i_sig_size == "Normal"
bool sz_large = i_sig_size == "Large"
plotshape(i_show_sig and sig_long and sz_tiny, "Buy Tiny", shape.triangleup, 
     location.belowbar, i_col_buy, size=size.tiny)
plotshape(i_show_sig and sig_long and sz_small, "Buy Small", shape.triangleup, 
     location.belowbar, i_col_buy, size=size.small)
plotshape(i_show_sig and sig_long and sz_norm, "Buy Normal", shape.triangleup, 
     location.belowbar, i_col_buy, size=size.normal)
plotshape(i_show_sig and sig_long and sz_large, "Buy Large", shape.triangleup, 
     location.belowbar, i_col_buy, size=size.large)
plotshape(i_show_sig and sig_short and sz_tiny, "Sell Tiny", shape.triangledown, 
     location.abovebar, i_col_sell, size=size.tiny)
plotshape(i_show_sig and sig_short and sz_small, "Sell Small", shape.triangledown, 
     location.abovebar, i_col_sell, size=size.small)
plotshape(i_show_sig and sig_short and sz_norm, "Sell Normal", shape.triangledown, 
     location.abovebar, i_col_sell, size=size.normal)
plotshape(i_show_sig and sig_short and sz_large, "Sell Large", shape.triangledown, 
     location.abovebar, i_col_sell, size=size.large)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 28: VISUALS - KEY LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var line[] res_lns = array.new_line(0)
var line[] sup_lns = array.new_line(0)
var label[] res_lbs = array.new_label(0)
var label[] sup_lbs = array.new_label(0)
var line daily_h_ln = na
var line daily_l_ln = na
var label daily_h_lb = na
var label daily_l_lb = na
var line[] fib_lns = array.new_line(0)
var label[] fib_lbs = array.new_label(0)
ln_style = switch i_lvl_style
    "Solid" => line.style_solid
    "Dashed" => line.style_dashed
    "Dotted" => line.style_dotted
    => line.style_dashed
if barstate.islast
    for l in res_lns
        line.delete(l)
    array.clear(res_lns)
    for l in sup_lns
        line.delete(l)
    array.clear(sup_lns)
    for l in res_lbs
        label.delete(l)
    array.clear(res_lbs)
    for l in sup_lbs
        label.delete(l)
    array.clear(sup_lbs)
    if i_lvl_on
        for i = 0 to math.min(array.size(res_arr) - 1, i_max_lvl - 1)
            float lv = array.get(res_arr, i)
            int ob = array.get(res_bar, i)
            if lv > close * 0.97 and lv < close * 1.08
                array.push(res_lns, line.new(ob, lv, bar_index + i_lvl_extend, lv, 
                     color=color.new(i_col_res, 50), style=ln_style, width=1))
                array.push(res_lbs, label.new(bar_index + i_lvl_extend + 2, lv, f_fmt(lv, 2), 
                     color=color.new(color.black, 100), textcolor=i_col_res, 
                     style=label.style_label_left, size=size.tiny))
        for i = 0 to math.min(array.size(sup_arr) - 1, i_max_lvl - 1)
            float lv = array.get(sup_arr, i)
            int ob = array.get(sup_bar, i)
            if lv < close * 1.03 and lv > close * 0.92
                array.push(sup_lns, line.new(ob, lv, bar_index + i_lvl_extend, lv, 
                     color=color.new(i_col_sup, 50), style=ln_style, width=1))
                array.push(sup_lbs, label.new(bar_index + i_lvl_extend + 2, lv, f_fmt(lv, 2), 
                     color=color.new(color.black, 100), textcolor=i_col_sup, 
                     style=label.style_label_left, size=size.tiny))
    line.delete(daily_h_ln)
    line.delete(daily_l_ln)
    label.delete(daily_h_lb)
    label.delete(daily_l_lb)
    if i_daily_on and not na(daily_h) and not na(daily_l)
        daily_h_ln := line.new(bar_index - 50, daily_h, bar_index + 15, daily_h, 
             color=color.new(i_col_daily, 50), style=line.style_dotted, width=1)
        daily_l_ln := line.new(bar_index - 50, daily_l, bar_index + 15, daily_l, 
             color=color.new(i_col_daily, 50), style=line.style_dotted, width=1)
        daily_h_lb := label.new(bar_index + 17, daily_h, "PDH", 
             color=color.new(color.black, 100), textcolor=i_col_daily, 
             style=label.style_label_left, size=size.tiny)
        daily_l_lb := label.new(bar_index + 17, daily_l, "PDL", 
             color=color.new(color.black, 100), textcolor=i_col_daily, 
             style=label.style_label_left, size=size.tiny)
    for l in fib_lns
        line.delete(l)
    array.clear(fib_lns)
    for l in fib_lbs
        label.delete(l)
    array.clear(fib_lbs)
    if i_fib_on and fib_rng > 0
        float[] ratios = array.from(0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0)
        string[] names = array.from("0%", "23.6%", "38.2%", "50%", "61.8%", "78.6%", "100%")
        for i = 0 to 6
            float r = array.get(ratios, i)
            float lv = fib_up ? fib_h - fib_rng * r : fib_l + fib_rng * r
            bool is_key = r == 0.5 or r == 0.618
            color fc = is_key ? color.new(i_col_fib_key, 50) : color.new(i_col_fib, 60)
            array.push(fib_lns, line.new(bar_index - i_fib_look, lv, bar_index + 20, lv, 
                 color=fc, style=line.style_dotted, width=is_key ? 2 : 1))
            array.push(fib_lbs, label.new(bar_index + 22, lv, array.get(names, i), 
                 color=color.new(color.black, 100), textcolor=fc, 
                 style=label.style_label_left, size=size.tiny))
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 29: VISUALS - VECTOR FIELD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var line[] vec_lns = array.new_line(0)
if i_show_vec and barstate.islast
    for l in vec_lns
        line.delete(l)
    array.clear(vec_lns)
    for i = i_vec_spacing to (i_vec_count * i_vec_spacing) by i_vec_spacing
        if bar_index > i + 1
            float sl = close[i] - close[i+1]
            if math.abs(sl) > atr * 0.03
                float y_st = close[i]
                float y_en = y_st + sl * 2
                color vc = math.abs(nz(curv_z[i])) > 1.5 ? i_col_spine_s : i_col_spine_b
                array.push(vec_lns, line.new(bar_index - i, y_st, bar_index - i + 2, y_en, 
                     color=color.new(vc, 50), style=line.style_arrow_right, width=1))
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 30: DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table dash = na
f_pos(string p) =>
    p == "Top Right" ? position.top_right : p == "Top Left" ? position.top_left : p == "Bottom Right" ? position.bottom_right : position.bottom_left
if i_dash_on and barstate.islast
    if not na(dash)
        table.delete(dash) 
    txt_sz = i_dash_size == "Tiny" ? size.tiny : i_dash_size == "Small" ? size.small : size.normal
    int cols = 4
    int rows = 18
    dash := table.new(f_pos(i_dash_pos), cols, rows, 
         bgcolor=color.new(#0a0a0a, 5), 
         border_width=1, 
         border_color=color.new(color.gray, 80),
         frame_width=2,
         frame_color=color.new(i_col_ql_b, 70))
    color hdr = color.new(i_col_ql_b, 75)
    color sec = color.new(#1a1a1a, 40)
    color cell = color.new(#0f0f0f, 30)
    int r = 0
    table.merge_cells(dash, 0, r, cols-1, r)
    table.cell(dash, 0, r, "ğŸ“Š MFC Dashboard - DAFE", bgcolor=hdr, text_color=color.white, 
         text_size=txt_sz, text_halign=text.align_center)
    r += 1
    table.merge_cells(dash, 0, r, cols-1, r)
    table.cell(dash, 0, r, "â”€â”€â”€ Market State â”€â”€â”€", bgcolor=sec, text_color=i_col_ql_b, 
         text_size=size.tiny, text_halign=text.align_center)
    r += 1
    string tr_txt = tr_st == 0 ? "â–¼ Down" : tr_st == 2 ? "â–² Up" : "â—† Range"
    color tr_col = tr_st == 0 ? i_col_sell : tr_st == 2 ? i_col_buy : color.gray
    table.cell(dash, 0, r, "Trend", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    table.cell(dash, 1, r, tr_txt, bgcolor=color.new(tr_col, 85), text_color=tr_col, text_size=txt_sz)
    table.cell(dash, 2, r, "Vol", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    string vol_txt = vol_st == 0 ? "Low" : vol_st == 2 ? "High" : "Normal"
    table.cell(dash, 3, r, vol_txt, bgcolor=cell, text_color=color.white, text_size=txt_sz)
    r += 1
    string cv_txt = is_turn ? "Turning" : is_flow ? "Flowing" : "Mixed"
    color cv_col = is_turn ? i_col_sell : is_flow ? i_col_buy : color.gray
    table.cell(dash, 0, r, "Curve", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    table.cell(dash, 1, r, cv_txt, bgcolor=color.new(cv_col, 85), text_color=cv_col, text_size=txt_sz)
    table.cell(dash, 2, r, "RSI", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    color rsi_col = rsi > 70 ? i_col_sell : rsi < 30 ? i_col_buy : color.gray
    table.cell(dash, 3, r, f_fmt(rsi, 0), bgcolor=color.new(rsi_col, 85), text_color=rsi_col, text_size=txt_sz)
    r += 1
    if i_show_mpi_dash
        table.merge_cells(dash, 0, r, cols-1, r)
        table.cell(dash, 0, r, "â”€â”€â”€ Market Pressure â”€â”€â”€", bgcolor=sec, text_color=i_col_mpi_b, 
             text_size=size.tiny, text_halign=text.align_center)
        r += 1
        color mpi_col = MPI > 0.3 ? i_col_buy : MPI < -0.3 ? i_col_sell : color.gray
        string flow_txt = str_buy ? "Strong Buy" : str_sell ? "Strong Sell" : "Neutral"
        color flow_col = str_buy ? i_col_buy : str_sell ? i_col_sell : color.gray
        table.cell(dash, 0, r, "MPI", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 1, r, f_fmt(MPI * 100, 0) + "%", bgcolor=color.new(mpi_col, 85), 
             text_color=mpi_col, text_size=txt_sz)
        table.cell(dash, 2, r, "Flow", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 3, r, flow_txt, bgcolor=color.new(flow_col, 85), text_color=flow_col, text_size=txt_sz)
        r += 1
    table.merge_cells(dash, 0, r, cols-1, r)
    table.cell(dash, 0, r, "â”€â”€â”€ Consensus â”€â”€â”€", bgcolor=sec, text_color=i_col_ql_b, 
         text_size=size.tiny, text_halign=text.align_center)
    r += 1
    table.cell(dash, 0, r, "Bull", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    table.cell(dash, 1, r, str.tostring(bull_sc) + "/3", 
         bgcolor=color.new(i_col_buy, 90 - bull_sc * 15), text_color=i_col_buy, text_size=txt_sz)
    table.cell(dash, 2, r, "Bear", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    table.cell(dash, 3, r, str.tostring(bear_sc) + "/3", 
         bgcolor=color.new(i_col_sell, 90 - bear_sc * 15), text_color=i_col_sell, text_size=txt_sz)
    r += 1
    int bars_left = math.max(0, i_cooldown - (bar_index - last_bar))
    string cd_txt = cd_ok ? "âœ“ Ready" : str.tostring(bars_left) + " bars"
    color cd_col = cd_ok ? i_col_buy : color.orange
    table.merge_cells(dash, 0, r, 1, r)
    table.cell(dash, 0, r, "Cooldown", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    table.merge_cells(dash, 2, r, 3, r)
    table.cell(dash, 2, r, cd_txt, bgcolor=color.new(cd_col, 85), text_color=cd_col, 
         text_size=txt_sz, text_halign=text.align_center)
    r += 1
    string ch_st = k > i_chan_k * 1.1 ? "Expanding" : k < i_chan_k * 0.9 ? "Squeezing" : "Normal"
    color ch_col = k > i_chan_k * 1.1 ? i_col_mpi_b : k < i_chan_k * 0.9 ? i_col_ql_b : color.gray
    table.merge_cells(dash, 0, r, 1, r)
    table.cell(dash, 0, r, "Channel", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
    table.merge_cells(dash, 2, r, 3, r)
    table.cell(dash, 2, r, ch_st + " (" + f_fmt(k, 2) + "Ïƒ)", bgcolor=color.new(ch_col, 85), 
         text_color=ch_col, text_size=txt_sz, text_halign=text.align_center)
    r += 1
    if i_show_ql_dash
        table.merge_cells(dash, 0, r, cols-1, r)
        table.cell(dash, 0, r, "â”€â”€â”€ Q-Learning â”€â”€â”€", bgcolor=sec, text_color=i_col_ql_b, 
             text_size=size.tiny, text_halign=text.align_center)
        r += 1
        string act_txt = sel_act == 0 ? "LONG" : sel_act == 1 ? "SHORT" : "HOLD"
        color act_col = sel_act == 0 ? i_col_buy : sel_act == 1 ? i_col_sell : color.gray
        table.cell(dash, 0, r, "Action", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 1, r, act_txt, bgcolor=color.new(act_col, 80), text_color=act_col, text_size=txt_sz)
        table.cell(dash, 2, r, "Conf", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        color conf_col = ql_conf > 0.3 ? i_col_buy : ql_conf < -0.3 ? i_col_sell : color.gray
        table.cell(dash, 3, r, f_fmt(ql_conf * 100, 0) + "%", bgcolor=color.new(conf_col, 85), 
             text_color=conf_col, text_size=txt_sz)
        r += 1
        table.cell(dash, 0, r, "Q(L)", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 1, r, f_fmt(ql_v, 1), bgcolor=cell, text_color=i_col_buy, text_size=txt_sz)
        table.cell(dash, 2, r, "Q(S)", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 3, r, f_fmt(qs_v, 1), bgcolor=cell, text_color=i_col_sell, text_size=txt_sz)
        r += 1
    if i_show_perf_dash
        table.merge_cells(dash, 0, r, cols-1, r)
        table.cell(dash, 0, r, "â”€â”€â”€ Performance â”€â”€â”€", bgcolor=sec, text_color=i_col_geo_b, 
             text_size=size.tiny, text_halign=text.align_center)
        r += 1
        color wr_col = wr >= 50 ? i_col_buy : wr >= 40 ? color.gray : i_col_sell
        color pf_col = pf >= 1.5 ? i_col_buy : pf >= 1.0 ? color.gray : i_col_sell
        table.cell(dash, 0, r, "Trades", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 1, r, str.tostring(trades), bgcolor=cell, text_color=color.white, text_size=txt_sz)
        table.cell(dash, 2, r, "Win%", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 3, r, f_fmt(wr, 1) + "%", bgcolor=color.new(wr_col, 85), 
             text_color=wr_col, text_size=txt_sz)
        r += 1
        color eq_col = eq >= 0 ? i_col_buy : i_col_sell
        table.cell(dash, 0, r, "PF", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 1, r, f_fmt(pf, 2), bgcolor=color.new(pf_col, 85), text_color=pf_col, text_size=txt_sz)
        table.cell(dash, 2, r, "Equity", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 3, r, f_fmt(eq, 2) + "%", bgcolor=color.new(eq_col, 85), 
             text_color=eq_col, text_size=txt_sz)
        r += 1
        table.cell(dash, 0, r, "MaxDD", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        table.cell(dash, 1, r, f_fmt(dd, 2) + "%", bgcolor=color.new(i_col_sell, 90), 
             text_color=i_col_sell, text_size=txt_sz)
        table.cell(dash, 2, r, "Expect", bgcolor=cell, text_color=color.gray, text_size=txt_sz)
        color exp_col = exp_val > 0 ? i_col_buy : exp_val < 0 ? i_col_sell : color.gray
        table.cell(dash, 3, r, f_fmt(exp_val, 3) + "%", bgcolor=color.new(exp_col, 85), 
             text_color=exp_col, text_size=txt_sz)
        r += 1
    table.merge_cells(dash, 0, r, cols-1, r)
    string st = sig_long ? "â–² BUY SIGNAL" : sig_short ? "â–¼ SELL SIGNAL" : pos_dir == 1 ? "â— Long Position" : pos_dir == -1 ? "â— Short Position" : "â—‹ Scanning..."
    color st_col = sig_long ? i_col_buy : sig_short ? i_col_sell : 
                   pos_dir == 1 ? color.new(i_col_buy, 50) : pos_dir == -1 ? color.new(i_col_sell, 50) : color.gray
    table.cell(dash, 0, r, st, bgcolor=sig_long or sig_short ? color.new(st_col, 70) : cell, text_color=st_col, text_size=txt_sz, text_halign=text.align_center)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 31: ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(sig_long, "MFC BUY", "Multi-Factor Consensus: BUY Signal")
alertcondition(sig_short, "MFC SELL", "Multi-Factor Consensus: SELL Signal")
alertcondition(sweep_hi, "Sweep High", "Liquidity Sweep at Highs")
alertcondition(sweep_lo, "Sweep Low", "Liquidity Sweep at Lows")
alertcondition(bull_div, "Bull Divergence", "Bullish MPI Divergence")
alertcondition(bear_div, "Bear Divergence", "Bearish MPI Divergence")
alertcondition(vol_spike, "Volume Spike", "Volume Spike Detected")
if sig_long
    alert("MFC BUY | " + syminfo.ticker + " @ " + str.tostring(close) + 
         " | Score: " + str.tostring(bull_sc) + "/3 | MPI: " + f_fmt(MPI*100, 0) + "%", 
         alert.freq_once_per_bar_close)
if sig_short
    alert("MFC SELL | " + syminfo.ticker + " @ " + str.tostring(close) + 
         " | Score: " + str.tostring(bear_sc) + "/3 | MPI: " + f_fmt(MPI*100, 0) + "%", 
         alert.freq_once_per_bar_close)
