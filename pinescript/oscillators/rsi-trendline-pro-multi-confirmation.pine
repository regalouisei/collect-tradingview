// This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© last_satoshi
//RSI Trendline Pro - Multi Confirmation | Kullanƒ±m Kƒ±lavuzu
//üáπüá∑ T√úRK√áE
//Genel Bakƒ±≈ü
//RSI Trendline Pro, RSI (Relative Strength Index) g√∂stergesi √ºzerinde otomatik trend √ßizgileri √ßizerek destek ve diren√ß kƒ±rƒ±lƒ±mlarƒ±nƒ± tespit eden geli≈ümi≈ü bir Pine Script g√∂stergesidir. √áoklu doƒürulama sistemi sayesinde y√ºksek kaliteli alƒ±m-satƒ±m sinyalleri √ºretir.‚Äã
//Temel √ñzellikler
//Otomatik Trend √áizgileri: RSI √ºzerinde pivot noktalarƒ± tespit ederek akƒ±llƒ± destek ve diren√ß √ßizgileri olu≈üturur‚Äã

//√áoklu Doƒürulama Sistemi: Volume, Stochastic RSI, ADX ve Divergence filtrelerini birle≈ütirerek yanlƒ±≈ü sinyal riskini azaltƒ±r‚Äã

//RSI Divergence Tespiti: Fiyat ve RSI arasƒ±ndaki sapmalarƒ± otomatik algƒ±lar (Bullish/Bearish)‚Äã

//Canlƒ± Dashboard: RSI deƒüeri, aktif trend √ßizgileri, ADX g√ºc√º ve son sinyal bilgilerini g√∂rsel panel √ºzerinde sunar‚Äã

//Akƒ±llƒ± Kƒ±rƒ±lƒ±m Algƒ±lama: Trend √ßizgisi kƒ±rƒ±lƒ±mlarƒ±nƒ± tespit edip LONG/SHORT sinyalleri √ºretir‚Äã

//Nasƒ±l Kullanƒ±lƒ±r?
//TradingView'a Ekleme: Kodu TradingView Pine Editor'e yapƒ±≈ütƒ±rƒ±p grafiƒüe ekleyin

//Parametreleri Ayarlama:

//RSI Length: RSI periyodu(varsayƒ±lan: 14)‚Äã

//Pivot Strength: Trend √ßizgisi hassasiyeti (d√º≈ü√ºk = daha fazla √ßizgi)‚Äã

//Filtreler: Volume, Divergence, Stoch RSI ve ADX onaylarƒ±nƒ± aktif/pasif edin‚Äã

//Sinyalleri Takip Edin:

//LONG(Ye≈üil): RSI diren√ß √ßizgisini yukarƒ± kƒ±rdƒ±ƒüƒ±nda‚Äã

//SHORT (Kƒ±rmƒ±zƒ±): RSI destek √ßizgisini a≈üaƒüƒ± kƒ±rdƒ±ƒüƒ±nda‚Äã

//Divergence: "D" i≈üaretleri olasƒ± trend d√∂n√º≈ülerini g√∂sterir‚Äã

//Alarm Kurulumu
//Script 4 farklƒ± alarm tipi sunar:‚Äã

//LONG Breakout: Diren√ß kƒ±rƒ±lƒ±mƒ±

//SHORT Breakout: Destek kƒ±rƒ±lƒ±mƒ±

//Bullish/Bearish Divergence: Sapma tespitleri

//Any Signal: T√ºm sinyaller i√ßin toplu alarm

//√ñneriler
//Y√ºksek hacimli kƒ±rƒ±lƒ±mlara √∂ncelik verin (Volume Filter a√ßƒ±k)‚Äã

//ADX > 25 olduƒüunda trendler daha g√º√ßl√ºd√ºr‚Äã

//Divergence sinyallerini fiyat aksiyonu ile doƒürulayƒ±n‚Äã

//2-3 doƒürulama birlikte geldiƒüinde i≈ülem yapƒ±n‚Äã

//üá¨üáß ENGLISH
//Overview
//RSI Trendline Pro is an advanced Pine Script indicator that automatically draws trendlines on the RSI (Relative Strength Index) to detect support and resistance breakouts. It generates high-quality trading signals through a multi-confirmation system.‚Äã

//Key Features
//Auto Trendlines: Detects pivot points on RSI to create intelligent support and resistance lines‚Äã

//Multi-Confirmation System: Combines Volume, Stochastic RSI, ADX, and Divergence filters to reduce false signals‚Äã

//RSI Divergence Detection: Automatically identifies bullish/bearish divergences between price and RSI‚Äã

//Live Dashboard: Displays RSI value, active trendlines, ADX strength, and last signal info on a visual panel‚Äã

//Smart Breakout Detection: Identifies trendline breaks and generates LONG/SHORT signals‚Äã

//How to Use
//Add to TradingView: Paste code into Pine Editor and add to chart

//Configure Parameters:

//RSI Length: RSI period(default: 14)‚Äã

//Pivot Strength: Trendline sensitivity(lower = more lines)‚Äã

//Filters: Enable / disable Volume, Divergence, Stoch RSI, and ADX confirmations‚Äã

//Follow Signals:

//LONG(Green): When RSI breaks resistance upward‚Äã

//SHORT (Red): When RSI breaks support downward‚Äã

//Divergence: "D" markers indicate potential trend reversals‚Äã

//Alert Setup
//Script offers 4 alert types:‚Äã

//LONG Breakout: Resistance break

//SHORT Breakout: Support break

//Bullish/Bearish Divergence: Divergence detection

//Any Signal: Combined alert for all signals

//Best Practices
//Prioritize high-volume breakouts (Volume Filter enabled)‚Äã

//Trends are stronger when ADX > 25‚Äã

//Confirm divergence signals with price action‚Äã

//Trade when 2-3 confirmations align

//@version=5
indicator("RSI Trendline Pro - Multi Confirmation", overlay=false, max_lines_count=30, max_labels_count=30)

// ============================================
// üìä INPUTS
// ============================================
// RSI Settings
rsiLen = input.int(14, "RSI Length", group="RSI Settings")
rsiOB = input.int(70, "Overbought", group="RSI Settings")
rsiOS = input.int(30, "Oversold", group="RSI Settings")

// Trendline Settings
pivotStrength = input.int(4, "Pivot Strength", minval=2, maxval=10, group="Trendline", tooltip="Lower = More lines")
minBars = input.int(10, "Min Bars Between Pivots", minval=5, maxval=30, group="Trendline")
maxBars = input.int(80, "Max Bars Between Pivots", minval=20, maxval=200, group="Trendline")
maxTrendlines = input.int(3, "Max Active Trendlines", minval=1, maxval=5, group="Trendline")

// Confirmation Filters
useVolumeFilter = input.bool(true, "Volume Confirmation", group="Filters")
useRsiDivergence = input.bool(true, "RSI Divergence Detection", group="Filters")
useStochRsi = input.bool(true, "Stochastic RSI Filter", group="Filters")
useTrendStrength = input.bool(true, "ADX Trend Strength", group="Filters")

// Visual
resistanceCol = input.color(color.new(#FF4444, 0), "Resistance Color", group="Visual")
supportCol = input.color(color.new(#00C853, 0), "Support Color", group="Visual")
lineWidth = input.int(2, "Line Width", minval=1, maxval=4, group="Visual")

// ============================================
// üìà INDICATORS
// ============================================
// RSI
rsi = ta.rsi(close, rsiLen)
rsiMA = ta.sma(rsi, 9)

// Stochastic RSI
stochK = ta.stoch(rsi, rsi, rsi, 14)
stochD = ta.sma(stochK, 3)

// ADX (Trend Strength)
[diPlus, diMinus, adx] = ta.dmi(14, 14)

// Volume
volSMA = ta.sma(volume, 20)
highVolume = volume > volSMA * 1.2

// Price-RSI Divergence Detection
bullishDiv = ta.pivotlow(low, pivotStrength, pivotStrength) and ta.pivotlow(rsi, pivotStrength, pivotStrength)
bearishDiv = ta.pivothigh(high, pivotStrength, pivotStrength) and ta.pivothigh(rsi, pivotStrength, pivotStrength)

// ============================================
// üé® PLOTS
// ============================================
plot(rsi, "RSI", color=#8B5CF6, linewidth=2)
plot(rsiMA, "RSI MA", color=color.new(color.yellow, 50), linewidth=1)
hline(rsiOB, "OB", color=color.red, linestyle=hline.style_dashed)
hline(50, "Mid", color=color.gray, linestyle=hline.style_dotted)
hline(rsiOS, "OS", color=color.lime, linestyle=hline.style_dashed)

// Stoch RSI (optional overlay)
plot(useStochRsi ? stochK : na, "Stoch K", color=color.new(color.orange, 70), linewidth=1)

// ============================================
// üîç PIVOT DETECTION
// ============================================
pivotHigh = ta.pivothigh(rsi, pivotStrength, pivotStrength)
pivotLow = ta.pivotlow(rsi, pivotStrength, pivotStrength)

plotchar(not na(pivotHigh), "PH", "‚ñº", location.top, color.red, size=size.tiny)
plotchar(not na(pivotLow), "PL", "‚ñ≤", location.bottom, color.lime, size=size.tiny)

// ============================================
// üìê TRENDLINE DATA STRUCTURE
// ============================================
type Trendline
    line lineObj
    int x1
    float y1
    int x2
    float y2
    bool isResistance
    float strength
    bool isActive

var array<Trendline> trendlines = array.new<Trendline>()

// ============================================
// üõ†Ô∏è TRENDLINE CREATION FUNCTION
// ============================================
createTrendline(int bar1, float val1, int bar2, float val2, bool isRes) =>
    // Calculate strength score
    float strength = 0.0
    float slope = (val2 - val1) / (bar2 - bar1)
    
    // Strength factors
    strength += math.abs(slope) < 0.1 ? 20 : 10  // Flat lines stronger
    strength += (bar2 - bar1) > 30 ? 15 : 5      // Longer lines stronger
    
    if isRes
        strength += val2 > rsiOB ? 10 : 0          // Resistance near OB
    else
        strength += val2 < rsiOS ? 10 : 0          // Support near OS
    
    // Create trendline object
    tl = Trendline.new()
    tl.x1 := bar1
    tl.y1 := val1
    tl.x2 := bar2
    tl.y2 := val2
    tl.isResistance := isRes
    tl.strength := strength
    tl.isActive := true
    
    col = isRes ? resistanceCol : supportCol
    tl.lineObj := line.new(bar1, val1, bar2, val2, color=col, width=lineWidth, extend=extend.right)
    
    array.push(trendlines, tl)

// ============================================
// üî∫ RESISTANCE TRENDLINE DETECTION
// ============================================
if not na(pivotHigh)
    // Find best matching previous pivot high
    float bestScore = 0.0
    int bestBar = na
    float bestVal = na
    
    for lookback = minBars to maxBars
        if bar_index >= lookback
            oldPH = ta.pivothigh(rsi[lookback], pivotStrength, pivotStrength)
            
            if not na(oldPH)
                // Scoring system
                float score = 0.0
                float priceDiff = math.abs(pivotHigh - oldPH)
                float slope = (pivotHigh - oldPH) / lookback
                
                // Prefer descending or flat
                if slope <= 0.15
                    score += 50
                
                // Prefer similar levels (horizontal-ish)
                if priceDiff < 15
                    score += 30
                
                // Prefer medium distance
                if lookback > 20 and lookback < 60
                    score += 20
                
                if score > bestScore
                    bestScore := score
                    bestBar := bar_index - lookback
                    bestVal := oldPH
    
    // Create if valid trend found
    if not na(bestBar) and bestScore > 50
        createTrendline(bestBar, bestVal, bar_index, pivotHigh, true)

// ============================================
// üîª SUPPORT TRENDLINE DETECTION
// ============================================
if not na(pivotLow)
    // Find best matching previous pivot low
    float bestScore = 0.0
    int bestBar = na
    float bestVal = na
    
    for lookback = minBars to maxBars
        if bar_index >= lookback
            oldPL = ta.pivotlow(rsi[lookback], pivotStrength, pivotStrength)
            
            if not na(oldPL)
                // Scoring system
                float score = 0.0
                float priceDiff = math.abs(pivotLow - oldPL)
                float slope = (pivotLow - oldPL) / lookback
                
                // Prefer ascending or flat
                if slope >= -0.15
                    score += 50
                
                // Prefer similar levels
                if priceDiff < 15
                    score += 30
                
                // Prefer medium distance
                if lookback > 20 and lookback < 60
                    score += 20
                
                if score > bestScore
                    bestScore := score
                    bestBar := bar_index - lookback
                    bestVal := oldPL
    
    // Create if valid trend found
    if not na(bestBar) and bestScore > 50
        createTrendline(bestBar, bestVal, bar_index, pivotLow, false)

// ============================================
// üßπ CLEANUP: Keep only strongest lines
// ============================================
if array.size(trendlines) > maxTrendlines
    // Sort by strength
    for i = 0 to array.size(trendlines) - 2
        for j = i + 1 to array.size(trendlines) - 1
            if array.get(trendlines, i).strength < array.get(trendlines, j).strength
                temp = array.get(trendlines, i)
                array.set(trendlines, i, array.get(trendlines, j))
                array.set(trendlines, j, temp)
    
    // Delete weakest
    while array.size(trendlines) > maxTrendlines
        weakest = array.pop(trendlines)
        line.delete(weakest.lineObj)

// ============================================
// ‚ö° BREAKOUT DETECTION
// ============================================
var bool longSignal = false
var bool shortSignal = false
var int lastSignalBar = 0

longSignal := false
shortSignal := false

if array.size(trendlines) > 0
    for tl in trendlines
        if tl.isActive and bar_index >= tl.x2
            // Calculate line price
            slope = (tl.y2 - tl.y1) / (tl.x2 - tl.x1)
            linePrice = tl.y2 + slope * (bar_index - tl.x2)
            
            // ‚úÖ RESISTANCE BREAKOUT (LONG)
            if tl.isResistance and ta.crossover(rsi, linePrice)
                // Multi-confirmation
                bool confirmed = true
                
                if useVolumeFilter and not highVolume
                    confirmed := false
                
                if useStochRsi and stochK < 20
                    confirmed := false
                
                if useTrendStrength and adx < 20
                    confirmed := false
                
                if confirmed and (bar_index - lastSignalBar) > 3
                    longSignal := true
                    lastSignalBar := bar_index
                    tl.isActive := false
                    line.set_color(tl.lineObj, color.new(color.lime, 60))
                    line.set_style(tl.lineObj, line.style_dashed)
            
            // ‚úÖ SUPPORT BREAKOUT (SHORT)
            if not tl.isResistance and ta.crossunder(rsi, linePrice)
                // Multi-confirmation
                bool confirmed = true
                
                if useVolumeFilter and not highVolume
                    confirmed := false
                
                if useStochRsi and stochK > 80
                    confirmed := false
                
                if useTrendStrength and adx < 20
                    confirmed := false
                
                if confirmed and (bar_index - lastSignalBar) > 3
                    shortSignal := true
                    lastSignalBar := bar_index
                    tl.isActive := false
                    line.set_color(tl.lineObj, color.new(color.red, 60))
                    line.set_style(tl.lineObj, line.style_dashed)

// ============================================
// üéØ SIGNALS
// ============================================
plotshape(longSignal, "LONG", shape.labelup, location.bottom, 
          color.new(color.lime, 0), text="LONG", textcolor=color.black, size=size.normal)
plotshape(shortSignal, "SHORT", shape.labeldown, location.top, 
          color.new(color.red, 0), text="SHORT", textcolor=color.white, size=size.normal)

bgcolor(longSignal ? color.new(color.lime, 85) : na)
bgcolor(shortSignal ? color.new(color.red, 85) : na)

// Divergence markers
plotchar(useRsiDivergence and bullishDiv, "Bull Div", "D", location.bottom, color.aqua, size=size.tiny)
plotchar(useRsiDivergence and bearishDiv, "Bear Div", "D", location.top, color.fuchsia, size=size.tiny)

// ============================================
// üö® ALERTS
// ============================================
alertcondition(longSignal, "LONG Breakout", "üü¢ RSI broke resistance with confirmation")
alertcondition(shortSignal, "SHORT Breakout", "üî¥ RSI broke support with confirmation")

// ‚úÖ NEW: Divergence Alerts
alertcondition(bullishDiv, "Bullish Divergence", "üîµ BULLISH DIVERGENCE: Potential reversal upward!")
alertcondition(bearishDiv, "Bearish Divergence", "üü£ BEARISH DIVERGENCE: Potential reversal downward!")

// Combined alert (any divergence)
alertcondition(bullishDiv or bearishDiv, "Any Divergence", "‚ö†Ô∏è RSI DIVERGENCE DETECTED - Check chart!")

// Combined alert (any signal)
alertcondition(longSignal or shortSignal or bullishDiv or bearishDiv, "Any Signal", 
               "üö® TRADING SIGNAL: Check RSI indicator for details")

// ============================================
// üìä INFO DASHBOARD
// ============================================
var table dashboard = table.new(position.top_right, 2, 7, bgcolor=color.new(#1E1E1E, 90), 
                                 border_color=color.gray, border_width=1, frame_color=color.gray, frame_width=1)

if barstate.islast
    // RSI
    table.cell(dashboard, 0, 0, "RSI", text_color=color.white, text_size=size.small, bgcolor=color.new(#2E2E2E, 80))
    rsiColor = rsi > rsiOB ? color.red : rsi < rsiOS ? color.lime : color.yellow
    table.cell(dashboard, 1, 0, str.tostring(rsi, "#.#"), text_color=rsiColor, text_size=size.normal)
    
    // Active Lines
    activeCount = 0
    for tl in trendlines
        if tl.isActive
            activeCount += 1
    
    table.cell(dashboard, 0, 1, "Trendlines", text_color=color.white, text_size=size.small, bgcolor=color.new(#2E2E2E, 80))
    table.cell(dashboard, 1, 1, str.tostring(activeCount), text_color=color.orange, text_size=size.normal)
    
    // ADX
    table.cell(dashboard, 0, 2, "ADX", text_color=color.white, text_size=size.small, bgcolor=color.new(#2E2E2E, 80))
    adxColor = adx > 25 ? color.lime : color.gray
    table.cell(dashboard, 1, 2, str.tostring(adx, "#.#"), text_color=adxColor, text_size=size.normal)
    
    // Stoch RSI
    table.cell(dashboard, 0, 3, "Stoch RSI", text_color=color.white, text_size=size.small, bgcolor=color.new(#2E2E2E, 80))
    stochColor = stochK > 80 ? color.red : stochK < 20 ? color.lime : color.gray
    table.cell(dashboard, 1, 3, str.tostring(stochK, "#"), text_color=stochColor, text_size=size.normal)
    
    // Volume
    table.cell(dashboard, 0, 4, "Volume", text_color=color.white, text_size=size.small, bgcolor=color.new(#2E2E2E, 80))
    volText = highVolume ? "HIGH ‚ñ≤" : "Normal"
    volColor = highVolume ? color.yellow : color.gray
    table.cell(dashboard, 1, 4, volText, text_color=volColor, text_size=size.small)
    
    // Last Signal
    table.cell(dashboard, 0, 5, "Last Signal", text_color=color.white, text_size=size.small, bgcolor=color.new(#2E2E2E, 80))
    barsSince = bar_index - lastSignalBar
    table.cell(dashboard, 1, 5, barsSince > 0 ? str.tostring(barsSince) + " bars" : "-", 
               text_color=color.gray, text_size=size.small)
    
    // Status
    table.cell(dashboard, 0, 6, "STATUS", text_color=color.white, text_size=size.small, bgcolor=color.new(#2E2E2E, 80))
    statusText = longSignal ? "LONG ‚¨Ü" : shortSignal ? "SHORT ‚¨á" : "Waiting..."
    statusColor = longSignal ? color.lime : shortSignal ? color.red : color.yellow
    table.cell(dashboard, 1, 6, statusText, text_color=statusColor, text_size=size.normal, bgcolor=color.new(statusColor, 90))
