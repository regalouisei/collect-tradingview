//@version=6
// ╔══════════════════════════════════════════════════════════════════════╗
// ║                   QuantumFlowTrader 2025                             ║
// ║                   Author: Socrates Flores                            ║
// ║                   All rights reserved.                               ║
// ║                                                                      ║
// ║ This script and its code is the intellectual property of the author. ║
// ║ Unauthorized copying, distribution, or modification is prohibited.   ║
// ║                                                                      ║
// ║                                                                      ║
// ╚══════════════════════════════════════════════════════════════════════╝

indicator("QFT MTF Range Detector", shorttitle="QFT Range Detector", overlay=false, max_lines_count=500)

//=====================================================================
// TIMEFRAME SETS (UNIFIED)
//=====================================================================
const string[] qft_TFS_ALL      = array.from("240","60","45","30","15","10","5","3","2","1")
const string[] qft_TFLABELS_ALL = array.from("4H","1H","45M","30M","15M","10M","5M","3M","2M","1M")

//=====================================================================
// INPUT
//=====================================================================
bool  qft_showBordersInput = input.bool(false, "Show Borders", group="Appearance")
color qft_textColorInput   = input.color(color.rgb(10, 10, 10), "Text Color", group="Appearance")

color qft_rangeColor    = input.color(color.new(#000000, 0), "Range Color", group="Signal Colors")
color qft_noRangeColor  = input.color(color.new(#b701ff, 0), "Non-Range Color", group="Signal Colors")
color qft_neutralColor  = input.color(color.gray, "Neutral Color", group="Signal Colors")

string qft_cornerInput = input.string("bottom_right", "Corner", options=["top_left","top_right","bottom_left","bottom_right"], group="Appearance")

//=====================================================================
// POSITION ENUM
//=====================================================================
f_qft_pos(qft_c) =>
    qft_c=="top_left"?position.top_left:
     qft_c=="top_right"?position.top_right:
     qft_c=="bottom_left"?position.bottom_left:
     position.bottom_right

//=====================================================================
// ADX MANUAL (v6)
//=====================================================================
f_qft_ADX(qft_len) =>
    qft_tr      = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs(low - nz(close[1])))
    qft_dmPlus  = (high - nz(high[1]) > nz(low[1]) - low) ? math.max(high - nz(high[1]), 0) : 0
    qft_dmMinus = (nz(low[1]) - low > high - nz(high[1])) ? math.max(nz(low[1]) - low, 0) : 0

    qft_smTr      = 0.0
    qft_smTr     := nz(qft_smTr[1]) - (nz(qft_smTr[1]) / qft_len) + qft_tr

    qft_smDmPlus  = 0.0
    qft_smDmPlus := nz(qft_smDmPlus[1]) - (nz(qft_smDmPlus[1]) / qft_len) + qft_dmPlus

    qft_smDmMinus  = 0.0
    qft_smDmMinus := nz(qft_smDmMinus[1]) - (nz(qft_smDmMinus[1]) / qft_len) + qft_dmMinus

    qft_diPlus  = qft_smDmPlus  / qft_smTr * 100
    qft_diMinus = qft_smDmMinus / qft_smTr * 100

    qft_dx = math.abs(qft_diPlus - qft_diMinus) / math.max(qft_diPlus + qft_diMinus, 1) * 100

    ta.sma(qft_dx, qft_len)

//=====================================================================
// RANGE DETECTOR
//=====================================================================
f_qft_rangeDetector(qft_tf) =>
    [qft_rsi, qft_rsiVol, qft_atrNorm, qft_adx, qft_hh, qft_ll] = request.security(syminfo.tickerid, qft_tf, [ta.rsi(close, 14), ta.stdev(ta.rsi(close, 14), 10), ta.atr(14) / close, f_qft_ADX(14), ta.highest(high, 20), ta.lowest(low, 20)])


    qft_rangeWidth = (qft_hh - qft_ll) / close
    qft_mid        = (qft_hh + qft_ll) * 0.5
    qft_distMid    = (qft_hh == qft_ll) ? 0.0 : math.abs(close - qft_mid) / (qft_hh - qft_ll)

    qft_condADX        = qft_adx < 17
    qft_condRangeWidth = qft_rangeWidth > 0.0012 and qft_rangeWidth < 0.0075
    qft_condATR        = qft_atrNorm > 0.0007 and qft_atrNorm < 0.0065
    qft_condRSI        = (qft_rsi > 40 and qft_rsi < 60) and (qft_rsiVol < 6)
    qft_condCenter     = qft_distMid < 0.65

    qft_total = (qft_condADX?1:0) + (qft_condRangeWidth?1:0) + (qft_condATR?1:0) + (qft_condRSI?1:0) + (qft_condCenter?1:0)

    qft_total >= 3 ? 1 : -1

//=====================================================================
// TABLE CREATION
//=====================================================================
var table qft_dash = na

if barstate.isfirst
    qft_dash := table.new(f_qft_pos(qft_cornerInput), array.size(qft_TFS_ALL)+1, 2, border_width = qft_showBordersInput ? 1 : 0)

    for qft_i = 0 to array.size(qft_TFLABELS_ALL)-1
        table.cell(qft_dash, qft_i+1, 0, array.get(qft_TFLABELS_ALL, qft_i), text_color=qft_textColorInput, text_halign=text.align_center)

    table.cell(qft_dash, 0, 1, "Black = Range", text_color=qft_textColorInput)

//=====================================================================
// FILL TABLE
//=====================================================================
int[] qft_results = array.new_int()

for qft_tf in qft_TFS_ALL
    array.push(qft_results, f_qft_rangeDetector(qft_tf))

for qft_i = 0 to array.size(qft_results)-1
    qft_v = array.get(qft_results, qft_i)
    qft_col = qft_v == 1 ? qft_rangeColor : qft_noRangeColor
    table.cell(qft_dash, qft_i+1, 1, "██", text_color=qft_col, text_halign=text.align_center, text_size = size.large)
