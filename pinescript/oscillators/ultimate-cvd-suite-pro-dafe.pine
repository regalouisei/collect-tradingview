//@version=5
indicator("Ultimate CVD Suite Pro [DAFE]", shorttitle="CVD-Pro", overlay=false, max_labels_count=500, max_lines_count=500, max_boxes_count=500)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
// â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—
// â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
// â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•      â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
// â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
//  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•  â•šâ•â•â•â•â•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•    â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                           DAFE Trading Systems - DskyzInvestments
//                              "The Institutional Flow Engine"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â„¹ï¸ TOOLTIP DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var string TT_LTF    = "ğŸ”¬ MICROSTRUCTURE DATA\n\nThis script requests data from a Lower Timeframe (LTF) to build accurate volume delta.\n\nâ€¢ For 1h charts: Use 5m LTF.\nâ€¢ For 5m charts: Use 1m LTF.\nâ€¢ Max Intrabars: Limits how much data is processed to prevent timeout errors."
var string TT_CORE   = "ğŸ“Š CVD COMPONENTS\n\nâ€¢ CVD Wave: Cumulative buying/selling pressure over time.\nâ€¢ Delta Histogram: Net buying/selling per bar.\nâ€¢ Sequence Sparkles: Detects patterns of Exhaustion (E), Momentum (M), and Late-stage (L) participation.\nâ€¢ Acceleration: Rate of change of the Delta."
var string TT_VIZ    = "ğŸ¨ VISUALIZATION ENGINE\n\nRenders the data in specialized modes:\n\nâ€¢ Nebula Pulse: Glows brighter as delta intensity increases.\nâ€¢ Tectonic Plates: Visualizes 'Stress' in the order flow.\nâ€¢ DNA Helix: Shows the interplay between CVD and Price structure."
var string TT_DIV    = "ğŸ”„ DIVERGENCE LOGIC\n\nDetects when Price and Order Flow disagree.\n\nâ€¢ Bullish: Price makes Lower Low, CVD makes Higher Low (Sellers exhausted).\nâ€¢ Bearish: Price makes Higher High, CVD makes Lower High (Buyers exhausted)."
var string TT_ZONES  = "ğŸ“ SMART KILL ZONES\n\nIdentifies price levels where aggressive market orders triggered a reversal.\n\nâ€¢ Demand (Green): Aggressive selling was absorbed, leading to a bounce.\nâ€¢ Supply (Red): Aggressive buying was absorbed, leading to a drop."
var string TT_IMB    = "âš–ï¸ IMBALANCE & ABSORPTION\n\nâ€¢ Imbalance: A statistical anomaly in buying/selling pressure (> 2 Sigma).\nâ€¢ Absorption: High Volume + Low Price Movement. Indicates Limit Orders act as a wall against Market Orders."
var string TT_MTF    = "ğŸŒ HORIZON DISPLAY\n\nProjects higher timeframe CVD metrics onto the current chart, allowing you to see the 'Macro Flow' without switching screens."
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT GROUPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string grpLTF        = "âš™ï¸ Lower Timeframe Data"
string grpCore       = "ğŸ“Š Core CVD Display"
string grpOriginal   = "ğŸ¨ Original Visuals Layer"
string grpViz        = "ğŸ¨ Visualization Engine"
string grpDiv        = "ğŸ”„ Divergence Detection"
string grpZones      = "ğŸ“ Smart Kill Zones"
string grpImbalance  = "âš–ï¸ Delta Imbalance"
string grpAbsorption = "ğŸ§² Absorption Detection"
string grpMain       = "ã€°ï¸ Main Chart Elements"
string grpMTF        = "ğŸŒ MTF Horizon Display"
string grpH1         = "ğŸŒ Horizon 1"
string grpH2         = "ğŸŒ Horizon 2"
string grpH3         = "ğŸŒ Horizon 3"
string grpOpt        = "ğŸ§ª Optimizer Engine"
string grpPanel      = "ğŸ“‹ Dashboard"
string grpTheme      = "ğŸ¨ Color Theme"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ltfTimeframe = input.timeframe("3", "LTF Resolution", group=grpLTF, tooltip=TT_LTF)
maxIntrabars = input.int(1000, "Max Intrabars", minval=100, maxval=5000, group=grpLTF)
showCVD = input.bool(true, "Show CVD Wave (Main Chart)", group=grpCore, tooltip=TT_CORE)
showDelta = input.bool(true, "Show Bar Delta Histogram", group=grpCore)
showSequence = input.bool(true, "Show Sequence Sparkles (âœ¦ E/M/L)", group=grpCore)
showAcceleration = input.bool(true, "Show Delta Acceleration", group=grpCore)
showPeaksTroughs = input.bool(true, "Show Peak/Trough Markers", group=grpCore)
showImbalanceLine = input.bool(true, "Show Imbalance Line", group=grpCore)
showOriginalVisuals = input.bool(true, "â˜… Enable Original Visual Layer â˜…", group=grpOriginal, tooltip="Keeps the standard histogram visible underneath the advanced effects.")
originalLayerOpacity = input.int(0, "Layer Transparency", minval=0, maxval=80, step=10, group=grpOriginal)
vizMode = input.string("4: Aurora Borealis", "â˜… Visualization Mode â˜…", 
     options=["1: Nebula Pulse", "2: Tectonic Plates", "3: DNA Helix", "4: Aurora Borealis", "5: Radar Sweep", "6: Holographic Prism", "OFF: Original Only"], 
     group=grpViz, tooltip=TT_VIZ)
vizIntensity = input.float(1.0, "Visual Intensity", minval=0.5, maxval=2.0, step=0.1, group=grpViz)
showGlowEffects = input.bool(true, "Enable Glow/Particle Effects", group=grpViz)
vizAnimationSpeed = input.int(5, "Animation Speed", minval=1, maxval=10, group=grpViz)
enableDivergence = input.bool(true, "Enable Divergence", group=grpDiv, tooltip=TT_DIV)
divLookback = input.int(14, "Lookback Period", minval=5, maxval=50, group=grpDiv)
divSensitivity = input.float(1.5, "Sensitivity (Ïƒ)", minval=0.5, maxval=3.0, step=0.1, group=grpDiv)
enableZones = input.bool(true, "Enable Kill Zones", group=grpZones, tooltip=TT_ZONES)
zoneSize = input.float(0.5, "Zone Height (ATR)", minval=0.1, maxval=2.0, step=0.1, group=grpZones)
zoneStrengthInput = input.int(70, "Min Strength %", minval=50, maxval=95, group=grpZones)
maxZones = input.int(5, "Max Active Zones", minval=1, maxval=10, group=grpZones)
zoneLookback = input.int(100, "Zone Lookback Bars", minval=20, maxval=300, group=grpZones)
zoneTransparency = input.int(75, "Zone Transparency", minval=50, maxval=95, group=grpZones)
showZoneLabels = input.bool(true, "Show Zone Labels", group=grpZones)
zoneMinDistance = input.float(1.5, "Min Zone Spacing (ATR)", minval=0.5, maxval=5.0, step=0.1, group=grpZones)
enableImbalance = input.bool(true, "Enable Imbalance Detection", group=grpImbalance, tooltip=TT_IMB)
imbalanceThreshold = input.float(3.0, "Threshold (Ïƒ)", minval=1.0, maxval=4.0, step=0.1, group=grpImbalance)
showImbalanceZones = input.bool(true, "Show Imbalance Levels", group=grpImbalance)
maxImbalanceLines = input.int(3, "Max Imbalance Lines", minval=1, maxval=10, group=grpImbalance)
imbalanceLookback = input.int(50, "Line Expiry (bars)", minval=10, maxval=200, group=grpImbalance)
enableAbsorption = input.bool(true, "Enable Absorption", group=grpAbsorption, tooltip="Detects where price stops moving despite high volume (Limit Order Wall).")
absorptionSensitivity = input.float(1.5, "Sensitivity", minval=0.5, maxval=3.0, step=0.1, group=grpAbsorption)
minAbsorptionVolume = input.float(1.2, "Min Volume Multiple", minval=1.0, maxval=3.0, step=0.1, group=grpAbsorption)
maxAbsorptionLines = input.int(3, "Max Lines Displayed", minval=1, maxval=10, group=grpAbsorption)
absorptionLookback = input.int(50, "Line Expiry (bars)", minval=10, maxval=200, group=grpAbsorption)
showLTFLine = input.bool(true, "Show LTF Price Line", group=grpMain)
ltfLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group=grpMain)
showLTFGlow = input.bool(true, "Show Line Glow", group=grpMain)
showSignalLevels = input.bool(true, "Show Signal Levels", group=grpMain)
maxSignalLines = input.int(3, "Max Signal Lines", minval=1, maxval=10, group=grpMain)
enableMTFHorizon = input.bool(true, "â˜… Enable MTF Horizon â˜…", group=grpMTF, tooltip=TT_MTF)
mtfHorizonOffset = input.int(100, "Future Offset (bars)", minval=10, maxval=150, group=grpMTF)
mtfBoxWidth = input.int(50, "Box Width (bars)", minval=20, maxval=100, group=grpMTF)
mtfBoxSpacing = input.int(8, "Box Spacing (bars)", minval=2, maxval=30, group=grpMTF)
mtfHorizonHeight = input.int(25, "Box Height %", minval=5, maxval=35, group=grpMTF)
mtfHorizonLocation = input.string("Bottom", "Vertical Position", options=["Bottom", "Top"], group=grpMTF)
mtfHorizonDepth = input.int(70, "History Depth", minval=10, maxval=80, group=grpMTF)
mtfHorizonStyle = input.string("Flowing Wave", "â˜… Display Style â˜…", options=["Flowing Wave", "Gradient Bars", "Neon Pulse", "Crystal Shards"], group=grpMTF)
mtfShowLabels = input.bool(true, "Show Metric Labels", group=grpMTF)
mtfShowTrend = input.bool(true, "Show Trend Arrows", group=grpMTF)
mtfShowValues = input.bool(true, "Show Current Values", group=grpMTF)
mtfGlowEffect = input.bool(true, "Glow Effect", group=grpMTF)
mtfHorizon1Show = input.bool(true, "Enable Horizon 1", group=grpH1)
mtfHorizon1TF = input.timeframe("1", "Timeframe", group=grpH1)
mtfHorizon1Metric = input.string("RSI", "Metric", options=["CVD", "Volume", "Volatility", "RSI", "Delta Flow", "Buy Pressure", "Sell Pressure", "Momentum", "MACD", "Stochastic"], group=grpH1)
mtfHorizon1Color = input.color(#FFD700, "Color", group=grpH1)
mtfHorizon2Show = input.bool(true, "Enable Horizon 2", group=grpH2)
mtfHorizon2TF = input.timeframe("240", "Timeframe", group=grpH2)
mtfHorizon2Metric = input.string("Volume", "Metric", options=["CVD", "Volume", "Volatility", "RSI", "Delta Flow", "Buy Pressure", "Sell Pressure", "Momentum", "MACD", "Stochastic"], group=grpH2)
mtfHorizon2Color = input.color(#FF00FF, "Color", group=grpH2)
mtfHorizon3Show = input.bool(false, "Enable Horizon 3", group=grpH3)
mtfHorizon3TF = input.timeframe("5", "Timeframe", group=grpH3)
mtfHorizon3Metric = input.string("MACD", "Metric", options=["CVD", "Volume", "Volatility", "RSI", "Delta Flow", "Buy Pressure", "Sell Pressure", "Momentum", "MACD", "Stochastic"], group=grpH3)
mtfHorizon3Color = input.color(#00FFAA, "Color", group=grpH3)
optMode = input.bool(false, "Enable Optimizer", group=grpOpt)
optTP = input.float(2.0, "TP (xATR)", minval=0.5, maxval=10.0, step=0.1, group=grpOpt)
optSL = input.float(1.5, "SL (xATR)", minval=0.5, maxval=10.0, step=0.1, group=grpOpt)
optSignalType = input.string("Strong Signals", "Signal Type", options=["Strong Signals", "All Signals", "Divergence Only", "Imbalance Only"], group=grpOpt)
showInfoPanel = input.bool(true, "Show Dashboard", group=grpPanel)
dashDisplayMode = input.string("Indicator Panel", "Dashboard Location", options=["Main Chart Overlay", "Indicator Panel"], group=grpPanel)
panelPosition = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=grpPanel)
panelSize = input.string("Full Dashboard", "Dashboard Size", options=["Full Dashboard", "Compact", "Mini"], group=grpPanel)
dashTextSize = input.string("Normal", "â˜… Text Size â˜…", options=["Tiny", "Small", "Normal", "Large"], group=grpPanel)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ COLOR THEME
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
colorTheme = input.string("Neon Tokyo", "Select Theme", options=["Neon Tokyo", "Ocean Depths", "Forest Canopy", "Arctic Aurora", "Sunset Blaze", "Classic Terminal", "Quantum Dark"], group=grpTheme,
     tooltip="Controls the overall color palette for all visualizations.")
bullColor = switch colorTheme
    "Neon Tokyo" => #00FFAA
    "Ocean Depths" => #00CED1
    "Forest Canopy" => #32CD32
    "Arctic Aurora" => #00FF7F
    "Sunset Blaze" => #FFD700
    "Classic Terminal" => #00FF00
    "Quantum Dark" => #00FF88
    => #00FFAA
bearColor = switch colorTheme
    "Neon Tokyo" => #FF0055
    "Ocean Depths" => #FF6B6B
    "Forest Canopy" => #CD5C5C
    "Arctic Aurora" => #FF4500
    "Sunset Blaze" => #FF4136
    "Classic Terminal" => #FF0000
    "Quantum Dark" => #FF0066
    => #FF0055
neutralColor = switch colorTheme
    "Neon Tokyo" => #8899AA
    "Ocean Depths" => #708090
    "Forest Canopy" => #8B8B7A
    "Arctic Aurora" => #B0C4DE
    "Sunset Blaze" => #AAAAAA
    "Classic Terminal" => #888888
    "Quantum Dark" => #8899AA
    => #8899AA
accentColor1 = switch colorTheme
    "Neon Tokyo" => #00DDFF
    "Ocean Depths" => #40E0D0
    "Forest Canopy" => #98FB98
    "Arctic Aurora" => #7FFFD4
    "Sunset Blaze" => #FFA07A
    "Classic Terminal" => #00FFFF
    "Quantum Dark" => #00CCFF
    => #00DDFF
accentColor2 = switch colorTheme
    "Neon Tokyo" => #FF00FF
    "Ocean Depths" => #9370DB
    "Forest Canopy" => #DEB887
    "Arctic Aurora" => #9932CC
    "Sunset Blaze" => #FF6347
    "Classic Terminal" => #FFFF00
    "Quantum Dark" => #AA00FF
    => #FF00FF
accentColor3 = switch colorTheme
    "Neon Tokyo" => #FFFF00
    "Ocean Depths" => #FF8C00
    "Forest Canopy" => #FFD700
    "Arctic Aurora" => #00BFFF
    "Sunset Blaze" => #FFD700
    "Classic Terminal" => #FF00FF
    "Quantum Dark" => #FFCC00
    => #FFFF00
peakColor = switch colorTheme
    "Neon Tokyo" => #00FF00
    "Ocean Depths" => #00FFAA
    "Forest Canopy" => #7CFC00
    "Arctic Aurora" => #00FF7F
    "Sunset Blaze" => #FFD700
    "Classic Terminal" => #00FF00
    "Quantum Dark" => #00FF00
    => #00FF00
troughColor = switch colorTheme
    "Neon Tokyo" => #FF0000
    "Ocean Depths" => #FF4444
    "Forest Canopy" => #DC143C
    "Arctic Aurora" => #FF6347
    "Sunset Blaze" => #FF4136
    "Classic Terminal" => #FF0000
    "Quantum Dark" => #FF0000
    => #FF0000
imbalanceColor = switch colorTheme
    "Neon Tokyo" => #FFD700
    "Ocean Depths" => #FFA500
    "Forest Canopy" => #DAA520
    "Arctic Aurora" => #FFD700
    "Sunset Blaze" => #FFA500
    "Classic Terminal" => #FFFF00
    "Quantum Dark" => #FFD700
    => #FFD700
bgColor = switch colorTheme
    "Neon Tokyo" => #0A0A14
    "Ocean Depths" => #0C1929
    "Forest Canopy" => #1A1F16
    "Arctic Aurora" => #0D1B2A
    "Sunset Blaze" => #1A1209
    "Classic Terminal" => #000000
    "Quantum Dark" => #0A0A14
    => #0A0A14
frameColor = switch colorTheme
    "Neon Tokyo" => #00DDFF
    "Ocean Depths" => #1E90FF
    "Forest Canopy" => #6B8E23
    "Arctic Aurora" => #7B68EE
    "Sunset Blaze" => #FF8C00
    "Classic Terminal" => #333333
    "Quantum Dark" => #00CCFF
    => #00DDFF
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ CORE CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
atr14 = ta.atr(14)
atr20 = ta.atr(20)
avgVolume20 = ta.sma(volume, 20)
var float cvd = 0.0
var float cvdMA = 0.0
var float prevCVD = 0.0
var array<float> deltaSequence = array.new<float>()
var array<float> deltaHistory = array.new<float>()
var array<float> demandZoneLevels = array.new<float>()
var array<float> demandZoneStrengths = array.new<float>()
var array<int> demandZoneBars = array.new<int>()
var array<float> demandZoneDeltas = array.new<float>()
var array<float> supplyZoneLevels = array.new<float>()
var array<float> supplyZoneStrengths = array.new<float>()
var array<int> supplyZoneBars = array.new<int>()
var array<float> supplyZoneDeltas = array.new<float>()
var array<box> zoneBoxes = array.new<box>()
var array<label> zoneLabels = array.new<label>()
var array<float> imbalanceLevels = array.new<float>()
var array<bool> imbalanceTypes = array.new<bool>()
var array<int> imbalanceBars = array.new<int>()
var array<float> absorptionLevels = array.new<float>()
var array<int> absorptionBars = array.new<int>()
var array<bool> absorptionTypes = array.new<bool>()
var array<line> signalLines = array.new<line>()
var array<label> signalLabels = array.new<label>()
var array<line> imbLines = array.new<line>()
var array<label> imbLabels = array.new<label>()
var array<line> absLines = array.new<line>()
var array<label> absLabels = array.new<label>()
var array<float> mtf1_history = array.new<float>(100, 0.0)
var array<float> mtf2_history = array.new<float>(100, 0.0)
var array<float> mtf3_history = array.new<float>(100, 0.0)
f_cleanupLineArray(array<line> arr, int maxItems) =>
    while array.size(arr) > maxItems
        line.delete(array.shift(arr))
f_cleanupLabelArray(array<label> arr, int maxItems) =>
    while array.size(arr) > maxItems
        label.delete(array.shift(arr))
f_cleanupBoxArray(array<box> arr, int maxItems) =>
    while array.size(arr) > maxItems
        box.delete(array.shift(arr))
if barstate.isnew
    array.clear(deltaSequence)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¡ LTF DATA REQUEST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[ltfO, ltfH, ltfL, ltfC, ltfV, ltfT] = request.security_lower_tf(syminfo.tickerid, ltfTimeframe, [open, high, low, close, volume, time])
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”¬ DELTA CALCULATION ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_calculateDelta(float o, float h, float l, float c, float v) =>
    priceRange = h - l
    float delta = 0.0
    float totalBuy = 0.0
    float totalSell = 0.0  
    if priceRange == 0 or v == 0
        delta := 0.0
    else
        bodyTop = math.max(o, c)
        bodyBottom = math.min(o, c)
        bodyRange = bodyTop - bodyBottom
        upperWick = h - bodyTop
        lowerWick = bodyBottom - l
        totalTime = upperWick * 0.7 + lowerWick * 0.7 + bodyRange * 1.5
        upperWickVol = totalTime > 0 ? v * (upperWick * 0.7 / totalTime) : 0.0
        lowerWickVol = totalTime > 0 ? v * (lowerWick * 0.7 / totalTime) : 0.0
        bodyVol = totalTime > 0 ? v * (bodyRange * 1.5 / totalTime) : v
        buyFromLowerWick = lowerWickVol * 2.0
        sellFromUpperWick = upperWickVol * 2.0
        if c > o
            bodyStrength = bodyRange > 0 ? (c - bodyBottom) / bodyRange : 1.0
            totalBuy := buyFromLowerWick + bodyVol * (0.6 + bodyStrength * 0.4) + upperWickVol * 0.2
            totalSell := sellFromUpperWick + bodyVol * (0.4 - bodyStrength * 0.3) + lowerWickVol * 0.2
        else if c < o
            bodyStrength = bodyRange > 0 ? (bodyTop - c) / bodyRange : 1.0
            totalSell := sellFromUpperWick + bodyVol * (0.6 + bodyStrength * 0.4) + lowerWickVol * 0.2
            totalBuy := buyFromLowerWick + bodyVol * (0.4 - bodyStrength * 0.3) + upperWickVol * 0.2
        else
            totalBuy := buyFromLowerWick + bodyVol * 0.5
            totalSell := sellFromUpperWick + bodyVol * 0.5
        delta := totalBuy - totalSell
    [totalBuy, totalSell, delta]
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ PROCESS LTF BARS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float barBuyVolume = 0.0
float barSellVolume = 0.0
float barDelta = 0.0
float totalBarVolume = 0.0
float ltfLastPrice = close
if bar_index > 0
    if not na(ltfC)
        int ltfSize = array.size(ltfC)
        if ltfSize > 0
            ltfLastPrice := array.get(ltfC, ltfSize - 1)
            int loopLimit = math.min(ltfSize, maxIntrabars)
            for i = 0 to loopLimit - 1
                float ltfOpen = array.get(ltfO, i)
                float ltfHigh = array.get(ltfH, i)
                float ltfLow = array.get(ltfL, i)
                float ltfClose = array.get(ltfC, i)
                float ltfVol = array.get(ltfV, i)
                
                [buy, sell, deltaTick] = f_calculateDelta(ltfOpen, ltfHigh, ltfLow, ltfClose, ltfVol)
                barBuyVolume += buy
                barSellVolume += sell
                totalBarVolume += ltfVol
                array.push(deltaSequence, deltaTick)
barDelta := barBuyVolume - barSellVolume
prevCVD := cvd
cvd += barDelta
if enableImbalance
    array.push(deltaHistory, barDelta)
    if array.size(deltaHistory) > 20
        array.shift(deltaHistory)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š SEQUENCE ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_analyzeSequence() =>
    size = array.size(deltaSequence)
    float earlyD = 0.0
    float midD = 0.0
    float lateD = 0.0
    float peak = 0.0
    float trough = 0.0
    string pattern = "NEUTRAL"
    float confidence = 0.0 
    if size >= 3
        third = math.floor(size / 3)
        float cumDelta = 0.0
        for i = 0 to size - 1
            d = array.get(deltaSequence, i)
            cumDelta += d
            peak := math.max(peak, cumDelta)
            trough := math.min(trough, cumDelta)
            if i < third
                earlyD += d
            else if i < third * 2
                midD += d
            else
                lateD += d
        totalDelta = math.abs(earlyD) + math.abs(midD) + math.abs(lateD)
        if totalDelta > 0
            if earlyD > 0 and lateD < 0 and math.abs(lateD) > earlyD * 0.6
                pattern := "EXHAUSTION_BUY"
                confidence := math.abs(lateD) / math.max(earlyD, 1)
            else if earlyD < 0 and lateD > 0 and lateD > math.abs(earlyD) * 0.6
                pattern := "EXHAUSTION_SELL"
                confidence := lateD / math.max(math.abs(earlyD), 1)
            else if earlyD > 0 and lateD > earlyD
                pattern := "ACCELERATION_BUY"
                confidence := lateD / math.max(earlyD, 1)
            else if earlyD < 0 and lateD < earlyD
                pattern := "ACCELERATION_SELL"
                confidence := math.abs(lateD) / math.max(math.abs(earlyD), 1)
    [earlyD, midD, lateD, lateD - earlyD, pattern, confidence, peak, trough, size]
[earlyDelta, midDelta, lateDelta, deltaAccel, deltaPattern, patternConfidence, deltaPeak, deltaTrough, seqSize] = f_analyzeSequence()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SIGNAL DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
priceSlope = (close - close[divLookback]) / divLookback
cvdSlope = (cvd - cvd[divLookback]) / divLookback
priceStdev = ta.stdev(close - close[1], divLookback)
cvdStdev = ta.stdev(cvd - cvd[1], divLookback)
normPriceSlope = priceStdev > 0 ? priceSlope / priceStdev : 0.0
normCvdSlope = cvdStdev > 0 ? cvdSlope / cvdStdev : 0.0
bullishDivergence = enableDivergence and normPriceSlope < -divSensitivity and normCvdSlope > divSensitivity
bearishDivergence = enableDivergence and normPriceSlope > divSensitivity and normCvdSlope < -divSensitivity
deltaMean = array.size(deltaHistory) >= 20 ? array.avg(deltaHistory) : 0.0
deltaStdevCalc = array.size(deltaHistory) >= 20 ? array.stdev(deltaHistory) : 1.0
normalizedImbalance = deltaStdevCalc > 0 ? (barDelta - deltaMean) / deltaStdevCalc : 0.0
buyImbalance = enableImbalance and array.size(deltaHistory) >= 20 and normalizedImbalance > imbalanceThreshold
sellImbalance = enableImbalance and array.size(deltaHistory) >= 20 and normalizedImbalance < -imbalanceThreshold
if enableImbalance and showImbalanceZones and (buyImbalance or sellImbalance)
    array.push(imbalanceLevels, close)
    array.push(imbalanceTypes, buyImbalance)
    array.push(imbalanceBars, bar_index)
if enableImbalance and array.size(imbalanceBars) > 0
    while array.size(imbalanceBars) > 0
        int oldestBar = array.get(imbalanceBars, 0)
        if bar_index - oldestBar > imbalanceLookback
            array.shift(imbalanceLevels)
            array.shift(imbalanceTypes)
            array.shift(imbalanceBars)
        else
            break
    while array.size(imbalanceLevels) > maxImbalanceLines * 2
        array.shift(imbalanceLevels)
        array.shift(imbalanceTypes)
        array.shift(imbalanceBars)
currentRange = high - low
volumeRatio = avgVolume20 > 0 ? volume / avgVolume20 : 0.0
rangeRatio = atr20 > 0 ? currentRange / atr20 : 1.0
absorption = enableAbsorption and volumeRatio > minAbsorptionVolume and rangeRatio < (1 / absorptionSensitivity)
buyAbsorption = absorption and barDelta > 0 and close >= high[1]
sellAbsorption = absorption and barDelta < 0 and close <= low[1]
if enableAbsorption and (buyAbsorption or sellAbsorption)
    array.push(absorptionLevels, close)
    array.push(absorptionBars, bar_index)
    array.push(absorptionTypes, buyAbsorption)
if enableAbsorption and array.size(absorptionBars) > 0
    while array.size(absorptionBars) > 0
        int oldestBar = array.get(absorptionBars, 0)
        if bar_index - oldestBar > absorptionLookback
            array.shift(absorptionLevels)
            array.shift(absorptionBars)
            array.shift(absorptionTypes)
        else
            break
    while array.size(absorptionLevels) > maxAbsorptionLines * 2
        array.shift(absorptionLevels)
        array.shift(absorptionBars)
        array.shift(absorptionTypes)
isExhaustionBuy = deltaPattern == "EXHAUSTION_BUY"
isExhaustionSell = deltaPattern == "EXHAUSTION_SELL"
strongBuySignal = bullishDivergence or isExhaustionSell or buyImbalance or buyAbsorption
strongSellSignal = bearishDivergence or isExhaustionBuy or sellImbalance or sellAbsorption
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ KILL ZONE DETECTION 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
significantBuyDelta = barDelta > deltaStdevCalc * 1.5 and totalBarVolume > avgVolume20 * 1.2
significantSellDelta = barDelta < -deltaStdevCalc * 1.5 and totalBarVolume > avgVolume20 * 1.2
f_zoneExistsNear(array<float> levels, float checkLevel, float minDist) =>
    bool exists = false
    if array.size(levels) > 0
        for i = 0 to array.size(levels) - 1
            if math.abs(array.get(levels, i) - checkLevel) < minDist
                exists := true
                break
    exists
if enableZones and significantBuyDelta
    zoneLevel = low
    minDistanceAtr = nz(atr14, 1.0) * zoneMinDistance
    if not f_zoneExistsNear(demandZoneLevels, zoneLevel, minDistanceAtr)
        if array.size(demandZoneLevels) >= maxZones
            array.shift(demandZoneLevels)
            array.shift(demandZoneStrengths)
            array.shift(demandZoneBars)
            array.shift(demandZoneDeltas)
        array.push(demandZoneLevels, zoneLevel)
        array.push(demandZoneStrengths, math.min(normalizedImbalance * 30 + 50, 100.0))
        array.push(demandZoneBars, bar_index)
        array.push(demandZoneDeltas, barDelta)
if enableZones and significantSellDelta
    zoneLevel = high
    minDistanceAtr = nz(atr14, 1.0) * zoneMinDistance
    if not f_zoneExistsNear(supplyZoneLevels, zoneLevel, minDistanceAtr)
        if array.size(supplyZoneLevels) >= maxZones
            array.shift(supplyZoneLevels)
            array.shift(supplyZoneStrengths)
            array.shift(supplyZoneBars)
            array.shift(supplyZoneDeltas)
        array.push(supplyZoneLevels, zoneLevel)
        array.push(supplyZoneStrengths, math.min(math.abs(normalizedImbalance) * 30 + 50, 100.0))
        array.push(supplyZoneBars, bar_index)
        array.push(supplyZoneDeltas, barDelta)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§ª OPTIMIZER ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var float optEntryPrice = na
var bool optInTrade = false
var bool optIsLong = false
var int btTotalTrades = 0
var int btWins = 0
var float btGrossProfit = 0.0
var float btGrossLoss = 0.0
bool optBuySignal = switch optSignalType
    "Strong Signals" => strongBuySignal
    "All Signals" => strongBuySignal or (barDelta > deltaStdevCalc * 1.5)
    "Divergence Only" => bullishDivergence
    "Imbalance Only" => buyImbalance
    => strongBuySignal
bool optSellSignal = switch optSignalType
    "Strong Signals" => strongSellSignal
    "All Signals" => strongSellSignal or (barDelta < -deltaStdevCalc * 1.5)
    "Divergence Only" => bearishDivergence
    "Imbalance Only" => sellImbalance
    => strongSellSignal
if optMode
    if optInTrade
        slPrice = optIsLong ? optEntryPrice - (atr14 * optSL) : optEntryPrice + (atr14 * optSL)
        tpPrice = optIsLong ? optEntryPrice + (atr14 * optTP) : optEntryPrice - (atr14 * optTP)
        hitSL = optIsLong ? low <= slPrice : high >= slPrice
        hitTP = optIsLong ? high >= tpPrice : low <= tpPrice
        exitOnOpposite = optIsLong ? optSellSignal : optBuySignal
        if hitSL or hitTP or exitOnOpposite
            exitP = hitTP ? tpPrice : hitSL ? slPrice : close
            pnl = optIsLong ? (exitP - optEntryPrice) : (optEntryPrice - exitP)
            btTotalTrades += 1
            if pnl > 0
                btWins += 1
                btGrossProfit += pnl
            else
                btGrossLoss += math.abs(pnl)
            optInTrade := false
            optEntryPrice := na
    if not optInTrade
        if optBuySignal
            optInTrade := true
            optIsLong := true
            optEntryPrice := close
        else if optSellSignal
            optInTrade := true
            optIsLong := false
            optEntryPrice := close
btWinRate = btTotalTrades > 0 ? (btWins / btTotalTrades) * 100 : 0.0
btProfitFactor = btGrossLoss > 0 ? btGrossProfit / btGrossLoss : btGrossProfit > 0 ? 99.9 : 0.0
btExpectancy = btTotalTrades > 0 ? (btGrossProfit - btGrossLoss) / btTotalTrades : 0.0
stabilityPoints = 0
stabilityPoints += btWinRate >= 55 ? 25 : btWinRate >= 50 ? 15 : btWinRate >= 45 ? 5 : 0
stabilityPoints += btExpectancy > 0.5 ? 25 : btExpectancy > 0.1 ? 15 : btExpectancy > 0 ? 5 : 0
stabilityPoints += btTotalTrades >= 30 ? 25 : btTotalTrades >= 20 ? 15 : btTotalTrades >= 10 ? 5 : 0
stabilityPoints += btProfitFactor >= 1.5 ? 25 : btProfitFactor >= 1.2 ? 15 : btProfitFactor >= 1.0 ? 5 : 0
robustText = stabilityPoints >= 80 ? "ROBUST" : stabilityPoints >= 60 ? "STABLE" : stabilityPoints >= 40 ? "FRAGILE" : "OVERFIT"
robustCol = stabilityPoints >= 80 ? bullColor : stabilityPoints >= 60 ? accentColor1 : stabilityPoints >= 40 ? accentColor3 : bearColor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“‰ VISUALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deltaMax = ta.highest(math.abs(barDelta), 50)
deltaIntensity = deltaMax > 0 ? math.min(math.abs(barDelta) / deltaMax, 1.0) : 0.0
smoothedDelta = ta.ema(barDelta, 3)
deltaVelocity = barDelta - nz(barDelta[1])
deltaMomentum = ta.ema(deltaVelocity, 5)
float animPhase = (bar_index % (100 / vizAnimationSpeed)) / (100.0 / vizAnimationSpeed)
float pulseWave = math.sin(animPhase * 2 * math.pi)
float breathe = 0.7 + 0.3 * pulseWave
cvdMomentum = cvd - nz(cvd[3])
cvdFlow = ta.ema(cvdMomentum, 5)
flowStrength = ta.highest(math.abs(cvdFlow), 20)
normalizedFlow = flowStrength > 0 ? cvdFlow / flowStrength : 0
buyPressure = barBuyVolume / math.max(totalBarVolume, 1)
sellPressure = barSellVolume / math.max(totalBarVolume, 1)
originalDeltaColor = barDelta > 0 ? 
     color.from_gradient(deltaIntensity, 0, 1, color.new(bullColor, 70 + originalLayerOpacity), color.new(bullColor, originalLayerOpacity)) :
     color.from_gradient(deltaIntensity, 0, 1, color.new(bearColor, 70 + originalLayerOpacity), color.new(bearColor, originalLayerOpacity))
plot(showOriginalVisuals and showDelta ? barDelta : na, "â˜… Delta Histogram", color=originalDeltaColor, style=plot.style_columns, linewidth=4)
seqTotal = math.abs(earlyDelta) + math.abs(midDelta) + math.abs(lateDelta)
sparkleBase = seqTotal > 0 ? math.max(seqTotal * 0.15, deltaMax * 0.05) : deltaMax * 0.05
earlySparkle = showOriginalVisuals and showSequence and seqSize >= 3 and earlyDelta != 0 ? sparkleBase * 0.4 * math.sign(earlyDelta) : na
midSparkle = showOriginalVisuals and showSequence and seqSize >= 3 and midDelta != 0 ? sparkleBase * 0.7 * math.sign(midDelta) : na
lateSparkle = showOriginalVisuals and showSequence and seqSize >= 3 and lateDelta != 0 ? sparkleBase * 1.0 * math.sign(lateDelta) : na
plot(earlySparkle, "âœ¦ Early", color=color.new(accentColor1, originalLayerOpacity), style=plot.style_circles, linewidth=2)
plot(midSparkle, "âœ¦ Mid", color=color.new(accentColor2, originalLayerOpacity), style=plot.style_circles, linewidth=3)
plot(lateSparkle, "âœ¦ Late", color=color.new(accentColor3, originalLayerOpacity), style=plot.style_circles, linewidth=4)
showPeakMarker = showOriginalVisuals and showPeaksTroughs and deltaPeak > math.abs(deltaTrough) * 1.5 and seqSize >= 3
showTroughMarker = showOriginalVisuals and showPeaksTroughs and math.abs(deltaTrough) > deltaPeak * 1.5 and seqSize >= 3
plot(showPeakMarker ? deltaPeak * 0.8 : na, "Peak âœš", color=color.new(peakColor, originalLayerOpacity), style=plot.style_cross, linewidth=3)
plot(showTroughMarker ? deltaTrough * 0.8 : na, "Trough âœš", color=color.new(troughColor, originalLayerOpacity), style=plot.style_cross, linewidth=3)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ã€°ï¸ ORIGINAL IMBALANCE LINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
imbalancePlotValue = showOriginalVisuals and showImbalanceLine and enableImbalance ? normalizedImbalance * deltaStdevCalc * 0.5 : na
plot(imbalancePlotValue, "Imbalance ã€°ï¸", color=color.new(imbalanceColor, 30 + originalLayerOpacity), style=plot.style_stepline, linewidth=2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š ORIGINAL ACCELERATION AREA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
accelPlotValue = showOriginalVisuals and showAcceleration ? deltaAccel * 0.3 : na
accelColor = deltaAccel > 0 ? color.new(bullColor, 75 + int(originalLayerOpacity * 0.3)) : color.new(bearColor, 75 + int(originalLayerOpacity * 0.3))
plot(accelPlotValue, "Acceleration", color=accelColor, style=plot.style_area, histbase=0)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â”€ ZERO LINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
plot(0, "Zero", color=color.new(neutralColor, 50), linewidth=1)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒˆ BIAS BACKGROUND
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
biasStrength = deltaMax > 0 ? barDelta / deltaMax : 0
bgcolor(showOriginalVisuals and biasStrength > 0.3 ? color.new(bullColor, 92) : showOriginalVisuals and biasStrength < -0.3 ? color.new(bearColor, 92) : na, title="Bias")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒŒ VISUALIZATION MODES (Layered Below Original)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float nebula_core = na
float nebula_ring1 = na
float nebula_ring2 = na
color nebula_coreColor = na
color nebula_ringColor = na
if vizMode == "1: Nebula Pulse"
    float ringExpansion = deltaIntensity * vizIntensity
    nebula_core := barDelta * 0.7
    nebula_ring1 := barDelta * (1 + ringExpansion * 0.4 * breathe) * 0.7
    nebula_ring2 := barDelta * (1 + ringExpansion * 0.7 * (1 - breathe * 0.5)) * 0.7
    float coreEnergy = math.min(deltaIntensity * 1.5, 1.0)
    if barDelta > 0
        nebula_coreColor := color.from_gradient(coreEnergy, 0, 1, color.new(bullColor, 50), color.new(bullColor, 20))
        nebula_ringColor := color.new(accentColor1, int(60 + (1 - coreEnergy) * 30))
    else
        nebula_coreColor := color.from_gradient(coreEnergy, 0, 1, color.new(bearColor, 50), color.new(bearColor, 20))
        nebula_ringColor := color.new(#FF6600, int(60 + (1 - coreEnergy) * 30))
plot(vizMode == "1: Nebula Pulse" and showGlowEffects ? nebula_ring2 : na, "Nebula Ring 2", color=color.new(nebula_ringColor, 70), style=plot.style_area, linewidth=1)
plot(vizMode == "1: Nebula Pulse" and showGlowEffects ? nebula_ring1 : na, "Nebula Ring 1", color=color.new(nebula_ringColor, 50), style=plot.style_area, linewidth=1)
float vizCore = na
color vizCoreColor = na
if vizMode == "2: Tectonic Plates"
    vizCore := smoothedDelta * 0.8
    float stress = math.abs(normalizedFlow) * vizIntensity
    vizCoreColor := barDelta > 0 ? color.from_gradient(stress, 0, 1, #4A3728, #CD853F) : color.from_gradient(stress, 0, 1, #2F4F4F, #5F9EA0)
if vizMode == "3: DNA Helix"
    float helixAngle = bar_index * 0.15 * vizAnimationSpeed
    vizCore := barDelta * 0.8 + math.sin(helixAngle) * deltaMax * 0.3 * vizIntensity
    vizCoreColor := barDelta > 0 ? color.new(#00FF88, 40) : color.new(#FF0066, 40)
if vizMode == "4: Aurora Borealis"
    float wave1 = math.sin(bar_index * 0.08 * vizAnimationSpeed)
    float flowIntensity = math.abs(normalizedFlow) * vizIntensity
    vizCore := barDelta * 0.8 + wave1 * deltaMax * 0.3 * flowIntensity
    if barDelta > 0
        vizCoreColor := color.from_gradient(flowIntensity, 0, 1, color.new(#00FF7F, 50), color.new(#00FFFF, 30))
    else
        vizCoreColor := color.from_gradient(flowIntensity, 0, 1, color.new(#FF69B4, 50), color.new(#FF00FF, 30))
if vizMode == "5: Radar Sweep"
    float sweepIntensity = 1 - ((bar_index % 20) / 20.0)
    vizCore := barDelta * sweepIntensity * 0.8
    vizCoreColor := color.new(#00FF00, int(30 + (1 - sweepIntensity) * 50))
if vizMode == "6: Holographic Prism"
    vizCore := smoothedDelta * 0.8
    float prismIntensity = deltaIntensity * vizIntensity
    vizCoreColor := color.from_gradient(prismIntensity, 0, 1, color.new(#00FFFF, 50), color.new(#FF00FF, 20))
plot(vizMode != "OFF: Original Only" ? vizCore : na, "Viz Core", color=vizCoreColor, style=plot.style_area, linewidth=2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ã€°ï¸ MAIN CHART OVERLAYS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
cvdMA := ta.sma(cvd, 50)
cvdStdDevVal = ta.stdev(cvd, 50)
priceStdDevChart = ta.stdev(close, 50)
priceMa = ta.sma(close, 50)
cvdAligned = priceMa + ((cvd - cvdMA) / math.max(cvdStdDevVal, 1)) * priceStdDevChart
cvdWaveColor = cvd > cvd[1] ? bullColor : bearColor
plot(showCVD ? cvdAligned : na, "CVD Wave", color=cvdWaveColor, linewidth=2, force_overlay=true)
plot(showCVD and showGlowEffects ? cvdAligned : na, "CVD Glow", color=color.new(cvdWaveColor, 70), linewidth=5, force_overlay=true)
ltfMomentum = ta.ema(ltfLastPrice - nz(ltfLastPrice[1]), 5)
ltfLineColor = ltfMomentum > 0 ? bullColor : bearColor
plot(showLTFLine ? ltfLastPrice : na, "LTF Price", color=ltfLineColor, linewidth=ltfLineWidth, force_overlay=true)
plot(showLTFLine and showLTFGlow ? ltfLastPrice : na, "LTF Glow", color=color.new(ltfLineColor, 70), linewidth=ltfLineWidth+3, force_overlay=true)
plotshape(strongBuySignal, "BUY", shape.triangleup, location.belowbar, color=bullColor, size=size.small, force_overlay=true)
plotshape(strongSellSignal, "SELL", shape.triangledown, location.abovebar, color=bearColor, size=size.small, force_overlay=true)
plotshape(bullishDivergence and not strongBuySignal, "DIV+", shape.circle, location.belowbar, color=accentColor1, size=size.tiny, force_overlay=true)
plotshape(bearishDivergence and not strongSellSignal, "DIV-", shape.circle, location.abovebar, color=accentColor2, size=size.tiny, force_overlay=true)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ KILL ZONES DRAWING 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if barstate.islast
    for b in zoneBoxes
        box.delete(b)
    array.clear(zoneBoxes)
    for lbl in zoneLabels
        label.delete(lbl)
    array.clear(zoneLabels)
    zoneHeight = nz(atr14, 1.0) * zoneSize
    if enableZones and array.size(demandZoneLevels) > 0
        for i = 0 to math.min(array.size(demandZoneLevels) - 1, maxZones - 1)
            zoneLevel = array.get(demandZoneLevels, i)
            zoneStrengthVal = array.get(demandZoneStrengths, i)
            zoneDelta = array.get(demandZoneDeltas, i)
            zoneBar = array.get(demandZoneBars, i)
            if bar_index - zoneBar < zoneLookback
                strengthTrans = int(zoneTransparency - (zoneStrengthVal - 50) * 0.3)
                zoneCol = color.new(bullColor, strengthTrans)
                borderCol = color.new(bullColor, strengthTrans - 20)
                zoneBox = box.new(zoneBar, zoneLevel + zoneHeight, bar_index + 10, zoneLevel, 
                     bgcolor=zoneCol, border_color=borderCol, border_width=2, force_overlay=true)
                array.push(zoneBoxes, zoneBox)
                if showZoneLabels
                    strengthPct = str.tostring(math.round(zoneStrengthVal)) + "%"
                    deltaStr = "Î”" + str.tostring(math.round(zoneDelta / 1000, 1)) + "K"
                    labelText = "ğŸŸ¢ DEMAND | " + strengthPct + " | " + deltaStr
                    zoneLbl = label.new(bar_index + 12, zoneLevel + zoneHeight * 0.5, labelText, 
                         style=label.style_label_left, color=color.new(bullColor, 70), 
                         textcolor=color.white, size=size.small, force_overlay=true)
                    array.push(zoneLabels, zoneLbl)
    if enableZones and array.size(supplyZoneLevels) > 0
        for i = 0 to math.min(array.size(supplyZoneLevels) - 1, maxZones - 1)
            zoneLevel = array.get(supplyZoneLevels, i)
            zoneStrengthVal = array.get(supplyZoneStrengths, i)
            zoneDelta = array.get(supplyZoneDeltas, i)
            zoneBar = array.get(supplyZoneBars, i)
            if bar_index - zoneBar < zoneLookback
                strengthTrans = int(zoneTransparency - (zoneStrengthVal - 50) * 0.3)
                zoneCol = color.new(bearColor, strengthTrans)
                borderCol = color.new(bearColor, strengthTrans - 20)
                zoneBox = box.new(zoneBar, zoneLevel, bar_index + 10, zoneLevel - zoneHeight, 
                     bgcolor=zoneCol, border_color=borderCol, border_width=2, force_overlay=true)
                array.push(zoneBoxes, zoneBox)
                if showZoneLabels
                    strengthPct = str.tostring(math.round(zoneStrengthVal)) + "%"
                    deltaStr = "Î”" + str.tostring(math.round(math.abs(zoneDelta) / 1000, 1)) + "K"
                    labelText = "ğŸ”´ SUPPLY | " + strengthPct + " | " + deltaStr
                    zoneLbl = label.new(bar_index + 12, zoneLevel - zoneHeight * 0.5, labelText, 
                         style=label.style_label_left, color=color.new(bearColor, 70), 
                         textcolor=color.white, size=size.small, force_overlay=true)
                    array.push(zoneLabels, zoneLbl)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ SIGNAL & IMBALANCE LINES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_cleanupLineArray(signalLines, maxSignalLines)
f_cleanupLabelArray(signalLabels, maxSignalLines)
if showSignalLevels and (strongBuySignal or strongSellSignal)
    lvlCol = strongBuySignal ? bullColor : bearColor
    lvlTxt = strongBuySignal ? "â˜… BUY" : "â˜… SELL"
    sigLine = line.new(bar_index, close, bar_index + 25, close, color=color.new(lvlCol, 40), style=line.style_dashed, width=2, force_overlay=true)
    array.push(signalLines, sigLine)
    sigLbl = label.new(bar_index + 26, close, lvlTxt, style=label.style_label_left, color=color.new(lvlCol, 80), textcolor=lvlCol, size=size.small, force_overlay=true)
    array.push(signalLabels, sigLbl)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš–ï¸ IMBALANCE LINES DRAWING 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if barstate.islast or barstate.isconfirmed
    for ln in imbLines
        line.delete(ln)
    array.clear(imbLines)
    for lbl in imbLabels
        label.delete(lbl)
    array.clear(imbLabels)
if enableImbalance and showImbalanceZones and barstate.islast and array.size(imbalanceLevels) > 0
    int imbCount = array.size(imbalanceLevels)
    int showCount = math.min(imbCount, maxImbalanceLines)
    for i = 0 to showCount - 1
        int idx = imbCount - 1 - i
        if idx >= 0
            float level = array.get(imbalanceLevels, idx)
            bool isBullImb = array.get(imbalanceTypes, idx)
            int storedBar = array.get(imbalanceBars, idx)
            if bar_index - storedBar <= imbalanceLookback
                float age = bar_index - storedBar
                float agePct = age / imbalanceLookback
                int fadeTransparency = int(30 + agePct * 50)  
                color imbCol = isBullImb ? bullColor : bearColor
                imbLine = line.new(storedBar, level, bar_index + 10, level, 
                     color=color.new(imbCol, fadeTransparency), 
                     style=line.style_dotted, width=2, force_overlay=true)
                array.push(imbLines, imbLine)
                if agePct < 0.5
                    string imbText = isBullImb ? "IMB â–²" : "IMB â–¼"
                    imbLbl = label.new(bar_index + 11, level, imbText, 
                         style=label.style_label_left, 
                         color=color.new(imbCol, fadeTransparency + 10), 
                         textcolor=color.white, size=size.tiny, force_overlay=true)
                    array.push(imbLabels, imbLbl)
if barstate.islast or barstate.isconfirmed
    for ln in absLines
        line.delete(ln)
    array.clear(absLines)
    for lbl in absLabels
        label.delete(lbl)
    array.clear(absLabels)
if enableAbsorption and barstate.islast and array.size(absorptionLevels) > 0
    int absCount = array.size(absorptionLevels)
    int showCount = math.min(absCount, maxAbsorptionLines)
    for i = 0 to showCount - 1
        int idx = absCount - 1 - i
        if idx >= 0
            float level = array.get(absorptionLevels, idx)
            int storedBar = array.get(absorptionBars, idx)
            bool isBullAbs = array.get(absorptionTypes, idx)
            if bar_index - storedBar <= absorptionLookback
                float age = bar_index - storedBar
                float agePct = age / absorptionLookback
                int fadeTransparency = int(20 + agePct * 50)  
                color absCol = isBullAbs ? bullColor : bearColor
                absLine = line.new(storedBar, level, bar_index + 5, level, 
                     color=color.new(absCol, fadeTransparency), 
                     style=line.style_solid, width=3, force_overlay=true)
                array.push(absLines, absLine)
                if agePct < 0.5
                    string absText = isBullAbs ? "ABS â–²" : "ABS â–¼"
                    absLbl = label.new(bar_index + 6, level, absText, 
                         style=label.style_label_left, 
                         color=color.new(absCol, fadeTransparency + 20), 
                         textcolor=color.white, size=size.tiny, force_overlay=true)
                    array.push(absLabels, absLbl)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ MTF HORIZON 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float currentRSI = ta.rsi(close, 14)
float currentDeltaFlow = ta.ema(barDelta, 8)
float currentMomentum = ta.mom(close, 10)
float currentVolatility = ta.atr(14) / close * 100
[currentMACD, currentSignal, currentHist] = ta.macd(close, 12, 26, 9)
float currentStochK = ta.stoch(close, high, low, 14)
float currentBuyPressure = barDelta > 0 ? barDelta : 0.0
float currentSellPressure = barDelta < 0 ? math.abs(barDelta) : 0.0
f_getMetricValue(string metric, float cvdVal, float volVal, float rsiVal, float deltaFlowVal, float momVal, float volatilityVal, float macdVal, float stochVal, float buyPressVal, float sellPressVal) =>
    switch metric
        "CVD" => cvdVal
        "Volume" => volVal
        "Volatility" => volatilityVal
        "RSI" => rsiVal
        "Delta Flow" => deltaFlowVal
        "Buy Pressure" => buyPressVal
        "Sell Pressure" => sellPressVal
        "Momentum" => momVal
        "MACD" => macdVal
        "Stochastic" => stochVal
        => cvdVal
[mtf1_cvd, mtf1_vol, mtf1_rsi, mtf1_deltaFlow, mtf1_mom, mtf1_volatility, mtf1_macd, mtf1_stoch, mtf1_buyPress, mtf1_sellPress] = 
     request.security(syminfo.tickerid, mtfHorizon1TF, 
     [cvd, volume, currentRSI, currentDeltaFlow, currentMomentum, currentVolatility, currentMACD, currentStochK, currentBuyPressure, currentSellPressure], 
     lookahead=barmerge.lookahead_off)
[mtf2_cvd, mtf2_vol, mtf2_rsi, mtf2_deltaFlow, mtf2_mom, mtf2_volatility, mtf2_macd, mtf2_stoch, mtf2_buyPress, mtf2_sellPress] = 
     request.security(syminfo.tickerid, mtfHorizon2TF, 
     [cvd, volume, currentRSI, currentDeltaFlow, currentMomentum, currentVolatility, currentMACD, currentStochK, currentBuyPressure, currentSellPressure], 
     lookahead=barmerge.lookahead_off)
[mtf3_cvd, mtf3_vol, mtf3_rsi, mtf3_deltaFlow, mtf3_mom, mtf3_volatility, mtf3_macd, mtf3_stoch, mtf3_buyPress, mtf3_sellPress] = 
     request.security(syminfo.tickerid, mtfHorizon3TF, 
     [cvd, volume, currentRSI, currentDeltaFlow, currentMomentum, currentVolatility, currentMACD, currentStochK, currentBuyPressure, currentSellPressure], 
     lookahead=barmerge.lookahead_off)
float mtf1_metric = f_getMetricValue(mtfHorizon1Metric, nz(mtf1_cvd), nz(mtf1_vol), nz(mtf1_rsi), nz(mtf1_deltaFlow), nz(mtf1_mom), nz(mtf1_volatility), nz(mtf1_macd), nz(mtf1_stoch), nz(mtf1_buyPress), nz(mtf1_sellPress))
float mtf2_metric = f_getMetricValue(mtfHorizon2Metric, nz(mtf2_cvd), nz(mtf2_vol), nz(mtf2_rsi), nz(mtf2_deltaFlow), nz(mtf2_mom), nz(mtf2_volatility), nz(mtf2_macd), nz(mtf2_stoch), nz(mtf2_buyPress), nz(mtf2_sellPress))
float mtf3_metric = f_getMetricValue(mtfHorizon3Metric, nz(mtf3_cvd), nz(mtf3_vol), nz(mtf3_rsi), nz(mtf3_deltaFlow), nz(mtf3_mom), nz(mtf3_volatility), nz(mtf3_macd), nz(mtf3_stoch), nz(mtf3_buyPress), nz(mtf3_sellPress))
if barstate.isconfirmed or barstate.islast
    array.unshift(mtf1_history, mtf1_metric)
    if array.size(mtf1_history) > mtfHorizonDepth
        array.pop(mtf1_history)
    array.unshift(mtf2_history, mtf2_metric)
    if array.size(mtf2_history) > mtfHorizonDepth
        array.pop(mtf2_history)
    array.unshift(mtf3_history, mtf3_metric)
    if array.size(mtf3_history) > mtfHorizonDepth
        array.pop(mtf3_history)
f_formatTF(string tf) =>
    int seconds = timeframe.in_seconds(tf)
    int minutes = seconds / 60
    int hours = minutes / 60
    int days = hours / 24
    hours >= 24 ? str.tostring(days) + "D" : hours >= 1 ? str.tostring(hours) + "H" : str.tostring(minutes) + "m"
f_metricShort(string metric) =>
    switch metric
        "CVD" => "CVD"
        "Volume" => "VOL"
        "Volatility" => "ATR%"
        "RSI" => "RSI"
        "Delta Flow" => "FLOW"
        "Buy Pressure" => "BUY"
        "Sell Pressure" => "SELL"
        "Momentum" => "MOM"
        "MACD" => "MACD"
        "Stochastic" => "STOCH"
        => "MTF"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ MTF HORIZON - DRAWING ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var array<chart.point> h1_points = array.new<chart.point>()
var array<chart.point> h2_points = array.new<chart.point>()
var array<chart.point> h3_points = array.new<chart.point>()
var polyline h1_wave = na
var polyline h2_wave = na
var polyline h3_wave = na
var polyline h1_glow = na
var polyline h2_glow = na
var polyline h3_glow = na
var box h1_bg = na
var box h2_bg = na
var box h3_bg = na
var box h1_header = na
var box h2_header = na
var box h3_header = na
var label h1_title = na
var label h2_title = na
var label h3_title = na
var label h1_value = na
var label h2_value = na
var label h3_value = na
var label h1_trend = na
var label h2_trend = na
var label h3_trend = na
var line h1_zero = na
var line h2_zero = na
var line h3_zero = na
var line h1_border_top = na
var line h1_border_bot = na
var line h2_border_top = na
var line h2_border_bot = na
var line h3_border_top = na
var line h3_border_bot = na
var array<box> h1_bars = array.new<box>()
var array<box> h2_bars = array.new<box>()
var array<box> h3_bars = array.new<box>()
var array<line> h1_crystals = array.new<line>()
var array<line> h2_crystals = array.new<line>()
var array<line> h3_crystals = array.new<line>()
int mtfLookbackBars = 300
float mtfChartHigh = ta.highest(high, mtfLookbackBars)
float mtfChartLow = ta.lowest(low, mtfLookbackBars)
float mtfChartRange = mtfChartHigh - mtfChartLow
if enableMTFHorizon and barstate.islast
    polyline.delete(h1_wave)
    polyline.delete(h2_wave)
    polyline.delete(h3_wave)
    polyline.delete(h1_glow)
    polyline.delete(h2_glow)
    polyline.delete(h3_glow)
    box.delete(h1_bg)
    box.delete(h2_bg)
    box.delete(h3_bg)
    box.delete(h1_header)
    box.delete(h2_header)
    box.delete(h3_header)
    label.delete(h1_title)
    label.delete(h2_title)
    label.delete(h3_title)
    label.delete(h1_value)
    label.delete(h2_value)
    label.delete(h3_value)
    label.delete(h1_trend)
    label.delete(h2_trend)
    label.delete(h3_trend)
    line.delete(h1_zero)
    line.delete(h2_zero)
    line.delete(h3_zero)
    line.delete(h1_border_top)
    line.delete(h1_border_bot)
    line.delete(h2_border_top)
    line.delete(h2_border_bot)
    line.delete(h3_border_top)
    line.delete(h3_border_bot)
    for b in h1_bars
        box.delete(b)
    array.clear(h1_bars)
    for b in h2_bars
        box.delete(b)
    array.clear(h2_bars)
    for b in h3_bars
        box.delete(b)
    array.clear(h3_bars)
    for ln in h1_crystals
        line.delete(ln)
    array.clear(h1_crystals)
    for ln in h2_crystals
        line.delete(ln)
    array.clear(h2_crystals)
    for ln in h3_crystals
        line.delete(ln)
    array.clear(h3_crystals)
    float boxHeight = mtfChartRange * mtfHorizonHeight / 100
    bool displayTop = mtfHorizonLocation == "Top"
    float verticalBase = displayTop ? mtfChartHigh + (mtfChartRange * 0.02) : mtfChartLow - boxHeight - (mtfChartRange * 0.02)
    float boxTop = verticalBase + boxHeight
    float boxBottom = verticalBase
    int activeCount = (mtfHorizon1Show ? 1 : 0) + (mtfHorizon2Show ? 1 : 0) + (mtfHorizon3Show ? 1 : 0)
    int baseX = bar_index + mtfHorizonOffset
    int currentX = baseX
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HORIZON 1 DRAWING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if mtfHorizon1Show
        int h1_left = currentX
        int h1_right = h1_left + mtfBoxWidth
        h1_bg := box.new(h1_left, boxTop, h1_right, boxBottom, 
             bgcolor=color.new(mtfHorizon1Color, 85), 
             border_color=color.new(mtfHorizon1Color, 40), 
             border_width=2, force_overlay=true)
        float headerHeight = boxHeight * 0.12
        h1_header := box.new(h1_left, boxTop, h1_right, boxTop - headerHeight,
             bgcolor=color.new(mtfHorizon1Color, 60),
             border_color=color.new(mtfHorizon1Color, 30),
             border_width=1, force_overlay=true)
        float h1_mid = (boxTop + boxBottom) / 2
        h1_zero := line.new(h1_left, h1_mid, h1_right, h1_mid, 
             color=color.new(color.white, 70), style=line.style_dotted, width=1, force_overlay=true)
        if mtfShowLabels
            string h1_titleText = f_metricShort(mtfHorizon1Metric) + " " + f_formatTF(mtfHorizon1TF)
            h1_title := label.new(h1_left + int(mtfBoxWidth / 2), boxTop - headerHeight / 2, h1_titleText,
                 style=label.style_none, textcolor=color.white, size=size.small, force_overlay=true)
        if mtfShowTrend
            bool h1_up = mtf1_metric > nz(mtf1_metric[1])
            string h1_arrow = h1_up ? "â–²" : "â–¼"
            color h1_arrowCol = h1_up ? bullColor : bearColor
            h1_trend := label.new(h1_right - 3, boxTop - headerHeight / 2, h1_arrow,
                 style=label.style_none, textcolor=h1_arrowCol, size=size.normal, force_overlay=true)
        if mtfShowValues
            string h1_valText = str.tostring(mtf1_metric, "#.##")
            color h1_valCol = mtf1_metric >= 0 ? bullColor : bearColor
            h1_value := label.new(h1_left + int(mtfBoxWidth / 2), boxBottom + boxHeight * 0.08, h1_valText,
                 style=label.style_none, textcolor=h1_valCol, size=size.small, force_overlay=true)
        array.clear(h1_points)
        int histSize1 = math.min(array.size(mtf1_history), mtfHorizonDepth)
        if histSize1 > 1
            float minVal1 = array.min(mtf1_history)
            float maxVal1 = array.max(mtf1_history)
            float valueRange1 = maxVal1 - minVal1
            if valueRange1 == 0
                valueRange1 := 1.0
            float waveTop = boxTop - headerHeight - boxHeight * 0.05
            float waveBottom = boxBottom + boxHeight * 0.08
            float waveHeight = waveTop - waveBottom
            if mtfHorizonStyle == "Flowing Wave" or mtfHorizonStyle == "Neon Pulse"
                for idx = 0 to histSize1 - 1
                    float val = array.get(mtf1_history, idx)
                    float normalized = (val - minVal1) / valueRange1
                    float priceY = waveBottom + (normalized * waveHeight)
                    int barX = h1_right - int(idx * mtfBoxWidth / histSize1)
                    array.push(h1_points, chart.point.from_index(barX, priceY))
                if array.size(h1_points) > 1
                    if mtfGlowEffect
                        int glowWidth = mtfHorizonStyle == "Neon Pulse" ? 8 : 5
                        h1_glow := polyline.new(h1_points, line_color=color.new(mtfHorizon1Color, 60), line_width=glowWidth, force_overlay=true)
                    int waveWidth = mtfHorizonStyle == "Neon Pulse" ? 3 : 2
                    h1_wave := polyline.new(h1_points, line_color=mtfHorizon1Color, line_width=waveWidth, force_overlay=true)
            else if mtfHorizonStyle == "Gradient Bars"
                int barCount = math.min(histSize1, 20)
                float barWidth = mtfBoxWidth / barCount
                for idx = 0 to barCount - 1
                    float val = array.get(mtf1_history, idx)
                    float normalized = (val - minVal1) / valueRange1
                    float barTop = waveBottom + (normalized * waveHeight)
                    int barLeft = h1_right - int((idx + 1) * barWidth)
                    int barRight = h1_right - int(idx * barWidth) - 1
                    int trans = int(80 - normalized * 50)
                    color barCol = val >= 0 ? color.new(mtfHorizon1Color, trans) : color.new(bearColor, trans)
                    gradBar = box.new(barLeft, barTop, barRight, waveBottom, bgcolor=barCol, border_color=na, force_overlay=true)
                    array.push(h1_bars, gradBar)
            else if mtfHorizonStyle == "Crystal Shards"
                for idx = 0 to histSize1 - 2
                    float val1 = array.get(mtf1_history, idx)
                    float val2 = array.get(mtf1_history, idx + 1)
                    float norm1 = (val1 - minVal1) / valueRange1
                    float norm2 = (val2 - minVal1) / valueRange1
                    float y1 = waveBottom + (norm1 * waveHeight)
                    float y2 = waveBottom + (norm2 * waveHeight)
                    int x1 = h1_right - int(idx * mtfBoxWidth / histSize1)
                    int x2 = h1_right - int((idx + 1) * mtfBoxWidth / histSize1)
                    int crystalWidth = int(3 - idx * 0.1)
                    if crystalWidth < 1
                        crystalWidth := 1
                    crystalLine = line.new(x1, y1, x2, y2, color=mtfHorizon1Color, width=crystalWidth, force_overlay=true)
                    array.push(h1_crystals, crystalLine)
                    if mtfGlowEffect and idx % 3 == 0
                        glowLine = line.new(x1, y1, x2, y2, color=color.new(mtfHorizon1Color, 60), width=crystalWidth + 3, force_overlay=true)
                        array.push(h1_crystals, glowLine)
        currentX := h1_right + mtfBoxSpacing
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HORIZON 2 DRAWING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if mtfHorizon2Show
        int h2_left = currentX
        int h2_right = h2_left + mtfBoxWidth
        h2_bg := box.new(h2_left, boxTop, h2_right, boxBottom, 
             bgcolor=color.new(mtfHorizon2Color, 85), 
             border_color=color.new(mtfHorizon2Color, 40), 
             border_width=2, force_overlay=true)
        float headerHeight2 = boxHeight * 0.12
        h2_header := box.new(h2_left, boxTop, h2_right, boxTop - headerHeight2,
             bgcolor=color.new(mtfHorizon2Color, 60),
             border_color=color.new(mtfHorizon2Color, 30),
             border_width=1, force_overlay=true)
        float h2_mid = (boxTop + boxBottom) / 2
        h2_zero := line.new(h2_left, h2_mid, h2_right, h2_mid, 
             color=color.new(color.white, 70), style=line.style_dotted, width=1, force_overlay=true)
        if mtfShowLabels
            string h2_titleText = f_metricShort(mtfHorizon2Metric) + " " + f_formatTF(mtfHorizon2TF)
            h2_title := label.new(h2_left + int(mtfBoxWidth / 2), boxTop - headerHeight2 / 2, h2_titleText,
                 style=label.style_none, textcolor=color.white, size=size.small, force_overlay=true)
        if mtfShowTrend
            bool h2_up = mtf2_metric > nz(mtf2_metric[1])
            string h2_arrow = h2_up ? "â–²" : "â–¼"
            color h2_arrowCol = h2_up ? bullColor : bearColor
            h2_trend := label.new(h2_right - 3, boxTop - headerHeight2 / 2, h2_arrow,
                 style=label.style_none, textcolor=h2_arrowCol, size=size.normal, force_overlay=true)
        if mtfShowValues
            string h2_valText = str.tostring(mtf2_metric, "#.##")
            color h2_valCol = mtf2_metric >= 0 ? bullColor : bearColor
            h2_value := label.new(h2_left + int(mtfBoxWidth / 2), boxBottom + boxHeight * 0.08, h2_valText,
                 style=label.style_none, textcolor=h2_valCol, size=size.small, force_overlay=true)
        array.clear(h2_points)
        int histSize2 = math.min(array.size(mtf2_history), mtfHorizonDepth)
        if histSize2 > 1
            float minVal2 = array.min(mtf2_history)
            float maxVal2 = array.max(mtf2_history)
            float valueRange2 = maxVal2 - minVal2
            if valueRange2 == 0
                valueRange2 := 1.0
            float waveTop2 = boxTop - headerHeight2 - boxHeight * 0.05
            float waveBottom2 = boxBottom + boxHeight * 0.08
            float waveHeight2 = waveTop2 - waveBottom2
            if mtfHorizonStyle == "Flowing Wave" or mtfHorizonStyle == "Neon Pulse"
                for idx = 0 to histSize2 - 1
                    float val = array.get(mtf2_history, idx)
                    float normalized = (val - minVal2) / valueRange2
                    float priceY = waveBottom2 + (normalized * waveHeight2)
                    int barX = h2_right - int(idx * mtfBoxWidth / histSize2)
                    array.push(h2_points, chart.point.from_index(barX, priceY))
                if array.size(h2_points) > 1
                    if mtfGlowEffect
                        int glowWidth2 = mtfHorizonStyle == "Neon Pulse" ? 8 : 5
                        h2_glow := polyline.new(h2_points, line_color=color.new(mtfHorizon2Color, 60), line_width=glowWidth2, force_overlay=true)
                    int waveWidth2 = mtfHorizonStyle == "Neon Pulse" ? 3 : 2
                    h2_wave := polyline.new(h2_points, line_color=mtfHorizon2Color, line_width=waveWidth2, force_overlay=true)
            else if mtfHorizonStyle == "Gradient Bars"
                int barCount2 = math.min(histSize2, 20)
                float barWidth2 = mtfBoxWidth / barCount2
                for idx = 0 to barCount2 - 1
                    float val = array.get(mtf2_history, idx)
                    float normalized = (val - minVal2) / valueRange2
                    float barTopY = waveBottom2 + (normalized * waveHeight2)
                    int barLeft2 = h2_right - int((idx + 1) * barWidth2)
                    int barRight2 = h2_right - int(idx * barWidth2) - 1
                    int trans2 = int(80 - normalized * 50)
                    color barCol2 = val >= 0 ? color.new(mtfHorizon2Color, trans2) : color.new(bearColor, trans2)
                    gradBar2 = box.new(barLeft2, barTopY, barRight2, waveBottom2, bgcolor=barCol2, border_color=na, force_overlay=true)
                    array.push(h2_bars, gradBar2)
            else if mtfHorizonStyle == "Crystal Shards"
                for idx = 0 to histSize2 - 2
                    float val1 = array.get(mtf2_history, idx)
                    float val2 = array.get(mtf2_history, idx + 1)
                    float norm1 = (val1 - minVal2) / valueRange2
                    float norm2 = (val2 - minVal2) / valueRange2
                    float y1 = waveBottom2 + (norm1 * waveHeight2)
                    float y2 = waveBottom2 + (norm2 * waveHeight2)
                    int x1 = h2_right - int(idx * mtfBoxWidth / histSize2)
                    int x2 = h2_right - int((idx + 1) * mtfBoxWidth / histSize2)                    
                    int crystalWidth2 = int(3 - idx * 0.1)
                    if crystalWidth2 < 1
                        crystalWidth2 := 1
                    crystalLine2 = line.new(x1, y1, x2, y2, color=mtfHorizon2Color, width=crystalWidth2, force_overlay=true)
                    array.push(h2_crystals, crystalLine2)
                    if mtfGlowEffect and idx % 3 == 0
                        glowLine2 = line.new(x1, y1, x2, y2, color=color.new(mtfHorizon2Color, 60), width=crystalWidth2 + 3, force_overlay=true)
                        array.push(h2_crystals, glowLine2)
        currentX := h2_right + mtfBoxSpacing
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HORIZON 3 DRAWING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if mtfHorizon3Show
        int h3_left = currentX
        int h3_right = h3_left + mtfBoxWidth
        h3_bg := box.new(h3_left, boxTop, h3_right, boxBottom, 
             bgcolor=color.new(mtfHorizon3Color, 85), 
             border_color=color.new(mtfHorizon3Color, 40), 
             border_width=2, force_overlay=true)
        float headerHeight3 = boxHeight * 0.12
        h3_header := box.new(h3_left, boxTop, h3_right, boxTop - headerHeight3,
             bgcolor=color.new(mtfHorizon3Color, 60),
             border_color=color.new(mtfHorizon3Color, 30),
             border_width=1, force_overlay=true)
        float h3_mid = (boxTop + boxBottom) / 2
        h3_zero := line.new(h3_left, h3_mid, h3_right, h3_mid, 
             color=color.new(color.white, 70), style=line.style_dotted, width=1, force_overlay=true)
        if mtfShowLabels
            string h3_titleText = f_metricShort(mtfHorizon3Metric) + " " + f_formatTF(mtfHorizon3TF)
            h3_title := label.new(h3_left + int(mtfBoxWidth / 2), boxTop - headerHeight3 / 2, h3_titleText,
                 style=label.style_none, textcolor=color.white, size=size.small, force_overlay=true)
        if mtfShowTrend
            bool h3_up = mtf3_metric > nz(mtf3_metric[1])
            string h3_arrow = h3_up ? "â–²" : "â–¼"
            color h3_arrowCol = h3_up ? bullColor : bearColor
            h3_trend := label.new(h3_right - 3, boxTop - headerHeight3 / 2, h3_arrow,
                 style=label.style_none, textcolor=h3_arrowCol, size=size.normal, force_overlay=true)
        if mtfShowValues
            string h3_valText = str.tostring(mtf3_metric, "#.##")
            color h3_valCol = mtf3_metric >= 0 ? bullColor : bearColor
            h3_value := label.new(h3_left + int(mtfBoxWidth / 2), boxBottom + boxHeight * 0.08, h3_valText,
                 style=label.style_none, textcolor=h3_valCol, size=size.small, force_overlay=true)
        array.clear(h3_points)
        int histSize3 = math.min(array.size(mtf3_history), mtfHorizonDepth)
        if histSize3 > 1
            float minVal3 = array.min(mtf3_history)
            float maxVal3 = array.max(mtf3_history)
            float valueRange3 = maxVal3 - minVal3
            if valueRange3 == 0
                valueRange3 := 1.0
            float waveTop3 = boxTop - headerHeight3 - boxHeight * 0.05
            float waveBottom3 = boxBottom + boxHeight * 0.08
            float waveHeight3 = waveTop3 - waveBottom3
            if mtfHorizonStyle == "Flowing Wave" or mtfHorizonStyle == "Neon Pulse"
                for idx = 0 to histSize3 - 1
                    float val = array.get(mtf3_history, idx)
                    float normalized = (val - minVal3) / valueRange3
                    float priceY = waveBottom3 + (normalized * waveHeight3)
                    int barX = h3_right - int(idx * mtfBoxWidth / histSize3)
                    array.push(h3_points, chart.point.from_index(barX, priceY))
                if array.size(h3_points) > 1
                    if mtfGlowEffect
                        int glowWidth3 = mtfHorizonStyle == "Neon Pulse" ? 8 : 5
                        h3_glow := polyline.new(h3_points, line_color=color.new(mtfHorizon3Color, 60), line_width=glowWidth3, force_overlay=true)
                    int waveWidth3 = mtfHorizonStyle == "Neon Pulse" ? 3 : 2
                    h3_wave := polyline.new(h3_points, line_color=mtfHorizon3Color, line_width=waveWidth3, force_overlay=true)
            else if mtfHorizonStyle == "Gradient Bars"
                int barCount3 = math.min(histSize3, 20)
                float barWidth3 = mtfBoxWidth / barCount3
                for idx = 0 to barCount3 - 1
                    float val = array.get(mtf3_history, idx)
                    float normalized = (val - minVal3) / valueRange3
                    float barTopY3 = waveBottom3 + (normalized * waveHeight3)
                    int barLeft3 = h3_right - int((idx + 1) * barWidth3)
                    int barRight3 = h3_right - int(idx * barWidth3) - 1
                    int trans3 = int(80 - normalized * 50)
                    color barCol3 = val >= 0 ? color.new(mtfHorizon3Color, trans3) : color.new(bearColor, trans3)
                    gradBar3 = box.new(barLeft3, barTopY3, barRight3, waveBottom3, bgcolor=barCol3, border_color=na, force_overlay=true)
                    array.push(h3_bars, gradBar3)
            else if mtfHorizonStyle == "Crystal Shards"
                for idx = 0 to histSize3 - 2
                    float val1 = array.get(mtf3_history, idx)
                    float val2 = array.get(mtf3_history, idx + 1)
                    float norm1 = (val1 - minVal3) / valueRange3
                    float norm2 = (val2 - minVal3) / valueRange3
                    float y1 = waveBottom3 + (norm1 * waveHeight3)
                    float y2 = waveBottom3 + (norm2 * waveHeight3)
                    int x1 = h3_right - int(idx * mtfBoxWidth / histSize3)
                    int x2 = h3_right - int((idx + 1) * mtfBoxWidth / histSize3)
                    int crystalWidth3 = int(3 - idx * 0.1)
                    if crystalWidth3 < 1
                        crystalWidth3 := 1
                    crystalLine3 = line.new(x1, y1, x2, y2, color=mtfHorizon3Color, width=crystalWidth3, force_overlay=true)
                    array.push(h3_crystals, crystalLine3)
                    if mtfGlowEffect and idx % 3 == 0
                        glowLine3 = line.new(x1, y1, x2, y2, color=color.new(mtfHorizon3Color, 60), width=crystalWidth3 + 3, force_overlay=true)
                        array.push(h3_crystals, glowLine3)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“‹ DASHBOARD 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tablePos = switch panelPosition
    "Top Right" => position.top_right
    "Top Left" => position.top_left
    "Bottom Right" => position.bottom_right
    "Bottom Left" => position.bottom_left
    => position.top_right
sz = switch dashTextSize
    "Tiny" => size.tiny
    "Small" => size.small
    "Normal" => size.normal
    "Large" => size.large
    => size.small
szS = switch dashTextSize
    "Tiny" => size.tiny
    "Small" => size.tiny
    "Normal" => size.small
    "Large" => size.normal
    => size.tiny
var table dashOverlay = table.new(tablePos, 3, 18, bgcolor=color.new(bgColor, 5), border_width=0, frame_width=2, frame_color=color.new(frameColor, 40), force_overlay=true)
var table dashPanel = table.new(tablePos, 3, 18, bgcolor=color.new(bgColor, 5), border_width=0, frame_width=2, frame_color=color.new(frameColor, 40), force_overlay=false)
table dash = dashDisplayMode == "Main Chart Overlay" ? dashOverlay : dashPanel
if barstate.islast and showInfoPanel
    if dashDisplayMode == "Main Chart Overlay"
        table.clear(dashPanel, 0, 0, 2, 17)
    else
        table.clear(dashOverlay, 0, 0, 2, 17)
    if panelSize == "Full Dashboard"
        table.cell(dash, 0, 0, "CVD", bgcolor=color.new(frameColor, 70), text_color=accentColor1, text_size=sz)
        table.cell(dash, 1, 0, "SUITE PRO", bgcolor=color.new(frameColor, 70), text_color=color.white, text_size=sz)
        vizShort = switch vizMode
            "1: Nebula Pulse" => "âœ¦ NEBULA"
            "2: Tectonic Plates" => "â—† TECTONIC"
            "3: DNA Helix" => "âŒ˜ DNA"
            "4: Aurora Borealis" => "â‰‹ AURORA"
            "5: Radar Sweep" => "â— RADAR"
            "6: Holographic Prism" => "â—ˆ PRISM"
            "OFF: Original Only" => "â˜… ORIGINAL"
            => "VIZ"
        table.cell(dash, 2, 0, vizShort, bgcolor=color.new(frameColor, 70), text_color=accentColor3, text_size=szS)
        table.cell(dash, 0, 1, "â”€â”€â”€", text_color=color.new(neutralColor, 60), text_size=szS)
        table.cell(dash, 1, 1, " FLOW ", text_color=color.new(neutralColor, 40), text_size=szS)
        table.cell(dash, 2, 1, "â”€â”€â”€", text_color=color.new(neutralColor, 60), text_size=szS)
        cvdStr = (cvd >= 0 ? "+" : "") + str.tostring(math.round(cvd/1000, 1)) + "K"
        table.cell(dash, 0, 2, "CVD", text_color=neutralColor, text_size=sz)
        table.cell(dash, 1, 2, cvdStr, text_color=cvd > 0 ? bullColor : bearColor, text_size=sz)
        cvdChg = cvd - prevCVD
        table.cell(dash, 2, 2, (cvdChg >= 0 ? "â–²" : "â–¼") + str.tostring(math.abs(math.round(cvdChg))), text_color=cvdChg > 0 ? bullColor : bearColor, text_size=szS)
        dltStr = (barDelta >= 0 ? "+" : "") + str.tostring(math.round(barDelta/1000, 1)) + "K"
        table.cell(dash, 0, 3, "DELTA", text_color=neutralColor, text_size=sz)
        table.cell(dash, 1, 3, dltStr, text_color=barDelta > 0 ? bullColor : bearColor, text_size=sz)
        dltPct = totalBarVolume > 0 ? (barDelta / totalBarVolume) * 100 : 0
        table.cell(dash, 2, 3, str.tostring(math.round(dltPct)) + "%", text_color=barDelta > 0 ? bullColor : bearColor, text_size=szS)
        table.cell(dash, 0, 4, "â”€â”€â”€", text_color=color.new(neutralColor, 60), text_size=szS)
        table.cell(dash, 1, 4, " SEQ ", text_color=color.new(neutralColor, 40), text_size=szS)
        table.cell(dash, 2, 4, str.tostring(seqSize) + " bars", text_color=frameColor, text_size=szS)
        table.cell(dash, 0, 5, "E:" + str.tostring(math.round(earlyDelta/1000, 1)) + "K", text_color=accentColor1, text_size=szS)
        table.cell(dash, 1, 5, "M:" + str.tostring(math.round(midDelta/1000, 1)) + "K", text_color=accentColor2, text_size=szS)
        table.cell(dash, 2, 5, "L:" + str.tostring(math.round(lateDelta/1000, 1)) + "K", text_color=accentColor3, text_size=szS)
        patIcon = switch deltaPattern
            "EXHAUSTION_BUY" => "âš  EXHâ†“"
            "EXHAUSTION_SELL" => "âš  EXHâ†‘"
            "ACCELERATION_BUY" => "ğŸš€ ACCâ†‘"
            "ACCELERATION_SELL" => "ğŸš€ ACCâ†“"
            => "â€¢ NEUTRAL"
        patCol = switch deltaPattern
            "EXHAUSTION_BUY" => bearColor
            "EXHAUSTION_SELL" => bullColor
            "ACCELERATION_BUY" => bullColor
            "ACCELERATION_SELL" => bearColor
            => neutralColor
        table.cell(dash, 0, 6, "PATTERN", text_color=neutralColor, text_size=sz)
        table.cell(dash, 1, 6, patIcon, text_color=patCol, text_size=sz)
        table.cell(dash, 2, 6, str.tostring(math.round(patternConfidence * 100)) + "%", text_color=accentColor3, text_size=szS)
        table.cell(dash, 0, 7, "â”€â”€â”€", text_color=color.new(neutralColor, 60), text_size=szS)
        table.cell(dash, 1, 7, " SIGNALS ", text_color=color.new(neutralColor, 40), text_size=szS)
        table.cell(dash, 2, 7, "â”€â”€â”€", text_color=color.new(neutralColor, 60), text_size=szS)
        sigTxt = strongBuySignal ? "â˜… BUY â˜…" : strongSellSignal ? "â˜… SELL â˜…" : "â€¢ WAIT â€¢"
        sigCol = strongBuySignal ? bullColor : strongSellSignal ? bearColor : neutralColor
        table.cell(dash, 0, 8, "", text_size=sz)
        table.cell(dash, 1, 8, sigTxt, text_color=sigCol, text_size=sz)
        table.cell(dash, 2, 8, "", text_size=sz)
        divTxt = bullishDivergence ? "DIV+" : bearishDivergence ? "DIV-" : "â€¢"
        imbTxt = buyImbalance ? "IMB+" : sellImbalance ? "IMB-" : "â€¢"
        absTxt = buyAbsorption ? "ABS+" : sellAbsorption ? "ABS-" : "â€¢"
        table.cell(dash, 0, 9, divTxt, text_color=bullishDivergence ? bullColor : bearishDivergence ? bearColor : neutralColor, text_size=szS)
        table.cell(dash, 1, 9, imbTxt, text_color=buyImbalance ? bullColor : sellImbalance ? bearColor : neutralColor, text_size=szS)
        table.cell(dash, 2, 9, absTxt, text_color=buyAbsorption ? bullColor : sellAbsorption ? bearColor : neutralColor, text_size=szS)
        table.cell(dash, 0, 10, "BUY: " + str.tostring(math.round(barBuyVolume/1000, 1)) + "K", text_color=bullColor, text_size=szS)
        table.cell(dash, 1, 10, " | ", text_color=neutralColor, text_size=szS)
        table.cell(dash, 2, 10, "SELL: " + str.tostring(math.round(barSellVolume/1000, 1)) + "K", text_color=bearColor, text_size=szS)
        demandCount = array.size(demandZoneLevels)
        supplyCount = array.size(supplyZoneLevels)
        table.cell(dash, 0, 11, "ğŸŸ¢ " + str.tostring(demandCount), text_color=bullColor, text_size=szS)
        table.cell(dash, 1, 11, "ZONES", text_color=neutralColor, text_size=szS)
        table.cell(dash, 2, 11, "ğŸ”´ " + str.tostring(supplyCount), text_color=bearColor, text_size=szS)
        if optMode
            table.cell(dash, 0, 12, "â”€â”€â”€", text_color=color.new(accentColor3, 50), text_size=szS)
            table.cell(dash, 1, 12, " OPTIMIZER ", text_color=accentColor3, text_size=szS)
            table.cell(dash, 2, 12, "â”€â”€â”€", text_color=color.new(accentColor3, 50), text_size=szS)
            wrCol = btWinRate >= 55 ? bullColor : btWinRate >= 45 ? accentColor3 : bearColor
            table.cell(dash, 0, 13, "WIN RATE", text_color=neutralColor, text_size=sz)
            table.cell(dash, 1, 13, str.tostring(btWinRate, "#.#") + "%", text_color=wrCol, text_size=sz)
            table.cell(dash, 2, 13, str.tostring(btTotalTrades) + " trades", text_color=frameColor, text_size=szS)
            pfCol = btProfitFactor >= 1.5 ? bullColor : btProfitFactor >= 1.0 ? accentColor3 : bearColor
            table.cell(dash, 0, 14, "P. FACTOR", text_color=neutralColor, text_size=sz)
            table.cell(dash, 1, 14, str.tostring(btProfitFactor, "#.##"), text_color=pfCol, text_size=sz)
            table.cell(dash, 2, 14, "", text_size=szS)
            table.cell(dash, 0, 15, "STATUS", text_color=neutralColor, text_size=sz)
            table.cell(dash, 1, 15, robustText, text_color=robustCol, text_size=sz)
            table.cell(dash, 2, 15, str.tostring(stabilityPoints) + "/100", text_color=robustCol, text_size=szS)
            table.cell(dash, 0, 16, "", text_size=szS)
            table.cell(dash, 1, 16, "â˜… DAFE Trading Systemsâ˜…", text_color=color.new(accentColor1, 40), text_size=szS)
            table.cell(dash, 2, 16, "", text_size=szS)
        else
            table.cell(dash, 0, 12, "", text_size=szS)
            table.cell(dash, 1, 12, "â˜… DAFE Trading Systemsâ˜…", text_color=color.new(accentColor1, 40), text_size=szS)
            table.cell(dash, 2, 12, "", text_size=szS)
    else if panelSize == "Compact"
        table.cell(dash, 0, 0, "CVD PRO", text_color=accentColor1, bgcolor=color.new(frameColor, 70), text_size=sz)
        cvdStr = (cvd >= 0 ? "+" : "") + str.tostring(math.round(cvd/1000, 1)) + "K"
        table.cell(dash, 0, 1, "CVD: " + cvdStr, text_color=cvd > 0 ? bullColor : bearColor, bgcolor=bgColor, text_size=sz)
        dltStr = (barDelta >= 0 ? "+" : "") + str.tostring(math.round(barDelta/1000, 1)) + "K"
        table.cell(dash, 0, 2, "DLT: " + dltStr, text_color=barDelta > 0 ? bullColor : bearColor, bgcolor=bgColor, text_size=sz)
        sigTxt = strongBuySignal ? "â˜… BUY" : strongSellSignal ? "â˜… SELL" : "â€¢ WAIT"
        sigCol = strongBuySignal ? bullColor : strongSellSignal ? bearColor : neutralColor
        table.cell(dash, 0, 3, sigTxt, text_color=sigCol, bgcolor=bgColor, text_size=sz)
        table.cell(dash, 0, 4, "ğŸŸ¢" + str.tostring(array.size(demandZoneLevels)) + " ğŸ”´" + str.tostring(array.size(supplyZoneLevels)), text_color=neutralColor, bgcolor=bgColor, text_size=sz)
        if optMode
            table.cell(dash, 0, 5, "WR: " + str.tostring(btWinRate, "#.#") + "%", text_color=btWinRate >= 55 ? bullColor : btWinRate >= 45 ? accentColor3 : bearColor, bgcolor=bgColor, text_size=sz)
            table.cell(dash, 0, 6, robustText, text_color=robustCol, bgcolor=bgColor, text_size=sz)
    else
        cvdStr = (cvd >= 0 ? "+" : "") + str.tostring(math.round(cvd/1000, 1)) + "K"
        table.cell(dash, 0, 0, cvdStr, text_color=cvd > 0 ? bullColor : bearColor, bgcolor=color.new(bgColor, 30), text_size=sz)
        sigIcon = strongBuySignal ? "â–² BUY" : strongSellSignal ? "â–¼ SELL" : "â— WAIT"
        sigCol = strongBuySignal ? bullColor : strongSellSignal ? bearColor : neutralColor
        table.cell(dash, 0, 1, sigIcon, text_color=sigCol, bgcolor=color.new(bgColor, 30), text_size=sz)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”” ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(strongBuySignal, "Strong Buy Signal", "CVD Suite Pro: Strong BUY - Multiple confirmations!")
alertcondition(strongSellSignal, "Strong Sell Signal", "CVD Suite Pro: Strong SELL - Multiple confirmations!")
alertcondition(bullishDivergence, "Bullish Divergence", "CVD: Bullish divergence - Price falling, CVD rising")
alertcondition(bearishDivergence, "Bearish Divergence", "CVD: Bearish divergence - Price rising, CVD falling")
alertcondition(buyImbalance, "Buy Imbalance", "CVD: Significant BUY imbalance detected")
alertcondition(sellImbalance, "Sell Imbalance", "CVD: Significant SELL imbalance detected")
alertcondition(buyAbsorption, "Buy Absorption", "CVD: Hidden buying - Absorption zone")
alertcondition(sellAbsorption, "Sell Absorption", "CVD: Hidden selling - Absorption zone")
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                                                                                                               â•‘
// â•‘                           DAFE CVD PRO - THEORY & USER GUIDE                                                  â•‘
// â•‘                                                                                                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 1. THE HIDDEN AUCTION (CVD EXPLAINED)                                                                         â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   Price is the "Advertisement." Volume is the "Truth."
//   CVD (Cumulative Volume Delta) measures the aggression of buyers vs. sellers.
//
//   â€¢ AGGRESSIVE BUYING (Market Orders): Hits the Ask. Pushes price UP.
//   â€¢ AGGRESSIVE SELLING (Market Orders): Hits the Bid. Pushes price DOWN.
//   â€¢ PASSIVE ABSORPTION (Limit Orders): Does not move price immediately but stops it.
//
//   The DAFE Engine calculates this by analyzing intra-bar data (micro-movements) to estimate
//   whether volume was transacted at the Bid or Ask.
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2. THE THREE PHASES OF ORDER FLOW                                                                             â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   This script visualizes the lifecycle of a move using Sequence Sparkles (âœ¦):
//
//   A. EARLY (E): "Smart Money" enters. Volume is low, but Delta is directional.
//   B. MID (M): Trend follows. Volume expands. Public participation.
//   C. LATE (L): "Bag Holders" enter. Volume is highest, but price stalls.
//
//   STRATEGY: Enter on (E) or (M). Tighten stops or take profit on (L).
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 3. DAFE SIGNAL TYPES                                                                                          â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   â€¢ ğŸ”„ DIVERGENCE (The "Trap"):
//     Price makes a Lower Low, but CVD makes a Higher Low.
//     Meaning: Sellers are exhausted. They are hitting the bid, but price refuses to drop further.
//     Result: Short Squeeze / Reversal imminent.
//
//   â€¢ ğŸ§² ABSORPTION (The "Wall"):
//     Detected when Volume is High, Delta is strong, but Price Movement is small (Range < ATR).
//     Meaning: A massive Limit Order (Iceberg) is absorbing all aggression.
//     Action: Fade the move. If price tries to break the wall and fails, enter opposite.
//
//   â€¢ âš–ï¸ IMBALANCE (The "Surge"):
//     A Delta bar that is > 2 Standard Deviations from the mean.
//     Meaning: One side has completely overwhelmed the other.
//     Action: Trend continuation. Momentum is on this side.
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 4. VISUALIZATION MODES                                                                                        â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   â€¢ Nebula Pulse: Glow intensity = Order flow aggression.
//   â€¢ Tectonic Plates: Visualizes stress. When the plates shift color, control has flipped.
//   â€¢ DNA Helix: Shows the intertwined relationship between Price and Delta.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                                            DAFE TRADING SYSTEMS
//                                           "Quantifying the Unseen"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
