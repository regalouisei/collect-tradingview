//@version=5
indicator("RSI Divergence Regular", overlay=true, max_lines_count=500, max_labels_count=500, max_boxes_count=0)

//=========================
// 
//=========================
swingLen = input.int(14, "Swing Strength", minval=1, group="General")

// Hidden fixed constants (removed from inputs)
int extendBars  = 3
int maxGapCheck = 300

int win = swingLen * 2 + 1
bool ok = bar_index >= swingLen * 2

//=========================
// 
//=========================
bullDiv       = input.bool(true, "Bullish RSI Divergence", group="Signal")
bearDiv       = input.bool(true, "Bearish RSI divergence", group="Signal")
rsiLen        = input.int(14, "RSI Length", minval=1, group="Signal")
levelsToCheck = input.int(5, "Levels to check (latest N)", minval=1, maxval=60, group="Signal")

// Fixed RSI filters (your request)
float bullRsiMax = 30.0
float bearRsiMin = 70.0

float rsi = ta.rsi(close, rsiLen)

f_candle_cross(float level, int off) =>
    level >= low[off] and level <= high[off]

//=========================
// BSL/SSL 
//=========================
int   bslKeepLvls = 200
int   sslKeepLvls = 200
bool  showBSL = true
bool  showSSL = true
color bslColor = color.red
color sslColor = color.teal

//=========================
// BSL 
//=========================
bool phSig = ok and high[swingLen] == ta.highest(high, win)

var line[]  hiLines   = array.new_line()
var float[] hiLvls    = array.new_float()
var bool[]  hiBroken  = array.new_bool()
var int[]   hiBars    = array.new_int()
var float[] hiRsiAtPv = array.new_float()

if phSig and showBSL
    int x1h = bar_index - swingLen
    float lvlH = high[swingLen]
    line lnH = line.new(x1h, lvlH, bar_index + extendBars, lvlH, color=bslColor, width=1)
    array.unshift(hiLines, lnH)
    array.unshift(hiLvls, lvlH)
    array.unshift(hiBroken, false)
    array.unshift(hiBars, x1h)
    array.unshift(hiRsiAtPv, rsi[swingLen])
    if array.size(hiLines) > bslKeepLvls
        line delH = array.pop(hiLines)
        array.pop(hiLvls)
        array.pop(hiBroken)
        array.pop(hiBars)
        array.pop(hiRsiAtPv)
        line.delete(delH)

int hs = array.size(hiLines)
if hs > 0 and showBSL
    for i = 0 to hs - 1
        line ln = array.get(hiLines, i)
        float lvl = array.get(hiLvls, i)
        bool br = array.get(hiBroken, i)
        if not br
            line.set_x2(ln, bar_index + extendBars)
            if close > lvl
                array.set(hiBroken, i, true)
                line.set_x2(ln, bar_index)
                line.set_style(ln, line.style_dashed)
        line.set_color(ln, array.get(hiBroken, i) ? color.new(bslColor, 60) : bslColor)

//=========================
// SSL 
//=========================
bool plSig = ok and low[swingLen] == ta.lowest(low, win)

var line[]  loLines   = array.new_line()
var float[] loLvls    = array.new_float()
var bool[]  loBroken  = array.new_bool()
var int[]   loBars    = array.new_int()
var float[] loRsiAtPv = array.new_float()

if plSig and showSSL
    int x1l = bar_index - swingLen
    float lvlL = low[swingLen]
    line lnL = line.new(x1l, lvlL, bar_index + extendBars, lvlL, color=sslColor, width=1)
    array.unshift(loLines, lnL)
    array.unshift(loLvls, lvlL)
    array.unshift(loBroken, false)
    array.unshift(loBars, x1l)
    array.unshift(loRsiAtPv, rsi[swingLen])
    if array.size(loLines) > sslKeepLvls
        line delL = array.pop(loLines)
        array.pop(loLvls)
        array.pop(loBroken)
        array.pop(loBars)
        array.pop(loRsiAtPv)
        line.delete(delL)

int ls = array.size(loLines)
if ls > 0 and showSSL
    for i = 0 to ls - 1
        line ln = array.get(loLines, i)
        float lvl = array.get(loLvls, i)
        bool br = array.get(loBroken, i)
        if not br
            line.set_x2(ln, bar_index + extendBars)
            if close < lvl
                array.set(loBroken, i, true)
                line.set_x2(ln, bar_index)
                line.set_style(ln, line.style_dashed)
        line.set_color(ln, array.get(loBroken, i) ? color.new(sslColor, 60) : sslColor)

//=========================

//=========================
bool cond1Bull = close > open and close[1] < open[1]
bool triUp = false

if bullDiv and cond1Bull and showSSL
    int szL = array.size(loLvls)
    int nCheck = math.min(levelsToCheck, szL)
    if nCheck > 0
        for j = 0 to nCheck - 1
            float lvlX = array.get(loLvls, j)
            int   barX = array.get(loBars, j)
            float rsiX = array.get(loRsiAtPv, j)

            int barsSinceX = bar_index - barX
            bool gapOkX = barsSinceX >= 2 and barsSinceX <= (maxGapCheck + 1)

            bool cutN  = gapOkX and (low <= lvlX) and (high >= lvlX)
            bool cutN1 = gapOkX and (low[1] <= lvlX) and (high[1] >= lvlX)
            bool cutOk = cutN or cutN1

            bool noCrossBetween = true
            if gapOkX
                int endOff = math.min(barsSinceX - 1, maxGapCheck + 1)
                if endOff >= 2
                    for off = 2 to endOff
                        if f_candle_cross(lvlX, off)
                            noCrossBetween := false

            float minRSIn = math.min(rsi, rsi[1])
            bool cond3 = minRSIn > rsiX
            bool cond4 = rsiX <= bullRsiMax

            if cutOk and noCrossBetween and cond3 and cond4
                triUp := true

//=========================

//=========================
bool cond1Bear = close < open and close[1] > open[1]
bool triDn = false

if bearDiv and cond1Bear and showBSL
    int szH = array.size(hiLvls)
    int nCheck2 = math.min(levelsToCheck, szH)
    if nCheck2 > 0
        for j = 0 to nCheck2 - 1
            float lvlY = array.get(hiLvls, j)
            int   barY = array.get(hiBars, j)
            float rsiY = array.get(hiRsiAtPv, j)

            int barsSinceY = bar_index - barY
            bool gapOkY = barsSinceY >= 3 and barsSinceY <= (maxGapCheck + 2)

            bool cutM = gapOkY and (f_candle_cross(lvlY, 0) or f_candle_cross(lvlY, 1) or f_candle_cross(lvlY, 2))

            bool noCrossBetweenY = true
            if gapOkY
                int endOffY = math.min(barsSinceY - 1, maxGapCheck + 2)
                if endOffY >= 3
                    for off = 3 to endOffY
                        if f_candle_cross(lvlY, off)
                            noCrossBetweenY := false

            bool cond3b = rsi[1] < rsiY
            bool cond4b = rsiY >= bearRsiMin

            if cutM and noCrossBetweenY and cond3b and cond4b
                triDn := true

//=========================
// Plots
//=========================
plotshape(triUp, title="Bullish RSI Divergence", style=shape.triangleup, location=location.belowbar, size=size.small, color=color.lime)
plotshape(triDn, title="Bearish RSI divergence", style=shape.triangledown, location=location.abovebar, size=size.small, color=color.red)
