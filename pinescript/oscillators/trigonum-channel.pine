//@version=5
indicator("Trigonum Channel", overlay = true)

// === Настройки отображения ===
// Параметры Bollinger Bands
show_bb_display = input.bool(false, title = "Display Bollinger Bands", group="Display Filters")
bb_length = input.int(20, title = "Bollinger Bands Length", group="Bollinger Bands")
bb_mult = input.float(2.0, title = "Bollinger Bands Multiplier", group="Bollinger Bands")

// === Настройки использования ===
// Использование Bollinger Bands
use_bb_filter = input.bool(true, title = "Use Bollinger Bands", group="Usage Filters")
// Использование Nadaraya-Watson
use_nwe_filter = input.bool(true, title = "Use Nadaraya-Watson", group="Usage Filters")
// Использование EMA Fill Zones
use_ema_fill_filter = input.bool(true, title = "Use EMA Fill Zones", group="Usage Filters")
// Использование RSI
use_rsi_filter = input.bool(true, title="Use RSI Trend Filter", group="Usage Filters")
// Использование Stochastic Oscillator
use_stoch_filter = input.bool(true, title="Use Stochastic Oscillator", group="Usage Filters")

// Параметры Nadaraya-Watson
show_nwe_display = input.bool(false, title = "Display Nadaraya-Watson", group="Display Filters")
h = input.float(8.0, title = "Nadaraya-Watson Bandwidth", group="Nadaraya-Watson")
mult_nw = input.float(3.0, title = "NWE Deviation Multiplier", group="Nadaraya-Watson")

// Параметры EMA Fill Zones
show_ema_fill_display = input.bool(false, title = "Display EMA Fill Zones", group="Display Filters")

// Параметры RSI
show_rsi_filter_display = input.bool(true, title="Display RSI Trend Filter", group="Display Filters")
rsi_length = input.int(14, title="RSI LENGTH", group="RSI Settings")
rsi_ma_length = input.int(100, title="RSI 50 level", group="RSI Settings")
rsi_ema_length = input.int(20, title="RSI EMA Length", group="RSI Settings")

// === Параметры сигналов ===
signal_lifetime = input.int(10, title = "Signal Lifetime (in bars)", minval = 1, group="Signal Settings")

// === Bollinger Bands ===
bb_basis = ta.sma(close, bb_length)
bb_upper = bb_basis + bb_mult * ta.stdev(close, bb_length)
bb_lower = bb_basis - bb_mult * ta.stdev(close, bb_length)

// === Nadaraya-Watson ===
gauss(x, h) => math.exp(-(math.pow(x, 2)/(h * h * 2)))
var float out = na
var float mae = na
den = 0.0
out := 0.0
for i = 0 to 499
    w = gauss(i, h)
    den += w
    out += close[i] * w
out /= den
mae := ta.sma(math.abs(close - out), 500) * mult_nw
nwe_upper = out + mae
nwe_lower = out - mae

// === EMA Fill Zones ===
ema20 = ta.ema(close, 20)
ema30 = ta.ema(close, 30)
ema50 = ta.ema(close, 50)
ema100 = ta.ema(close, 100)
ema200 = ta.ema(close, 200)

var color color20_30 = na
var color color30_50 = na
var color color50_100 = na
var color color100_200 = na

if ta.crossover(ema20, ema30)
    color20_30 := color.new(color.green, 40)
if ta.crossunder(ema20, ema30)
    color20_30 := color.new(color.red, 40)

if ta.crossover(ema30, ema50)
    color30_50 := color.new(color.green, 60)
if ta.crossunder(ema30, ema50)
    color30_50 := color.new(color.red, 60)

if ta.crossover(ema50, ema100)
    color50_100 := color.new(color.green, 80)
if ta.crossunder(ema50, ema100)
    color50_100 := color.new(color.red, 80)

if ta.crossover(ema100, ema200)
    color100_200 := color.new(color.green, 90)
if ta.crossunder(ema100, ema200)
    color100_200 := color.new(color.red, 90)

ema20_line = plot(show_ema_fill_display ? ema20 : na, color = na, title = "EMA 20")
ema30_line = plot(show_ema_fill_display ? ema30 : na, color = na, title = "EMA 30")
ema50_line = plot(show_ema_fill_display ? ema50 : na, color = na, title = "EMA 50")
ema100_line = plot(show_ema_fill_display ? ema100 : na, color = na, title = "EMA 100")
ema200_line = plot(show_ema_fill_display ? ema200 : na, color = na, title = "EMA 200")

// === Глобальная обработка заливки ===
fill(ema20_line, ema30_line, color = show_ema_fill_display ? color20_30 : na, title = "Zone 20-30")
fill(ema30_line, ema50_line, color = show_ema_fill_display ? color30_50 : na, title = "Zone 30-50")
fill(ema50_line, ema100_line, color = show_ema_fill_display ? color50_100 : na, title = "Zone 50-100")
fill(ema100_line, ema200_line, color = show_ema_fill_display ? color100_200 : na, title = "Zone 100-200")

// === Настройки RSI ===
grid_color = color.rgb(26, 22, 22, 34)
adjrsi = close + ta.atr(100) * ta.rsi(close, rsi_length) / 100
rma = ta.ema(adjrsi, rsi_ma_length)

// === Отображение RSI (все отображение зависит от фильтров)
r1 = plot(show_rsi_filter_display ? adjrsi : na, color=na, display=display.all, title="RSI")
r2 = plot(show_rsi_filter_display ? rma : na,color = open > rma ? color.new(#00ff08, 80) : open < rma ? color.new(#ff0404, 80) : color.new(color.white, 80),title = "RSI MA",linewidth = 1)
fill( r1, r2,color = show_rsi_filter_display and adjrsi > rma ? color.rgb(76, 175, 79, 90) : color.rgb(255, 82, 82, 92),title = "RSI Cloud")

// === Уровни RSI ===
level2 = input.float(10, title="RSI LEVEL2", minval=10, maxval=100, group="RSI Levels")
rmau = rma + ta.atr(100) * level2 / 10
rmal = rma - ta.atr(100) * level2 / 10
u = plot(show_rsi_filter_display ? rmau : na, color=na, title="70")
l = plot(show_rsi_filter_display ? rmal : na, color=na, title="30")
fill(u, l, color = show_rsi_filter_display ? color.rgb(232, 237, 242, 95) : na, title = "RSI ZeroBand")

level3 = input.float(40, title="RSI LEVEL3", minval=10, maxval=100, group="RSI Levels")
rmau3 = rma + ta.atr(100) * level3 / 10
rmal3 = rma - ta.atr(100) * level3 / 10
o8 = plot(show_rsi_filter_display ? rmau3 : na, color=na, title="80")
o2 = plot(show_rsi_filter_display ? rmal3 : na, color=na, title="20")

level5 = input.float(50, title="RSI LEVEL5", minval=10, maxval=100, group="RSI Levels")
rmau5 = rma + ta.atr(100) * level5 / 10
rmal5 = rma - ta.atr(100) * level5 / 10
ul = plot(show_rsi_filter_display ? rmau5 : na, color=na, title="100")
ll = plot(show_rsi_filter_display ? rmal5 : na, color=na, title="0")
fill(o8, ul, color = show_rsi_filter_display ? color.rgb(232, 4, 23, 90) : na, title = "OverBought")
fill(o2, ll, color = show_rsi_filter_display ? color.rgb(9, 198, 15, 90) : na, title = "OverSold")
fill(r2, ul, color = show_rsi_filter_display ? color.rgb(76, 175, 79, 95) : na, title = "UP TREND")
fill(r2, ll, color = show_rsi_filter_display ? color.rgb(175, 76, 167, 95) : na, title = "DOWN TREND")

// === EMA RSI ===
rsi_ma = ta.ema(adjrsi, rsi_ema_length)
plot(show_rsi_filter_display ? rsi_ma : na, color=na)

// === Stochastic Oscillator ===
periodK = input.int(14, title="%K Length", minval=1)
smoothK = input.int(1, title="%K Smoothing", minval=1)
periodD = input.int(3, title="%D Smoothing", minval=1)
k = ta.sma(ta.stoch(close, high, low, periodK), smoothK)
d = ta.sma(k, periodD)
h0 = hline(80, "Upper Band", color=#787B86)
hline(50, "Middle Band", color=color.new(#787B86, 50))
h1 = hline(20, "Lower Band", color=#787B86)

// === Логика сигналов ===
var int bb_long_bar = na
var int nwe_long_bar = na
var bool last_signal_long = false
var int bb_short_bar = na
var int nwe_short_bar = na
var bool last_signal_short = false
var int so_long_bar= na
var int so_short_bar= na

bb_long = use_bb_filter and close <= bb_lower
nwe_long = use_nwe_filter and close <= nwe_lower
bb_short = use_bb_filter and close >= bb_upper
nwe_short = use_nwe_filter and close >= nwe_upper
rsi_long = use_rsi_filter and close<=rmal3
rsi_short = use_rsi_filter and close>=rmau3
ema_condition__long_met = close < ema20 and close < ema30 and close < ema50 and close < ema100 and close < ema200
ema_condition__short_met = close > ema20 and close > ema30 and close > ema50 and close > ema100 and close > ema200
So_short_condition= k>80 and d>80
So_long_condition=k<20 and d<20

if bb_long
    bb_long_bar := bar_index
if nwe_long
    nwe_long_bar := bar_index
if So_long_condition
    so_long_bar:=bar_index
bb_long_active = (bar_index - bb_long_bar) <= signal_lifetime
nwe_long_active = (bar_index - nwe_long_bar) <= signal_lifetime
so_long_active = (bar_index - so_long_bar) <= signal_lifetime
if bb_short
    bb_short_bar := bar_index
if nwe_short
    nwe_short_bar := bar_index
if So_short_condition
    so_short_bar:=bar_index
bb_short_active = (bar_index - bb_short_bar) <= signal_lifetime
nwe_short_active = (bar_index - nwe_short_bar) <= signal_lifetime
so_short_active = (bar_index - so_short_bar) <= signal_lifetime

final_long_signal = (bb_long_active or not use_bb_filter) and (nwe_long_active or not use_nwe_filter) and (ema_condition__long_met or not use_ema_fill_filter) and (rsi_long or not use_rsi_filter) and (so_long_active or not use_stoch_filter)
final_short_signal = (bb_short_active or not use_bb_filter) and (nwe_short_active or not use_nwe_filter) and (ema_condition__short_met or not use_ema_fill_filter) and (rsi_short or not use_rsi_filter) and (so_short_active or not use_stoch_filter)

if final_long_signal and last_signal_long == false
    label.new(bar_index, close, "LONG", color = color.green, style = label.style_label_up, textcolor = color.white)
    last_signal_long := true
    last_signal_short := false
if final_short_signal and last_signal_short == false
    label.new(bar_index, close, "SHORT", color = color.red, style = label.style_label_down, textcolor = color.white)
    last_signal_short := true
    last_signal_long := false

// === Визуализация ===
plot(show_bb_display ? bb_upper : na, color = color.red, title = "BB Upper")
plot(show_bb_display ? bb_lower : na, color = color.green, title = "BB Lower")
plot(show_bb_display ? bb_basis : na, color = color.gray, title = "BB Basis")

plot(show_nwe_display ? nwe_upper : na, color = color.red, title = "NWE Upper")
plot(show_nwe_display ? nwe_lower : na, color = color.green, title = "NWE Lower")

//Settings
//-----------------------------------------------------------------------------{
length  = input.int(1000, 'Lookback', minval = 1) // Увеличено значение Lookback
columns = input.int(7, minval = 2)
rows    = input.int(20, minval = 2)

//Colors
showAreas = input.bool(false, 'Areas'                 , inline = 'Gradient', group = 'Style')
lowCss    = input.color(color.new(#0a0032, 50), '' , inline = 'Gradient', group = 'Style')
highCss   = input.color(color.new(#ff1100, 50), '' , inline = 'Gradient', group = 'Style')

showPoc = input.bool(false, 'Column POC', inline = 'poc', group = 'Style')
pocCss  = input.color(color.white, '', inline = 'poc', group = 'Style')

showAxis = input.bool(false, 'Axis', inline = 'axis', group = 'Style')
axisCss  = input(#ff5d00, ''    , inline = 'axis', group = 'Style')
//-----------------------------------------------------------------------------}
//Main variables
//-----------------------------------------------------------------------------{

n = bar_index
upper = ta.highest(length)
lower = ta.lowest(length)

var dist = length / columns
var pocs = array.new<line>(0)
mt = matrix.new<float>(rows, columns, 0)

if barstate.isfirst and showPoc
    for i = 0 to columns-1
        pocs.unshift(line.new(na,na,na,na,color = pocCss))
//-----------------------------------------------------------------------------}
//Display volume matrix
//-----------------------------------------------------------------------------{
var horizontal = line.new(na, na, na, na, color = axisCss)
var vertical   = line.new(na, na, na, na, color = axisCss)

for bx in box.all
    bx.delete()

if barstate.islast
    poc = line.new(na,na,na,na)
    x1 = n - length + 1
    x2 = n + 1

    //Loop trough most recent bars and accumulate volume on corresponding matrix entry
    for i = 0 to length-1
        col = math.ceil(i / (length-1) * columns)
        rh = math.ceil((high[i] - lower)/(upper - lower) * rows)
        rl = math.ceil((low[i] - lower)/(upper - lower) * rows)

        //Loop trough rows where price is lying on the corresponding column and accumulate volume
        for j = math.max(rl-1, 0) to math.max(rh-1, 0)
            get_val = mt.get(j, math.max(col-1, 0))
            mt.set(j, math.max(col-1, 0), get_val + volume[i])

    //Get matrix maximum/minimum
    max = mt.max()
    min = mt.min()

    get_val = 0.

    //Loop trough columns
    for i = 0 to columns-1
        up = upper
        dn = upper
        get_col_max = mt.col(i).max()

        //Loop trough rows
        for j = 0 to rows-1
            get_val := mt.get(rows-1 - j, i)

            //Color gradient
            css1 = color.from_gradient(get_val, 0, .8 * max + .1 * min, lowCss, highCss)
            css2 = css1 // Убрана желтая зона

            dn -= (upper - lower) / rows

            //Set POC
            if get_val == get_col_max and showPoc
                avg = math.avg(up, dn)
                
                get_l = pocs.get(i)
                get_l.set_xy1(n + 1 - dist * (i + 1), avg)
                get_l.set_xy2(n + 1 - dist * i, avg)

                if get_val == max
                    poc := get_l
                    poc.set_x2(n)
                    

            //Set Box
            if get_val != 0 and showAreas
                box.new(n + 1 - dist * (i + 1), up, n + 1 - dist * i, dn, na
                  , bgcolor = css2)
            
            up := dn

    //Set Axis
    if showAxis
        horizontal.set_xy1(n - length + 1, lower)
        horizontal.set_xy2(n + 1, lower)

        vertical.set_xy1(n - length + 1, upper)
        vertical.set_xy2(n - length + 1, lower)

//-----------------------------------------------------------------------------}
