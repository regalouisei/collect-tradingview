//@version=6
indicator("SMI Trigger System")

// ════════════════════════════════════════════════════════════════════════════════════
// SMI Trigger System
// Created by: NPR21
// Version: 2.0
// Last Updated: December 2024
// 
// Description: Momentum oscillator using Smoothed Stochastic Momentum Index with
// color-changing lines, cloud shading, and triangle triggers that mark exact 
// momentum shift points.
//
// Features:
// - Color-changing SMI line (green/red for bullish/bearish)
// - Zero-split cloud shading
// - Triangle markers at momentum flips
// - Upper/Lower limit lines
// - Built-in alert system
// - Fully customizable colors and sizes
//
// All Rights Reserved
// ════════════════════════════════════════════════════════════════════════════════════──────────────────────────────────────
//====================
// Inputs (DEFAULTS SET)
//====================
smiscale  = input.float(100,  "SMI Scale", minval=1)
audio     = input.bool(true,  "Enable Alerts")
smilimit  = input.float(40.0, "SMI Limit")

showCloud = input.bool(true, "Show SMI Cloud (to Zero)")

percentDLength = input.int(3, "SMI %D Length", minval=1)
percentKLength = input.int(5, "SMI %K Length", minval=1)

//====================
// Color inputs (DEFAULTS)
//====================
// SMI (smoothed) colors

smiUpColor = input.color(color.new(color.lime, 0), "SMI (Smoothed) Up Color")
smiDnColor = input.color(color.new(color.red,  0), "SMI (Smoothed) Down Color")
smiRawColor    = input.color(color.new(color.gray, 0),  "SMI (Raw) Color")
zeroColor      = input.color(color.new(color.gray, 0),  "Zero Line Color")

upperColor     = input.color(color.new(color.red, 0),   "Upper Limit Color")
lowerColor     = input.color(color.new(color.lime, 0),  "Lower Limit Color")

cloudAboveColor = input.color(color.new(color.lime, 75), "Cloud Above 0 Color")
cloudBelowColor = input.color(color.new(color.red, 75),  "Cloud Below 0 Color")

//====================
// SMI Flip Triangles (DEFAULTS)
//====================
showFlipTris  = input.bool(true, "Show SMI Flip Triangles")
flipShiftBars = input.int(1, "Triangle Shift Bars (1 = aligns with visible color flip)", minval=0)
triOffset     = input.int(20, "SMI Triangle Offset (SMI units)", minval=1)
triSizeStr    = input.string("Large", "SMI Triangle Size",
     options=["Tiny","Small","Normal","Large","Huge"])
smiTriOffset = input.float(20.0, "SMI Triangle Offset (SMI units)", step=0.1)

triUpColor    = input.color(color.new(color.lime, 0), "SMI Up Triangle Color")
triDownColor  = input.color(color.new(color.red, 0),  "SMI Down Triangle Color")

maxTriLabels  = input.int(300, "Max Triangle Labels (safety)", minval=50)

//====================
// SMI calculation
//====================
min_low  = ta.lowest(low,  percentKLength)
max_high = ta.highest(high, percentKLength)

rel_diff = close - (max_high + min_low) / 2.0
diffx    = max_high - min_low

avgrel  = ta.ema(ta.ema(rel_diff, percentDLength), percentDLength)
avgdiff = ta.ema(ta.ema(diffx,    percentDLength), percentDLength)

smi_raw = avgdiff != 0.0 ? (avgrel / (avgdiff / 2.0)) * smiscale : 0.0
smi     = ta.ema(smi_raw, 3)

//====================
// Cloud shading (split above/below zero)
//====================
smiAbove = math.max(smi, 0)
smiBelow = math.min(smi, 0)

// Use the SAME names as your inputs:
plot(showCloud ? smiAbove : na, title="SMI Cloud Above 0", style=plot.style_area, color=cloudAboveColor)
plot(showCloud ? smiBelow : na, title="SMI Cloud Below 0", style=plot.style_area, color=cloudBelowColor)

//====================
// SMI plots (DEFAULT STYLES)
//====================

// Zero line
plot(
     0,
     title     = "Zero",
     color     = zeroColor,
     linewidth = 1
)

// SMI color logic (used for BOTH plot + flip detection)
smiColor = smi >= smi[1] ? smiUpColor : smiDnColor

// SMI (smoothed) — PRIMARY LINE (DEFAULT STYLE)
plot(
    smi,
    title = "SMI (smoothed)",
    color = smiColor,
    linewidth = 3,
    style = plot.style_line
)

// SMI (raw) — secondary
plot(
     smi_raw,
     title     = "SMI (raw)",
     color     = smiRawColor,
     linewidth = 1,
     style     = plot.style_line
)

// Upper / Lower limits
plot(
     smilimit,
     title     = "Upper",
     color     = upperColor,
     linewidth = 1,
     style     = plot.style_line
)

plot(
    -smilimit,
     title     = "Lower",
     color     = lowerColor,
     linewidth = 1,
     style     = plot.style_line
)

//====================
// SMI Flip detection (EXACTLY matches smiColor rule)
// IMPORTANT: detect flip on CURRENT bar; only shift the *marker placement*.
//====================
shiftBars = math.max(flipShiftBars, 0)

// Flip logic must match your line coloring rule:
// smiColor = smi >= smi[1] ? up : down
smiUpNow  = smi >= smi[1]
smiUpPrev = smi[1] >= smi[2]

smiFlipUp   = smiUpNow and not smiUpPrev     // red → green
smiFlipDown = not smiUpNow and smiUpPrev     // green → red

// Safety: need enough bars for smi[2] and shifting
validShift = bar_index >= (shiftBars + 2)

// Marker bar + y anchoring (this is the ONLY place we use shiftBars)
xFlip = bar_index - shiftBars
yBase = shiftBars > 0 ? smi[shiftBars] : smi
yUp   = yBase - smiTriOffset           // green ▲ below SMI
yDn   = yBase + smiTriOffset           // red ▼ above SMI

//====================
// Flip triangles (labels) with safety cap
//====================
var label[] triLabels = array.new_label()

f_addTri(_x, _y, _txt, _txtColor, _sz) =>
    lb = label.new(_x, _y, _txt,
         xloc=xloc.bar_index, yloc=yloc.price,
         style=label.style_label_center,
         textcolor=_txtColor,
         color=color.new(_txtColor, 100),
         size=_sz)
    array.push(triLabels, lb)
    if array.size(triLabels) > maxTriLabels
        old = array.shift(triLabels)
        label.delete(old)

// Use the input names you actually have:
// showFlipTris, triSizeStr, triUpColor, triDownColor
if showFlipTris and validShift and smiFlipUp
    if triSizeStr == "Tiny"
        f_addTri(xFlip, yUp, "▲", triUpColor, size.tiny)
    else if triSizeStr == "Small"
        f_addTri(xFlip, yUp, "▲", triUpColor, size.small)
    else if triSizeStr == "Normal"
        f_addTri(xFlip, yUp, "▲", triUpColor, size.normal)
    else if triSizeStr == "Large"
        f_addTri(xFlip, yUp, "▲", triUpColor, size.large)
    else
        f_addTri(xFlip, yUp, "▲", triUpColor, size.huge)

if showFlipTris and validShift and smiFlipDown
    if triSizeStr == "Tiny"
        f_addTri(xFlip, yDn, "▼", triDownColor, size.tiny)
    else if triSizeStr == "Small"
        f_addTri(xFlip, yDn, "▼", triDownColor, size.small)
    else if triSizeStr == "Normal"
        f_addTri(xFlip, yDn, "▼", triDownColor, size.normal)
    else if triSizeStr == "Large"
        f_addTri(xFlip, yDn, "▼", triDownColor, size.large)
    else
        f_addTri(xFlip, yDn, "▼", triDownColor, size.huge)

//====================
// Alerts: SMI Flip Triangles
//====================

// Alertconditions (used by TradingView alert dialog)
alertcondition(
     audio and showFlipTris and validShift and smiFlipUp,
     title   = "SMI Flip UP (Triangle)",
     message = "{{ticker}} {{interval}} — SMI flipped UP (red → green). Up triangle printed."
)

alertcondition(
     audio and showFlipTris and validShift and smiFlipDown,
     title   = "SMI Flip DOWN (Triangle)",
     message = "{{ticker}} {{interval}} — SMI flipped DOWN (green → red). Down triangle printed."
)

// Optional real-time alerts (fires immediately on bar close)
if audio and showFlipTris and validShift and smiFlipUp
    alert("SMI Flip UP — Triangle printed", alert.freq_once_per_bar_close)

if audio and showFlipTris and validShift and smiFlipDown
    alert("SMI Flip DOWN — Triangle printed", alert.freq_once_per_bar_close)


//====================
// Alerts (clean)
//====================
crossUp0   = ta.crossover(smi, 0)
crossDn0   = ta.crossunder(smi, 0)

crossUpLim = ta.crossover(smi, smilimit)
crossDnLim = ta.crossunder(smi, smilimit)
limitCross = crossUpLim or crossDnLim

alertcondition(audio and crossUp0,   title="SMI Long",        message="SMI crossed above 0 (Long)")
alertcondition(audio and crossDn0,   title="SMI Short",       message="SMI crossed below 0 (Short)")
alertcondition(audio and limitCross, title="SMI Limit Cross", message="SMI crossed the +SMI limit")
