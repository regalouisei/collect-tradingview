//@version=6
////////////////////////////////////////////////////////////////
//* Gypsy Bot Trade Engine - Study, Strategy, and Backtest   *//
//////////////////////////////////////////////////////////////// 

//Code by SignalLynx
//Signal Lynx | Free Scripts supporting Automation for the Night-Shift Nation

// NOTE FOR NEW PINESCRIPT USERS: 
// If you want to see the alerts purely visually without running a backtest, 
// you would comment out the 'strategy' line and uncomment the 'study' line.
// In addition, you will need to comment out the strategy buys/sells at the 
// bottom of this file, and uncomment the alert plots.

//indicator("Gyspy Bot Trade Engine - V1.2B - (Gypsy Bot) Alerts 12-7-25", shorttitle="Gyspy Bot Trade Engine - V1.2B - Alerts", overlay=false)

// The line below is the "Strategy" declaration. This allows for backtesting (buy/sell simulation).
// overlay=true means the buy/sell arrows appear ON the price chart, not in a separate pane below it.
// initial_capital set to 1000 USD for testing purposes.
strategy('Gyspy Bot Trade Engine - V1.2B - Strategy 12-7-25', shorttitle = 'Gyspy Bot Trade Engine - V1.2B - Strat', overlay = true, initial_capital = 1000, commission_type = strategy.commission.percent, commission_value = 0.26, currency = currency.USD, default_qty_type = strategy.percent_of_equity, default_qty_value = 100, pyramiding = 0, slippage = 5)

////////////////////////////////////////////////////////////////  
//* Gypsy Bot Trade Engine - Code Information                *// 
////////////////////////////////////////////////////////////////    

///////////////////////////////////////////////////////////////////////////////////////////////////
// Gypsy Bot Trade Engine (MK6 V1.2B) – Executive Summary
//
// Gypsy Bot is a highly sophisticated, modular "Trade Engine" designed for the TradingView 
// Pine Script v6 environment. Unlike traditional strategies that rely on a single indicator 
// or simple crossover logic, Gypsy Bot functions as a consensus algorithm. It aggregates data 
// from up to 12 distinct technical analysis modules—ranging from Guppy MMAs and Ehlers Roofing 
// Filters to Ichimoku Clouds and Harmonic Oscillators—to determine high-probability market entries.
//
// The engine operates on a voting system: it monitors all active modules and only executes a trade 
// when a user-defined threshold of concurring signals is met. This consensus approach helps filter 
// out noise and false signals common in volatile cryptocurrency markets.
//
// Risk Management & Volatility Protection:
// Beyond entry signals, Gypsy Bot distinguishes itself with a robust Risk Management suite. 
// It features a specialized "Dump Protection Team" (DPT) module designed to identify extreme 
// market volatility (Moon/Nuke scenarios) and force-exit positions or pause trading to preserve 
// capital. Additional filters include Miner Capitulation logic, BTC dominance checks, and 
// flat-market filters (ADX) to prevent trading during non-trending periods.
//
// Critical Note on Optimization and Curve Fitting:
// Users must exercise caution when applying Gypsy Bot to new pairs. By design, this engine allows 
// for granular control over dozens of variables, effectively making it a powerful curve-fitting 
// algorithm. 
// -- Do not chase raw Net Profit: When tuning parameters, prioritize high Profit Factor and 
//    Percent Profitable rates. A strategy tuned solely for maximum profit on historical data 
//    is often over-fitted and will fail in live market conditions.
// -- Regular Maintenance: Market conditions shift. Parameters that worked in a bull market may 
//    fail in a crab or bear market. Gypsy Bot settings should be reviewed and adjusted at regular  
//    intervals to ensure continued optimal performance.
//
// Timeframe Recommendations:
// Gypsy Bot is optimized for High Time Frame (HTF) trend following. It generally produces the 
// most reliable results on charts ranging from 1-Hour to 12-Hours, with the 4-Hour timeframe 
// historically serving as the "sweet spot" for most major cryptocurrency assets.
//
// Key Features:
// -- 12 Selectable Signal Modules: Mix and match indicators like TSI, MTI, Forecast Oscillators, etc.
// -- Advanced Exit Logic: Includes Staged Take Profits (TP1, TP2, TP3), Adaptive Trailing Stops (ATS), 
//    and Martingale/DCA recovery options.
// -- Market Filters: Integrated Bitcoin Halving logic, Weekend Trading halts, and CryptoCap market 
//    breadth analysis, and a sentiment ribbon.
// -- Pine v6 Compliance: Fully updated to adhere to strict type-checking and historical consistency 
//    requirements of Pine Script v6.
///////////////////////////////////////////////////////////////////////////////////////////////////

//Revision Control and Code Information

//This is a trade engine (MK6, V1.2B - Gypsy Bot) - Code Release date: 12-7-25
//This code is in perpetual development - Gyspy Bot first build was in November 2019 - It has come a long way
//Variable names may get a bit odd - Evidence of when I got a bit loopy during coding (Captain DeadPool for instance)
//
//MK6 V1.2B - Upgrade to pinescript v6
//MK6 V1.2A Fixes issues with QUANDL data for hashrate
//MK6 V1.2 Changes Houbi tickers to Kraken - Houbi tickers were banned by TV (morons); Also integrates additional adaptations for further flexibility
//MK6 V1.1 is the releaseed version of the MK6 V1.0 development series
//MK6 V1.0Z is a build off of V1.0Y and looks at reducing memory consumption without sacrificing performance
//MK6 V1.0Y is built off of V1.0X, but looks at how to slow down trades in times of major chop/crab
//MK6 V1.0X is an offshoot of V1.0 - in order to preserve V1.0'X performance - v.10X looks at enhanced integration of renko overlays and removal of TD9- 
//MK6 V1.0 - Featuring upgrades with CyrptoCap and moved to Pine V5
//MK5 code replaces fisher transform error that Killed mk5. Additional improvements.
//MK4 codes look at data back to 1/1/17 (MK3 was 1/1/2019 forward), and features trend based parameter changes
//MK3 CodesV2.62 looks at improving performance on dates 2019 and earlier, and miner captiulation settings/parameters
//V2.60RR Looks at improving the MESA filter due to a missed 30% long
//V2.59RR attempts to revert the code to a more succesful calculation method
//V2.4+ is reduced Modules in order to decrease compilation/power requirements
//Earlier codes - see individual code.
//Trade engine is designed to allow various code modules to be easily dropped into the main body, to allow for a
//complex code, quick and easy changing of variables.
//Trade engine buit by SignalLynx, with code peices from numerous individuals. I have done by best to maintain documentation, but its basically a new system built out over time.
//RSI Qualifier Code by SignalLynx
//Risk Managment built by SignalLynx - initially started with some script segments from other TV users (names have been lost to time)

//Code shall be kept as freesource, any privization of code is not allowed; Inclusive of any downstream use in other codes
//Violators will be reported to Tradingview
//Note: Code peices have been picked up along the way, and likely have forgotten to mention contributors (Appologies in advance)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
//* Backtest Setting                                         *//
////////////////////////////////////////////////////////////////

// Grouping inputs makes the settings menu cleaner in TradingView.
var BackTestMod = 'Back Test Inputs'

// Users can define the specific window of time to run the backtest.
testStartYear = input(2019, '- Start year', group = BackTestMod)
testStartMonth = input(01, '- Start month', group = BackTestMod)
testStartDay = input(01, '- Start day', group = BackTestMod)
// Timestamp converts human readable dates into computer time (milliseconds since 1970).
testPeriodStart = timestamp(testStartYear, testStartMonth, testStartDay, 0, 0)

testStopYear = input(99999, '- Stop year', group = BackTestMod)
testStopMonth = input(12, '- Stop month', group = BackTestMod)
testStopDay = input(30, '-Stop day', group = BackTestMod)
testPeriodStop = timestamp(testStopYear, testStopMonth, testStopDay, 0, 0)

// This function checks if the current bar on the chart is within the user-defined date range.
testPeriod() =>
    time >= testPeriodStart and time <= testPeriodStop ? true : false


/////////////////////////////////////
//Longs and shorts

var LnS = 'Strategy Options - Longs and Shorts'
LnS_Longs = input(true, title = 'Longs', group = LnS)
LnS_Shorts = input(true, title = 'Shorts', group = LnS)

// Logic to determine direction: 1=Both, 2=Longs Only, 3=Shorts Only
LongAndShort = LnS_Longs == true and LnS_Shorts == true ? 1 : LnS_Longs == true and LnS_Shorts == false ? 2 : LnS_Longs == false and LnS_Shorts == true ? 3 : 1

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Credit provoidided to original creators, however most sections have been Modified by SignalLynx
// Note: MK5 removed - Removed Hull MA to reduce memory consumption
// Original las mods by @NeoButane 12 July 2018
// Original Guppy by @ChrisMoody: https://www.tradingview.com/script/3rxOtFe0-CM-Guppy-EMA/
// Original Super Guppy by @FritzMurphy: https://www.tradingview.com/script/ViEwbRCA-CM-Super-Guppy/
// Original Log=space ideas by @fskrypt: https://www.tradingview.com/u/fskrypt/

// Guppy Multiple Moving Average (GMMA) Logic
// This pulls daily ('D') closing prices regardless of the chart timeframe you are on.
typeSPI = request.security(syminfo.tickerid, 'D', close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
srcSPI = math.log(typeSPI) // Uses Logarithmic scale for better trend detection on crypto

// Custom Moving Average function
maSPI(_lenSPI) =>
    ema_1SPI = ta.ema(srcSPI, _lenSPI)
    ema_2SPI = ta.ema(srcSPI, _lenSPI)
    math.exp(ema_1SPI)

// Defining MA lengths
ma1SPI = 3
ma13SPI = 39
ma2SPI = 6
ma14SPI = 42
ma3SPI = 9
ma15SPI = 45
ma4SPI = 12
ma16SPI = 48
ma5SPI = 15
ma17SPI = 51
ma6SPI = 18
ma18SPI = 54
ma7SPI = 21
ma19SPI = 57
ma8SPI = 24
ma20SPI = 60
ma9SPI = 27
ma21SPI = 63
ma10SPI = 30
ma22SPI = 66
ma11SPI = 33
ma23SPI = 200
ma12SPI = 36

// --- V6 FIX EXPLANATION ---
// In Pine Script V6, functions that calculate based on history (like maSPI calling ta.ema) 
// MUST execute on every single bar to maintain consistency.
// Previously, these were called inside the boolean logic (e.g., if x > y). 
// If x wasn't > y, the subsequent MAs wouldn't calculate, breaking the historical series.
// We now pre-calculate them into variables (v_ma1, v_ma2, etc) to ensure they run every time.
v_ma1 = maSPI(ma1SPI), v_ma2 = maSPI(ma2SPI), v_ma3 = maSPI(ma3SPI), v_ma4 = maSPI(ma4SPI), v_ma5 = maSPI(ma5SPI), v_ma6 = maSPI(ma6SPI), v_ma7 = maSPI(ma7SPI)
v_ma8 = maSPI(ma8SPI), v_ma9 = maSPI(ma9SPI), v_ma10 = maSPI(ma10SPI), v_ma11 = maSPI(ma11SPI), v_ma12 = maSPI(ma12SPI), v_ma13 = maSPI(ma13SPI)
v_ma14 = maSPI(ma14SPI), v_ma15 = maSPI(ma15SPI), v_ma16 = maSPI(ma16SPI), v_ma17 = maSPI(ma17SPI), v_ma18 = maSPI(ma18SPI), v_ma19 = maSPI(ma19SPI)
v_ma20 = maSPI(ma20SPI), v_ma21 = maSPI(ma21SPI), v_ma22 = maSPI(ma22SPI)

// Logic: Are the Fast MAs stacked properly (1 > 2 > 3...)?
fastLongXSPI = v_ma1 > v_ma2 and v_ma2 > v_ma3 and v_ma3 > v_ma4 and v_ma4 > v_ma5 and v_ma5 > v_ma6 and v_ma6 > v_ma7
fastShortXSPI = v_ma1 < v_ma2 and v_ma2 < v_ma3 and v_ma3 < v_ma4 and v_ma4 < v_ma5 and v_ma5 < v_ma6 and v_ma6 < v_ma7
// Logic: Are the Slow MAs stacked properly?
slowLongXSPI = v_ma8 > v_ma9 and v_ma9 > v_ma10 and v_ma10 > v_ma11 and v_ma11 > v_ma12 and v_ma12 > v_ma13 and v_ma13 > v_ma14 and v_ma14 > v_ma15 and v_ma15 > v_ma16 and v_ma16 > v_ma17 and v_ma17 > v_ma18 and v_ma18 > v_ma19 and v_ma19 > v_ma20 and v_ma20 > v_ma21 and v_ma21 > v_ma22
slowShortXSPI = v_ma8 < v_ma9 and v_ma9 < v_ma10 and v_ma10 < v_ma11 and v_ma11 < v_ma12 and v_ma12 < v_ma13 and v_ma13 < v_ma14 and v_ma14 < v_ma15 and v_ma15 < v_ma16 and v_ma16 < v_ma17 and v_ma17 < v_ma18 and v_ma18 < v_ma19 and v_ma19 < v_ma20 and v_ma20 < v_ma21 and v_ma21 < v_ma22

traderbullsigSPI = 3
traderbearsigSPI = -3
investorbullsigSPI = 2
investorbearsigSPI = -2

// Determine Fast Signal Strength
fastSigSPI(_bullSPI, _bullishSPI, _bearSPI, _bearishSPI) =>
    ma__1SPI = maSPI(ma1SPI)
    mom_1SPI = ta.mom(ma__1SPI, 4) // Momentum of the fastest MA
    // Ternary operator: If Bullish -> 3, If Bearish -> -3, Else check momentum
    _sigSPI = _bullSPI and _bullishSPI ? traderbullsigSPI : _bearSPI and _bearishSPI ? traderbearsigSPI : not _bullishSPI and not _bearSPI and not _bearishSPI and mom_1SPI > 0 ? 1 : -1
    _sigSPI
sig1SPI = fastSigSPI(fastLongXSPI, slowLongXSPI, fastShortXSPI, slowShortXSPI)

// Determine Slow Signal Strength
slowSigSPI(_sharkSPI, _tadpoleSPI) =>
    ma__1SPI = maSPI(ma8SPI)
    mom_1SPI = ta.mom(ma__1SPI, 3)
    _sigSPI = _sharkSPI ? investorbullsigSPI : _tadpoleSPI ? investorbearsigSPI : not _sharkSPI and not _tadpoleSPI and mom_1SPI > 0 ? 1 : -1
    _sigSPI
sig2SPI = slowSigSPI(slowLongXSPI, slowShortXSPI)

// Smoothing the signals to reduce noise
sig1smoother = ta.ema(sig1SPI, 14)
sig2smoother = ta.ema(sig2SPI, 5)
// Final check: If both smoothers agree, we have a signal.
SPI_Final_Sig = sig1smoother > 0 and sig2smoother > 0 ? 1 : sig1smoother < 0 and sig2smoother < 0 ? -1 : 0
// A very long EMA (4000) acts as a baseline trend filter.
SSGuppy = ta.ema(sig1smoother, 4000)

// True Strength Index (TSI) Calculation
longTSI = 25
shortTSI = 13
signalTSI = 50
priceTSI = close
double_smoothTSI(srcTSI, longTSI, shortTSI) =>
    fist_smoothTSI = ta.ema(srcTSI, longTSI)
    ta.ema(fist_smoothTSI, shortTSI)
pcTSI = ta.change(priceTSI)
double_smoothed_pcTSI = double_smoothTSI(pcTSI, longTSI, shortTSI)
double_smoothed_abs_pcTSI = double_smoothTSI(math.abs(pcTSI), longTSI, shortTSI)
tsi_valueTSI = 100 * (double_smoothed_pcTSI / double_smoothed_abs_pcTSI)

TSI_Inhib = ta.ema(tsi_valueTSI, signalTSI)
TSI_InhibFinal = TSI_Inhib < 0 ? -1 : 0

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Hirashima Sugita R/S Code HSRS
// This calculates dynamic Support/Resistance based on linear regression and weighted moving averages
lengthHSRS = 1000
maHSRS = ta.ema(close, lengthHSRS)
dHSRS = close - maHSRS

sHSRS = ta.linreg(dHSRS, lengthHSRS, 0)
xHSRS = maHSRS + sHSRS

d_HSRS = close - xHSRS
s_HSRS = ta.linreg(d_HSRS, lengthHSRS, 0)
basisHSRS = maHSRS + sHSRS + ta.change(s_HSRS)

upperHSRS = basisHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)
lowerHSRS = basisHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)
upper_HSRS = upperHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)
lower_HSRS = lowerHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)

HSRS_Gap = upper_HSRS - lower_HSRS
HSRS_Threshold = 10 // input.int(title='HSRS Threshold', defval=10, minval=0) / 100
// HSRS Inhibitor: If gap is wide, volatility is high.
HSRS_InhibXy = close * HSRS_Threshold < HSRS_Gap ? 0 : 1

// Check if the HSRS Gap is falling (Volatility decreasing)
s_HSRS2 = HSRS_Gap
nm_HSRS = 21
falling_old_HSRS(s_HSRS2, nm_HSRS) =>
    res = true
    for i = 1 to nm_HSRS by 1
        if s_HSRS2[0] >= s_HSRS2[i]
            res := false
            break
    res

HSRS_Gap_Falling = falling_old_HSRS(s_HSRS2, nm_HSRS) ? 1 : 0

// Bitcoin Halving Dates (Known and Projected)
halving_1 = timestamp(2012, 11, 28, 0, 0)
halving_2 = timestamp(2016, 7, 9, 0, 0)
halving_3 = timestamp(2020, 4, 30, 0, 0)
halving_4 = timestamp(2024, 4, 19, 0, 0) 
halving_5 = timestamp(2028, 3, 26, 0, 0) // projected! https://www.bitcoinclock.com/
halving_6 = timestamp(2032, 4, 14, 0, 0) // projected! https://www.bitcoinclock.com/
halving_7 = timestamp(2036, 4, 18, 0, 0) // projected! https://www.bitcoinclock.com/
halving_8 = timestamp(2040, 4, 21, 0, 0) // projected! https://www.bitcoinclock.com/

//Inhibitors for Miner Capitulation Flip - from 7 days before halving to 90 days after
// This logic prevents certain trades during chaotic periods around BTC halvings.
h1_range = time >= halving_1 - 7 * 24 * 60 * 60 * 1000 and time <= halving_1 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0
h2_range = time >= halving_2 - 7 * 24 * 60 * 60 * 1000 and time <= halving_2 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0
h3_range = time >= halving_3 - 7 * 24 * 60 * 60 * 1000 and time <= halving_3 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0
h4_range = time >= halving_4 - 14 * 24 * 60 * 60 * 1000 and time <= halving_4 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0
h5_range = time >= halving_5 - 14 * 24 * 60 * 60 * 1000 and time <= halving_5 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0
h6_range = time >= halving_6 - 14 * 24 * 60 * 60 * 1000 and time <= halving_6 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0
h7_range = time >= halving_7 - 14 * 24 * 60 * 60 * 1000 and time <= halving_7 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0
h8_range = time >= halving_8 - 14 * 24 * 60 * 60 * 1000 and time <= halving_8 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0

h1_range2 = time >= halving_1 - 500 * 24 * 60 * 60 * 1000 and time <= halving_1 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0
h2_range2 = time >= halving_2 - 500 * 24 * 60 * 60 * 1000 and time <= halving_2 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0
h3_range2 = time >= halving_3 - 500 * 24 * 60 * 60 * 1000 and time <= halving_3 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0
h4_range2 = time >= halving_4 - 500 * 24 * 60 * 60 * 1000 and time <= halving_4 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0
h5_range2 = time >= halving_5 - 500 * 24 * 60 * 60 * 1000 and time <= halving_5 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0
h6_range2 = time >= halving_6 - 500 * 24 * 60 * 60 * 1000 and time <= halving_6 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0
h7_range2 = time >= halving_7 - 500 * 24 * 60 * 60 * 1000 and time <= halving_7 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0
h8_range2 = time >= halving_8 - 500 * 24 * 60 * 60 * 1000 and time <= halving_8 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0

h7range = time >= timestamp(2019, 1, 1, 0, 0) and time <= timestamp(2020, 10, 31, 0, 0) ? 1 : 0
HalvingInhibitor2 = h1_range2 == 1 or h2_range2 == 1 or h3_range2 == 1 or h4_range2 == 1 or h5_range2 == 1 or h6_range2 == 1 or h7_range2 == 1 or h8_range2 == 1 ? 1 : 0

// High Time Frame (14 Day) RSI Check
close_HTF = request.security(syminfo.tickerid, '14D', close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
RSI_HTF = ta.rsi(close_HTF, 1000)
smoothedCloseRSI_HTF = ta.wma(RSI_HTF, 125)
RSI_HTF_Activator = smoothedCloseRSI_HTF >= 50 ? 1 : 0
RSI_HTF_Activator2 = smoothedCloseRSI_HTF >= 50 ? 1 : 0

// Combining Guppy, Halving, and RSI Filters
SSGuppyFinal = SSGuppy >= 0 or HalvingInhibitor2 == 1 or TSI_InhibFinal == 0 ? 1 : -1
TrendPath = SSGuppy <= 0 or RSI_HTF_Activator2 == 0 ? 1 : 0
TrendPath2 = RSI_HTF_Activator2 == 0 ? 1 : 0
HalvingInhibitor = h1_range == 1 or h2_range == 1 or h3_range == 1 or h4_range == 1 or h5_range == 1 or h6_range == 1 or h7_range == 1 or h8_range == 1 or SSGuppyFinal == -1 or RSI_HTF_Activator == 1 ? 1 : 0
Engagey = TrendPath2 == 1 and HalvingInhibitor2 == 0 ? 1 : 0

//Kicker Variables
BBADXKicker = float(na)

///////CryptoCap Module
// This module checks the Total Crypto Market Cap to see if the overall market is trending up or down.
var CCMod = 'CryptoCap Modifier'
UseBTCDMod = input(false, title = 'Use CryptoCap - Trades with CryptoCap Market Value (Default = No) ', group = CCMod)
BTCDCloseCheck = input(false, title = 'Close Trade on CryptoCap Signal? (Default = No)', group = CCMod)
BTCvsAltCheck = input(false, title = 'Flip CryptoCap Signals? (Default = No)', group = CCMod)

intval1FTMTFX = input.string('H01', 'CryptoCap ATR', options = ['M01', 'M03', 'M05', 'M15', 'M30', 'M45', 'H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', 'Week', 'Month', 'Year'], group = CCMod)

// Helper function to standardize interval strings
getRezFTMTFX(intvalFTMTFX) =>
    iff_1X = intvalFTMTFX == 'Year' ? '12M' : '60'
    iff_2X = intvalFTMTFX == 'Month' ? 'M' : iff_1X
    iff_3X = intvalFTMTFX == 'Week' ? 'W' : iff_2X
    iff_4X = intvalFTMTFX == 'Day' ? 'D' : iff_3X
    iff_5X = intvalFTMTFX == 'H12' ? '720' : iff_4X
    iff_6X = intvalFTMTFX == 'H08' ? '480' : iff_5X
    iff_7X = intvalFTMTFX == 'H06' ? '360' : iff_6X
    iff_8X = intvalFTMTFX == 'H04' ? '240' : iff_7X
    iff_9X = intvalFTMTFX == 'H03' ? '180' : iff_8X
    iff_10X = intvalFTMTFX == 'H02' ? '120' : iff_9X
    iff_11X = intvalFTMTFX == 'H01' ? '60' : iff_10X
    iff_12X = intvalFTMTFX == 'M45' ? '45' : iff_11X
    iff_13X = intvalFTMTFX == 'M30' ? '30' : iff_12X
    iff_14X = intvalFTMTFX == 'M15' ? '15' : iff_13X
    iff_15X = intvalFTMTFX == 'M05' ? '5' : iff_14X
    iff_16X = intvalFTMTFX == 'M03' ? '3' : iff_15X
    int_1FTMTFX = intvalFTMTFX == 'M01' ? '1' : iff_16X
    int_1FTMTFX

resFTMTFX = getRezFTMTFX(intval1FTMTFX)

// Getting data from CRYPTOCAP:TOTAL
TCAP_PSAR = request.security('CRYPTOCAP:TOTAL', resFTMTFX, ta.ema(close, 21)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
TCAP_Close = request.security('CRYPTOCAP:TOTAL', resFTMTFX, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

dirSARTrue = TCAP_PSAR < TCAP_Close ? 1 : -1
dirSARFlipped = TCAP_PSAR < TCAP_Close ? -1 : 1

//final signals for trade engine
BTCD_FlipCheck = BTCvsAltCheck == false ? dirSARTrue : dirSARFlipped

//Final Trade Engine signals conversions from BTC.D

BTCDSignal = BTCD_FlipCheck
//Check to see if we should be using BTC.D Module signals for buys/sells BTCD

LgCheck_BTCDMod = UseBTCDMod == true ? BTCDSignal : 1
ShCheck_BTCDMod = UseBTCDMod == true ? BTCDSignal : -1

LgCheck_BTCDModDPT = BTCDSignal == 1 ? 1 : 0
ShCheck_BTCDModDPT = BTCDSignal == -1 ? -1 : 0

BTCD_inLong = BTCDSignal == 1 ? 1 : 0
BTCD_inShort = BTCDSignal == -1 ? -1 : 0

//check to see if we should be closing trades on BTCD Module Signals
BTCD_LongCloseCheck = BTCDCloseCheck == true ? BTCD_inLong : 1
BTCD_ShortCloseCheck = BTCDCloseCheck == true ? BTCD_inShort : -1

//End of CryptoCap  Module code

////////////////////////////////////////////////////////////////
//* Code Module Section                                      *//
////////////////////////////////////////////////////////////////

//Trade engine is set up for a multiple code moduals: First Module is Main; Second Module is constraining, etc
// The strategy votes on trades based on how many modules are active.

////////////////////////////////////////////////////////////////
//* First Module                                             *//
//*Code Type - Modified Slope Angle                          *//
////////////////////////////////////////////////////////////////

//First Module - Yes or no to use
var TEMod1 = 'First Module - Modified Slope Angle (MSA)'
Use1stMod = input(true, title = 'Use First Module - Modified Slope Angle (MSA)', group = TEMod1)
FstCloseCheck = input(false, title = 'Close Trade on MSA Signal? (Default = No)', group = TEMod1)

//place first Module code below this line

// Modified Angle Slope (Code build 12-19-21) - Originally by aamonkey, modified by SignalLynx with alternate timeframes and adapted for TE

ftMAS = 2
fbMAS = -2
srcMAS = close

//Alternate TF
intvalMAS = input.string('H01', 'Modified Slope Angle - ATR', options = ['M01', 'M03', 'M05', 'M15', 'M30', 'M45', 'H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', 'Week', 'Month', 'Year'], group = TEMod1)
MASLength = input.int(14, 'Modified Slope Angle - Length (Default=14)', minval = 0, group = TEMod1)


// Correct the interval used //MAS
getRezMAS(intvalMAS) =>
    iff_1MAS = intvalMAS == 'Year' ? '12M' : '60'
    iff_2MAS = intvalMAS == 'Month' ? 'M' : iff_1MAS
    iff_3MAS = intvalMAS == 'Week' ? 'W' : iff_2MAS
    iff_4MAS = intvalMAS == 'Day' ? 'D' : iff_3MAS
    iff_5MAS = intvalMAS == 'H12' ? '720' : iff_4MAS
    iff_6MAS = intvalMAS == 'H08' ? '480' : iff_5MAS
    iff_7MAS = intvalMAS == 'H06' ? '360' : iff_6MAS
    iff_8MAS = intvalMAS == 'H04' ? '240' : iff_7MAS
    iff_9MAS = intvalMAS == 'H03' ? '180' : iff_8MAS
    iff_10MAS = intvalMAS == 'H02' ? '120' : iff_9MAS
    iff_11MAS = intvalMAS == 'H01' ? '60' : iff_10MAS
    iff_12MAS = intvalMAS == 'M45' ? '45' : iff_11MAS
    iff_13MAS = intvalMAS == 'M30' ? '30' : iff_12MAS
    iff_14MAS = intvalMAS == 'M15' ? '15' : iff_13MAS
    iff_15MAS = intvalMAS == 'M05' ? '5' : iff_14MAS
    iff_16MAS = intvalMAS == 'M03' ? '3' : iff_15MAS
    int_MAS = intvalMAS == 'M01' ? '1' : iff_16MAS
    int_MAS

resMAS = getRezMAS(intvalMAS)

//// //// Determine Angle by KyJ //// //// 
angleMAS(_srcMAS) =>
    rad2degreeMAS = 180 / 3.14159265359 //pi  
    angMAS = rad2degreeMAS * math.atan((_srcMAS[0] - _srcMAS[1]) / ta.atr(14))
    angMAS

maMASPre = request.security(syminfo.tickerid, resMAS, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
maMAS = ta.ema(maMASPre, MASLength)
ma_slopeMAS = angleMAS(maMAS)

///////////// Final Signal /////////////
signalMAS = ma_slopeMAS > ftMAS ? 1 : ma_slopeMAS < fbMAS ? -1 : 0

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

FirstSignal = signalMAS

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from first Module

//Check to see if we should be using 1st Module signals for buys/sells 
// Logic: If Module is ON, use the signal. If OFF, return 1 (neutral/pass).

LgCheck_1stMod = Use1stMod == true ? FirstSignal : 1
ShCheck_1stMod = Use1stMod == true ? FirstSignal : -1

LgCheck_1stModDPT = FirstSignal == 1 ? 1 : 0
ShCheck_1stModDPT = FirstSignal == -1 ? -1 : 0

Fst_inLong = FirstSignal == 1 ? 1 : 0
Fst_inShort = FirstSignal == -1 ? -1 : 0

//check to see if we should be closing trades on 1st Module Signals
Fst_LongCloseCheck = FstCloseCheck == true ? Fst_inLong : 1
Fst_ShortCloseCheck = FstCloseCheck == true ? Fst_inShort : -1

//End of first Module code

////////////////////////////////////////////////////////////////
//* Second  Module                                           *//
//*Code Type - Ehlers Correlation trend Indicator (CTI)      *//
////////////////////////////////////////////////////////////////

//Second Module - Yes or no to use
var TEMod2 = 'Second Module - Correlation trend Indicator (CTE)'
UseSecondMod = input(true, title = 'Use Second Module - Correlation Trend Indicator (CTI)', group = TEMod2)
SecondCloseCheck = input(false, title = 'Close Trade on CTI Signal? (Default = No)', group = TEMod2)

//Originally by Crypohythms, modified by SignalLynx 

XCTI = 0.0
YCTI = 0.0
CorrCTI = 0.0
SxCTI = 0.0
SyCTI = 0.0
SxxCTI = 0.0
SxyCTI = 0.0
SyyCTI = 0.0
positionCTI = 0
LengthCTI = 14 //input(14, '----CTI Length')

resultCTI = for countCTI = 0 to LengthCTI - 1 by 1
    XCTI := close[countCTI]
    YCTI := -countCTI
    SxCTI := SxCTI + XCTI
    SyCTI := SyCTI + YCTI
    SxxCTI := SxxCTI + XCTI * XCTI
    SxyCTI := SxyCTI + XCTI * YCTI
    SyyCTI := SyyCTI + YCTI * YCTI
    SyyCTI

if LengthCTI * SxxCTI - SxCTI * SxCTI > 0 and LengthCTI * SyyCTI - SyCTI * SyCTI > 0
    CorrCTI := (LengthCTI * SxyCTI - SxCTI * SyCTI) / math.sqrt((LengthCTI * SxxCTI - SxCTI * SxCTI) * (LengthCTI * SyyCTI - SyCTI * SyCTI))
    CorrCTI

CTI_SignalPre = CorrCTI >= 0.1 ? 1 : CorrCTI < -0.1 ? -1 : 0
CTI_SignalSmoother = ta.sma(CTI_SignalPre, 14)
CTI_Signal = CTI_SignalSmoother >= 0 ? 1 : -1

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

SecondSignal = CTI_Signal

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from Thirteenth module

//Check to see if we should be using 2nd module signals for buys/sells

LgCheck_2ndMod = UseSecondMod == true ? SecondSignal : 1
ShCheck_2ndMod = UseSecondMod == true ? SecondSignal : -1

LgCheck_2ndModDPT = SecondSignal == 1 ? 1 : 0
ShCheck_2ndModDPT = SecondSignal == -1 ? -1 : 0

Second_inLong = SecondSignal == 1 ? 1 : -1
Second_inShort = SecondSignal == -1 ? -1 : -1

//check to see if we should be closing trades on 2nd module Signals
Second_LongCloseCheck = SecondCloseCheck == true ? Second_inLong : 1
Second_ShortCloseCheck = SecondCloseCheck == true ? Second_inShort : -1

////////////////////////////////////////////////////////////////
//* Tertiary Module                                          *//
//*Code Type - Ehlers Roofing Filter                         *//
////////////////////////////////////////////////////////////////

//Tertiary Module - Yes or no to use
var TEMod3 = 'Third Module - Ehlers Roofing Filter (ERF)'
Use3rdMod = input(true, title = 'Use Tertiary Module - Ehlers Roofing Filter (ERF)', group = TEMod3)
ThirdCloseCheck = input(false, title = 'Close Trade on ERF Signal? (Default = No)', group = TEMod3)

// Ehlers Roofing Filter indicator script may be freely distributed under the MIT license.
//Originally by Everget, modified by SignalLynx for use in trade engine
// This filter removes low frequency noise (trend) and high frequency noise (cycle) to find the "Roof"

highpassLengthERF = 48 // input.int(title='HighPass Length', defval=48, minval=1)
ssfLengthERF = 17 // input.int(title='Super Smoother Filter Length', defval=17, minval=1)
numberOfPolesERF = 3 //input.int(title='Number of Poles', defval=3, options=[2, 3])
srcERF = close
PIERF = 2 * math.asin(1)

twoPoleSuperSmootherFilterERF(srcERF, lengthERF) =>
    argERF = math.sqrt(2) * PIERF / lengthERF
    a1ERF = math.exp(-argERF)
    b1ERF = 2 * a1ERF * math.cos(argERF)
    c2ERF = b1ERF
    c3ERF = -math.pow(a1ERF, 2)
    c1ERF = 1 - c2ERF - c3ERF

    ssfERF = 0.0
    ssfERF := c1ERF * srcERF + c2ERF * nz(ssfERF[1]) + c3ERF * nz(ssfERF[2])
    ssfERF

threePoleSuperSmootherFilterERF(srcERF, lengthERF) =>
    argERF = PIERF / lengthERF
    a1ERF = math.exp(-argERF)
    b1ERF = 2 * a1ERF * math.cos(1.738 * argERF)
    c1ERF = math.pow(a1ERF, 2)

    coef2ERF = b1ERF + c1ERF
    coef3ERF = -(c1ERF + b1ERF * c1ERF)
    coef4ERF = math.pow(c1ERF, 2)
    coef1ERF = 1 - coef2ERF - coef3ERF - coef4ERF

    ssfERF = 0.0
    ssfERF := coef1ERF * srcERF + coef2ERF * nz(ssfERF[1]) + coef3ERF * nz(ssfERF[2]) + coef4ERF * nz(ssfERF[3])
    ssfERF

roofingFilterERF(srcERF, highpassLengthERF, ssfLengthERF, numberOfPolesERF) =>
    alphaArgERF = 2 * PIERF / (highpassLengthERF * math.sqrt(2))

    alphaERF = 0.0
    alphaERF := math.cos(alphaArgERF) != 0 ? (math.cos(alphaArgERF) + math.sin(alphaArgERF) - 1) / math.cos(alphaArgERF) : nz(alphaERF[1])

    highpassERF = 0.0
    highpassERF := math.pow(1 - alphaERF / 2, 2) * (srcERF - 2 * nz(srcERF[1]) + nz(srcERF[2])) + 2 * (1 - alphaERF) * nz(highpassERF[1]) - math.pow(1 - alphaERF, 2) * nz(highpassERF[2])

    twoPoleSuperSmootherFilter__1ERF = twoPoleSuperSmootherFilterERF((highpassERF + nz(highpassERF[1])) / 2, ssfLengthERF)
    threePoleSuperSmootherFilter__1ERF = threePoleSuperSmootherFilterERF((highpassERF + nz(highpassERF[1])) / 2, ssfLengthERF)
    numberOfPolesERF == 2 ? twoPoleSuperSmootherFilter__1ERF : threePoleSuperSmootherFilter__1ERF

erfERF = roofingFilterERF(srcERF, highpassLengthERF, ssfLengthERF, numberOfPolesERF)
erfSignal = erfERF >= 0.0 ? 1 : -1

//Convert Third Modual SIgnal to the trade Engine
//signal must be 1 for long, -1 for short and 0 for no trade

Third_Signal = erfSignal

//Check to see if we should be using 3rd Module

LgCheck_3rdMod = Use3rdMod == true ? Third_Signal : 1
ShCheck_3rdMod = Use3rdMod == true ? Third_Signal : -1

LgCheck_3rdModDPT = Third_Signal == 1 ? 1 : 0
ShCheck_3rdModDPT = Third_Signal == -1 ? -1 : 0

Third_inLong = Third_Signal == 1 ? 1 : -1
Third_inShort = Third_Signal == -1 ? -1 : 1

//check to see if we should be closing trades on Chandi Signals
Third_LongCloseCheck = ThirdCloseCheck == true ? Third_Signal : 1
Third_ShortCloseCheck = ThirdCloseCheck == true ? Third_Signal : -1

///////////////////////////////////////////////////////////////
//* Fourth   Module                                         *//
//*Code Type - Forecast Module                              *//
///////////////////////////////////////////////////////////////

//Fourth Module - Yes or no to use
var TEMod4 = 'Fourth Module - Forecast Oscillator'
UseFourthMod = input(true, title = 'Use Fourth Module - Forecast Oscillator ', group = TEMod4)
FourthCloseCheck = input(false, title = 'Close Trade on Forecast Signal? (Default = No)', group = TEMod4)

//place Fourth Module code below this line
//Inputs
AgressiveFO = input(false, 'Use Agressive Forecasting (Default = Conservative)', group = TEMod4)
lengthFO = 14 //input.int(title='Length', defval=14, minval=1)
srcFO = close
fosc = 100 * (srcFO - ta.linreg(srcFO, lengthFO, 0)) / srcFO

//Final Buy Signals
s_fosc = fosc
nm_fosc = 1
rising_old_fosc(s_fosc, nm_fosc) =>
    res = true
    for i = 1 to nm_fosc by 1
        if s_fosc[0] <= s_fosc[i]
            res := false
            break
    res
FOAgressSig = rising_old_fosc(s_fosc, nm_fosc) == true ? 1 : -1
FOSignal = FOAgressSig > 0 and AgressiveFO == true ? 1 : FOAgressSig < 0 and AgressiveFO == true ? -1 : fosc > 0 and AgressiveFO == false ? 1 : fosc < 0 and AgressiveFO == false ? -1 : 0

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

FourthSignal = FOSignal

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from first Module

//Check to see if we should be using 4th Module signals for buys/sells

LgCheck_4thMod = UseFourthMod == true ? FourthSignal : 1
ShCheck_4thMod = UseFourthMod == true ? FourthSignal : -1

LgCheck_4thModDPT = FourthSignal == 1 ? 1 : 0
ShCheck_4thModDPT = FourthSignal == -1 ? -1 : 0

Fourth_inLong = FourthSignal == 1 ? 1 : -1
Fourth_inShort = FourthSignal == -1 ? -1 : 1

//check to see if we should be closing trades on Fourth Module Signals
Fourth_LongCloseCheck = FourthCloseCheck == true ? Fourth_inLong : 1
Fourth_ShortCloseCheck = FourthCloseCheck == true ? Fourth_inShort : -1

//End of fourth Module code

////////////////////////////////////////////////////////////////
//* Fifth Module                                             *//
//*Code Type - Chandileir ATR Stop with Bull/Bear            *//
////////////////////////////////////////////////////////////////

//Fifth Module - Yes or no to use
var TEMod5 = 'Fifth Module - Chandeler ATR Stop'
Use5thMod = input(true, title = 'Use Fifth Module as Order Signal - Chandeleir ATR Stop', group = TEMod5)
BullBearQualifier = input(true, title = 'Use Bull Bear Qualifier? (Default = Yes)', group = TEMod5)
FifthCloseCheck = input(false, title = 'Close Trade on Chandeleir Signal? (Default = No)', group = TEMod5)

//Fifth Code Module Information and Authors
//Orignal Author of this script has been lost to time, as I have modified it multiple times.  

//Inputs
Lengthz = 22
ATRPeriod = 22 //input(title='ATR Period', defval=22)
Mult = input(title = 'ATR Multiplier', defval = 3, group = TEMod5)

//calculate stop value
short_stop = ta.lowest(Lengthz) + Mult * ta.atr(ATRPeriod)
long_stop = ta.highest(Lengthz) - Mult * ta.atr(ATRPeriod)

longStop = 0.0
longStop := close[1] > longStop[1] ? math.max(long_stop, longStop[1]) : long_stop

shortStop = 0.0
shortStop := close[1] < shortStop[1] ? math.min(short_stop, shortStop[1]) : short_stop

//dir =1 then Long, dir=-1 then short
dir = 1
dir := close > shortStop[1] ? 1 : close < longStop[1] ? -1 : nz(dir[1], dir)

//BullBear Qualifier (BBQ)
windowBBQ = input(title = 'Bull Bear Qualifier - Lookback Window:', defval = 7, group = TEMod5)

f_exp_lrBBQ(_heightBBQ, _lengthBBQ) =>
    _retBBQ = _heightBBQ + _heightBBQ / _lengthBBQ
    _retBBQ

h_valueBBQ = ta.highest(close, windowBBQ)
l_valueBBQ = ta.lowest(close, windowBBQ)

h_barBBQ = bar_index - ta.highestbars(close, windowBBQ)
l_barBBQ = bar_index - ta.lowestbars(close, windowBBQ)

bearBBQ = 0 - f_exp_lrBBQ(h_valueBBQ - close, bar_index - h_barBBQ)
bullBBQ = 0 + f_exp_lrBBQ(close - l_valueBBQ, bar_index - l_barBBQ)

trendBBQ = bullBBQ - math.abs(bearBBQ)
smoothedtrendBBQ = ta.sma(trendBBQ, 21)
txBBQ = smoothedtrendBBQ > 0 ? 1 : smoothedtrendBBQ < 0 ? -1 : 0
UseBBQCheckLong = BullBearQualifier == true ? txBBQ : 1
UseBBQCheckShort = BullBearQualifier == true ? txBBQ : -1

//convert Module signal to trade engine signal

fifthcombo = dir == 1 and UseBBQCheckLong == 1 ? 1 : dir == -1 and UseBBQCheckShort == -1 ? -1 : 0

FifthSignal = fifthcombo

//Check to see if we should be using 4th Module
LgCheck_5thMod = Use5thMod == true ? FifthSignal : 1
ShCheck_5thMod = Use5thMod == true ? FifthSignal : -1

LgCheck_5thModDPT = FifthSignal == 1 ? 1 : 0
ShCheck_5thModDPT = FifthSignal == -1 ? -1 : 0

//check to see if we should be closing trades on fifth Module Signals
Fifth_LongCloseCheck = FifthCloseCheck == true ? FifthSignal : 1
Fifth_ShortCloseCheck = FifthCloseCheck == true ? FifthSignal : -1

////////////////////////////////////////////////////////////////
//* Sixth Module                                             *//
//*Code Type - Crypto Market Breadth                         *//
////////////////////////////////////////////////////////////////

//Sixth Module - Yes or no to use
var TEMod6 = 'Sixth Module - Crypto Market Breadth (CMB)'
UseSixthMod = input(true, title = 'Use Sixth Module - Crypto Market Breadth (CMB)', group = TEMod6)
SixthCloseCheck = input(false, title = 'Close Trade on CMB Signal? (Default = No)', group = TEMod6)

//place Sixth Module code below this line
//Module Code Info and author goes here

///Orignal Author of this script has been lost to time,I must have accidently clipped the first line of the below blurb
// This script was generated from https://github.com/m59peacemaker/pine-crypto-market-breadth
// Modified by SignalLynx for use in the trade engine and to reduce memory usage
// The percent of top market cap crypto-currencies advancing and the percent declining.
// Whether the asset is advancing or declining is determined by whether it closes above or below its moving average. 
// Credit to @bigurb for suggesting and helping with this indicator.

//Inputs
AgressiveCMB = input(true, 'Use Agressive Crypto Market Breadth Settings (Default = Aggressive)', group = TEMod6)
CMBAgressiveTrend = input(true, 'Use Agressive Trend Mapping for CMB (Default = Yes)', group = TEMod6)
CMBmovingAverageLength1 = 20 // input(20, title='Moving Average Length 1')
CMBmovingAverageLength2 = 50 //input(50, title='Moving Average Length 2')
CMB_SmootherLength = 7 //input(7, title='CMB Smoother Length')

CMBtickerValue(CMBexpression, CMBtkr) =>
    request.security(CMBtkr, timeframe.period, CMBexpression[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

CMBNumberOfCurrencies = 6 //make sure ths is total of tickers below


//Tickers for Breadth
BTCUSD_closeC = CMBtickerValue(close, 'KRAKEN:BTCUSD')
ETHUSD_closeC = CMBtickerValue(close, 'KRAKEN:ETHUSD')
XBTUSD_closeB = CMBtickerValue(close, 'BINANCE:BTCPERP')
ETHUSD_closeB = CMBtickerValue(close, 'BINANCE:ETHPERP')
XBTUSD_closeK = CMBtickerValue(close, 'COINBASE:BTCUSD')
ETHUSD_closeK = CMBtickerValue(close, 'COINBASE:ETHUSD')

BTCUSD_movingAverage1C = ta.sma(BTCUSD_closeC, CMBmovingAverageLength1)
ETHUSD_movingAverage1C = ta.sma(ETHUSD_closeC, CMBmovingAverageLength1)
XBTUSD_movingAverage1K = ta.sma(XBTUSD_closeK, CMBmovingAverageLength1)
ETHUSD_movingAverage1K = ta.sma(ETHUSD_closeK, CMBmovingAverageLength1)
XBTUSD_movingAverage1B = ta.sma(XBTUSD_closeB, CMBmovingAverageLength1)
ETHUSD_movingAverage1B = ta.sma(ETHUSD_closeB, CMBmovingAverageLength1)

CMBadvancing1 = (BTCUSD_closeC > BTCUSD_movingAverage1C ? 1 : 0) + (ETHUSD_closeC > ETHUSD_movingAverage1C ? 1 : 0) + (XBTUSD_closeK > XBTUSD_movingAverage1K ? 1 : 0) + (ETHUSD_closeK > ETHUSD_movingAverage1K ? 1 : 0) + (XBTUSD_closeB > XBTUSD_movingAverage1B ? 1 : 0) + (ETHUSD_closeB > ETHUSD_movingAverage1B ? 1 : 0)

CMBadvancingRatio1 = CMBadvancing1 / CMBNumberOfCurrencies
CMBadvancingPercent1 = CMBadvancingRatio1 * 100
CMBdecliningPercent1 = 100 - CMBadvancingPercent1
CMBpairsUsedPercent1 = 100

BTCUSD_movingAverage2C = ta.sma(BTCUSD_closeC, CMBmovingAverageLength2)
ETHUSD_movingAverage2C = ta.sma(ETHUSD_closeC, CMBmovingAverageLength2)
XBTUSD_movingAverage2K = ta.sma(XBTUSD_closeK, CMBmovingAverageLength2)
ETHUSD_movingAverage2K = ta.sma(ETHUSD_closeK, CMBmovingAverageLength2)
XBTUSD_movingAverage2B = ta.sma(XBTUSD_closeB, CMBmovingAverageLength2)
ETHUSD_movingAverage2B = ta.sma(ETHUSD_closeB, CMBmovingAverageLength2)

CMBadvancing2 = (BTCUSD_closeC > BTCUSD_movingAverage2C ? 1 : 0) + (ETHUSD_closeC > ETHUSD_movingAverage2C ? 1 : 0) + (XBTUSD_closeK > XBTUSD_movingAverage2K ? 1 : 0) + (ETHUSD_closeK > ETHUSD_movingAverage2K ? 1 : 0) + (XBTUSD_closeB > XBTUSD_movingAverage2B ? 1 : 0) + (ETHUSD_closeB > ETHUSD_movingAverage2B ? 1 : 0)

CMBadvancingRatio2 = CMBadvancing2 / CMBNumberOfCurrencies
CMBadvancingPercent2 = CMBadvancingRatio2 * 100
CMBdecliningPercent2 = 100 - CMBadvancingPercent2
CMBpairsUsedPercent2 = 100

//Signals
CMB_Smoother = ta.ema(CMBadvancingPercent2, CMB_SmootherLength)

s_CMB = CMB_Smoother
nm_CMB = 1
rising_old_CMB(s_CMB, nm_CMB) =>
    res = true
    for i = 1 to nm_CMB by 1
        if s_CMB[0] <= s_CMB[i]
            res := false
            break
    res

CMB_HTF_SignalAgg = rising_old_CMB(s_CMB, nm_CMB) == true or CMB_Smoother >= 50 and CMB_Smoother == CMB_Smoother[1] ? 1 : -1
CMB_HTF_SignalCon = CMB_Smoother >= 50 ? 1 : -1

CMB_Final_Signal = AgressiveCMB == false ? CMB_HTF_SignalCon : CMB_HTF_SignalAgg

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

SixthSignal = CMB_Final_Signal

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from first Module

//Check to see if we should be using 6th Module signals for buys/sells

LgCheck_6thMod1 = UseSixthMod == true and Engagey == 0 ? SixthSignal : 1
ShCheck_6thMod1 = UseSixthMod == true and Engagey == 0 ? SixthSignal : -1

LgCheck_6thMod2 = UseSixthMod == true ? SixthSignal : 1
ShCheck_6thMod2 = UseSixthMod == true ? SixthSignal : -1

LgCheck_6thMod = CMBAgressiveTrend == true ? LgCheck_6thMod1 : LgCheck_6thMod2
ShCheck_6thMod = CMBAgressiveTrend == true ? ShCheck_6thMod1 : ShCheck_6thMod2

LgCheck_6thModDPT = SixthSignal == 1 ? 1 : 0
ShCheck_6thModDPT = SixthSignal == -1 ? -1 : 0

Sixth_inLong = SixthSignal == 1 ? 1 : -1
Sixth_inShort = SixthSignal == -1 ? -1 : 1

//check to see if we should be closing trades on sixth Module Signals
Sixth_LongCloseCheck = SixthCloseCheck == true ? Sixth_inLong : 1
Sixth_ShortCloseCheck = SixthCloseCheck == true ? Sixth_inShort : -1


//End of Sixth Module code

////////////////////////////////////////////////////////////////
//* Seventh Module                                           *//
//*Code Type - Directional Index Convergence                 *//
////////////////////////////////////////////////////////////////

//Seventh Module - Yes or no to use
var TEMod7 = 'Seventh Module - Directional Index Convergence (DIC)'
UseSeventhMod = input(true, title = 'Use Seventh Module - Directional Index Convergence (DIC)', group = TEMod7)
DICAgressiveTrend = input(false, 'Use Agressive Trend Mapping for DIC (Default = No)', group = TEMod7)
SeventhCloseCheck = input(false, title = 'Close Trade on DIC Signal? (Default = No)', group = TEMod7)

//place Seventh Module code below this line


// Displays the Convergence of the positive and negative of the 
// Directional Index(DI), 0 will be generally between 20 <-> 25 on the DI.


int fast_lengthDIC = 10
int slow_lengthDICPRE = 2000
int signalDIC = 1
DIC_Avg = 3

slow_lengthDIC = BBADXKicker >= 2 ? int(slow_lengthDICPRE / 2) : slow_lengthDICPRE

Instant_Threshold = 5
Avg_Threshold = 5

// DI function
dirmov(lenDIC) =>
    upDIC = ta.change(high)
    downDIC = -ta.change(low)
    plusDM = na(upDIC) ? na : upDIC > downDIC and upDIC > 0 ? upDIC : 0
    minusDM = na(downDIC) ? na : downDIC > upDIC and downDIC > 0 ? downDIC : 0
    truerangeDIC = ta.rma(ta.tr, lenDIC)
    plusDIC = fixnan(100 * ta.rma(plusDM, lenDIC) / truerangeDIC)
    minusDIC = fixnan(100 * ta.rma(minusDM, lenDIC) / truerangeDIC)
    [plusDIC, minusDIC]

[bullfastDIC, bearfastDIC] = dirmov(fast_lengthDIC)
[bullslowDIC, bearslowDIC] = dirmov(slow_lengthDIC)

bullhistDIC = ta.ema(math.max(0, bullfastDIC - bullslowDIC), signalDIC)
bearhistDIC = ta.ema(math.max(0, bearfastDIC - bearslowDIC), signalDIC) * -1

DMTrend = bullhistDIC > 0 ? bullhistDIC : bearhistDIC

DMSmoothed = math.avg(DMTrend, DIC_Avg)

DIC_Trend = bullhistDIC > Instant_Threshold and DMSmoothed > Avg_Threshold ? 1 : bearhistDIC < Instant_Threshold * -1 and DMSmoothed < Avg_Threshold * -1 ? -1 : 0

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

SeventhSignal = DIC_Trend

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from seventh Module

//Check to see if we should be using 7th Module signals for buys/sells


LgCheck_7thMod1 = UseSeventhMod == true and Engagey == 0 ? SeventhSignal : 1
ShCheck_7thMod1 = UseSeventhMod == true and Engagey == 0 ? SeventhSignal : -1

LgCheck_7thMod2 = UseSeventhMod == true ? SeventhSignal : 1
ShCheck_7thMod2 = UseSeventhMod == true ? SeventhSignal : -1

LgCheck_7thMod = DICAgressiveTrend == true ? LgCheck_7thMod1 : LgCheck_7thMod2
ShCheck_7thMod = DICAgressiveTrend == true ? ShCheck_7thMod1 : ShCheck_7thMod2

LgCheck_7thModDPT = SeventhSignal == 1 ? 1 : 0
ShCheck_7thModDPT = SeventhSignal == -1 ? -1 : 0

Seventh_inLong = SeventhSignal == 1 ? 1 : -1
Seventh_inShort = SeventhSignal == -1 ? -1 : 1

//check to see if we should be closing trades on Seventh Module Signals
Seventh_LongCloseCheck = SeventhCloseCheck == true ? Seventh_inLong : 1
Seventh_ShortCloseCheck = SeventhCloseCheck == true ? Seventh_inShort : -1

//End of Seventh Module code

////////////////////////////////////////////////////////////////
//* Eigth Module                                             *//
//* Code Type - Market Thrust Indicator                      *//
////////////////////////////////////////////////////////////////

//Eigth Module - Yes or no to use
var TEMod8 = 'Eigth Module - Market thurst Indicator (MTI)'
Use8thMod = input(true, title = 'Use Eigth Module - Market Thrust Indicator (MTI)', group = TEMod8)
EigthCloseCheck = input(false, title = 'Close Trade on MTI Signal? (Default = No)', group = TEMod8)

//Eigth Code Module Information and Authors
//originally by DreadBlitz, modified by SignalLynx for use in trade engine

//Inputs
MTIAgressiveTrend = input(true, 'Use Agressive Trend Mapping for MTI (Default = Yes)', group = TEMod8)
AgressiveMTI = input(false, 'Use Agressive MTI Settings (Default = Conservative)', group = TEMod8)
m_src = close
ma_type = input.string(defval = 'WMA', title = 'MTI MA Type: ', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA', 'DEMA', 'TEMA', 'HullMA', 'ZEMA', 'TMA', 'SSMA'], group = TEMod8)
reaction = 1
malen1 = input.int(defval = 14, title = 'MTI Agressive Length', minval = 1, group = TEMod8)
malen2 = input.int(defval = 35, title = 'MTI Normal Length', minval = 1, group = TEMod8)

ma_len = BBADXKicker >= 2 ? malen1 : malen2

adv = request.security('USI:ADV', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
uvol = request.security('USI:UVOL', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
decl = request.security('USI:DECL', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
dvol = request.security('USI:DVOL', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

mti = adv * uvol - decl * dvol
ma_src = mti

// SuperSmoother filter
// © 2013  John F. Ehlers
variant_supersmoother(src, len) =>
    a1 = math.exp(-1.414 * 3.14159 / len)
    b1 = 2 * a1 * math.cos(1.414 * 3.14159 / len)
    c2 = b1
    c3 = -a1 * a1
    c1 = 1 - c2 - c3
    v9 = 0.0
    v9 := c1 * (src + nz(src[1])) / 2 + c2 * nz(v9[1]) + c3 * nz(v9[2])
    v9

variant_smoothed(src, len) =>
    v5 = 0.0
    sma_1 = ta.sma(src, len)
    v5 := na(v5[1]) ? sma_1 : (v5[1] * (len - 1) + src) / len
    v5

variant_zerolagema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    v10 = ema1 + ema1 - ema2
    v10

variant_doubleema(src, len) =>
    v2 = ta.ema(src, len)
    v6 = 2 * v2 - ta.ema(v2, len)
    v6

variant_tripleema(src, len) =>
    v2 = ta.ema(src, len)
    v7 = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len)
    v7

variant(type, src, len) =>
    ema_1 = ta.ema(src, len)
    wma_1 = ta.wma(src, len)
    vwma_1 = ta.vwma(src, len)
    variant_smoothed__1 = variant_smoothed(src, len)
    variant_doubleema__1 = variant_doubleema(src, len)
    variant_tripleema__1 = variant_tripleema(src, len)
    wma_2 = ta.wma(src, len / 2)
    wma_3 = ta.wma(src, len)
    wma_4 = ta.wma(2 * wma_2 - wma_3, math.round(math.sqrt(len)))
    variant_supersmoother__1 = variant_supersmoother(src, len)
    variant_zerolagema__1 = variant_zerolagema(src, len)
    sma_1 = ta.sma(src, len)
    sma_2 = ta.sma(sma_1, len)
    sma_3 = ta.sma(src, len)
    type == 'EMA' ? ema_1 : type == 'WMA' ? wma_1 : type == 'VWMA' ? vwma_1 : type == 'SMMA' ? variant_smoothed__1 : type == 'DEMA' ? variant_doubleema__1 : type == 'TEMA' ? variant_tripleema__1 : type == 'HullMA' ? wma_4 : type == 'SSMA' ? variant_supersmoother__1 : type == 'ZEMA' ? variant_zerolagema__1 : type == 'TMA' ? sma_2 : sma_3

// === Moving Average
ma_series = variant(ma_type, ma_src, ma_len)

direction = 0

s_falling = ma_series
nm_falling = reaction
falling_old_falling(s_falling, nm_falling) =>
    res = true
    for i = 1 to nm_falling by 1
        if s_falling[0] >= s_falling[i]
            res := false
            break
    res

s_ma = ma_series
nm_ma = reaction
rising_old_ma(s_ma, nm_ma) =>
    res = true
    for i = 1 to nm_ma by 1
        if s_ma[0] <= s_ma[i]
            res := false
            break
    res

DRsing = rising_old_ma(s_ma, nm_ma)
DFalling = falling_old_falling(s_falling, nm_falling)

direction := DRsing == true ? 1 : DFalling == true ? -1 : nz(direction[1])

//finals signals
MTIAgressSig = direction > 0 ? 1 : -1
MTISignal = MTIAgressSig > 0 and AgressiveMTI == true ? 1 : MTIAgressSig < 0 and AgressiveMTI == true ? -1 : ma_series > 0 and AgressiveMTI == false ? 1 : ma_series < 0 and AgressiveMTI == false ? -1 : 0

//Check to see if we should be using 8th Module MTIAgressiveTrend

LgCheck_8thMod1 = Use8thMod == true and Engagey == 0 and SSGuppyFinal == 1 ? MTISignal : 1
ShCheck_8thMod1 = Use8thMod == true and Engagey == 0 and SSGuppyFinal == 1 ? MTISignal : -1

LgCheck_8thMod2 = Use8thMod == true ? MTISignal : 1
ShCheck_8thMod2 = Use8thMod == true ? MTISignal : -1

LgCheck_8thMod = MTIAgressiveTrend == true ? LgCheck_8thMod1 : LgCheck_8thMod2
ShCheck_8thMod = MTIAgressiveTrend == true ? ShCheck_8thMod1 : ShCheck_8thMod2

LgCheck_8thModDPT = MTISignal == 1 ? 1 : 0
ShCheck_8thModDPT = MTISignal == -1 ? -1 : 0

//check to see if we should be closing trades on eigth Module Signals
Eigth_LongCloseCheck = EigthCloseCheck == true ? MTISignal : 1
Eigth_ShortCloseCheck = EigthCloseCheck == true ? MTISignal : -1

//end of eigth Module

////////////////////////////////////////////////////////////////
//* Ninth   Module                                          *//
//*Code Type - Simple Ichimoku cloud                         *//
////////////////////////////////////////////////////////////////

//Ninth Module - Yes or no to use
var TEMod9 = 'Ninth Module - Simple Ichimoku Cloud (SIC)'
UseNinthMod = input(true, title = 'Use Ninth Module - Simple Ichimoku Cloud (SIC)', group = TEMod9)
SICAgressiveTrend = input(true, 'Use Agressive Trend Mapping for SIC (Default = Yes)', group = TEMod9)
NinthCloseCheck = input(false, title = 'Close Trade on SIC Signal? (Default = No)', group = TEMod9)

//place Ninth Module code below this line
//Simple Ichimokue Cloud Indicator, originally by Yo_adriiiiaan, modified by SignalLynx for use in the trade engine

conversionPeriodsICHICLOUD = 9
basePeriodsICHICLOUD = 26
laggingSpan2PeriodsICHICLOUD = 52
displacementICHICLOUD = 26

donchianICHICLOUD(lenICHICLOUD) =>
    math.avg(ta.lowest(lenICHICLOUD), ta.highest(lenICHICLOUD))

conversionLineICHICLOUD = donchianICHICLOUD(conversionPeriodsICHICLOUD)
baseLineICHICLOUD = donchianICHICLOUD(basePeriodsICHICLOUD)
leadLine1ICHICLOUD = math.avg(conversionLineICHICLOUD, baseLineICHICLOUD)
leadLine2ICHICLOUD = donchianICHICLOUD(laggingSpan2PeriodsICHICLOUD)

buyICHICLOUD = close > leadLine1ICHICLOUD[26] and close > leadLine2ICHICLOUD[26]
sellICHICLOUD = close < leadLine1ICHICLOUD[26] and close < leadLine2ICHICLOUD[26]

IchiCloud_Trend = close > leadLine1ICHICLOUD[26] and close > leadLine2ICHICLOUD[26] ? 1 : close < leadLine1ICHICLOUD[26] and close < leadLine2ICHICLOUD[26] ? -1 : 0

IchiCloudTrendAverage = (IchiCloud_Trend + IchiCloud_Trend[1] + IchiCloud_Trend[2] + IchiCloud_Trend[3]) / 4

Ichi_Cloud_FinalOrder = IchiCloudTrendAverage > 0.7 ? 1 : IchiCloudTrendAverage < -0.7 ? -1 : 0

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

NinthSignal = Ichi_Cloud_FinalOrder

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from first Module

//Check to see if we should be using 9th Module signals for buys/sells

LgCheck_9thMod1 = UseNinthMod == true and TrendPath2 == 0 ? NinthSignal : 1
ShCheck_9thMod1 = UseNinthMod == true and TrendPath2 == 0 ? NinthSignal : -1

LgCheck_9thMod2 = UseNinthMod == true ? NinthSignal : 1
ShCheck_9thMod2 = UseNinthMod == true ? NinthSignal : -1

LgCheck_9thMod = SICAgressiveTrend == true ? LgCheck_9thMod1 : LgCheck_9thMod2
ShCheck_9thMod = SICAgressiveTrend == true ? ShCheck_9thMod1 : ShCheck_9thMod2

LgCheck_9thModDPT = NinthSignal == 1 ? 1 : 0
ShCheck_9thModDPT = NinthSignal == -1 ? -1 : 0

Ninth_inLong = NinthSignal == 1 ? 1 : -1
Ninth_inShort = NinthSignal == -1 ? -1 : 1

//check to see if we should be closing trades on Ninth Module Signals
Ninth_LongCloseCheck = NinthCloseCheck == true ? Ninth_inLong : 1
Ninth_ShortCloseCheck = NinthCloseCheck == true ? Ninth_inShort : -1

//End of Ninth Module code

////////////////////////////////////////////////////////////////
//* Tenth Module                                            *//
//*Code Type - Simple Harmonic Oscillator                    *//
////////////////////////////////////////////////////////////////

//Tenth Module - Yes or no to use
var TEMod10 = 'Tenth Module - Simple Harmonic Oscillator'
UseTenthMod = input(true, title = 'Use Tenth Module - Simple Harmonic Oscillator', group = TEMod10)
TenthCloseCheck = input(false, title = 'Close Trade on Harmonic Signal? (Default = No)', group = TEMod10)

//Place tenth Module code below this line


//Inputs
AgressiveHARM = input(false, 'Use Agressive Harmoic Setting (Default = Conservative)', group = TEMod10)
srcHO = close
lenHO = 14
pi = 3.14159265359

sho(s) =>
    C = s
    Cy = C[1]
    Cby = C[2]
    Vt = C - Cy
    Vy = Cy - Cby
    At = Vt - Vy
    A = ta.ema(At, lenHO)
    T = 2 * pi * math.sqrt(math.abs(Vt / A))
    Ti = C > Cy ? T : T * -1
    VP = ta.ema(Ti, lenHO)
    TP = ta.ema(T, lenHO)
    SHO = VP / TP * 100
    SHO

sho_line = sho(srcHO)
signal = ta.sma(sho_line, 3)

//Final Buy Signals

s_harmonic = signal
nm_harmonic = 1
rising_old_harmonic(s_harmonic, nm_harmonic) =>
    res = true
    for i = 1 to nm_harmonic by 1
        if s_harmonic[0] <= s_harmonic[i]
            res := false
            break
    res

HarmonicAgressSig = rising_old_harmonic(s_harmonic, nm_harmonic) ? 1 : -1
HarmonicSignal = HarmonicAgressSig > 0 and AgressiveHARM == true ? 1 : HarmonicAgressSig < 0 and AgressiveHARM == true ? -1 : signal > 0 and AgressiveHARM == false ? 1 : signal < 0 and AgressiveHARM == false ? -1 : 0

//Convert Module signal to trade engine 
//1 for Buy, -1 for sell, 0 is no trade

TenthSignal = HarmonicSignal

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from first Module

//Check to see if we should be using 10th Module signals for buys/sells

LgCheck_10thMod = UseTenthMod == true ? TenthSignal : 1
ShCheck_10thMod = UseTenthMod == true ? TenthSignal : -1

LgCheck_10thModDPT = TenthSignal == 1 ? 1 : 0
ShCheck_10thModDPT = TenthSignal == -1 ? -1 : 0

Tenth_inLong = TenthSignal == 1 ? 1 : -1
Tenth_inShort = TenthSignal == -1 ? -1 : 1

//check to see if we should be closing trades on Tenth Module Signals 
Tenth_LongCloseCheck = TenthCloseCheck == true ? Tenth_inLong : 1
Tenth_ShortCloseCheck = TenthCloseCheck == true ? Tenth_inShort : -1

//End of tenth Module code

///////////////////////////////////////////////////////////////
//* Eleventh   Module                                      *// 
//*Code Type - Hirashina Sugita Compression                 *//  
/////////////////////////////////////////////////////////////// 

//Eleventh Module - Yes or no to use
var TEMod11 = 'Eleventh Module - HRSR Compression OR Super AO'
Use11thMod = input(false, title = 'Use Eleventh Module - HRSR Compression OR Super AO (Default = No)', group = TEMod11)
EleventhModChoice = input(false, title = 'Use Super AO (Default = HSRS Compression)', group = TEMod11)
EleventhCloseCheck = input(false, title = 'Close Trade on HSRS Comp Signal? (Default = No)', group = TEMod11)

//place 11th Module code below this line

///By SignalLynx, built off someones originally HSRS script

//inputs Hirashima Sugita R/s
lengthComp = input.int(21, title = 'HSRS Compression Length', minval = 1, group = TEMod11)
compTrigger = 2 // input(2)

//Hirashima Sugita R/S Code - Compression Comp
maComp = ta.ema(close, lengthComp)
dComp = close - maComp
//
sComp = ta.linreg(dComp, lengthComp, 0)
xComp = maComp + sComp
//
d_Comp = close - xComp
s_Comp = ta.linreg(d_Comp, lengthComp, 0)
basisComp = maComp + sComp + ta.change(s_Comp)
//
upperComp = basisComp + ta.wma(math.abs(dComp), lengthComp)
lowerComp = basisComp - ta.wma(math.abs(dComp), lengthComp)
upper_Comp = upperComp + ta.wma(math.abs(dComp), lengthComp)
lower_Comp = lowerComp - ta.wma(math.abs(dComp), lengthComp)

HSRS_Spread = math.abs(basisComp - close) //upperComp - lowerComp

HSRSCompression = HSRS_Spread / close * 100
HSRSCompSig = HSRSCompression >= compTrigger ? 1 : -1

HSRSBandSig = close > upperComp ? 1 : close < lowerComp ? -1 : 0

//Super AO

//Super-AO - By SignalLynx

//Awesome Oscilator
AOfastLength = input(title = 'AO Fast Length', defval = 14)
AOslowLength = input(title = 'AO Slow Length', defval = 500)
ao = ta.sma(close, AOfastLength) - ta.sma(close, AOslowLength)
AOSmoothInput = input(title = 'AO Smoother length', defval = 21)
aoSmooth = ta.ema(ao, AOSmoothInput)
AORising = ta.rising(ao, AOSmoothInput) ? 1 : -1

//SuperTrend
STPeriods = input(title = 'ST ATR Period', defval = 14)
STsrc = close
STMultiplier = input.float(title = 'ST ATR Multiplier', defval = 7)


STatr = ta.atr(STPeriods)
STup = STsrc - STMultiplier * STatr
STup1 = nz(STup[1], STup)
STup := close[1] > STup1 ? math.max(STup, STup1) : STup
STdn = STsrc + STMultiplier * STatr
STdn1 = nz(STdn[1], STdn)
STdn := close[1] < STdn1 ? math.min(STdn, STdn1) : STdn
STtrend = 1
STtrend := nz(STtrend[1], STtrend)
STtrend := STtrend == -1 and close > STdn1 ? 1 : STtrend == 1 and close < STup1 ? -1 : STtrend
STbuySignal = STtrend == 1 and STtrend[1] == -1
STsellSignal = STtrend == -1 and STtrend[1] == 1

STdnsmooth = ta.sma(STdn, 14)
STupsmooth = ta.sma(STup, 14)
STUpRise = ta.rising(STupsmooth, 14) and STtrend == 1 ? 1 : 0
STDnFall = ta.falling(STdnsmooth, 14) and STtrend == -1 ? -1 : 0

//final signals
SAO = ao >= 0 and AORising == 1 and STtrend == 1 ? 1 : ao <= 0 and AORising == -1 and STtrend == -1 ? -1 : 0

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

EleventhSignal = EleventhModChoice == false ? HSRSBandSig : SAO

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from first Module

//Check to see if we should be using 11th Module signals for buys/sells

LgCheck_11thMod = Use11thMod == true ? EleventhSignal : 1
ShCheck_11thMod = Use11thMod == true ? EleventhSignal : -1

LgCheck_11thModDPT = EleventhSignal == 1 ? 1 : 0
ShCheck_11thModDPT = EleventhSignal == -1 ? -1 : 0

Eleventh_inLong = EleventhSignal == 1 ? 1 : -1
Eleventh_inShort = EleventhSignal == -1 ? -1 : 1

//check to see if we should be closing trades on Eleventh Module Signals
Eleventh_LongCloseCheck = EleventhCloseCheck == true ? Eleventh_inLong : 1
Eleventh_ShortCloseCheck = EleventhCloseCheck == true ? Eleventh_inShort : -1

//End of 11th Module code

////////////////////////////////////////////////////////////////
//* Twelfth   Module                                        *//
//*Code Type - Fisher Transform MultiTimeFrame               *//
////////////////////////////////////////////////////////////////

//Twelfth Module - Yes or no to use
var TEMod12 = 'Twelfth Module - Fischer Transform (MTF)'
Use12thMod = input(false, title = 'Use Twelfth Module - Fischer Transform (MTF) - (Default = No)', group = TEMod12)
TwelfthCloseCheck = input(false, title = 'Close Trade on Fischer Transform Signal? (Default = No)', group = TEMod12)

//place 12th Module code below this line
//original script by mortdiggiddy, converted to V4/v5 and modified for trade engine by SignalLynx

lengthFTMTF = 10 //input.int(10, title='Length', minval=1)
weightFTMTF = 0.33 //input(0.33, title="Normalized Price Weighting (0 < weight < 1)", type=input.float, minval=0.001, maxval=0.999, step=0.01)

intval1FTMTF = input.string('Day', 'Fischer Transform ATR', options = ['M01', 'M03', 'M05', 'M15', 'M30', 'M45', 'H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', 'Week', 'Month', 'Year'], group = TEMod12)

thresh1FTMTF = 1.0
thresh2FTMTF = 2.5

useChartIntVal1FTMTF = false //input(false, "Always Use Chart Interval Instead?")

// Correct the interval used
getRezFTMTF(intvalFTMTF) =>
    iff_1 = intvalFTMTF == 'Year' ? '12M' : '60'
    iff_2 = intvalFTMTF == 'Month' ? 'M' : iff_1
    iff_3 = intvalFTMTF == 'Week' ? 'W' : iff_2
    iff_4 = intvalFTMTF == 'Day' ? 'D' : iff_3
    iff_5 = intvalFTMTF == 'H12' ? '720' : iff_4
    iff_6 = intvalFTMTF == 'H08' ? '480' : iff_5
    iff_7 = intvalFTMTF == 'H06' ? '360' : iff_6
    iff_8 = intvalFTMTF == 'H04' ? '240' : iff_7
    iff_9 = intvalFTMTF == 'H03' ? '180' : iff_8
    iff_10 = intvalFTMTF == 'H02' ? '120' : iff_9
    iff_11 = intvalFTMTF == 'H01' ? '60' : iff_10
    iff_12 = intvalFTMTF == 'M45' ? '45' : iff_11
    iff_13 = intvalFTMTF == 'M30' ? '30' : iff_12
    iff_14 = intvalFTMTF == 'M15' ? '15' : iff_13
    iff_15 = intvalFTMTF == 'M05' ? '5' : iff_14
    iff_16 = intvalFTMTF == 'M03' ? '3' : iff_15
    int_1FTMTF = intvalFTMTF == 'M01' ? '1' : iff_16
    int_1FTMTF

resFTMTF = getRezFTMTF(intval1FTMTF)

// Show intermediate values for fisher transform along the time frame desired
getFisherFTMTF(lenFTMTF, rezFTMTF, useChartIntValFTMTF) =>
    startFTMTF = request.security(syminfo.tickerid, rezFTMTF, time[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
    change_1 = ta.change(startFTMTF)


    bool newSessionFTMTF = change_1 != 0
    sinceNewFTMTF = ta.barssince(newSessionFTMTF)

    barsInIntFTMTF = 0
    barsInIntFTMTF := na(barsInIntFTMTF[1]) or sinceNewFTMTF > nz(barsInIntFTMTF[1]) ? sinceNewFTMTF : nz(barsInIntFTMTF[1])

    isChartIntValFTMTF = useChartIntValFTMTF or barsInIntFTMTF == 0


    hFTMTF = high
    hFTMTF := isChartIntValFTMTF ? high : newSessionFTMTF ? high : math.max(nz(hFTMTF[1]), high)

    lFTMTF = low
    lFTMTF := isChartIntValFTMTF ? low : newSessionFTMTF ? low : math.min(nz(lFTMTF[1]), low)

    opFTMTF = open
    opFTMTF := newSessionFTMTF or isChartIntValFTMTF ? open : nz(opFTMTF[1])
    pFTMTF = close

    hh1FTMTF = ta.highest(pFTMTF, math.max(lengthFTMTF - 1, 1))
    ll1FTMTF = ta.lowest(pFTMTF, math.max(lengthFTMTF - 1, 1))

    hh2FTMTF = request.security(syminfo.tickerid, rezFTMTF, hh1FTMTF[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on) // grab previous highest-mid that is historical
    ll2FTMTF = request.security(syminfo.tickerid, rezFTMTF, ll1FTMTF[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on) // grab previous lowest-mid that is historical

    highest_1FTMTF = ta.highest(pFTMTF, lengthFTMTF) // merge the (length -1) highest-mid with current value
    hhFTMTF = isChartIntValFTMTF ? highest_1FTMTF : math.max(hh2FTMTF, pFTMTF)
    lowest_1FTMTF = ta.lowest(pFTMTF, lengthFTMTF) // merge the (length -1) lowest-mid with current value
    llFTMTF = isChartIntValFTMTF ? lowest_1FTMTF : math.min(ll2FTMTF, pFTMTF)

    v0FTMTF = 2 * ((pFTMTF - llFTMTF) / (hhFTMTF - llFTMTF) - 0.5) // price normalized to -1 <= p <= 1
    v1FTMTF = 0.5

    v1_pFTMTF = v1FTMTF
    v1_pFTMTF := newSessionFTMTF or isChartIntValFTMTF ? nz(v1FTMTF[1]) : nz(v1_pFTMTF[1])

    v1FTMTF := weightFTMTF * v0FTMTF + (1.0 - weightFTMTF) * v1_pFTMTF
    v2FTMTF = math.max(math.min(v1FTMTF, 0.9999), -0.9999) // cap values to prevent floating point errors

    sFisherFTMTF = 0.0

    sFisher_pFTMTF = 0.0
    sFisher_pFTMTF := newSessionFTMTF or isChartIntValFTMTF ? nz(sFisherFTMTF[1]) : nz(sFisher_pFTMTF[1])

    fisherFTMTF = math.log((1 + v2FTMTF) / (1 - v2FTMTF)) // fisher transform function
    sFisherFTMTF := 0.5 * (fisherFTMTF + sFisher_pFTMTF) // smoothed fisher transform

    sFisherRFTMTF = math.round(sFisherFTMTF / 0.0001) * 0.0001

    trendFTMTF = 0
    change_1FTMTF = ta.change(sFisherRFTMTF)
    change_2FTMTF = ta.change(sFisherRFTMTF)
    trendFTMTF := barsInIntFTMTF == sinceNewFTMTF or useChartIntValFTMTF ? fisherFTMTF > sFisherFTMTF and change_1FTMTF >= 0 ? 1 : fisherFTMTF < sFisherFTMTF and change_2FTMTF <= 0 ? -1 : nz(trendFTMTF[1]) : nz(trendFTMTF[1])

    trendChangeFTMTF = ta.change(trendFTMTF)

    [sFisherFTMTF, sFisher_pFTMTF, trendFTMTF, trendChangeFTMTF]

[fisherFTMTF, fisher1FTMTF, trendFTMTF, trendChangeFTMTF] = getFisherFTMTF(lengthFTMTF, resFTMTF, useChartIntVal1FTMTF)

FTMTF_Signal = trendChangeFTMTF > 0 ? 10 : trendChangeFTMTF < 0 ? -10 : 0

FTMTF_Signal_Final = float(na)
FTMTF_Signal_Final := FTMTF_Signal == 10 ? 1 : FTMTF_Signal == -10 ? -1 : FTMTF_Signal_Final[1]

//Convert Module signal to trade engine
//1 for Buy, -1 for sell, 0 is no trade

TwelfthSignal = FTMTF_Signal_Final

//No Module code below this line -trade engine code

//Final Trade Engine signals conversions from first Module

//Check to see if we should be using 12th Module signals for buys/sells

LgCheck_12thMod = Use12thMod == true ? TwelfthSignal : 1
ShCheck_12thMod = Use12thMod == true ? TwelfthSignal : -1

LgCheck_12thModDPT = TwelfthSignal == 1 ? 1 : 0
ShCheck_12thModDPT = TwelfthSignal == -1 ? -1 : 0

Twelfth_inLong = TwelfthSignal == 1 ? 1 : -1
Twelfth_inShort = TwelfthSignal == -1 ? -1 : 1

//check to see if we should be closing trades on Twelfth Module Signals
Twelfth_LongCloseCheck = TwelfthCloseCheck == true ? Twelfth_inLong : 1
Twelfth_ShortCloseCheck = TwelfthCloseCheck == true ? Twelfth_inShort : -1

//End of 12th Module code

////////////////////////////////////////////////////////////////
//*Order Qualifier Module - Part of Risk Management         *// 
////////////////////////////////////////////////////////////////

//ADX - Identfies flat market and does not place orders if true
var TEADX = 'ADX Module - Flat Market Protocol'
UseADX = input(false, title = 'Use ADX Qualifier - Will not Trade in Flat Market', group = TEADX)
ADXlen = input.int(25, minval = 1, title = 'ADX DI Length', group = TEADX)
ADXlensig = 14 //input(14, title="ADX Smoothing", minval=1, maxval=50)
ADXlenDPT = 4 //input(4, minval=1, title="ADX DPT Length")

ADXup = ta.change(high)
ADXdown = -ta.change(low)
ADXtrur = ta.rma(ta.tr, ADXlen)
ADXtrurDPT = ta.rma(ta.tr, ADXlenDPT)

ADXplus = fixnan(100 * ta.rma(ADXup > ADXdown and ADXup > 0 ? ADXup : 0, ADXlen) / ADXtrur)
ADXminus = fixnan(100 * ta.rma(ADXdown > ADXup and ADXdown > 0 ? ADXdown : 0, ADXlen) / ADXtrur)
ADXplusDPT = fixnan(100 * ta.rma(ADXup > ADXdown and ADXup > 0 ? ADXup : 0, ADXlenDPT) / ADXtrurDPT)
ADXminusDPT = fixnan(100 * ta.rma(ADXdown > ADXup and ADXdown > 0 ? ADXdown : 0, ADXlenDPT) / ADXtrurDPT)

ADXsum = ADXplus + ADXminus
adx = 100 * ta.rma(math.abs(ADXplus - ADXminus) / (ADXsum == 0 ? 1 : ADXsum), ADXlensig)
ADXsumDPT = ADXplusDPT + ADXminusDPT
adxDPT = 100 * ta.rma(math.abs(ADXplusDPT - ADXminusDPT) / (ADXsumDPT == 0 ? 1 : ADXsumDPT), ADXlensig)

ADXosob = 40 // input(40, title='Exhaustion Level for ADX, default = 40')
ADXThreshold = input(10, title = 'Primary Order Activation Threshold (Default = 10)', group = TEADX)
ADXSepThreshold = input(8, title = 'Secondary Order Activation Threshold (Default = 8)', group = TEADX)

//Buy Signal for Trade Engine
ADX_OrderActivate = adx > ADXThreshold ? 1 : 0
ADX_RM = adx < ADXThreshold ? 1 : 0
ADXSep = math.abs(ADXplus - ADXminus)
ADXSepActivate = ADXSep > ADXSepThreshold ? 1 : 0

//Buy Signal for DPT
ADX_OrderActivateDPT = adxDPT > ADXThreshold ? 1 : 0
ADX_RMDPT = adxDPT < ADXThreshold ? 1 : 0
ADXSepDPT = math.abs(ADXplusDPT - ADXminusDPT)
ADXSepActivateDPT = ADXSepDPT > ADXSepThreshold ? 1 : 0

//Trade engine Buy Signals
ADXFinal = ADX_OrderActivate == 1 and ADXSepActivate == 1 ? 1 : 0

//DPT Signals
ADXFinalDPTN = ADX_OrderActivateDPT == 1 and ADXSepActivateDPT == 1 ? 0 : -1
ADXFinalDPTM = ADX_OrderActivateDPT == 1 and ADXSepActivateDPT == 1 ? 1 : 0

//Check for ADX Use
ADX_Check = UseADX == true ? ADXFinal : 1

//Smoothed RSI
var RSIMOD = 'RSI Module -  Market Protocols'
UseConRSI = input(true, title = 'Use Order Constraining RSI - Do not place order if Above/Below limits', group = RSIMOD)
Slength = input(7, 'Fast RSI Length', group = RSIMOD)
SlengthSlow = input(35, 'Slow RSI Length', group = RSIMOD)
Sp = ta.ema(ta.rsi(close, Slength), 5)
SpSlow = ta.ema(ta.rsi(close, SlengthSlow), 5)

intval1FTMTFXQQE = input.string('Week', 'QQE Module ATR - Determines use of Fast/Slow RSI', options = ['H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', '2D', '3D', '4D', 'Week', 'Month', 'Year'], group = RSIMOD)

// Correct the interval used
getRezFTMTFXQQE(intvalFTMTFXQQE) =>
    iff_1XQQE = intvalFTMTFXQQE == 'Year' ? '12M' : '60'
    iff_2XQQE = intvalFTMTFXQQE == 'Month' ? 'M' : iff_1XQQE
    iff_3XQQE = intvalFTMTFXQQE == 'Week' ? 'W' : iff_2XQQE
    iff_4XQQE = intvalFTMTFXQQE == 'Day' ? '4D' : iff_3XQQE
    iff_5XQQE = intvalFTMTFXQQE == 'Day' ? '3D' : iff_4XQQE
    iff_6XQQE = intvalFTMTFXQQE == 'Day' ? '2D' : iff_5XQQE
    iff_7XQQE = intvalFTMTFXQQE == 'Day' ? 'D' : iff_6XQQE
    iff_8XQQE = intvalFTMTFXQQE == 'H12' ? '720' : iff_7XQQE
    iff_9XQQE = intvalFTMTFXQQE == 'H08' ? '480' : iff_8XQQE
    iff_10XQQE = intvalFTMTFXQQE == 'H06' ? '360' : iff_9XQQE
    iff_11XQQE = intvalFTMTFXQQE == 'H04' ? '240' : iff_10XQQE
    iff_12XQQE = intvalFTMTFXQQE == 'H03' ? '180' : iff_11XQQE
    iff_13XQQE = intvalFTMTFXQQE == 'H02' ? '120' : iff_12XQQE
    int_1FTMTFXQQE = intvalFTMTFXQQE == 'H01' ? '60' : iff_13XQQE
    int_1FTMTFXQQE

resFTMTFXQQE = getRezFTMTFXQQE(intval1FTMTFXQQE)

srcQQE = request.security(syminfo.tickerid, resFTMTFXQQE, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
lengthQQE = input.int(14, 'QQE Module - RSI Length', minval = 1, group = RSIMOD)
SSFQQE = 5 //input.int(5, 'SF RSI SMoothing Factor', minval=1)
RSIIQQE = ta.ema(ta.rsi(srcQQE, lengthQQE), SSFQQE)
TRQQE = math.abs(RSIIQQE - RSIIQQE[1])
wwalphaQQE = 1 / lengthQQE
WWMAQQE = 0.0
WWMAQQE := wwalphaQQE * TRQQE + (1 - wwalphaQQE) * nz(WWMAQQE[1])
ATRRSIQQE = 0.0
ATRRSIQQE := wwalphaQQE * WWMAQQE + (1 - wwalphaQQE) * nz(ATRRSIQQE[1])
QQEFQQE = ta.ema(ta.rsi(srcQQE, lengthQQE), SSFQQE)
QUPQQE = QQEFQQE + ATRRSIQQE * 4.236
QDNQQE = QQEFQQE - ATRRSIQQE * 4.236
QQESQQE = 0.0
QQESQQE := QUPQQE < nz(QQESQQE[1]) ? QUPQQE : QQEFQQE > nz(QQESQQE[1]) and QQEFQQE[1] < nz(QQESQQE[1]) ? QDNQQE : QDNQQE > nz(QQESQQE[1]) ? QDNQQE : QQEFQQE < nz(QQESQQE[1]) and QQEFQQE[1] > nz(QQESQQE[1]) ? QUPQQE : nz(QQESQQE[1])

buySignalrQQE = ta.crossover(QQEFQQE, QQESQQE)
sellSignallrQQE = ta.crossunder(QQEFQQE, QQESQQE)

var QQE_Signal = 0
QQE_Signal := buySignalrQQE ? 1 : sellSignallrQQE ? -1 : QQE_Signal[1]
SpX = QQE_Signal == 1 ? Sp : SpSlow

//RSI oversold/overbought Modules
//First Section - Do not long/short
SRSI_UpperOrder = input(90, 'RSI Upper Order Limit', group = RSIMOD)
SRSI_LowerOrder = input(10, 'RSI Lower Order Limit', group = RSIMOD)
SRSI_UpperChop = input(56, 'RSI - CHOP - Upper Order Limit', group = RSIMOD)
SRSI_LowerChop = input(44, 'RSI - CHOP - Lower Order Limit', group = RSIMOD)

//BollingerBand Chop Inidicator
var BBCHopMod = 'Bollinger Band Chop Qualifier'
UseBBInhib = input(true, title = 'Use Order Constraining Bollinger Band Inhibitor', group = BBCHopMod)
srcMBB = close
lengthMBB = 34
multMBB = 2.0

basisMBB = ta.sma(srcMBB, lengthMBB)
devMBB = ta.stdev(srcMBB, lengthMBB)
dev2MBB = multMBB * devMBB
dev3MBB = multMBB * 2 * devMBB

upper1MBB = basisMBB + devMBB
lower1MBB = basisMBB - devMBB
upper2MBB = basisMBB + dev2MBB
lower2MBB = basisMBB - dev2MBB
upper3MBB = basisMBB + dev3MBB
lower3MBB = basisMBB - dev3MBB

BBInhibPercent = input(15, 'BB Activation Percentage', group = BBCHopMod)
BBTrend = upper3MBB - lower3MBB
BBTrendSmooth = ta.ema(BBTrend, 14)

s_BB = BBTrendSmooth
nm_BB = 14
rising_old_BB(s_BB, nm_BB) =>
    res = true
    for i = 1 to nm_BB by 1
        if s_BB[0] <= s_BB[i]
            res := false
            break
    res

BBTrendUp = rising_old_BB(s_BB, nm_BB) == true ? 1 : 0
BBChopInhib = close * (BBInhibPercent / 100) > upper3MBB - lower3MBB ? 1 : 0
BBChopInhibFinal = UseBBInhib == true and BBTrendUp == 0 ? BBChopInhib : 1

BBADXKicker := close < lower3MBB or close > upper3MBB ? 1 : close <= upper3MBB and close > upper2MBB ? 2 : close >= lower3MBB and close < lower2MBB ? 2 : close <= upper2MBB and close > upper1MBB ? 3 : close >= lower2MBB and close < lower1MBB ? 3 : 4 // close <=upper1MBB and close > lower1MBB ? 4: 0

// Chop Filter
UseCFInhibPre = input(false, title = 'Use Chop Filter = BB Based (Default - No)', group = BBCHopMod)
UseActiveChopFilter = input(false, 'Use Active Agressiviness - BB Based (Default- No)', group = BBCHopMod)
UseCFInhib = QQE_Signal == 1 and UseActiveChopFilter == true ? true : UseActiveChopFilter == false ? UseCFInhibPre : false
ChopSignal = QQE_Signal == 1 ? 0 : 1
ChopFilterInhibFinal = UseCFInhib == true ? ChopSignal : 1

SRSI_NoBuy = SpX < SRSI_UpperOrder ? true : false
SRSI_NoSell = SpX > SRSI_LowerOrder ? true : false
SRSI_NoBuyChop = SpX > SRSI_UpperChop and BBChopInhibFinal == 1 and ChopFilterInhibFinal == 1 ? true : false
SRSI_NoSellChop = SpX < SRSI_LowerChop and BBChopInhibFinal == 1 and ChopFilterInhibFinal == 1 ? true : false

SRSI_NoBuyFinal = SRSI_NoBuy == true and SRSI_NoBuyChop == true ? 1 : UseConRSI == false ? 1 : 0
SRSI_NoSellFinal = SRSI_NoSell == true and SRSI_NoSellChop == true ? 1 : UseConRSI == false ? 1 : 0

//Second Module - close Orders based on RSI
//RSI oversold/overbought Module
var RSICloseMod = 'Close on RSI Level'
SellOnRSI = input(false, title = 'Close On RSI - Close Orders if RSI Level Breached', group = RSICloseMod)
SOR_UpperOrder = input(90, 'RSI - Close on Upper Limit', group = RSICloseMod)
SOR_LowerOrder = input(10, 'RSI - Close on Lower Limit', group = RSICloseMod)

SOR_CloseLong = Sp > SOR_UpperOrder ? true : false
SOR_CloseShort = Sp < SOR_LowerOrder ? true : false
SOR_CloseLong_Final = SOR_CloseLong == true ? 1 : 0
SOR_CloseShort_Final = SOR_CloseShort == true ? 1 : 0
SOR_CloseLong_Check = SellOnRSI == true ? SOR_CloseLong_Final : 0
SOR_CloseShort_Check = SellOnRSI == true ? SOR_CloseShort_Final : 0

////////////////////////////////////////////////////////////////
//* Miner Capitulation - HashRate                            *//
////////////////////////////////////////////////////////////////

var MinerMod = 'Miner Hash Rate Qualifier'
UseMCHR = input(false, title = 'Do Not Trade During Miner Captiulation? (Default = Yes Trade)', group = MinerMod)
MCHRCloseCheck = input(false, title = 'Close Trade on Miner Capitulation? (Default = No)', group = MinerMod)
MCHR_Tail = input(7, 'MCHR Tail Off Percent (%)', group = MinerMod) / 100
HashSource = input.string('INTOTHEBLOCK:BTC_HASHRATE', options = ['QUANDL:BCHAIN/HRATE', 'INTOTHEBLOCK:BTC_HASHRATE'], title = 'Source Hash Rate')

// Hash Ribbons Indicator
MCHRHR_short = request.security(HashSource, 'D', ta.sma(close, 30)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
MCHRHR_long = request.security(HashSource, 'D', ta.sma(close, 60)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

//-1 is Capitulation
Minercapitulation = MCHRHR_short >= MCHRHR_long ? 1 : -1

MCHRdelta = MCHRHR_short - MCHRHR_long
MCHRdiff = MCHRdelta / MCHRHR_short * 100

var MCHRHashCounter = 0
MCHRHashCounter := Minercapitulation == -1 and MCHRHR_short < MCHRHR_short[1] ? MCHRHashCounter - 1 : Minercapitulation == 1 ? 0 : MCHRHashCounter[1]
MCHRHashCounterSmoother = ta.sma(MCHRHashCounter, 21)

MCHRR2 = MCHRHashCounterSmoother * MCHR_Tail

s_MCHR = MCHRdiff
nm_MCHR = 7
rising_old_MCHR(s_MCHR, nm_MCHR) =>
    res = true
    for i = 1 to nm_MCHR by 1
        if s_MCHR[0] <= s_MCHR[i]
            res := false
            break
    res

// --- V6 FIX EXPLANATION ---
// Pre-calculating the loop result before using it in the ternary operator.
MCHR_isRising = rising_old_MCHR(s_MCHR, nm_MCHR)
MCHRHashClear = ta.crossover(MCHRdiff, MCHRR2) and MCHR_isRising ? 10 : 0
MCHRHash_CU = ta.crossunder(MCHRdiff, MCHRR2) ? 0 : -1
MCHRHashClearSignal = float(na)
MCHRHashClearSignal := MCHRHashClear == 10 ? 1 : Minercapitulation == 1 ? 0 : MCHRHash_CU == 0 ? 0 : MCHRHashClearSignal[1]

MinerCapitulationFinal = Minercapitulation == -1 and MCHRHashClearSignal == 0 ? -1 : 1

MinerPlot = MCHRHR_short < MCHRHR_long

MCHR_Change = MinerCapitulationFinal == MinerCapitulationFinal[1] ? 1 : -1
//Final SIgnals for Module

//Check to see if we should be using MCHR Module
Check_MCHR = UseMCHR == true ? MinerCapitulationFinal : 1

//check to see if we should be closing trades on MCHR Signals
var HalvingKicker = 0
var MCStateKicker = 0
MCHR_CloseCheck = MCHRCloseCheck == true ? MinerCapitulationFinal : 1
MCHR_Change_Final = MCHRCloseCheck == true and HalvingKicker == 0 ? MCHR_Change : MCStateKicker == 2 and HalvingKicker == 1 ? 1 : MCStateKicker == -2 and HalvingKicker == 1 ? -1 : int(MCStateKicker / 2)

/////////////////////////////////////////////////////////////////////////////////
//======[ Trailing Stop  Activator - Ehlers Super BandPass Filter (ESPF)]======//
/////////////////////////////////////////////////////////////////////////////////

fastLengthESPF = 40
slowLengthESPF = 60
srcESPF = close
var ESBFMod = 'Ehlers Super BandPass Filter (ESPF)'
UseESPFMod = input(false, title = 'Inhibit Trade based on ESBF? (Default = No)', group = ESBFMod)
ESPFCloseCheck = input(false, title = 'Close Trade on ESPF Signal? (Default = No)', group = ESBFMod)
stdDevESPFInhibit = input.float(title = 'Main ESBF Inhibit', minval = 0, maxval = 10, step = 0.1, defval = 2.0, group = ESBFMod)
stdDevESPF1 = input.float(title = 'Trailing Stop ESBF Inhibit', minval = 0, maxval = 10, step = 0.1, defval = 2.0, group = ESBFMod)
stdDevESPFMartingale = input.float(title = 'Martingale ESBF Inhibit', minval = 0, maxval = 10, step = 0.1, defval = 1.5, group = ESBFMod)

getESPF(srcESPF, fastLengthESPF, slowLengthESPF) =>
    a1ESPF = 5 / fastLengthESPF
    a2ESPF = 5 / slowLengthESPF

    espf = 0.0
    espf := (a1ESPF - a2ESPF) * srcESPF + (a2ESPF * (1 - a1ESPF) - a1ESPF * (1 - a2ESPF)) * nz(srcESPF[1]) + (1 - a1ESPF + 1 - a2ESPF) * nz(espf[1]) - (1 - a1ESPF) * (1 - a2ESPF) * nz(espf[2])
    espf

espf = getESPF(srcESPF, fastLengthESPF, slowLengthESPF)

// Compute Root Mean Square
rmsESPF1 = math.sqrt(math.sum(espf * espf, 50) / 50) * stdDevESPF1
rmsESPFInhibit = math.sqrt(math.sum(espf * espf, 50) / 50) * stdDevESPFInhibit
rmsESPFMartingale = math.sqrt(math.sum(espf * espf, 50) / 50) * stdDevESPFMartingale

//Signal: 1 indicates long trend, -1 indicates short trend
espf_Signal1 = espf > rmsESPF1 ? 1 : espf < -rmsESPF1 ? -1 : 0
espf_SignalInhibit = espf > rmsESPFInhibit ? 1 : espf < -rmsESPFInhibit ? -1 : 0
espf_SignalMartingale = espf > rmsESPFMartingale ? 1 : espf < -rmsESPFMartingale ? -1 : 0

espf_Pre_Final = espf_Signal1 == 1 and espf_Signal1 != espf_Signal1[1] ? 1 : espf_Signal1 == -1 and espf_Signal1 != espf_Signal1[1] ? -1 : 0

espf_Pre_Inhibit = espf_SignalInhibit == 1 and espf_SignalInhibit != espf_SignalInhibit[1] ? 1 : espf_SignalInhibit == -1 and espf_SignalInhibit != espf_SignalInhibit[1] ? -1 : 0

espf_Pre_Martingale = espf_SignalMartingale == 1 and espf_SignalMartingale != espf_SignalMartingale[1] ? 1 : espf_SignalMartingale == -1 and espf_SignalMartingale != espf_SignalMartingale[1] ? -1 : 0

espf_FinalX = float(na)
espf_FinalX := espf_Pre_Final == 1 ? 1 : espf_Pre_Final == -1 ? -1 : espf_FinalX[1]

//ESPFCloseCheck
espf_Final = ESPFCloseCheck == true ? espf_FinalX : 0

espf_Inhibit = float(na)
espf_Inhibit := espf_Pre_Inhibit == 1 ? 1 : espf_Pre_Inhibit == -1 ? -1 : espf_Inhibit[1]

espf_MartingaleFinal = float(na)
espf_MartingaleFinal := espf_Pre_Martingale == 1 ? 1 : espf_Pre_Martingale == -1 ? -1 : espf_MartingaleFinal[1]

//Final SIgnals for Module

//Check to see if we should be using ESPF Module
LgCheck_ESPFMod = UseESPFMod == true ? espf_Inhibit : 1
ShCheck_ESPFMod = UseESPFMod == true ? espf_Inhibit : -1

ESPF_inLong = espf_Inhibit == 1 ? 1 : -1
ESPF_inShort = espf_Inhibit == -1 ? -1 : 1

//check to see if we should be closing trades on 1st Module Signals
ESPF_LongCloseCheck = ESPFCloseCheck == true ? ESPF_inLong : 1
ESPF_ShortCloseCheck = ESPFCloseCheck == true ? ESPF_inShort : -1

//End of ESPF Module code


////////////////////////////////////////////////////////////////
// Pi Cycle Module                                            //
//////////////////////////////////////////////////////////////// 

//Originally by Doncic, modified by SignalLynx for use in the trade engine

var PiOfC = 'Pi Cycle Bottom Indicator'
UsePiC = input(true, title = 'Use Pi Cycle Bottom Indicator (Buys on Pi Cycle Signal)', group = PiOfC)
Source_PiC = input(false, title = 'Use Chart Pair for Pi Cycle Signal - Default is BTC Pair (False)', group = PiOfC)

ln_ma_bottomlong = 471
ln_ma_bottomshort = 150
long_multiple = 0.745
short_multiple = 1

Source_PiC_Final = Source_PiC == false ? 'COINBASE:BTCUSD' : syminfo.tickerid

ma_bottomlong = request.security(Source_PiC_Final, 'D', (ta.sma(close, ln_ma_bottomlong) * long_multiple)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
ma_bottomshort = request.security(Source_PiC_Final, 'D', (ta.ema(close, ln_ma_bottomshort) * short_multiple)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
src = request.security(Source_PiC_Final, 'D', close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

//1 = bottom
PiCycleBottom = ta.crossunder(ma_bottomshort, ma_bottomlong) ? 1 : 0
plotshape(PiCycleBottom == 1, style = shape.triangleup, size = size.small, text = 'Pi Cycle Bottom', color = color.new(color.aqua, 0), textcolor = color.new(color.aqua, 0), location = location.belowbar)

//Final Signal for Pi Cycle Bottom

PiC_Signal = UsePiC == true ? PiCycleBottom : 0

//Weekend Halt
var WeekInputs = 'Trade Weekends?'
WeekdayInput = input(false, title = 'Do NOT Trade WeekDAYS (Default=Trade)', group = WeekInputs)
WeekendInput = input(false, title = 'Do NOT Trade WeekENDS (Default=Trade)', group = WeekInputs)
weekend = dayofweek == 1 or dayofweek == 7 ? 1 : 0
weekday = dayofweek == 2 or dayofweek == 3 or dayofweek == 4 or dayofweek == 5 or dayofweek == 6 ? 1 : 0
WeekendHalt = WeekendInput == true ? weekend : 0
WeekdayHalt = WeekdayInput == true ? weekday : 0
DayHalt = WeekendHalt == 1 or WeekdayHalt == 1 ? 1 : 0

////////////////////////////////////////////////////////////////
// Dump Protection Team Module                                //
////////////////////////////////////////////////////////////////  

//Dump Protection Team Module - V1.0 - 5/24/20
//Intent of the Dump Protection Team (DPT) is to predict Moon/Nukes and close any open trades accordingly. 
//Will also restart trading at end of whale manipulation

///////////////////////////////////////////////////////////
//Laguerrie Filter (LagF)                                //
///////////////////////////////////////////////////////////

//Orignally by Kıvanç Özbilgiç, modified by SignalLynx 
srcLAGF = close
alphaLAGF = 0.2

gammaLAGF = 1 - alphaLAGF
L0LAGF = 0.0
L0LAGF := (1 - gammaLAGF) * srcLAGF + gammaLAGF * nz(L0LAGF[1])
L1LAGF = 0.0
L1LAGF := -gammaLAGF * L0LAGF + nz(L0LAGF[1]) + gammaLAGF * nz(L1LAGF[1])

L2LAGF = 0.0
L2LAGF := -gammaLAGF * L1LAGF + nz(L1LAGF[1]) + gammaLAGF * nz(L2LAGF[1])

L3LAGF = 0.0
L3LAGF := -gammaLAGF * L2LAGF + nz(L2LAGF[1]) + gammaLAGF * nz(L3LAGF[1])

LagF = (L0LAGF + 2 * L1LAGF + 2 * L2LAGF + L3LAGF) / 6

LAGF_Signal = LagF > LagF[1] ? 1 : -1

//end of LagF module

///////////////////////////////////////////////////////////
//Tom Demark 9 (TD9) - Simple                            //
///////////////////////////////////////////////////////////

////originally by Scarf, with thanks to the scripts by glaz, bioharz and stripykitteh. Modified by SignalLynx, and modified by SignalLynx

Count1TD = 0
CountTD = close > close[4] ? 1 : 0
Count1TD := CountTD == 1 ? nz(Count1TD[1]) == 0 ? 1 : Count1TD[1] == 1 ? 2 : Count1TD[1] == 2 ? 3 : Count1TD[1] == 3 ? 4 : Count1TD[1] == 4 ? 5 : Count1TD[1] == 5 ? 6 : Count1TD[1] == 6 ? 7 : Count1TD[1] == 7 ? 8 : Count1TD[1] == 8 ? 9 : 0 : 0

Count2TD = 0
CountaTD = close < close[4] ? 1 : 0
Count2TD := CountaTD == 1 ? nz(Count2TD[1]) == 0 ? 1 : Count2TD[1] == 1 ? 2 : Count2TD[1] == 2 ? 3 : Count2TD[1] == 3 ? 4 : Count2TD[1] == 4 ? 5 : Count2TD[1] == 5 ? 6 : Count2TD[1] == 6 ? 7 : Count2TD[1] == 7 ? 8 : Count2TD[1] == 8 ? 9 : 0 : 0

piepbTD = 0
piep2TD = 0
piepbTD := Count1TD == 9 and piepbTD[1] == 0 ? 1 : piepbTD[1] > 0 ? piep2TD[1] == 13 ? 0 : nz(piepbTD[1]) + 1 : 0
piep2TD := piepbTD > 0 and close > high[2] ? piep2TD[1] == 13 ? 0 : nz(piep2TD[1]) + 1 : piep2TD[1] == 13 ? 0 : piep2TD[1]

piepaTD = 0
piepTD = 0
piepaTD := Count2TD == 9 and piepaTD[1] == 0 ? 1 : piepaTD[1] > 0 ? piepTD[1] == 13 ? 0 : nz(piepaTD[1]) + 1 : 0
piepTD := piepaTD > 0 and close < low[2] and close < low[1] ? piepTD[1] == 13 ? 0 : nz(piepTD[1]) + 1 : piepTD[1] == 13 ? 0 : piepTD[1]

EightTD = 0.0
ThirteenTD = 0
EightTD := piepTD == 8 ? close : EightTD[1]
ThirteenTD := piepTD == 13 and close > EightTD ? 2 : piepTD == 13 and close < EightTD ? 3 : 1
Thirteen_countTD = ThirteenTD[1] == 3 and close > EightTD ? 3 : ThirteenTD[1]

Eight2TD = 0.0
Thirteen2TD = 0
Eight2TD := piep2TD == 8 ? close : Eight2TD[1]
Thirteen2TD := piep2TD == 13 and close < Eight2TD ? 2 : piep2TD == 13 and close > Eight2TD ? 3 : 1
Thirteen_count2TD = Thirteen2TD[1] == 3 and close < Eight2TD ? 3 : Thirteen2TD[1]

TD_Orders = Count2TD == 9 or piepTD == 13 and piepTD[1] == 12 ? 1 : Count1TD == 9 or piep2TD == 13 and piep2TD[1] == 12 ? -1 : 0

TD_OrdersPerp = float(na)
TD_OrdersPerp := TD_Orders == 1 ? 1 : TD_Orders == -1 ? -1 : TD_OrdersPerp[1]


///////////////////////////////////////////////////////////
//Kijun Sen Bollinger Bands (KJBB)                       //
///////////////////////////////////////////////////////////

middleDonchianKJBB(LengthKJBB) =>
    lowerKJBB = ta.lowest(LengthKJBB)
    upperKJBB = ta.highest(LengthKJBB)
    math.avg(upperKJBB, lowerKJBB)

basePeriodsKJBB = 14
displacementKJBB = 14
KijunKJBB = middleDonchianKJBB(basePeriodsKJBB)
xChikouKJBB = close
xPriceKJBB = close

BB_lengthKJBB = 7
BB_stdDevKJBB = 3

bb_sKJBB = KijunKJBB
basisKJBB = ta.sma(bb_sKJBB, BB_lengthKJBB)
devKJBB = BB_stdDevKJBB * ta.stdev(bb_sKJBB, BB_lengthKJBB)
upperKJBB = basisKJBB + devKJBB
lowerKJBB = basisKJBB - devKJBB

KijunOrder = xPriceKJBB > upperKJBB ? 1 : xPriceKJBB < lowerKJBB ? -1 : 0

//end of Kijun sen BB module

///////////////////////////////////////////////////////////
//Super Z Module                                      //
///////////////////////////////////////////////////////////

//script taken from https://www.tradingview.com/script/kChCRRZI-Hull-Moving-Average/ 

src5SZ = close
tfSZ = 1440
len5SZ = timeframe.isintraday and timeframe.multiplier >= 1 ? tfSZ / timeframe.multiplier * 7 : timeframe.isintraday and timeframe.multiplier < 60 ? 60 / timeframe.multiplier * 24 * 7 : 7
maSZ = ta.ema(src5SZ * volume, len5SZ) / ta.ema(volume, len5SZ)
src1SZ = maSZ

pSZ(src1SZ, len5SZ) =>
    nSZ = 0.0
    sSZ = 0.0
    for iSZ = 0 to len5SZ - 1 by 1
        wSZ = (len5SZ - iSZ) * len5SZ
        nSZ := nSZ + wSZ
        sSZ := sSZ + src5SZ[iSZ] * wSZ
        sSZ
    sSZ / nSZ

hmSZ = 2.0 * pSZ(src1SZ, math.floor(len5SZ / 2)) - pSZ(src1SZ, len5SZ)
vhmaSZ = pSZ(hmSZ, math.floor(math.sqrt(len5SZ)))

vlSZ = vhmaSZ[0]
llSZ = vhmaSZ[1]

oSZ = request.security(syminfo.tickerid, timeframe.period, open[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
cSZ = request.security(syminfo.tickerid, timeframe.period, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
hzSZ = request.security(syminfo.tickerid, timeframe.period, high[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
lSZ = request.security(syminfo.tickerid, timeframe.period, low[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)

// INPUTS //
st_multSZ = 1.0
st_periodSZ = 30
// CALCULATIONS //
up_levSZ = lSZ - st_multSZ * ta.atr(st_periodSZ)
dn_levSZ = hzSZ + st_multSZ * ta.atr(st_periodSZ)

up_trendSZ = 0.0
up_trendSZ := cSZ[1] > up_trendSZ[1] ? math.max(up_levSZ, up_trendSZ[1]) : up_levSZ

down_trendSZ = 0.0
down_trendSZ := cSZ[1] < down_trendSZ[1] ? math.min(dn_levSZ, down_trendSZ[1]) : dn_levSZ

// Calculate trend var
trendSZ = 0
trendSZ := cSZ > down_trendSZ[1] ? 1 : cSZ < up_trendSZ[1] ? -1 : nz(trendSZ[1], 1)

// Calculate SuperTrend Line
st_lineSZ = trendSZ == 1 ? up_trendSZ : down_trendSZ

buySZ = ta.crossover(cSZ, st_lineSZ) ? 1 : 0
sellSZ = ta.crossunder(cSZ, st_lineSZ) ? -1 : 0

SZ_Signal = buySZ == 1 ? 1 : sellSZ == -1 ? -1 : 0
SZ_SignalPerp = float(na)
SZ_SignalPerp := SZ_Signal == 1 ? 1 : SZ_Signal == -1 ? -1 : SZ_SignalPerp[1]

//end of Super Z module

//Linear Regression Module
srcLRS = close
clenLRS = 50
slenLRS = 5
glenLRS = 13

lrcLRS = ta.linreg(srcLRS, clenLRS, 0)
lrsLRS = (lrcLRS - lrcLRS[1]) / 1
slrsLRS = ta.ema(lrsLRS, slenLRS)
alrsLRS = ta.sma(slrsLRS, glenLRS)
uacceLRS = lrsLRS > alrsLRS and lrsLRS > 0
dacceLRS = lrsLRS < alrsLRS and lrsLRS < 0

s_LRS = alrsLRS
nm_LRS = 7
rising_old_LRS(s_LRS, nm_LRS) =>
    res = true
    for i = 1 to nm_LRS by 1
        if s_LRS[0] <= s_LRS[i]
            res := false
            break
    res

LRS_SignalAgg = rising_old_LRS(s_LRS, nm_LRS) ? 1 : -1

///////////////////////////////////////////////////////////
//MESA Filter                                            //
///////////////////////////////////////////////////////////
// Copyright (c) 2018-present, Alex Orekhov (everget)
//Originally by everget, modified by SignalLynx for use in the trade engine

fastLimitMESA = 0.5
slowLimitMESA = 0.05
srcMESA = close
PIMESA = 2 * math.asin(1)

// Truncated Hilbert transform
hilbertTransformMESA(srcMESA) =>
    0.0962 * srcMESA + 0.5769 * nz(srcMESA[2]) - 0.5769 * nz(srcMESA[4]) - 0.0962 * nz(srcMESA[6])

computeComponentMESA(srcMESA, mesaPeriodMultMESA) =>
    hilbertTransformMESA(srcMESA) * mesaPeriodMultMESA

computeAlphaMESA(srcMESA, fastLimitMESA, slowLimitMESA) =>
    mesaPeriodMESA = 0.0
    mesaPeriodMultMESA = 0.075 * nz(mesaPeriodMESA[1]) + 0.54

    smoothMESA = 0.0
    smoothMESA := (4 * srcMESA + 3 * nz(srcMESA[1]) + 2 * nz(srcMESA[2]) + nz(srcMESA[3])) / 10

    detrenderMESA = 0.0
    detrenderMESA := computeComponentMESA(smoothMESA, mesaPeriodMultMESA)

    // Compute InPhase and Quadrature components
    I1MESA = nz(detrenderMESA[3])
    Q1MESA = computeComponentMESA(detrenderMESA, mesaPeriodMultMESA)

    // Advance the phase of I1 and Q1 by 90 degrees
    jIMESA = computeComponentMESA(I1MESA, mesaPeriodMultMESA)
    jQMESA = computeComponentMESA(Q1MESA, mesaPeriodMultMESA)

    I2MESA = 0.0
    Q2MESA = 0.0

    // Phasor addition for 3 bar averaging
    I2MESA := I1MESA - jQMESA
    Q2MESA := Q1MESA + jIMESA

    // Smooth the I and Q components before applying the discriminator
    I2MESA := 0.2 * I2MESA + 0.8 * nz(I2MESA[1])
    Q2MESA := 0.2 * Q2MESA + 0.8 * nz(Q2MESA[1])

    // Homodyne Discriminator
    ReMESA = I2MESA * nz(I2MESA[1]) + Q2MESA * nz(Q2MESA[1])
    ImMESA = I2MESA * nz(Q2MESA[1]) - Q2MESA * nz(I2MESA[1])

    ReMESA := 0.2 * ReMESA + 0.8 * nz(ReMESA[1])
    ImMESA := 0.2 * ImMESA + 0.8 * nz(ImMESA[1])

    if ReMESA != 0 and ImMESA != 0
        mesaPeriodMESA := 2 * PIMESA / math.atan(ImMESA / ReMESA)
        mesaPeriodMESA

    if mesaPeriodMESA > 1.5 * nz(mesaPeriodMESA[1])
        mesaPeriodMESA := 1.5 * nz(mesaPeriodMESA[1])
        mesaPeriodMESA

    if mesaPeriodMESA < 0.67 * nz(mesaPeriodMESA[1])
        mesaPeriodMESA := 0.67 * nz(mesaPeriodMESA[1])
        mesaPeriodMESA

    if mesaPeriodMESA < 6
        mesaPeriodMESA := 6
        mesaPeriodMESA

    if mesaPeriodMESA > 50
        mesaPeriodMESA := 50
        mesaPeriodMESA

    mesaPeriodMESA := 0.2 * mesaPeriodMESA + 0.8 * nz(mesaPeriodMESA[1])

    phaseMESA = 0.0

    if I1MESA != 0
        phaseMESA := 180 / PIMESA * math.atan(Q1MESA / I1MESA)
        phaseMESA

    deltaPhaseMESA = nz(phaseMESA[1]) - phaseMESA

    if deltaPhaseMESA < 1
        deltaPhaseMESA := 1
        deltaPhaseMESA

    alphaMESA = fastLimitMESA / deltaPhaseMESA

    if alphaMESA < slowLimitMESA
        alphaMESA := slowLimitMESA
        alphaMESA
    alphaMESA

alphaMESA = computeAlphaMESA(srcMESA, fastLimitMESA, slowLimitMESA)
alpha2MESA = alphaMESA / 2

mamaMESA = 0.0
mamaMESA := alphaMESA * srcMESA + (1 - alphaMESA) * nz(mamaMESA[1])

famaMESA = 0.0
famaMESA := alpha2MESA * mamaMESA + (1 - alpha2MESA) * nz(famaMESA[1])

longMESA = ta.crossover(mamaMESA, famaMESA)
shortMESA = ta.crossunder(mamaMESA, famaMESA)

MESA_Signal = longMESA == true ? 1 : shortMESA == true ? -1 : 0

MESA_SignalFinal = float(na)
MESA_SignalFinal := MESA_Signal == 1 ? 1 : MESA_Signal == -1 ? -1 : MESA_SignalFinal[1]

//Smoother Code
CloseSmoother = ta.ema(close, 14)

//Price Momentum Oscillator Inhibitor
// Originally by Alex Orekhov (everget), modified by SignalLynx for use in the trade engine

PMOfirstLength = 35
PMOsecondLength = 20
PMOsignalLength = 10
PMO_Inhib_Threshold = 0.4
PMOsrc = close

pmo = ta.ema(10 * ta.ema(nz(ta.roc(PMOsrc, 1)), PMOfirstLength), PMOsecondLength)
PMOsignal = ta.ema(pmo, PMOsignalLength)

PMO_CO = ta.crossover(pmo, PMOsignal)
PMO_CU = ta.crossunder(pmo, PMOsignal)

PMO_Signal = 1
PMO_Signal := PMO_CO ? 1 : PMO_CU ? -1 : PMO_Signal[1]

PMO_InhibPre = PMO_Inhib_Threshold * -1 < pmo and pmo < PMO_Inhib_Threshold and PMO_Inhib_Threshold * -1 < PMOsignal and PMOsignal < PMO_Inhib_Threshold ? 1 : HSRS_InhibXy == 1 ? 1 : 0

///////////////////////////////////////////////////////////
//DPT Final Signals                                      //
/////////////////////////////////////////////////////////// 

DPT3 = LAGF_Signal == 1 and TD_OrdersPerp == 1 and KijunOrder == 1 and SZ_SignalPerp == 1 and LRS_SignalAgg == 1 and MESA_SignalFinal == 1 ? 4 : LAGF_Signal == -1 and TD_OrdersPerp == -1 and KijunOrder == -1 and SZ_SignalPerp == -1 and LRS_SignalAgg == -1 and MESA_SignalFinal == -1 ? -4 : 0

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//End of Code Modules
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Buy Activator
var OrdersMod = 'Total Signals To Place Order'
ActivateOrders = input.int(title = 'Number Of Modules With Positive Signals to Place a Buy (Max=11)', minval = 1, defval = 11, maxval = 11, group = OrdersMod)

//Longs
// This calculates how many of the 12 modules are returning a "Long" signal (1) or a pass (0).
GoLongCount = LgCheck_1stMod + LgCheck_2ndMod + LgCheck_3rdMod + LgCheck_4thMod + LgCheck_5thMod + LgCheck_6thMod + LgCheck_7thMod + LgCheck_9thMod + LgCheck_10thMod + LgCheck_11thMod + LgCheck_12thMod

//Shorts 
// This calculates how many modules are returning a "Short" signal (-1).
GoShortCount = ShCheck_1stMod + ShCheck_2ndMod + ShCheck_3rdMod + ShCheck_4thMod + ShCheck_5thMod + ShCheck_6thMod + ShCheck_7thMod + ShCheck_9thMod + ShCheck_10thMod + ShCheck_11thMod + ShCheck_12thMod

// Trend Tracker Band aggregates all raw signals to visualize the overall market sentiment.
// Positive values = Bullish, Negative = Bearish.
TrendTrackerBand = FirstSignal + SecondSignal + Third_Signal + FourthSignal + FifthSignal + SixthSignal + SeventhSignal + MTISignal + NinthSignal + TenthSignal + EleventhSignal + TwelfthSignal
TrendTackerBandColor = TrendTrackerBand <= -8 ? color.red : TrendTrackerBand > -8 and TrendTrackerBand <= -5 ? color.orange : TrendTrackerBand > -5 and TrendTrackerBand <= -3 ? color.yellow : TrendTrackerBand > -3 and TrendTrackerBand <= 3 ? color.gray : TrendTrackerBand > 3 and TrendTrackerBand <= 5 ? color.olive : TrendTrackerBand > 5 and TrendTrackerBand < 8 ? color.green : TrendTrackerBand >= 8 ? color.lime : color.black

plotshape(TrendTrackerBand, style = shape.square, color = TrendTackerBandColor, location = location.top, size = size.tiny, title = 'Market Sentiment')

//Nuke and Moon Protection Code (Dump Protection Team - da DPT)
var NewOpen = 0
var OrderState = 1
var ItClosed = 0

/// Dump Protection Team 
// DPT is designed to detect extreme volatility (Pumps or Dumps) and force exits regardless of other indicators.
var DPTMod = 'Dump/Moon Protection Inputs'
DPTNum = input.int(title = 'Minimum Number of Modules to trigger DPT Moon Signal (Max=9)', minval = 1, defval = 6, maxval = 9, group = DPTMod)
DPTNumNeg = input.int(title = 'Minimum Number of Modules to trigger DPT Nuke Signal (Max=-9)', minval = -9, defval = -6, maxval = -1, group = DPTMod)
KickerPercentChoice = input(false, 'Use Agressive Trend Mapping for Kicker (Default = No)', group = DPTMod)
KickerPercentUpTrendPre = input.float(2.0, 'MTI Kicker Activation (%) - Up Trend', minval = 0, step = 0.1, group = DPTMod)
KickerPercentDnTrend = input.float(6.0, 'MTI Kicker Activation (%) - Down Trend', minval = 0, step = 0.1, group = DPTMod)
var DPTMod2 = 'Dump/Moon Protection Qualifiers'
CaptainDeadPool = input(true, title = 'Use \'Loose\' DPT (Default = Yes)', group = DPTMod2)

var MTI_Kicker_Final = 0
var MTI_Kick = 0

KickerPercentUpTrend = smoothedCloseRSI_HTF >= 88 ? KickerPercentUpTrendPre * 1.5 : KickerPercentUpTrendPre

DPT_Nuke = ShCheck_1stModDPT + ShCheck_3rdModDPT + ShCheck_4thModDPT + ShCheck_5thModDPT + ShCheck_6thModDPT + ShCheck_7thModDPT + ShCheck_10thModDPT + ShCheck_12thModDPT + ShCheck_BTCDModDPT <= DPTNumNeg ? -1 : 0
DPT_Moon = LgCheck_1stModDPT + LgCheck_3rdModDPT + LgCheck_4thModDPT + LgCheck_5thModDPT + LgCheck_6thModDPT + LgCheck_7thModDPT + LgCheck_10thModDPT + LgCheck_12thModDPT + LgCheck_BTCDModDPT >= DPTNum ? 1 : 0


DeadPoolL = DPT3 == 4 and DPT_Moon == 1 and MTI_Kicker_Final == 1 ? 1 : DPT3 == -4 and DPT_Nuke == -1 and MTI_Kicker_Final == -1 ? -1 : 0
DeadPoolR = DPT3 == 4 and DPT_Moon == 1 and MTI_Kick == -1 ? 1 : DPT3 == -4 and DPT_Nuke == -1 and MTI_Kick == 1 ? -1 : 0

DeadPool = CaptainDeadPool == true ? DeadPoolL : DeadPoolR
DPT_Final = DeadPool

DPT_FinalPerp = float(na)
DPT_FinalPerp := DPT_Final == 1 ? 1 : DPT_Final == -1 ? -1 : DPT_FinalPerp[1]

DPT_FinalPerp2 = float(na)
DPT_FinalPerp2 := DPT_Final == 1 ? 1 : DPT_Final == -1 ? -1 : NewOpen == 2 or NewOpen == -2 or ItClosed == 1 or ItClosed == -1 ? 0 : DPT_FinalPerp[1]

DPT_FirstPulse = DPT_FinalPerp == 1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == -2 ? 2 : DPT_FinalPerp == -1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == 2 ? -2 : 0
DRT_FirstPulse = DPT_FinalPerp == 1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == 2 ? 2 : DPT_FinalPerp == -1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == -2 ? -2 : 0

DRTX1 = input(true, title = 'Dump Protection Team - Close on Signal (Default = Yes)', group = DPTMod2)
DRTXR = input(false, title = 'Dump Protection Team - Restart On Signal - Note: DPT Close on Signal must be selected (Default = No)', group = DPTMod2)
DRTX2 = input(true, title = 'Dump Protection Team - Martingale on Signal (Default = Yes)', group = DPTMod2)
DrStrange = input(true, title = 'Use Restrictive Restart Inhibitor (Default = Yes)', group = DPTMod2)


DRT_MartCovertor = DPT_FirstPulse == 2 ? 1 : DPT_FirstPulse == -2 ? -1 : 0
DRT_RestartConverter = DRT_FirstPulse == 2 ? 1 : DRT_FirstPulse == -2 ? -1 : 0
DRT_Close = DRTX1 == true ? DPT_FirstPulse : 0 // 2 and -2
DRT_Mart = DRTX2 == true ? DRT_MartCovertor : 0 // 1 and -1
DRT_Restart = DRTX1 == true and DRTXR == true ? DRT_RestartConverter : 0

DPT_RestartInhibR = DRTX1 == true and DPT_FinalPerp2 == 1 and TD_OrdersPerp == 1 ? 1 : DRTX1 == true and DPT_FinalPerp2 == -1 and TD_OrdersPerp == -1 ? -1 : 0
DPT_RestartInhibL = 0
DPT_RestartInhib = DrStrange == true ? DPT_RestartInhibR : DPT_RestartInhibL

////////////////////////////////////////////////////////////////
//* Generate Combined Signals                                *//
////////////////////////////////////////////////////////////////

//Place Final Order Variables Below - Modify as needed based on code Modules buy and sell signals

var Martingale = 0
var MartingaleOpen = 0
var MartingaleCounter = 0
var ATSMart = 0
var tsMart = 0
var slMart = 0

MartingaleCounter := Martingale != 0 ? MartingaleCounter + 1 : (espf_SignalMartingale == 0 ? 0 : MartingaleCounter[1])

UsePMOInhib = input(false, title = 'Use PMO/HSRS Inhib? (Default = No)', group = DPTMod2)
PMO_Inhib = UsePMOInhib == true and SSGuppyFinal == 1 ? PMO_InhibPre : 0

//Prime Signals
// This logic checks if the Total Vote Count (GoLongCount/GoShortCount) meets the User Threshold (ActivateOrders).
// It also checks that Inhibitors (like ADX, HashRate, etc) are green.
GoLongPrime = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and MESA_SignalFinal == 1 and PMO_Inhib == 0 ? true : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == -1 or slMart == -1 or PiC_Signal == 1 ? true : false
CloseLongPrime = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or Fourth_LongCloseCheck == -1 or SOR_CloseLong_Check == 1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or Twelfth_LongCloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? true : false
GoShortPrime = math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and MESA_SignalFinal == -1 and PMO_Inhib == 0 ? true : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 ? true : false
CloseShortPrime = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or Fourth_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or Twelfth_ShortCloseCheck == 1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? true : false

AlertOpenPrime = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and MESA_SignalFinal == 1 and PMO_Inhib == 0 ? 2 : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == -1 or slMart == -1 or PiC_Signal == 1 ? 2 : math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and MESA_SignalFinal == -1 and PMO_Inhib == 0 ? -2 : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 ? -2 : 0
AlertCloseLPrime = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or SOR_CloseLong_Check == -1 or Fourth_LongCloseCheck == -1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or Twelfth_LongCloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? 1 : 0
AlertCloseSPrime = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fourth_ShortCloseCheck == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or Twelfth_ShortCloseCheck == 1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? -1 : 0

//Alt Signals - these are flipped for reverse trades
GoShortAlt = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and PMO_Inhib == 0 ? true : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == 1 or slMart == -1 ? true : false
CloseShortAlt = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or Fourth_LongCloseCheck == -1 or SOR_CloseLong_Check == 1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or Twelfth_LongCloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? true : false
GoLongAlt = math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and PMO_Inhib == 0 ? true : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 or PiC_Signal == 1 ? true : false
CloseLongAlt = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or Fourth_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or Twelfth_ShortCloseCheck == 1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? true : false

AlertOpenAlt = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and PMO_Inhib == 0 ? -2 : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == -1 or slMart == -1 ? -2 : math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and PMO_Inhib == 0 ? 2 : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 or PiC_Signal == 1 ? 2 : 0
AlertCloseSAlt = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or SOR_CloseLong_Check == -1 or Fourth_LongCloseCheck == -1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or Twelfth_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? 1 : 0
AlertCloseLAlt = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fourth_ShortCloseCheck == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or Twelfth_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? -1 : 0
////////////////////////////////////////////////////////////////
//* BB Chop Kicker - Swtich to MESA based trade              *//
////////////////////////////////////////////////////////////////
//BB code is in Order Qualifier Module
var MesaMod = 'MESA Based Trading Qualifier'
BBPinchFlip = input(false, title = 'MESA Trade Module - Switch to MESA based trading below this BB Spread Percentage (Default = No)', group = MesaMod)
BBPinchTrend = input(false, title = 'BB Pinch Trend Following - Conservative  (Default = No)', group = MesaMod)
BBInhibPercentFlip = input.float(3, 'BB Pinch % to Engage', minval = 0, step = 0.1, group = MesaMod)
BBChopInhibFlip = close * (BBInhibPercentFlip / 100) > upper3MBB - lower3MBB ? 1 : 0
DPT4 = LAGF_Signal == 1 and SZ_SignalPerp == 1 ? 4 : LAGF_Signal == -1 and SZ_SignalPerp == -1 ? -4 : 0
BBFlipFinal1 = BBPinchFlip == true and BBTrendUp == 0 and BBChopInhibFlip == 1 and Engagey == 0 ? 1 : 0 //and DPT4==0 and MTI_Kick!=0 ? 1 : 0
BBFlipFinal2 = BBPinchFlip == true and BBTrendUp == 0 and BBChopInhibFlip == 1 ? 1 : 0 //and DPT4==0 and MTI_Kick!=0 ? 1 : 0
BBFlipFinal = BBPinchTrend == true ? BBFlipFinal2 : BBFlipFinal1

s_CS = CloseSmoother
nm_CS = 14
rising_old_CS(s_CS, nm_CS) =>
    res = true
    for i = 1 to nm_CS by 1
        if s_CS[0] <= s_CS[i]
            res := false
            break
    res

falling_old_CS(s_CS, nm_CS) =>
    res = true
    for i = 1 to nm_CS by 1
        if s_CS[0] >= s_CS[i]
            res := false
            break
    res

// --- V6 FIX EXPLANATION ---
// Pre-calculating loop results for MESA activations
CS_isRising = rising_old_CS(s_CS, nm_CS)
CS_isFalling = falling_old_CS(s_CS, nm_CS)

MESA_ActivateLong = MESA_SignalFinal == 1 and Third_Signal == 1 and FifthSignal == 1 and SixthSignal == 1 and SeventhSignal == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and LAGF_Signal == 1 and CS_isRising == true and espf_MartingaleFinal == 1 and HSRS_Gap_Falling == 1 ? 2 : 0
MESA_ActivateShort = MESA_SignalFinal == -1 and Third_Signal == -1 and FifthSignal == -1 and SixthSignal == -1 and SeventhSignal == -1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and LAGF_Signal == -1 and CS_isFalling == true and espf_MartingaleFinal == -1 and HSRS_Gap_Falling == 1 ? -2 : 0
MESA_Activate = MESA_ActivateLong == 2 ? 2 : MESA_ActivateShort == -2 ? -2 : 0

////////////////////////////////////////////////////////////////
//* Flip Trades Code                                         *// 
////////////////////////////////////////////////////////////////

//Flip Trades - A Long calls a short, and a Short calls a long
var FlipMod = 'Special Circumstances - Flip Trade Signals'
FlipTradesX = input(false, 'Flip Trades? (Default = No)', group = FlipMod)
FlipMC = input(true, 'Flip Trades during Miner Captiulation and not near BTC Halving? (Default = Yes)', group = FlipMod)

FlipMCX = FlipMC == true and MinerCapitulationFinal == -1 and HalvingInhibitor == 0 ? true : false
Flippity = FlipTradesX == true or FlipMCX == true ? true : false

GoLongM = Flippity == false ? GoLongPrime : GoLongAlt
CloseLong = Flippity == false ? CloseLongPrime : CloseLongAlt
GoShortM = Flippity == false ? GoShortPrime : GoShortAlt
CloseShort = Flippity == false ? CloseShortPrime : CloseShortAlt

AlertOpenM = Flippity == false ? AlertOpenPrime : AlertOpenAlt
AlertCloseL = Flippity == false ? AlertCloseLPrime : AlertCloseLAlt
AlertCloseS = Flippity == false ? AlertCloseSPrime : AlertCloseSAlt

// --- V6 FIX EXPLANATION ---
// In V6, mixing Types (Integers and Booleans) in logic is strictly forbidden.
// Previously this returned 2 or -2 (Integers), but GoLongM returns True/False.
// We must normalize this so it always returns True or False.
GoLongX = MartingaleOpen == 3 ? true : GoLongM
GoShortX = MartingaleOpen == -3 ? true : GoShortM
AlertOpenX = MartingaleOpen == 3 ? 2 : MartingaleOpen == -3 ? -2 : AlertOpenM

GoLong = BBFlipFinal == 1 and MESA_ActivateLong == 2 ? true : GoLongX
GoShort = BBFlipFinal == 1 and MESA_ActivateLong == -2 ? true : GoShortX
AlertOpenY = BBFlipFinal == 1 ? MESA_Activate : AlertOpenX
MESA_Tracker = BBFlipFinal == 1 and MESA_Activate != 0 ? 1 : 0

//Check for Days to Buy
AlertOpen = DayHalt == 1 ? 0 : AlertOpenY

MCHR_plotColor = Minercapitulation == -1 and MinerCapitulationFinal == -1 and HalvingInhibitor == 0 ? color.red : Minercapitulation == -1 and MinerCapitulationFinal == -1 and HalvingInhibitor == 1 ? color.blue : color.orange
plotshape(MinerPlot, style = shape.circle, color = MCHR_plotColor, location = location.bottom, size = size.tiny, title = 'Miner Capitulation')

////////////////////////////////////////////////////////////////
//* Trade State Engine (Risk Managemnt Translation)          *//
////////////////////////////////////////////////////////////////

//Buy Confirmations
var BuyMod = 'Order Signal Modifier - Sequential Signals'
BuyConfirms = input.int(title = 'Buy Confirmations: Required Number of Sequential Buy Signals to Trigger (Default=1)', minval = 1, defval = 1, group = BuyMod)

var BuyCounts = 0
BuyCounts := AlertOpen == 2 ? BuyCounts + 1 : AlertOpen == -2 ? BuyCounts - 1 : 0

//Do not modify Variables below this - Trade Engine Code
// --- V6 FIX EXPLANATION ---
// Added parentheses to clarify Order of Operations for the parser.
AOX = (AlertOpen == 2 and AlertOpen != AlertOpen[1]) ? 2 : (AlertOpen == -2 and AlertOpen != AlertOpen[1]) ? -2 : 0
AOZ = (AlertOpen == 2 and BuyConfirms == BuyCounts) ? 2 : (AlertOpen == -2 and BuyConfirms == BuyCounts * -1) ? -2 : 0
AO = BuyConfirms == 1 ? AOX : AOZ

var AT = 0
AT := AO == 2 ? 2 : AO == -2 ? -2 : AT[1]
AF = float(na)
AF := AT == 2 and AT[1] != 2 ? 2 : AT == -2 and AT[1] != -2 ? -2 : 0

MCStateKicker := Flippity == false ? AT : AT * -1

OrderState := AT
CS = CloseShort == true ? -1 : 0
CL = CloseLong == true ? 1 : 0

CS1 = CS == -1 and CS != CS[1] ? -1 : 0
CL1 = CL == 1 and CL != CL[1] ? 1 : 0

CSX = AT == 2 ? CL1 : AT == -2 ? CS1 : 0
AlertClose = AT == 2 ? AlertCloseL : AT == -2 ? AlertCloseS : 0

//Determine what kind of Risk We want to take
//Using Agressive Setting will "reset" Risk Management values if Algo determines conditions are still valid (consider this a pyrmamiding type I)
var RiskMod = 'Main Risk Managment Settings'
AgressiveRMPre = input(true, 'Utilize Agresive RM - Reset RM Values as Long as Algo determines entry conditions are valid (Default- Agressive)', group = RiskMod)
UseAGRM = input(true, 'Use Active RM Agressiviness (Default- Yes)', group = RiskMod)
AgressiveRM = BBADXKicker >= 2 and UseAGRM == true ? true : UseAGRM == false ? AgressiveRMPre : false

TradeEngineX = AlertOpen == 2 ? 1 : AlertOpen == -2 ? -1 : 0
TradeEngineY = AF == 2 ? 1 : AF == -2 ? -1 : 0

TradeEngineRisk = AgressiveRM == false ? TradeEngineY : TradeEngineX
TradeEngineRiskTight = TradeEngineY

RebuySentiment = AlertOpen == 2 ? 1 : AlertOpen == -2 ? -1 : na
RebuySentimentColor = AlertOpen == 2 ? color.green : AlertOpen == -2 ? color.red : color.purple
plotshape(RebuySentiment, style = shape.cross, color = RebuySentimentColor, location = location.bottom, size = size.small, title = 'Re-Buy Sentiment')

//////////////////////////////
//* Risk Management Code   *//
//////////////////////////////

//DO NOT MODIFY
open_ = open[1]
close_ = close[1]
high_X = high[1]
low_X = low[1]

// === RISK MANAGEMENT VALUE PREP ===
//Determine what Bar values we should use for Risk managment
BarTypeRM = input(false, 'Use Candle Open/Close for Risk Management (Default is Candle High/Low)', group = RiskMod)

low_ = BarTypeRM == true ? close_ : low_X
high_ = BarTypeRM == true ? close_ : high_X

////////////////////////////////////////////////
// Risk Management generates Buy Sell signals //
////////////////////////////////////////////////

RiskOpenR = AgressiveRM == false ? AF : AO
RiskCloseLR = AgressiveRM == false ? CSX : CL
RiskCloseSR = AgressiveRM == false ? CSX : CS

RiskOpenRTight = AF
RiskCloseLRTight = CSX
RiskCloseSRTight = CSX

openLongR = RiskOpenR == 2 ? true : false
closeLongR = RiskCloseLR == 1 ? true : false

openLongRTight = RiskOpenRTight == 2 ? true : false
closeLongRTight = RiskCloseLRTight == 1 ? true : false

openShortR = RiskOpenR == -2 ? true : false
closeShortR = RiskCloseSR == -1 ? true : false //

openShortRTight = RiskOpenRTight == -2 ? true : false
closeShortRTight = RiskCloseSRTight == -1 ? true : false

buy = 0
buy := openLongR ? nz(buy[1]) > 0 ? buy[1] + 1 : 1 : 0
sell = 0
sell := openShortR ? nz(sell[1]) > 0 ? sell[1] + 1 : 1 : 0

buyTight = 0
buyTight := openLongRTight ? nz(buyTight[1]) > 0 ? buyTight[1] + 1 : 1 : 0
sellTight = 0
sellTight := openShortRTight ? nz(sellTight[1]) > 0 ? sellTight[1] + 1 : 1 : 0

//////////////////////////
//* Trade State Engine *//
//////////////////////////

// Keep track of current trade state
var bool longCloseX  = false
var bool shortCloseX = false

// Carry forward previous bar state by default
if bar_index > 0
    longCloseX  := longCloseX[1]
    shortCloseX := shortCloseX[1]

tradeState = TradeEngineRisk
tradeStateTight = TradeEngineRiskTight

//////////////////////////////////////////////////////////
//Handle Entry Conditions, when state changes direction //
//////////////////////////////////////////////////////////

// --- V6 FIX EXPLANATION ---
// In V6, the result of ta.change() is a float (the difference between values).
// You cannot use "float and bool". You must convert the float to bool by checking "!= 0".
longCondition = false
shortCondition = false
longCondition := ta.change(tradeState) != 0 and tradeState == 1
shortCondition := ta.change(tradeState) != 0 and tradeState == -1

longConditionTight = false
shortConditionTight = false
longConditionTight := ta.change(tradeStateTight) != 0 and tradeStateTight == 1
shortConditionTight := ta.change(tradeStateTight) != 0 and tradeStateTight == -1

// Exit on Sell signal
longExitC = CL == 1 or AlertOpen == -2 ? 1 : 0
shortExitC = CS == -1 or AlertOpen == 2 ? 1 : 0

// Exit condition for no SL.
longExit = ta.change(longExitC) != 0 and longExitC == 1 and tradeState == 1
shortExit = ta.change(shortExitC) != 0 and shortExitC == 1 and tradeState == -1

/////////////////////////////////////
//======[ Deal Entry Prices ]======//
/////////////////////////////////////

last_open_longCondition = float(na)
last_open_shortCondition = float(na)
last_open_longCondition := longCondition ? close : nz(last_open_longCondition[1])
last_open_shortCondition := shortCondition ? close : nz(last_open_shortCondition[1])

last_open_longConditionTight = float(na)
last_open_shortConditionTight = float(na)
last_open_longConditionTight := longConditionTight ? close : nz(last_open_longConditionTight[1])
last_open_shortConditionTight := shortConditionTight ? close : nz(last_open_shortConditionTight[1])

//////////////////////////////////
//======[ Position State ]======//
//////////////////////////////////

in_longCondition = AT == 2 ? true : false
in_shortCondition = AT == -2 ? true : false

MESA_SL_Kicker = AT != 0 and AT != AT[1] and MESA_Tracker == 1 ? 1 : 0
MESA_SL_KickerPerp = float(na)
MESA_SL_KickerPerp := MESA_SL_Kicker == 1 ? 1 : AT != AT[1] ? 0 : MESA_SL_KickerPerp[1]

/////////////////////////////////
//======[ Trailing Stop ]======//
/////////////////////////////////

var TSMod = 'Trailing Stop Settings'
isTSPre = input(true, 'Trailing Stop', group = TSMod)
ESPF_TS_Activation = input(false, 'Activate Trailing Stop on ESPF Signal (Start with Act of 10% and TS of 20%)', group = TSMod)
useActiveHSRS_TS = input(false, 'Use Active HSRS Trailing Stop (Default = No)', group = TSMod)
tsActivationPre = input.float(18.0, 'Trailing Stop Activation (%)', minval = 0, step = 0.1, group = TSMod) / 100
tsPre = input.float(6.0, 'Trailing Stop (%)', minval = 0, step = 0.1, group = TSMod) / 100

isTS = HSRS_InhibXy == 1 and useActiveHSRS_TS == true ? true : isTSPre
tsActivation = HSRS_InhibXy == 1 and useActiveHSRS_TS == true ? 0.03 : tsActivationPre
ts = HSRS_InhibXy == 1 and useActiveHSRS_TS == true ? 0.01 : tsPre

espf_LongTSActivate = ESPF_TS_Activation == true and espf_FinalX == -1 ? true : false
espf_ShortTSActivate = ESPF_TS_Activation == true and espf_FinalX == 1 ? true : false

LongTSActivate = low_X > last_open_longCondition + last_open_longCondition * tsActivation and isTS == true ? true : false
ShortTSActivate = high_X < last_open_shortCondition - last_open_shortCondition * tsActivation and isTS == true ? true : false

last_highTS = float(na)
last_lowTS = float(na)
last_high_shortTS = float(na)
last_low_longTS = float(na)
last_highTS := not in_longCondition ? na : in_longCondition and (na(last_highTS[1]) or high_X > nz(last_highTS[1])) ? high_X : nz(last_highTS[1])
last_high_shortTS := not in_shortCondition ? na : in_shortCondition and (na(last_highTS[1]) or high_X > nz(last_highTS[1])) ? high_X : nz(last_highTS[1])
last_lowTS := not in_shortCondition ? na : in_shortCondition and (na(last_lowTS[1]) or low_X < nz(last_lowTS[1])) ? low_X : nz(last_lowTS[1])
last_low_longTS := not in_longCondition ? na : in_longCondition and (na(last_lowTS[1]) or low_X < nz(last_lowTS[1])) ? low_X : nz(last_lowTS[1])

long_ts = (isTS or ESPF_TS_Activation) and in_longCondition and not na(last_highTS) and (LongTSActivate == true or espf_LongTSActivate == true) and low_X <= last_highTS - last_highTS * ts
short_ts = (isTS or ESPF_TS_Activation) and in_shortCondition and not na(last_lowTS) and (ShortTSActivate == true or espf_ShortTSActivate == true) and high_X >= last_lowTS + last_lowTS * ts

var MesaTSMod = 'MESA Trailing Stop'
BB_TS_On = input(false, 'MESA Trades - Activate Trailing Stop', group = MesaTSMod)
BBtsActivate = input.float(2.0, 'MESA ONLY - Trailing Stop  Activation (%)', minval = 0, step = 0.1, group = MesaTSMod) / 100
tsbb = input.float(1.0, 'Trailing Stop (%)', minval = 0, step = 0.1, group = MesaTSMod) / 100

LongTSActivateBB = low_X > last_open_longConditionTight + last_open_longConditionTight * BBtsActivate and BB_TS_On == true and HSRS_Gap_Falling == 1 ? true : false
ShortTSActivateBB = high_X < last_open_shortConditionTight - last_open_shortConditionTight * BBtsActivate and BB_TS_On == true and HSRS_Gap_Falling == 1 ? true : false

long_tsBB = BB_TS_On and MESA_SL_KickerPerp == 1 and in_longCondition and not na(last_highTS) and LongTSActivateBB == true and low_X <= last_highTS - last_highTS * tsbb
short_tsBB = BB_TS_On and MESA_SL_KickerPerp == 1 and in_shortCondition and not na(last_lowTS) and ShortTSActivateBB == true and high_X >= last_lowTS + last_lowTS * tsbb

ts_CloseSignal = long_ts == true or long_tsBB == true ? 1 : short_ts == true or short_tsBB == true ? -1 : 0

///////////////////////////////////////////////////////////
// Highs and Lows tracking for Take Profit and Stop Loss //
///////////////////////////////////////////////////////////

last_high = float(na)
last_low = float(na)
last_high_short = float(na)
last_low_long = float(na)
last_high := not in_longCondition ? na : in_longCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : nz(last_high[1])
last_high_short := not in_shortCondition ? na : in_shortCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : nz(last_high[1])
last_low := not in_shortCondition ? na : in_shortCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : nz(last_low[1])
last_low_long := not in_longCondition ? na : in_longCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : nz(last_low[1])

///////////////////////////////  
//======[ Take Profit ]======//
/////////////////////////////// 

var TakeProfitMod = 'Take Profit Settings'
isTP = input(false, 'Take Profit', group = TakeProfitMod)
tp = input.float(12.0, 'Take Profit (%)', minval = 0, step = 0.1, group = TakeProfitMod) / 100
ttp = input.float(2.5, 'Trailing Profit (%)', minval = 0, step = 0.1, group = TakeProfitMod) / 100
ttp := ttp > tp ? tp : ttp

long_tp = isTP and in_longCondition and last_high >= last_open_longCondition + last_open_longCondition * tp and low_ <= last_high - last_high * ttp
short_tp = isTP and in_shortCondition and last_low <= last_open_shortCondition - last_open_shortCondition * tp and high_ >= last_low + last_low * ttp

/////////////////////////////////////
//======[ Staged Take Profit]======//   
/////////////////////////////////////

var StagedTPMod = 'Staged Take Profit Settings'
isSTP = input(false, 'Use Staged Take Profit (Default = No)', group = StagedTPMod)
isSTPIndices = input(false, 'Add Indices Exit Modifier (Default = No)', group = StagedTPMod)
isSTPIndicesFlip = input(false, 'Flip Indices Exit Modifier (Default = No)', group = StagedTPMod)
Stp1Per = input.float(10.0, '1st Level - Take Profit Activation Percent (%))', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp1Trail = input.float(5.0, '1st Level - Trailing Profit Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp1Qty = input.float(10.0, '1st Level - Close Order Quantity (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp2Per = input.float(20.0, '2nd Level - Take Profit Activation Percent (%))', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp2Trail = input.float(10.0, '2nd Level - Trailing Profit Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp2Qty = input.float(10.0, '2nd Level - Close Order Quantity (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp3Per = input.float(30.0, '3rd Level - Take Profit Activation Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp3Trail = input.float(5.0, '3rd Level - Trailing Profit Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100
Stp3Qty = input.float(70.0, '3rd Level - Close Order Quantity (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100

//Indices Strength Buy/Sell Requirements
IndicesStrengthTP1 = input.int(title = 'TP1 - Indices Trigger Strength(Max=12; Min=1)', minval = 1, defval = 6, maxval = 12, group = StagedTPMod)
IndicesContTP1 = input.int(title = 'TP1 - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = StagedTPMod)
IndicesStrengthTP2 = input.int(title = 'TP2 - Indices Trigger Strength(Max=12; Min=1)', minval = 1, defval = 8, maxval = 12, group = StagedTPMod)
IndicesContTP2 = input.int(title = 'TP2 - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = StagedTPMod)
IndicesStrengthTP3 = input.int(title = 'TP3 - Indices Trigger Strength(Max=12; Min=1)', minval = 1, defval = 10, maxval = 12, group = StagedTPMod)
IndicesContTP3 = input.int(title = 'TP3 - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = StagedTPMod)

var ICL1_EnterCounter = 0
var ICS1_EnterCounter = 0
var ICL2_EnterCounter = 0
var ICS2_EnterCounter = 0
var ICL3_EnterCounter = 0
var ICS3_EnterCounter = 0

ICL1_EnterCounter := TrendTrackerBand >= IndicesStrengthTP1 ? ICL1_EnterCounter + 1 : 0
ICS1_EnterCounter := TrendTrackerBand <= IndicesStrengthTP1 * -1 ? ICS1_EnterCounter + 1 : 0
ICL2_EnterCounter := TrendTrackerBand >= IndicesStrengthTP2 ? ICL2_EnterCounter + 1 : 0
ICS2_EnterCounter := TrendTrackerBand <= IndicesStrengthTP2 * -1 ? ICS2_EnterCounter + 1 : 0
ICL3_EnterCounter := TrendTrackerBand >= IndicesStrengthTP3 ? ICL3_EnterCounter + 1 : 0
ICS3_EnterCounter := TrendTrackerBand <= IndicesStrengthTP3 * -1 ? ICS3_EnterCounter + 1 : 0

//Prime Indices Conditions
IndicesBuy1Prime = TrendTrackerBand >= IndicesStrengthTP1 and ICL1_EnterCounter >= IndicesContTP1 and close_ < last_open_shortConditionTight ? 1 : 0
IndicesShort1Prime = TrendTrackerBand <= IndicesStrengthTP1 * -1 and ICS1_EnterCounter >= IndicesContTP1 and close_ > last_open_longConditionTight ? -1 : 0
IndicesBuy2Prime = TrendTrackerBand >= IndicesStrengthTP2 and ICL2_EnterCounter >= IndicesContTP2 and close_ < last_open_shortConditionTight ? 1 : 0
IndicesShort2Prime = TrendTrackerBand <= IndicesStrengthTP2 * -1 and ICS2_EnterCounter >= IndicesContTP2 and close_ > last_open_longConditionTight ? -1 : 0
IndicesBuy3Prime = TrendTrackerBand >= IndicesStrengthTP3 and ICL3_EnterCounter >= IndicesContTP3 and close_ < last_open_shortConditionTight ? 1 : 0
IndicesShort3Prime = TrendTrackerBand <= IndicesStrengthTP3 * -1 and ICS3_EnterCounter >= IndicesContTP3 and close_ > last_open_longConditionTight ? -1 : 0

//Alternate Indices Conditions 
IndicesBuy1Alt = TrendTrackerBand <= IndicesStrengthTP1 * -1 and ICL1_EnterCounter >= IndicesContTP1 and close_ > last_open_longConditionTight ? 1 : 0
IndicesShort1Alt = TrendTrackerBand >= IndicesStrengthTP1 and ICS1_EnterCounter >= IndicesContTP1 and close_ < last_open_shortConditionTight ? -1 : 0
IndicesBuy2Alt = TrendTrackerBand <= IndicesStrengthTP2 * -1 and ICL2_EnterCounter >= IndicesContTP2 and close_ > last_open_longConditionTight ? 1 : 0
IndicesShort2Alt = TrendTrackerBand >= IndicesStrengthTP2 and ICS2_EnterCounter >= IndicesContTP2 and close_ < last_open_shortConditionTight ? -1 : 0
IndicesBuy3Alt = TrendTrackerBand <= IndicesStrengthTP3 * -1 and ICL3_EnterCounter >= IndicesContTP3 and close_ > last_open_longConditionTight ? 1 : 0
IndicesShort3Alt = TrendTrackerBand >= IndicesStrengthTP3 and ICS3_EnterCounter >= IndicesContTP3 and close_ < last_open_shortConditionTight ? -1 : 0

IndicesBuy1 = isSTPIndicesFlip == false ? IndicesBuy1Prime : IndicesBuy1Alt
IndicesBuy2 = isSTPIndicesFlip == false ? IndicesBuy2Prime : IndicesBuy2Alt
IndicesBuy3 = isSTPIndicesFlip == false ? IndicesBuy3Prime : IndicesBuy3Alt
IndicesShort1 = isSTPIndicesFlip == false ? IndicesShort1Prime : IndicesShort1Alt
IndicesShort2 = isSTPIndicesFlip == false ? IndicesShort2Prime : IndicesShort2Alt
IndicesShort3 = isSTPIndicesFlip == false ? IndicesShort3Prime : IndicesShort3Alt

LongTSActivate1 = last_high >= last_open_longCondition + last_open_longCondition * (Stp1Per / 100) ? true : false
ShortTSActivate1 = last_low <= last_open_shortCondition - last_open_shortCondition * (Stp1Per / 100) ? true : false
LongTSActivate2 = last_high >= last_open_longCondition + last_open_longCondition * (Stp2Per / 100) ? true : false
ShortTSActivate2 = last_low <= last_open_shortCondition - last_open_shortCondition * (Stp2Per / 100) ? true : false
LongTSActivate3 = last_high >= last_open_longCondition + last_open_longCondition * (Stp3Per / 100) ? true : false
ShortTSActivate3 = last_low <= last_open_shortCondition - last_open_shortCondition * (Stp3Per / 100) ? true : false

long_Stp1 = isSTP and in_longCondition and not na(last_high) and isSTPIndices == true and IndicesShort1 == -1 ? true : isSTP and in_longCondition and not na(last_high) and LongTSActivate1 == true and low_ <= last_high - last_high * (Stp1Trail / 100) ? true : false
short_Stp1 = isSTP and in_shortCondition and not na(last_low) and isSTPIndices == true and IndicesBuy1 == 1 ? true : isSTP and in_shortCondition and not na(last_low) and ShortTSActivate1 == true and high_ >= last_low + last_low * (Stp1Trail / 100) ? true : false
long_Stp2 = isSTP and in_longCondition and not na(last_high) and isSTPIndices == true and IndicesShort2 == -1 ? true : isSTP and in_longCondition and not na(last_high) and LongTSActivate2 == true and low_ <= last_high - last_high * (Stp2Trail / 100) ? true : false
short_Stp2 = isSTP and in_shortCondition and not na(last_low) and isSTPIndices == true and IndicesBuy2 == 1 ? true : isSTP and in_shortCondition and not na(last_low) and ShortTSActivate2 == true and high_ >= last_low + last_low * (Stp2Trail / 100) ? true : false
long_Stp3 = isSTP and in_longCondition and not na(last_high) and isSTPIndices == true and IndicesShort3 == -1 ? true : isSTP and in_longCondition and not na(last_high) and LongTSActivate3 == true and low_ <= last_high - last_high * (Stp3Trail / 100) ? true : false
short_Stp3 = isSTP and in_shortCondition and not na(last_low) and isSTPIndices == true and IndicesBuy3 == 1 ? true : isSTP and in_shortCondition and not na(last_low) and ShortTSActivate3 == true and high_ >= last_low + last_low * (Stp3Trail / 100) ? true : false

longSTP1S = long_Stp1 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na
longSTP2S = long_Stp2 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na
longSTP3S = long_Stp3 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na

shortSTP1S = short_Stp1 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na
shortSTP2S = short_Stp2 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na
shortSTP3S = short_Stp3 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na

longSTP1 = isSTPIndices == true and IndicesShort1 == -1 ? close : long_Stp1 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na
longSTP2 = isSTPIndices == true and IndicesShort2 == -1 ? close : long_Stp2 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na
longSTP3 = isSTPIndices == true and IndicesShort3 == -1 ? close : long_Stp3 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na

shortSTP1 = isSTPIndices == true and IndicesBuy1 == 1 ? close : short_Stp1 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na
shortSTP2 = isSTPIndices == true and IndicesBuy2 == 1 ? close : short_Stp2 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na
shortSTP3 = isSTPIndices == true and IndicesBuy3 == 1 ? close : short_Stp3 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na

Stp1QtyF = Stp1Qty <= 0 ? na : Stp1Qty
Stp2QtyF = Stp2Qty <= 0 ? na : Stp2Qty
Stp3QtyF = Stp3Qty <= 0 ? na : Stp3Qty

// --- V6 FIX EXPLANATION ---
// In V6, we cannot compare a boolean to 0 (e.g. `long_Stp1 != 0`).
// We must just check the boolean itself.
var Counter_LTP1 = 0
Counter_LTP1 := long_Stp1 ? Counter_LTP1 + 1 : AF != 0 ? 0 : Counter_LTP1[1]
var Counter_LTP2 = 0
Counter_LTP2 := long_Stp2 ? Counter_LTP2 + 1 : AF != 0 ? 0 : Counter_LTP2[1]
var Counter_LTP3 = 0
Counter_LTP3 := long_Stp3 ? Counter_LTP3 + 1 : AF != 0 ? 0 : Counter_LTP3[1]
var Counter_STP1 = 0
Counter_STP1 := short_Stp1 ? Counter_STP1 + 1 : AF != 0 ? 0 : Counter_STP1[1]
var Counter_STP2 = 0
Counter_STP2 := short_Stp2 ? Counter_STP2 + 1 : AF != 0 ? 0 : Counter_STP2[1]
var Counter_STP3 = 0
Counter_STP3 := short_Stp3 ? Counter_STP3 + 1 : AF != 0 ? 0 : Counter_STP3[1]

TakeProfit1Plot = long_Stp1 == true and long_Stp1 != long_Stp1[1] and Counter_LTP1 == 1 ? 1 : short_Stp1 == true and short_Stp1 != short_Stp1[1] and Counter_STP1 == 1 ? -1 : 0
TakeProfit2Plot = long_Stp2 == true and long_Stp2 != long_Stp2[1] and Counter_LTP2 == 1 ? 2 : short_Stp2 == true and short_Stp2 != short_Stp2[1] and Counter_STP2 == 1 ? -2 : 0
TakeProfit3Plot = long_Stp3 == true and long_Stp3 != long_Stp3[1] and Counter_LTP3 == 1 ? 3 : short_Stp3 == true and short_Stp3 != short_Stp3[1] and Counter_STP3 == 1 ? -3 : 0

/////////////////////////////
//======[ Stop Loss ]======//
///////////////////////////// 

var SLMod = 'Stop Loss Settings'
isSLPre = input(true, 'Stop Loss', group = SLMod)
slPre = input.float(18.0, 'Stop Loss (%)', minval = 0, step = 0.1, group = SLMod) / 100
useActiveHSRS_SL = input(false, 'Use Active HSRS Stop Loss (Default = No)', group = SLMod)

IndicesStrengthOmegaStop = input.int(title = '*Omega Stop - Indices Trigger Strength (Max=12; Min=1)', minval = 1, defval = 12, maxval = 12, group = SLMod)
IndicesContOmegaStop = input.int(title = '*Omega Stop - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = SLMod)

var ICLOmegaStop_EnterCounter = 0
var ICSOmegaStop_EnterCounter = 0

ICLOmegaStop_EnterCounter := TrendTrackerBand >= IndicesStrengthOmegaStop ? ICLOmegaStop_EnterCounter + 1 : 0
ICSOmegaStop_EnterCounter := TrendTrackerBand <= IndicesStrengthOmegaStop * -1 ? ICSOmegaStop_EnterCounter + 1 : 0

IndicesBuyOmegaStop = TrendTrackerBand >= IndicesStrengthOmegaStop and ICLOmegaStop_EnterCounter >= IndicesContOmegaStop ? 1 : 0
IndicesShortOmegaStop = TrendTrackerBand <= IndicesStrengthOmegaStop * -1 and ICSOmegaStop_EnterCounter >= IndicesContOmegaStop ? -1 : 0

isSL = HSRS_InhibXy == 1 and useActiveHSRS_SL == true ? true : isSLPre
sl = HSRS_InhibXy == 1 and useActiveHSRS_SL == true ? 0.02 : slPre

long_sl = isSL and in_longCondition and low_ <= last_open_longCondition - last_open_longCondition * sl ? true : IndicesShortOmegaStop == -1 ? true : false
short_sl = isSL and in_shortCondition and high_ >= last_open_shortCondition + last_open_shortCondition * sl ? true : IndicesBuyOmegaStop == 1 ? true : false

sl_CloseSignal = long_sl == true ? 1 : short_sl == true ? -1 : 0

/////////////////////////////////////////////////
//======[Advance Adaptive Trailing Stop ]======//
/////////////////////////////////////////////////

//50 period EMA
lenEMA = 50
srcEMA = close
outEMA = ta.sma(srcEMA, lenEMA)
CS_AATS = ta.ema(close, 7)

HSRS_RangePenthouse = CS_AATS >= upper_HSRS ? 6 : 0
HSRS_Range4thFloor = CS_AATS < upper_HSRS and CS_AATS >= upperHSRS ? 5 : 0
HSRS_Range3rdFloor = CS_AATS < upperHSRS and CS_AATS >= basisHSRS ? 4 : 0
HSRS_Range2ndFloor = CS_AATS < basisHSRS and CS_AATS >= lowerHSRS ? 3 : 0
HSRS_Range1stFloor = CS_AATS < lowerHSRS and CS_AATS >= lower_HSRS ? 2 : 0
HSRS_RangeDungeon = CS_AATS < lower_HSRS ? 1 : 0
HSRS_Location = HSRS_RangeDungeon + HSRS_Range1stFloor + HSRS_Range2ndFloor + HSRS_Range3rdFloor + HSRS_Range4thFloor + HSRS_RangePenthouse

AATS_Engage3 = CS_AATS > outEMA and CS_AATS > basisHSRS and CS_AATS > upper1MBB ? 1 : CS_AATS < outEMA and CS_AATS < basisHSRS and CS_AATS < lower1MBB ? -1 : 0
AATS_Factor = AATS_Engage3 == 1 and HSRS_Location == 6 ? 0.5 : AATS_Engage3 == 1 and HSRS_Location == 5 ? 2 : AATS_Engage3 == 1 and HSRS_Location == 4 ? 3 : AATS_Engage3 == -1 and HSRS_Location == 1 ? 0.5 : AATS_Engage3 == -1 and HSRS_Location == 2 ? 2 : AATS_Engage3 == -1 and HSRS_Location == 3 ? 3 : 4

var SLMod2 = 'Stop Loss Qualifiers'

//ATS Code
//Code originlly by alexgrover, modified by SignalLynx for use in the trade engine
UseAATS = input(true, 'Use Advance Adaptive Trailing Stop (AATS) - (Default is On)', group = SLMod2)
RestrictiveAATS = input(true, 'Use Restrictive AATS - Good for majors (Default is On)', group = SLMod2)
UseRSIS = input(true, 'Use RSI Stop (RSIS) - (Default is On)', group = SLMod2)

srcATS = close
aATS = 0.0
bATS = 0.0
osATS = 0.0

atsFacInput = input(100, 'ATS Stop Factor (0+)', group = SLMod2)
erATS = AATS_Factor / atsFacInput


aATS := math.max(srcATS, nz(aATS[1], srcATS)) - math.abs(srcATS - nz(aATS[1], srcATS)) * erATS
bATS := math.min(srcATS, nz(bATS[1], srcATS)) + math.abs(srcATS - nz(bATS[1], srcATS)) * erATS

ATSCross1 = ta.cross(aATS, srcATS) ? 1 : 0
ATSCross2 = ta.cross(bATS, srcATS) ? 0 : -1

osATS := ATSCross1 == 1 ? 1 : ATSCross2 == 0 ? 0 : osATS[1]
tsATS = osATS * bATS + (1 - osATS) * aATS

ATSaX = ta.sma(close - (aATS - close), 7)
ATSbX = ta.sma(close + close - bATS, 7)

//RSI Stop Loss Testing
McGinleyRSIS(_srcRSIS, lenRSIS) =>
    MDRSIS = 0.0
    MDRSIS := na(_srcRSIS[1]) ? _srcRSIS : MDRSIS[1] + (_srcRSIS - MDRSIS[1]) / (0.6 * lenRSIS * math.pow(_srcRSIS / MDRSIS[1], 4))
    MDRSIS

rsi_maRSIS = McGinleyRSIS(close, 14)
ATRRSIS = ta.atr(27)
top_lineRSIS = rsi_maRSIS + ATRRSIS
bottom_lineRSIS = rsi_maRSIS - ATRRSIS
DirectionRSIS1 = ta.crossover(close, top_lineRSIS) ? 1 : 0
DirectionRSIS2 = ta.crossunder(close, bottom_lineRSIS) ? -1 : 0
directionRSIS = 1
directionRSIS := DirectionRSIS1 == 1 ? 1 : DirectionRSIS2 == -1 ? -1 : directionRSIS[1]
stop_lineRSIS = rsi_maRSIS - directionRSIS * ATRRSIS
RSIS_Signal = directionRSIS

ATS_CloseLongsX = UseRSIS == true and in_longCondition == true and AATS_Engage3 == 1 and espf_FinalX == -1 and RSIS_Signal == -1 ? true : false
ATS_CloseShortsX = UseRSIS == true and in_shortCondition == true and AATS_Engage3 == -1 and espf_FinalX == 1 and RSIS_Signal == 1 ? true : false

//Check to see if we should be using ATS Module
ATS_CloseLongsY = UseAATS == true and in_longCondition == true and AATS_Engage3 == 1 and espf_FinalX == -1 and MTISignal == -1 and low_ < bATS and low_ < ATSbX and low_ < ATSaX ? true : false ///
ATS_CloseShortsY = UseAATS == true and in_shortCondition == true and AATS_Engage3 == -1 and espf_FinalX == 1 and MTISignal == 1 and high_ > aATS and high_ > ATSaX and high_ > ATSbX ? true : false

ATS_CloseLongsAgg = ATS_CloseLongsX == true or ATS_CloseLongsY == true ? true : false
ATS_CloseShortsAgg = ATS_CloseShortsX == true or ATS_CloseShortsY == true ? true : false

ATS_CloseLongsRestrictive = ATS_CloseLongsY == true ? true : false
ATS_CloseShortsRestrictive = ATS_CloseShortsY == true ? true : false

ATS_CloseLongs = RestrictiveAATS == true ? ATS_CloseLongsRestrictive : ATS_CloseLongsAgg
ATS_CloseShorts = RestrictiveAATS == true ? ATS_CloseShortsRestrictive : ATS_CloseShortsAgg

/////////////////////////////////
//======[ Close Signals ]======//
/////////////////////////////////

// Create a single close for all the different closing conditions, all conditions here are non-repainting
longCloseX := (long_tp or long_sl or long_ts or long_tsBB or ATS_CloseLongs) and not longCondition
shortCloseX := (short_tp or short_sl or short_ts or short_tsBB or ATS_CloseShorts) and not shortCondition

/////////////////////////////////
//======[ MTI Kicker ]=========//
/////////////////////////////////

//Restrictive DPT Code Settings
KickerPercentUp1 = TrendPath == 1 and HalvingInhibitor2 == 0 ? KickerPercentDnTrend / 100 + 1 : KickerPercentUpTrend / 100 + 1
KickerPercentDown1 = TrendPath == 1 and HalvingInhibitor2 == 0 ? 1 - KickerPercentDnTrend / 100 : 1 - KickerPercentUpTrend / 100
KickerPercent1 = TrendPath == 1 and HalvingInhibitor2 == 0 ? KickerPercentDnTrend : KickerPercentUpTrend

KickerPercentUp2 = Engagey == 1 ? KickerPercentDnTrend / 100 + 1 : KickerPercentUpTrend / 100 + 1
KickerPercentDown2 = Engagey == 1 ? 1 - KickerPercentDnTrend / 100 : 1 - KickerPercentUpTrend / 100
KickerPercent2 = Engagey == 1 ? KickerPercentDnTrend : KickerPercentUpTrend

KickerPercentUp = KickerPercentChoice == true ? KickerPercentUp1 : KickerPercentUp2
KickerPercentDown = KickerPercentChoice == true ? KickerPercentDown1 : KickerPercentDown2
KickerPercent = KickerPercentChoice == true ? KickerPercent1 : KickerPercent2

KickerLongActivate = in_longCondition and not na(last_highTS) and close_ <= last_highTS - last_highTS * (KickerPercent / 100) or ATS_CloseLongs ? true : false
KickerShortActivate = in_shortCondition and not na(last_lowTS) and close_ >= last_lowTS + last_lowTS * (KickerPercent / 100) or ATS_CloseShorts ? true : false

MTI_Kicker_X = KickerLongActivate == true ? 1 : KickerShortActivate == true ? -1 : 0

MTI_Kick := MTI_Kicker_X

//Loose DPT Kicker Code
var MTI_Kicker_Reset = 0

CloseTracker = float(na)
CloseTracker := ItClosed == 1 ? 1 : ItClosed == -1 ? -1 : NewOpen == 2 or NewOpen == -2 ? 0 : nz(CloseTracker[1])

last_CloseUp = float(na)
last_CloseDown = float(na)
last_CloseUp := ItClosed == 1 or MTI_Kicker_Reset == 1 ? close : NewOpen == 2 or NewOpen == -2 ? 0 : nz(last_CloseUp[1])
last_CloseDown := ItClosed == -1 or MTI_Kicker_Reset == 1 ? close : NewOpen == 2 or NewOpen == -2 ? 0 : nz(last_CloseDown[1])

CloseTracker2 = CloseTracker == 1 or CloseTracker == -1 ? 1 : 0

close_Kicker = close > last_CloseUp * KickerPercentUp and last_CloseUp != 0 ? 2 : close > last_CloseDown * KickerPercentUp and last_CloseDown != 0 ? 2 : close < last_CloseUp * KickerPercentDown and last_CloseUp != 0 ? -2 : close < last_CloseDown * KickerPercentDown and last_CloseDown != 0 ? -2 : 0

close_Kicker2 = float(na)
close_Kicker2 := close_Kicker == 2 ? 4 : close_Kicker == -2 ? -4 : NewOpen == 2 or NewOpen == -2 or MTI_Kicker_Reset == 1 ? 0 : close_Kicker2[1]

close_Kicker3 = close_Kicker2 == 4 and close_Kicker2 != close_Kicker2[1] ? 2 : close_Kicker2 == -4 and close_Kicker2 != close_Kicker2[1] ? -2 : 0

in_CloseUp = ItClosed == 1 ? true : false
in_CloseDown = ItClosed == -1 ? true : false

last_OpenUp = float(na)
last_OpenDown = float(na)
last_OpenUp := NewOpen == 2 or MTI_Kicker_Reset == 1 ? close : ItClosed == 1 or ItClosed == -1 or NewOpen == -2 ? 0 : nz(last_OpenUp[1])
last_OpenDown := NewOpen == -2 or MTI_Kicker_Reset == 1 ? close : ItClosed == 1 or ItClosed == -1 or NewOpen == 2 ? 0 : nz(last_OpenDown[1])

Open_Kicker = close > last_OpenUp * KickerPercentUp and last_OpenUp != 0 ? 2 : close > last_OpenDown * KickerPercentUp and last_OpenDown != 0 ? 2 : close < last_OpenUp * KickerPercentDown and last_OpenUp != 0 ? -2 : close < last_OpenDown * KickerPercentDown and last_OpenDown != 0 ? -2 : 0
Open_Kicker2 = float(na)
Open_Kicker2 := Open_Kicker == 2 ? 4 : Open_Kicker == -2 ? -4 : ItClosed == 1 or ItClosed == -1 or NewOpen == 2 or NewOpen == -2 or MTI_Kicker_Reset == 1 ? 0 : Open_Kicker2[1]
Open_Kicker3 = Open_Kicker2 == 4 and Open_Kicker2 != Open_Kicker2[1] ? 2 : Open_Kicker2 == -4 and Open_Kicker2 != Open_Kicker2[1] ? -2 : 0

MTI_Kicker_Reset := close_Kicker3 == 2 or close_Kicker3 == -2 or Open_Kicker3 == 2 or Open_Kicker3 == -2 ? 1 : 0
MTI_Kicker_Final := close_Kicker3 == 2 or Open_Kicker3 == 2 ? 1 : close_Kicker3 == -3 or Open_Kicker3 == -2 ? -1 : 0

MTI_Kicker_Reset_Mod = MTI_Kicker_Reset == 1 ? 100 : 0

////////////////////////////////////////////////////////////////
//* Final Order Signals - Buys and Sells                     *//
////////////////////////////////////////////////////////////////

//Final Inputs for Risk Mitgattion Code Sequence
InhibitOnStop = input(true, 'Inhibit Trading Directional Trailing Stop Out - Use ESBF (Default = Yes)', group = SLMod2)
InhibitOnATS = input(true, 'Inhibit Trading Adaptive Trailing Stop - Use ESBF (Default = Yes)', group = SLMod2)
UseMartingaleTS = input(true, 'Engage Martingale on Trailing Stop Out (Default = Yes)', group = SLMod2)
UseMartingaleSL = input(false, 'Engage Martingale on Stop Loss (Default = No)', group = SLMod2)
UseMartingaleATS = input(true, 'Engage Martingale on ATS or AATS Stop Out (Default = Yes)', group = SLMod2)

ATSMartPre = ATS_CloseLongs == true ? 1 : ATS_CloseShorts == true ? -1 : 0
tsMart := UseMartingaleTS == true ? ts_CloseSignal : 0
slMart := UseMartingaleSL == true ? sl_CloseSignal : 0
ATSMart := UseMartingaleATS == true ? ATSMartPre : 0

RMPlot = longCloseX == true or CSX == 1 ? 1 : shortCloseX == true or CSX == -1 ? -1 : 0
RMSig = RMPlot == 1 and RMPlot != RMPlot[1] ? 1 : RMPlot == -1 and RMPlot != RMPlot[1] ? -1 : 0

ClearRM = AT == 2 and RMSig == 1 ? 3 : AT == -2 and RMSig == -1 ? -3 : 0

ClearRMP = float(na)
ClearRMP := ClearRM == 3 ? 3 : ClearRM == -3 ? -3 : AO == 2 or AO == -2 ? 0 : ClearRMP[1]

ReOrder = ClearRMP == 0 and ClearRMP[1] == 3 and ClearRMP != ClearRMP[1] ? 4 : ClearRMP == 0 and ClearRMP[1] == -3 and ClearRMP != ClearRMP[1] ? -4 : 0

RM_Hold = float(na)
RM_Hold := RMSig == 1 ? 1 : RMSig == -1 ? -1 : RM_Hold[1]

TradeInhibitorZ = espf_Inhibit == 1 ? 4 : espf_Inhibit == -1 ? -4 : 0

InhibA = long_ts == true or long_tsBB == true ? 1 : short_ts == true or short_tsBB == true ? -1 : 0
InhibATS = ATS_CloseLongs == true ? 1 : ATS_CloseShorts == true ? -1 : 0

InhibX = float(na)
InhibX := InhibA == 1 ? 3 : InhibA == -1 ? -3 : AT != AT[1] ? 0 : InhibX[1]

InhibATSX = float(na)
InhibATSX := InhibATS == 1 ? 3 : InhibATS == -1 ? -3 : InhibATSX[1]

InhibB = InhibX == 3 and TradeInhibitorZ == 4 ? 2 : InhibX == -3 and TradeInhibitorZ == -4 ? -2 : 0
InhibATSB = InhibATSX == 3 and TradeInhibitorZ == 4 and AT == 2 ? 2 : InhibATSX == -3 and TradeInhibitorZ == -4 and AT == -2 ? -2 : 0

InhibLongFinalTS = InhibitOnStop == true ? InhibB : 0
InhibShortFinalTS = InhibitOnStop == true ? InhibB : 0
InhibLongFinalATS = InhibitOnATS == true ? InhibATSB : 0
InhibShortFinalATS = InhibitOnATS == true ? InhibATSB : 0

FinPre = AF == 2 or ReOrder == 4 and AT == 2 and InhibLongFinalTS != 2 and InhibLongFinalATS != 2 ? 2 : AF == -2 or ReOrder == -4 and AT == -2 and InhibShortFinalTS != -2 and InhibShortFinalATS != -2 ? -2 : 0

var Counter = 0
Counter := RMSig != 0 ? Counter + 1 : FinPre != 0 ? 0 : Counter[1]

CloseEmAll = RMSig == 1 and Counter == 1 and Counter != Counter[1] ? 1 : RMSig == -1 and Counter == 1 and Counter != Counter[1] ? -1 : 0
ItClosed := CloseEmAll

//Martingale Code
ActivateMartingale = UseMartingaleTS == true and InhibitOnStop == true ? true : UseMartingaleSL == true and InhibitOnATS == true ? true : UseMartingaleATS == true and InhibitOnATS == true ? true : false

//+3 for going long (short stop out); -3 for going Short (long stop out)
Martingale := ActivateMartingale == true and CloseEmAll == 1 ? -3 : ActivateMartingale == true and CloseEmAll == -1 ? 3 : 0

MartingaleOpen := Martingale == 3 and espf_Final == 1 or MCHRHashClear == 10 and AT == -2 and MCHR_Change_Final == 1 ? 3 : Martingale == -3 and espf_Final == -1 ? -3 : AF == 2 or AF == -2 ? 0 : MartingaleOpen[1]

Fin = FinPre
NewOpen := Fin

/////////////////////////////
//======[ DCA ]======//
/////////////////////////////
var DCAMod = 'DCA Module'
isDCA = input(false, 'Activate DCA', group = DCAMod)
DCA = input.float(1.0, 'DCA Threshold(%)', minval = 0, step = 0.1, group = DCAMod) / 100

long_DCA = isDCA and in_longCondition and close <= last_open_longConditionTight - last_open_longConditionTight * DCA
short_DCA = isDCA and in_shortCondition and close >= last_open_shortConditionTight + last_open_shortConditionTight * DCA

var DCATracker = 0
DCATracker := long_DCA == true or short_DCA == true ? DCATracker + 1 : FinPre != 0 or FinPre != FinPre[1] ? 0 : DCATracker[1]
DCACommit = long_DCA == true and DCATracker == 1 ? 1 : short_DCA == true and DCATracker == 1 ? -1 : 0

////////////////////////////////////////////////////////////////
//* Backtest Buys and Sells                                  *//
////////////////////////////////////////////////////////////////

//Uncomment if an strategy - comment if a indicator

if testPeriod() and LongAndShort == 1
    if Fin == 2
        strategy.entry('Long', strategy.long, comment = 'Long')
    if DCACommit == 1
        strategy.entry('LongDCA', strategy.long, comment = 'Long DCA')
    strategy.exit('TP1 L', from_entry = 'Long', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1')
    strategy.exit('TP2 L', from_entry = 'Long', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2')
    strategy.exit('TP3 L', from_entry = 'Long', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3')
    strategy.exit('TP1 LDCA', from_entry = 'LongDCA', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1-DCA')
    strategy.exit('TP2 LDCA', from_entry = 'LongDCA', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2-DCA')
    strategy.exit('TP3 LDCA', from_entry = 'LongDCA', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3-DCA')
    if CSX == 1 or longCloseX
        strategy.close('Long')
    if CSX == 1 or longCloseX
        strategy.close('LongDCA')


if testPeriod() and LongAndShort == 1
    if Fin == -2
        strategy.entry('Short', strategy.short, comment = 'Short')
    if DCACommit == -1
        strategy.entry('ShortDCA', strategy.short, comment = 'Short DCA')
    strategy.exit('TP1 S', from_entry = 'Short', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1')
    strategy.exit('TP2 S', from_entry = 'Short', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2')
    strategy.exit('TP3 S', from_entry = 'Short', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3')
    strategy.exit('TP1 SDCA', from_entry = 'ShortDCA', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1DCA')
    strategy.exit('TP2 SDCA', from_entry = 'ShortDCA', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2DCA')
    strategy.exit('TP3 SDCA', from_entry = 'ShortDCA', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3DCA')
    if CSX == -1 or shortCloseX
        strategy.close('Short')
    if CSX == -1 or shortCloseX
        strategy.close('ShortDCA')

if testPeriod() and LongAndShort == 2
    if Fin == 2
        strategy.entry('Long', strategy.long, comment = 'Long')
    if DCACommit == 1
        strategy.entry('LongDCA', strategy.long, comment = 'Long DCA')
    strategy.exit('TP1 L', from_entry = 'Long', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1')
    strategy.exit('TP2 L', from_entry = 'Long', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2')
    strategy.exit('TP3 L', from_entry = 'Long', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3')
    strategy.exit('TP1 LDCA', from_entry = 'LongDCA', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1-DCA')
    strategy.exit('TP2 LDCA', from_entry = 'LongDCA', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2-DCA')
    strategy.exit('TP3 LDCA', from_entry = 'LongDCA', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3-DCA')
    if CSX == 1 or longCloseX or Fin == -2
        strategy.close('Long')
    if CSX == 1 or longCloseX or Fin == -2
        strategy.close('LongDCA')



if testPeriod() and LongAndShort == 3
    if Fin == -2
        strategy.entry('Short', strategy.short, comment = 'Short')
    if DCACommit == -1
        strategy.entry('ShortDCA', strategy.short, comment = 'Short DCA')
    strategy.exit('TP1 S', from_entry = 'Short', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1')
    strategy.exit('TP2 S', from_entry = 'Short', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2')
    strategy.exit('TP3 S', from_entry = 'Short', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3')
    strategy.exit('TP1 SDCA', from_entry = 'ShortDCA', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1DCA')
    strategy.exit('TP2 SDCA', from_entry = 'ShortDCA', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2DCA')
    strategy.exit('TP3 SDCA', from_entry = 'ShortDCA', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3DCA')
    if CSX == -1 or shortCloseX or Fin == 2
        strategy.close('Short')
    if CSX == -1 or shortCloseX or Fin == 2
        strategy.close('ShortDCA')


////////////////////////////////////////////////////////////////
//* Alerts Buys and Sells                                    *//
////////////////////////////////////////////////////////////////

//Uncomment if an indicator - Comment if a strategy

//Buy and Sell Signals - Fin==2 Long, Fin==-2 Short
//plot(Fin, title="Order Open",linewidth=3,color=color.blue)

//RM Close Alerts = Close Long = 1, Close Short =-1
//plot(CloseEmAll, title="RM Close", linewidth=3,color=color.yellow)

//Take Profit Plot 1,2, 3 for Long TP1, 2, 3, and -1 -2 -3 for shorts
//plot(TakeProfitStopsPlot, title="TP Close", linewidth=3,color=color.orange)
//plot(isSTP==true ? TakeProfit1Plot : na, title="TP-1 Close", linewidth=3,color=color.lime)
//plot(isSTP==true ? TakeProfit2Plot : na, title="TP-2 Close", linewidth=3,color=color.olive)
//plot(isSTP==true ? TakeProfit3Plot : na, title="TP-3 Close", linewidth=3,color=color.green)

///////////////////////////////////
//======[ Reset Variables ]======//
///////////////////////////////////

//Do not modify, key variables for TradeState engine to function

if longCloseX or not in_longCondition
    last_high := na
    last_high_short := na
    last_high_short

if shortCloseX or not in_shortCondition
    last_low := na
    last_low_long := na
    last_low_long

if longCloseX or shortCloseX
    tradeState := 0
    in_longCondition := false
    in_shortCondition := false
    in_shortCondition

///////////////////////////////////
//======[ EOF - Done Baby ]======//
///////////////////////////////////
