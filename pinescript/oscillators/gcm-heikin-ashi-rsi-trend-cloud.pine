//@version=6
indicator("GCM Heikin Ashi RSI Trend Cloud", "GCM HRTC", overlay=false, format=format.price, precision=2)

//                            ====== INPUTS ======                            //

// -- Main Config
string GROUP_MAIN = "Config » General"
i_trendMode = input.string("Neutral", "Traders", options=["Neutral", "Buyers", "Sellers"], group=GROUP_MAIN)

// -- Candle config
string GROUP_CAND = "Config » HARSI Candles"
i_lenHARSI  = input.int(10, "Length", group=GROUP_CAND, minval=1)
i_smoothing = input.int(5, "Open Smoothing", group=GROUP_CAND, minval=1, maxval=100)

// --- CANDLE COLORS
i_colCandleUp   = input.color(#089981, "Candle Colour", group=GROUP_CAND, inline="CandleCol")
i_colCandleDown = input.color(#f23645, " ", group=GROUP_CAND, inline="CandleCol")

// --- CLOUD/RSI COLORS
i_colCloudUp    = input.color(#37ff0c, "Cloud/RSI Colour", group=GROUP_CAND, inline="CloudCol")
i_colCloudDown  = input.color(#ff0014, " ", group=GROUP_CAND, inline="CloudCol")

// -- RSI plot config
string GROUP_PLOT = "Config » RSI Plot"
i_source    = input.source(ohlc4, "Source", group=GROUP_PLOT)
i_lenRSI    = input.int(7, "Length", group=GROUP_PLOT, minval=1)
i_mode      = input.bool(true, "Smoothed Mode RSI?", group=GROUP_PLOT)
i_showPlot  = input.bool(true, "Show RSI Plot?", group=GROUP_PLOT)

// -- HTF RSI config
string GROUP_HTF = "Config » HTF Overlays"
i_htf1      = input.timeframe("", "Timeframe 1 (Empty=Auto)", group=GROUP_HTF)
i_showHtf1  = input.bool(false, "Show HTF 1 Line?", group=GROUP_HTF)
i_colHtf1   = input.color(color.new(#00e5ff, 20), "Color HTF 1", group=GROUP_HTF)

i_htf2      = input.timeframe("", "Timeframe 2 (Empty=Auto)", group=GROUP_HTF)
i_showHtf2  = input.bool(false, "Show HTF 2 Line?", group=GROUP_HTF)
i_colHtf2   = input.color(color.new(#e040fb, 20), "Color HTF 2", group=GROUP_HTF)

i_showCloud = input.bool(true, "Show Ribbon Clouds?", group=GROUP_HTF)
i_cloudTrns = input.int(80, "Cloud Transparency", group=GROUP_HTF, minval=0, maxval=100)

// -- Channel OB/OS config
string GROUP_CHAN = "Config » OB/OS Boundaries"
i_upper     = input.int(20, "OB", group=GROUP_CHAN, inline="OB", minval=1, maxval=50)
i_upperx    = input.int(30, "OB Extreme", group=GROUP_CHAN, inline="OB", minval=1, maxval=50)

i_lower     = input.int(-20, "OS", group=GROUP_CHAN, inline="OS", minval=-50, maxval=-1)
i_lowerx    = input.int(-30, "OS Extreme", group=GROUP_CHAN, inline="OS", minval=-50, maxval=-1)

// -- SIGNALS Config
string GROUP_SIG = "Config » Buy & Sell Signals"
i_showMainSig   = input.bool(false, "Show Main Labels (HARSI)?", group=GROUP_SIG)
i_showFastSig   = input.bool(true, "Show Fast Alerts (RSI)?", group=GROUP_SIG)

// -- DIVERGENCE Config
string GROUP_DIV = "Config » Divergence Theory"
i_showDiv       = input.bool(true, "Show Divergence Lines?", group=GROUP_DIV)
i_divLookback   = input.int(3, "Pivot Lookback", minval=1, maxval=10, group=GROUP_DIV)
color colDivBull = #1b5e20
color colDivBear = #801922

// Colors
color colSignalBuy  = #00E676 
color colSignalSell = #FF5252 
color colTextBuy    = #004D25 
color colTextSell   = #4B0000 

//                          ====== FUNCTIONS ======                           //

f_zrsi(_source, _length) => ta.rsi(_source, _length) - 50

f_rsi(_source, _length, _mode) =>
    float _zrsi = f_zrsi(_source, _length)
    var float _smoothed = na
    _smoothed := na(_smoothed[1]) ? _zrsi : (_smoothed[1] + _zrsi) / 2
    _mode ? _smoothed : _zrsi

f_rsiHeikinAshi(_length) =>
    float _closeRSI = f_zrsi(close, _length)
    float _openRSI  = nz(_closeRSI[1], _closeRSI)
    float _highRSI_raw  = f_zrsi(high, _length)
    float _lowRSI_raw   = f_zrsi(low, _length)
    float _highRSI  = math.max(_highRSI_raw, _lowRSI_raw)
    float _lowRSI   = math.min(_highRSI_raw, _lowRSI_raw)
    float _close    = (_openRSI + _highRSI + _lowRSI + _closeRSI) / 4
    var float _open = na
    _open  := na(_open[i_smoothing]) ? (_openRSI + _closeRSI) / 2 : ((_open[1] * i_smoothing) + _close[1]) / (i_smoothing + 1)
    float _high     = math.max(_highRSI, math.max(_open, _close))
    float _low      = math.min(_lowRSI,  math.min(_open, _close))
    [_open, _high, _low, _close]

f_getAutoTF(_step) =>
    var int[] tf_mins = array.from(1, 3, 5, 15, 30, 45, 60, 120, 180, 240, 1440, 10080, 43200)
    var string[] tf_strs = array.from("1", "3", "5", "15", "30", "45", "60", "120", "180", "240", "D", "W", "M")
    float chart_mins = timeframe.in_seconds(timeframe.period) / 60
    int idx = -1
    for i = 0 to array.size(tf_mins) - 1
        if chart_mins < array.get(tf_mins, i)
            idx := i
            break
    if idx == -1
        idx := array.size(tf_mins) - 1
    int target_idx = idx + (_step - 1)
    if target_idx >= array.size(tf_strs)
        target_idx := array.size(tf_strs) - 1
    array.get(tf_strs, target_idx)

//                   ====== SERIES, LINES and LABELS ======                   //

float RSI = f_rsi(i_source, i_lenRSI, i_mode)
[O, H, L, C] = f_rsiHeikinAshi(i_lenHARSI)

bool rsiRising = RSI >= RSI[1] 
bool isVisible = i_trendMode == "Neutral" ? true : (i_trendMode == "Buyers" ? rsiRising : not rsiRising)

color colRSI = isVisible ? (rsiRising ? i_colCloudUp : i_colCloudDown) : na
color bodyFinal = isVisible ? (C > O ? i_colCandleUp : i_colCandleDown) : na

string tf1_final = i_htf1 == "" ? f_getAutoTF(1) : i_htf1
string tf2_final = i_htf2 == "" ? f_getAutoTF(2) : i_htf2
float rsi_htf1_val = request.security(syminfo.tickerid, tf1_final, f_rsi(i_source, i_lenRSI, i_mode))
float rsi_htf2_val = request.security(syminfo.tickerid, tf2_final, f_rsi(i_source, i_lenRSI, i_mode))

//                     ====== DRAWING and PLOTTING ======                     //

// Reference Lines with 60% Opacity (Transparency 60)
color colRef = color.new(color.silver, 60)
upperx  = hline(i_upperx, "OB Extreme", colRef)
upper   = hline(i_upper,  "OB", colRef)
median  = hline(0,        "Median", color.new(color.orange, 60), hline.style_dotted)
lower   = hline(i_lower,  "OS", colRef)
lowerx  = hline(i_lowerx, "OS Extreme", colRef)

fill(upper, upperx, color.new(color.red, 90))
fill(upper, lower,  color.new(color.blue, 90))
fill(lower, lowerx, color.new(color.green, 90))

plotcandle(O, H, L, C, "HARSI", bodyFinal, bodyFinal, bordercolor=bodyFinal)
p_rsi = plot(i_showPlot ? RSI : na, "RSI Overlay", colRSI, 1)
plot(i_showPlot ? RSI : na, "RSI Trend Bias", isVisible ? colRSI : na, 2)

p_htf1 = plot(rsi_htf1_val, "HTF 1 RSI", (i_showHtf1 and isVisible) ? i_colHtf1 : na, 1)
p_htf2 = plot(rsi_htf2_val, "HTF 2 RSI", (i_showHtf2 and isVisible) ? i_colHtf2 : na, 1)

fill(p_rsi, p_htf1, i_showCloud and isVisible ? (RSI > rsi_htf1_val ? color.new(i_colCloudUp, i_cloudTrns) : color.new(i_colCloudDown, i_cloudTrns)) : na)

//                     ====== DIVERGENCE THEORY LOGIC ======                     //

int lb = i_divLookback
float phRSI = ta.pivothigh(RSI, lb, lb)
float plRSI = ta.pivotlow(RSI, lb, lb)

var float lastPhRSI = na, var int lastPhIdx = na, var float prevPhRSI = na, var int prevPhIdx = na
var float lastPlRSI = na, var int lastPlIdx = na, var float prevPlRSI = na, var int prevPlIdx = na
var float lastPhPrice = na, var float prevPhPrice = na
var float lastPlPrice = na, var float prevPlPrice = na

if not na(phRSI)
    prevPhRSI := lastPhRSI
    prevPhIdx := lastPhIdx
    prevPhPrice := lastPhPrice
    lastPhRSI := phRSI
    lastPhIdx := bar_index - lb
    lastPhPrice := high[lb]
    
    if not na(prevPhRSI)
        bool rsiDown = lastPhRSI < prevPhRSI
        bool priceUp = lastPhPrice > prevPhPrice
        if rsiDown and priceUp and i_showDiv
            line.new(prevPhIdx, prevPhRSI, lastPhIdx, lastPhRSI, color=colDivBear, width=1)
            label.new(lastPhIdx, lastPhRSI, "Bear\nDiv", color=colDivBear, textcolor=color.white, style=label.style_label_down, size=size.tiny)
            line.new(prevPhIdx, prevPhPrice, lastPhIdx, lastPhPrice, color=colDivBear, width=1, force_overlay=true)
            label.new(lastPhIdx, lastPhPrice, "Bear\nDiv", color=colDivBear, textcolor=color.white, style=label.style_label_down, size=size.tiny, force_overlay=true)

if not na(plRSI)
    prevPlRSI := lastPlRSI
    prevPlIdx := lastPlIdx
    prevPlPrice := lastPlPrice
    lastPlRSI := plRSI
    lastPlIdx := bar_index - lb
    lastPlPrice := low[lb]

    if not na(prevPlRSI)
        bool rsiUp = lastPlRSI > prevPlRSI
        bool priceDown = lastPlPrice < prevPlPrice
        if rsiUp and priceDown and i_showDiv
            line.new(prevPlIdx, prevPlRSI, lastPlIdx, lastPlRSI, color=colDivBull, width=1)
            label.new(lastPlIdx, lastPlRSI, "Bull\nDiv", color=colDivBull, textcolor=color.white, style=label.style_label_up, size=size.tiny)
            line.new(prevPlIdx, prevPlPrice, lastPlIdx, lastPlPrice, color=colDivBull, width=1, force_overlay=true)
            label.new(lastPlIdx, lastPlPrice, "Bull\nDiv", color=colDivBull, textcolor=color.white, style=label.style_label_up, size=size.tiny, force_overlay=true)

//                     ====== SIGNALS ======                     //

bool harsiBull = (C > O) and not (C[1] > O[1])
bool harsiBear = not (C > O) and (C[1] > O[1])
bool rsiBull   = rsiRising and not rsiRising[1]
bool rsiBear   = not rsiRising and rsiRising[1]

plotshape(i_showMainSig and harsiBull ? L - 5 : na, "Main Buy", shape.labelup, location.absolute, colSignalBuy, text="B", textcolor=colTextBuy, size=size.tiny)
plotshape(i_showMainSig and harsiBear ? H + 5 : na, "Main Sell", shape.labeldown, location.absolute, colSignalSell, text="S", textcolor=colTextSell, size=size.tiny)
plotshape(i_showFastSig and rsiBull ? RSI[1] : na, "Fast Buy", shape.circle, location.absolute, colSignalBuy, size=size.tiny, offset=-1)
plotshape(i_showFastSig and rsiBear ? RSI[1] : na, "Fast Sell", shape.circle, location.absolute, colSignalSell, size=size.tiny, offset=-1)
