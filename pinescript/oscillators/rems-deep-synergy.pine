// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © KodiakMarket

//REMS Synergy. Uses confluence of RSI, EMAs, MACD, and Stochastic RSI as other REMS indicators, but with more control over filters in 3 confluence levels.
//REMS Deep Synergy allows user full control over inputs. More control + more complexity
//Confluence 1 and 2 allow the same evaluation of individual timeframes. Allows filters to be more flexible than previously
//Update 1 adds extra alert level for use in Alerts. No change in logic.
//@version=6
indicator("REMS - Deep Synergy Overlay",shorttitle = "REMS Deep Synergy" ,overlay = true, max_labels_count = 500)

///////////////////////////
// Timeframes
///////////////////////////
primaryTF   = input.timeframe("", "Primary Timeframe", group="Timeframe")
secondaryTF = input.timeframe("2", "Secondary Timeframe", group="Timeframe")

waitPrimary   = input.bool(true,  "Wait for Primary Close", group="Timeframe")
waitSecondary = input.bool(true, "Wait for Secondary Close", group="Timeframe")

lookaheadSetting(wait) =>
    wait ? barmerge.lookahead_off : barmerge.lookahead_on

// Enhanced Candles Inputs
// ====================
colorTrigger     = input.string("Off", "Color Trigger", options=["Off", "EMA Cross - Primary", "EMA Cross - Secondary", "Confluence 1", "Confluence 2", "Confluence 3"], tooltip = "Select conditions for Enhanced Candles. Colors bullish/bearish conditions based on selecion. Visual Only.", group="Enhanced Candles")
directionFilter  = input.string("N/A", "Direction Filter", options=["N/A", "Bullish Only", "Bearish Only"], tooltip = "Select if you have a bias and only want to see respective candles.", group="Enhanced Candles")

///////////////////////////
// RSI Series
///////////////////////////
rsiSource = close
rsiLengthPrimary   = input.int(14,  "RSI Length (Primary)", minval = 1, tooltip = "RSI value on the Primary Timeframe", group="RSI Parameters - Primary")
rsiLengthSecondary = input.int(7,  "RSI Length (Secondary)", minval = 1, tooltip = "RSI value on the Secondary Timeframe", group="RSI Parameters - Secondary")
rsiSmoothing_P       = input.int(20,  "RSI Smoothing (Primary)", minval = 1, tooltip = "RSI smoothing for MA", group="RSI Parameters - Primary")
rsiSmoothing_S       = input.int(20,  "RSI Smoothing (Secondary)", minval = 1, tooltip = "RSI smoothing for MA", group="RSI Parameters - Secondary")

rsiPrimary   = request.security(syminfo.tickerid, primaryTF,   ta.rsi(rsiSource, rsiLengthPrimary), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitPrimary))
rsiPrimaryMA = ta.sma(rsiPrimary, rsiSmoothing_P)
rsiSecondary = request.security(syminfo.tickerid, secondaryTF, ta.rsi(rsiSource, rsiLengthSecondary), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitSecondary))
rsiSecondaryMA = ta.sma(rsiSecondary, rsiSmoothing_S)

///////////////////////////
// EMA Inputs
///////////////////////////
emaFast_P = input.int(8,  "Primary EMA Alpha Length", minval = 1, tooltip = "EMA Alpha (fast) used on the Primary Timeframe", group="EMA Parameters")
emaSlow_P  = input.int(21, "Primary EMA Beta Length",  minval = 1, tooltip = "EMA Beta (slow) used on the Primary Timeframe", group="EMA Parameters")
emaFast_S = input.int(8,  "Secondary EMA Alpha Length", minval = 1, tooltip = "EMA Alpha (fast) used on the Secondary Timeframe", group="EMA Parameters")
emaSlow_S = input.int(21, "Secondary EMA Beta Length",  minval = 1, tooltip = "EMA Beta (slow) used on the Secondary Timeframe", group="EMA Parameters")

//-----------------------
// EMA Series
//-----------------------
emaPrimaryAlpha   = request.security(syminfo.tickerid, primaryTF,   ta.ema(close, emaFast_P), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitPrimary))
emaPrimaryBeta    = request.security(syminfo.tickerid, primaryTF,   ta.ema(close, emaSlow_P),  gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitPrimary))
emaSecondaryAlpha = request.security(syminfo.tickerid, secondaryTF, ta.ema(close, emaFast_S), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitSecondary))
emaSecondaryBeta  = request.security(syminfo.tickerid, secondaryTF, ta.ema(close, emaSlow_S),  gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitSecondary))

// Plot EMAs
pAlpha = plot(emaPrimaryAlpha, "Primary EMA Alpha", color=color.yellow, linewidth=2)
pBeta  = plot(emaPrimaryBeta,  "Primary EMA Beta",  color=color.blue,   linewidth=2)
plot(emaSecondaryAlpha, "Secondary EMA Alpha", color=color.orange, linewidth=2, display=display.none)
plot(emaSecondaryBeta,  "Secondary EMA Beta", color=color.red,    linewidth=2, display=display.none)

// EMA Gradient
fillColor = emaPrimaryAlpha >= emaPrimaryBeta ? color.new(color.green, 80) : color.new(color.red, 80)
fill(pAlpha, pBeta, color=fillColor)

///////////////////////////
// MACD Series
///////////////////////////
MACD_P_Fast = input.int(12,  "MACD Fast Length (Primary)", minval = 1, tooltip = "MACD Fast Length on Primary Timeframe", group="MACD Parameters - Primary")
MACD_P_Slow = input.int(26,  "MACD Slow Length (Primary)", minval = 1, tooltip = "MACD Slow Length on Primary Timeframe", group="MACD Parameters - Primary")
MACD_P_Smooth = input.int(9,  "MACD Smoothing (Primary)", minval = 1, group="MACD Parameters - Primary")

MACD_S_Fast = input.int(12,  "MACD Fast Length (Secondary)", minval = 1, tooltip = "MACD Fast Length on Secondary Timeframe", group="MACD Parameters - Secondary")
MACD_S_Slow = input.int(26,  "MACD Slow Length (Secondary)", minval = 1, tooltip = "MACD Slow Length on Secondary Timeframe", group="MACD Parameters - Secondary")
MACD_S_Smooth = input.int(9,  "MACD Smoothing (Secondary)", minval = 1, group="MACD Parameters - Secondary")

[macdP, sigP, _] = request.security(syminfo.tickerid, primaryTF,   ta.macd(close, MACD_P_Fast, MACD_P_Slow, MACD_P_Smooth), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitPrimary))
[macdS, sigS, _] = request.security(syminfo.tickerid, secondaryTF, ta.macd(close, MACD_S_Fast, MACD_S_Slow, MACD_S_Smooth), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitSecondary))

// MACD Histogram Direction Logic
macdHistP = macdP - sigP
macdHistS = macdS - sigS

macdHistRisingP  = macdHistP > macdHistP[1]
macdHistFallingP = macdHistP < macdHistP[1]
macdHistRisingS  = macdHistS > macdHistS[1]
macdHistFallingS = macdHistS < macdHistS[1]

// MACD Thresholds (single definition, next to EMAs)
macdLongThreshold  = input.float(0.0, "MACD Long Threshold MAX. (Primary)", step=0.1, tooltip = "Maximum MACD (Primary) permitted for LONG signal", group="MACD Threshold - Primary")
macdShortThreshold = input.float(0.0, "MACD Short Threshold MIN. (Primary)", step=0.1, tooltip = "Minimum MACD (Primary) permitted for SHORT signal", group="MACD Threshold - Primary")

macdLongThreshold2  = input.float(0.0, "MACD Long Threshold MAX. (Secondary)", step=0.1, tooltip = "Maximum MACD (Secondary) permitted for LONG signal", group="MACD Threshold - Secondary")
macdShortThreshold2 = input.float(0.0, "MACD Short Threshold MIN. (Secondary)", step=0.1, tooltip = "Minimum MACD (Secondary) permitted for SHORT signal", group="MACD Threshold - Secondary")

///////////////////////////
// Stochastic RSI Helper
///////////////////////////
stochRsiK(rsiLen, stLen, kLen) =>
    r  = ta.rsi(close, rsiLen)
    lo = ta.lowest(r, stLen)
    hi = ta.highest(r, stLen)
    den = math.max(hi - lo, 1e-10)
    raw = (r - lo) / den * 100.0
    ta.sma(raw, kLen)

stochRsiD(kSeries, dLen) =>
    ta.sma(kSeries, dLen)

stochKPrimary    = input.int(3,  "K (Primary)", minval = 1, tooltip = "%K on Primary Timeframe", group="Stochastic RSI Parameters - Primary")
stochDPrimary    = input.int(3,  "D (Primary)", minval = 1, tooltip = "%D on Primary Timeframe", group="Stochastic RSI Parameters - Primary")
stochRSILengthP  = input.int(14,  "Stochastic RSI Length (Primary)", minval = 1, tooltip = "Stochastic RSI length on Primary Timeframe", group="Stochastic RSI Parameters - Primary")
stochStochLengthP = input.int(8,  "Stochastic Length (Primary)", minval = 1, tooltip = "Stochastic length on Primary Timeframe", group="Stochastic RSI Parameters - Primary")

stochKSecondary  = input.int(3,  "K (Secondary)", minval = 1, tooltip = "%K on Secondary Timeframe", group="Stochastic RSI Parameters - Secondary")
stochDSecondary  = input.int(2,  "D (Secondary)", minval = 1, tooltip = "%D on Secondary Timeframe", group="Stochastic RSI Parameters - Secondary")
stochRSILengthS  = input.int(7,  "Stochastic RSI Length (Secondary)", minval = 1, tooltip = "Stochastic RSI length on Secondary Timeframe", group="Stochastic RSI Parameters - Secondary")
stochStochLengthS = input.int(7,  "Stochastic Length (Secondary)", minval = 1, tooltip = "Stochastic length on Secondary Timeframe", group="Stochastic RSI Parameters - Secondary")

stochK_P = request.security(syminfo.tickerid, primaryTF,   stochRsiK(stochRSILengthP, stochStochLengthP, stochKPrimary), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitPrimary))
stochD_P = stochRsiD(stochK_P, stochDPrimary)
stochK_S = request.security(syminfo.tickerid, secondaryTF, stochRsiK(stochRSILengthS, stochStochLengthS, stochKSecondary), gaps=barmerge.gaps_off, lookahead=lookaheadSetting(waitSecondary))
stochD_S = stochRsiD(stochK_S, stochDSecondary)

//──────────────────────────────
// Stochastic RSI Range Inputs
//──────────────────────────────

// Primary
stochShortMaxK_P = input.float(100.0, "Max. %K Short", minval=0, maxval=100, step=0.1, group = "Primary Stochastic Range", inline = "PMAX")
stochShortMinK_P = input.float(20.0, "Min. %K Short ", minval=0, maxval=100, step=0.1, group = "Primary Stochastic Range", inline = "PMIN")
stochLongMaxK_P  = input.float(80.0, "Max. %K Long",  minval=0, maxval=100, step=0.1, group = "Primary Stochastic Range", inline = "PMAX")
stochLongMinK_P  = input.float(0, "Min. %K Long ",  minval=0, maxval=100, step=0.1, group = "Primary Stochastic Range", inline = "PMIN")

// Secondary
stochShortMaxK_S = input.float(100.0, "Max. %K Short", minval=0, maxval=100, step=0.1, group = "Secondary Stochastic Range", inline = "SMAX")
stochShortMinK_S = input.float(30.0, "Min. %K Short ", minval=0, maxval=100, step=0.1, group = "Secondary Stochastic Range", inline = "SMIN")
stochLongMaxK_S  = input.float(70.0, "Max. %K Long",  minval=0, maxval=100, step=0.1, group = "Secondary Stochastic Range", inline = "SMAX")
stochLongMinK_S  = input.float(0, "Min. %K Long ",  minval=0, maxval=100, step=0.1, group = "Secondary Stochastic Range", inline = "SMIN")

//──────────────────────────────
// Stochastic Range Check Helper
//──────────────────────────────
stochInRange(k, minK, maxK) =>
    minKReal = math.min(minK, maxK)
    maxKReal = math.max(minK, maxK)
    k >= minKReal and k <= maxKReal

// ────────────────────────────────
// VWAP
// ────────────────────────────────
vwapValue = ta.vwap
plot(vwapValue, "VWAP (Session)", color=color.white, linewidth=2)

///////////////////////////
// Confluence 1 Inputs (15 checkboxes)
///////////////////////////

useRSIPrimaryC1    = input.bool(true,  "RSI Primary                    ", group="Confluence 1 Signal Filters", inline = "C1RSI")
useRSISecondaryC1  = input.bool(true,  "RSI Secondary", group="Confluence 1 Signal Filters", inline = "C1RSI")
useEMAPrimaryC1    = input.bool(true,  "EMA Primary                 ", group="Confluence 1 Signal Filters", inline = "C1EMA")
useEMASecondaryC1  = input.bool(true,  "EMA Secondary", group="Confluence 1 Signal Filters", inline = "C1EMA")
useMACDPrimaryC1   = input.bool(true,  "MACD (Primary)        ", group="Confluence 1 Signal Filters", inline = "C1MACD")
useMACDSecondaryC1 = input.bool(true, "MACD (Secondary)", tooltip = "Evaluates MACD as above/below Signal Line on respective timeframes.", group="Confluence 1 Signal Filters", inline = "C1MACD")
useMACDHistC1_P = input.bool(false, "MACD Hist. (Prime)", group="Confluence 1 Signal Filters", inline = "C1MACDHist")
useMACDHistC1_S = input.bool(false, "MACD Hist. (Second)", group="Confluence 1 Signal Filters", inline = "C1MACDHist")
filterMACD_P_C1  = input.bool(false, "MACD Threshold (Primary)", group="Confluence 1 Signal Filters")
filterMACD_S_C1 = input.bool(false, "MACD Threshold (Secondary)", group="Confluence 1 Signal Filters")
useStochP_C1       = input.bool(true,  "Stoch RSI Primary   ", group="Confluence 1 Signal Filters", inline = "C1Stoch")
useStochS_C1       = input.bool(true,  "Stoch RSI Secondary", group="Confluence 1 Signal Filters", inline = "C1Stoch")
useStochRangePC1 = input.bool(false, "Stochastic Range (Primary)", group="Confluence 1 Signal Filters")
useStochRangeSC1 = input.bool(false, "Stochastic Range (Secondary)", group="Confluence 1 Signal Filters")
useVWAP_C1 = input.bool(false, "VWAP Filter (Session)", group="Confluence 1 Signal Filters")

///////////////////////////
// Confluence 2 Inputs (15 checkboxes)
///////////////////////////
useRSIPrimaryC2    = input.bool(true,  "RSI Primary                    ", group="Confluence 2 Signal Filters", inline = "C2RSI")
useRSISecondaryC2  = input.bool(true,  "RSI Secondary", group="Confluence 2 Signal Filters", inline = "C2RSI")
useEMAPrimaryC2    = input.bool(true,  "EMA Primary                 ", group="Confluence 2 Signal Filters", inline = "C2EMA")
useEMASecondaryC2  = input.bool(true,  "EMA Secondary", group="Confluence 2 Signal Filters", inline = "C2EMA")
useMACDPrimaryC2   = input.bool(true,  "MACD (Primary)        ", group="Confluence 2 Signal Filters", inline = "C2MACD")
useMACDSecondaryC2 = input.bool(false, "MACD (Secondary)", tooltip = "Evaluates MACD as above/below Signal Line on respective timeframes.", group="Confluence 2 Signal Filters", inline = "C2MACD")
useMACDHistC2_P = input.bool(false, "MACD Hist. (Prime)", group="Confluence 2 Signal Filters", inline = "C2MACDHist")
useMACDHistC2_S = input.bool(false, "MACD Hist. (Second)", group="Confluence 2 Signal Filters", inline = "C2MACDHist")
filterMACD_P_C2  = input.bool(false, "MACD Threshold (Primary Only)", group="Confluence 2 Signal Filters")
filterMACD_S_C2 = input.bool(false, "MACD Threshold (Secondary)", group="Confluence 2 Signal Filters")
useStochP_C2       = input.bool(true,  "Stoch RSI Primary   ", group="Confluence 2 Signal Filters", inline = "C2Stoch")
useStochS_C2       = input.bool(true,  "Stoch RSI Secondary", group="Confluence 2 Signal Filters", inline = "C2Stoch")
useStochRangePC2 = input.bool(false, "Stochastic Range (Primary)", group="Confluence 2 Signal Filters")
useStochRangeSC2 = input.bool(false, "Stochastic Range (Secondary)", group="Confluence 2 Signal Filters")
useVWAP_C2 = input.bool(false, "VWAP Filter (Session)", group="Confluence 2 Signal Filters")

// ────────────────
// Confluence 3 Inputs (16 checkboxes)
// ────────────────
requiredTrueC3     = input.int(3, "Number of True Signals Required", minval=1, maxval=14, tooltip = "Select possible filters. Required number from selected filters must be true to trigger signal.", group="Confluence 3 Signal Filters")
useRSIPrimaryC3    = input.bool(false,  "RSI Primary                    ", group="Confluence 3 Signal Filters", inline = "C3RSI")
useRSISecondaryC3  = input.bool(false,  "RSI Secondary", group="Confluence 3 Signal Filters", inline = "C3RSI")
useEMAPrimaryC3    = input.bool(false,  "EMA Primary                 ", group="Confluence 3 Signal Filters", inline = "C3EMA")
useEMASecondaryC3  = input.bool(false,  "EMA Secondary", group="Confluence 3 Signal Filters", inline = "C3EMA")
useMACDPrimaryC3   = input.bool(false,  "MACD (Primary)        ", group="Confluence 3 Signal Filters", inline = "C3MACD")
useMACDSecondaryC3 = input.bool(false, "MACD (Secondary)", group="Confluence 3 Signal Filters", inline = "C3MACD")
useMACDHistC3_P = input.bool(false, "MACD Hist. (Prime)", group="Confluence 3 Signal Filters", inline = "C3MACDHist")
useMACDHistC3_S = input.bool(false, "MACD Hist. (Second)", group="Confluence 3 Signal Filters", inline = "C3MACDHist")
filterMACD_P_C3 = input.bool(false, "MACD Threshold (Primary)", group="Confluence 3 Signal Filters")
filterMACD_S_C3 = input.bool(false, "MACD Threshold (Secondary)", group="Confluence 3 Signal Filters")
useStochP_C3       = input.bool(false,  "Stoch RSI Primary   ", group="Confluence 3 Signal Filters", inline = "C3Stoch")
useStochS_C3       = input.bool(false,  "Stoch RSI Secondary", group="Confluence 3 Signal Filters", inline = "C3Stoch")
useStochRangePC3 = input.bool(false, "Stochastic Range (Primary)", group="Confluence 3 Signal Filters")
useStochRangeSC3 = input.bool(false, "Stochastic Range (Secondary)", group="Confluence 3 Signal Filters")
useVWAP_C3 = input.bool(false, "VWAP Filter (Session)", group="Confluence 3 Signal Filters")

/////////////////////////////
// Confluence Helper Function (C1 / C2)
// Fully paired Primary/Secondary toggles for C1/C2
// Includes VWAP, Stoch Range, and MACD Histogram support
///////////////////////////
confluence(longDir, 
           rsiCheckP=false, rsiCheckS=false, 
           emaCheckP=false, emaCheckS=false, 
           macdCheckP=false, macdCheckS=false, 
           stochCheckP=false, stochCheckS=false, 
           filterMACDP=false, filterMACDS=false,
           useStochRangePC1=false, useStochRangeSC1=false, useStochRangePC2=false, useStochRangeSC2=false, 
           useVWAP=false,
           useMACDHistC1_P=false, useMACDHistC1_S=false, useMACDHistC2_P=false, useMACDHistC2_S=false) =>

    // ─── Skip if nothing selected ──────────────────────────────
    anySelected = rsiCheckP or rsiCheckS or emaCheckP or emaCheckS or macdCheckP or macdCheckS or stochCheckP or stochCheckS or useStochRangePC1 or useStochRangeSC1 or useStochRangePC2 or useStochRangeSC2 or useVWAP or useMACDHistC1_P or useMACDHistC1_S or useMACDHistC2_P or useMACDHistC2_S or filterMACDP or filterMACDS
    if not anySelected
        false
    else
        // ─── RSI Checks ──────────────────────────────
        rsiOK = (not rsiCheckP or (longDir ? rsiPrimary > rsiPrimaryMA : rsiPrimary < rsiPrimaryMA)) and  
                 (not rsiCheckS or (longDir ? rsiSecondary > rsiSecondaryMA : rsiSecondary < rsiSecondaryMA))

        // ─── EMA Checks ──────────────────────────────
        emaOK = (not emaCheckP or (longDir ? emaPrimaryAlpha > emaPrimaryBeta : emaPrimaryAlpha < emaPrimaryBeta)) and  
                 (not emaCheckS or (longDir ? emaSecondaryAlpha > emaSecondaryBeta : emaSecondaryAlpha < emaSecondaryBeta))

        // ─── MACD Cross (signal line) ─────────────────
        macdOK = (not macdCheckP or (longDir ? macdP > sigP : macdP < sigP)) and
                 (not macdCheckS or (longDir ? macdS > sigS : macdS < sigS))

        // ─── MACD Thresholds (independent) ───────────
        if filterMACDP
            primaryThresholdOK = (not macdCheckP) or (longDir ? macdP <= macdLongThreshold : macdP >= macdShortThreshold)
            macdOK := macdOK and primaryThresholdOK
        if filterMACDS
            secondaryThresholdOK = (not macdCheckS) or (longDir ? macdS <= macdLongThreshold2 : macdS >= macdShortThreshold2)
            macdOK := macdOK and secondaryThresholdOK

        // ─── MACD Histogram (independent toggles for C1 & C2) ──
        macdHistOK = (not useMACDHistC1_P or (longDir ? macdHistRisingP : macdHistFallingP)) and
                     (not useMACDHistC1_S or (longDir ? macdHistRisingS : macdHistFallingS)) and
                     (not useMACDHistC2_P or (longDir ? macdHistRisingP : macdHistFallingP)) and
                     (not useMACDHistC2_S or (longDir ? macdHistRisingS : macdHistFallingS))

        // ─── Stochastic Signal Cross (paired) ─────────
        stochOK = (not stochCheckP or (longDir ? stochK_P > stochD_P : stochK_P < stochD_P)) and
                  (not stochCheckS or (longDir ? stochK_S > stochD_S : stochK_S < stochD_S))

        // ─── VWAP ─────────────────────────────────────
        vwapOK = not useVWAP or (longDir ? close > vwapValue : close < vwapValue)

        // ─── Stochastic Range Logic (paired for C1/C2) ─
        stochP_pass_C1 = not useStochRangePC1 or (longDir ? stochInRange(stochK_P, stochLongMinK_P, stochLongMaxK_P) : stochInRange(stochK_P, stochShortMinK_P, stochShortMaxK_P))
        stochS_pass_C1 = not useStochRangeSC1 or (longDir ? stochInRange(stochK_S, stochLongMinK_S, stochLongMaxK_S) : stochInRange(stochK_S, stochShortMinK_S, stochShortMaxK_S))
        stochRangePass_C1 = stochP_pass_C1 and stochS_pass_C1

        stochP_pass_C2 = not useStochRangePC2 or (longDir ? stochInRange(stochK_P, stochLongMinK_P, stochLongMaxK_P) : stochInRange(stochK_P, stochShortMinK_P, stochShortMaxK_P))
        stochS_pass_C2 = not useStochRangeSC2 or (longDir ? stochInRange(stochK_S, stochLongMinK_S, stochLongMaxK_S) : stochInRange(stochK_S, stochShortMinK_S, stochShortMaxK_S))
        stochRangePass_C2 = stochP_pass_C2 and stochS_pass_C2

        // Final Stochastic Range Evaluation (handles either C1 or C2 toggles)
        stochRangePass = ( (useStochRangePC1 or useStochRangeSC1) ? stochRangePass_C1 :
                           ( (useStochRangePC2 or useStochRangeSC2) ? stochRangePass_C2 : true ) )

        // ─── Final Confluence Evaluation ──────────────
        rsiOK and emaOK and macdOK and macdHistOK and stochOK and stochRangePass and vwapOK


////////////////////////////
// Confluence 3 Helper Function (Stochastic Range Fix)
///////////////////////////
confluence3(longDir, rsiCheckP=false, rsiCheckS=false, emaCheckP=false, emaCheckS=false, macdCheckP=false, macdCheckS=false, stochCheckP=false, stochCheckS=false, macdThresholdCheckP=false, macdThresholdCheckS=false, requiredTrue=1, useStochRangePC3=false, useStochRangeSC3=false, useVWAP=false, useMACDHistC3_P=false, useMACDHistC3_S=false) =>

    // ── Return false immediately if nothing is toggled ─────────────
    anyToggled = rsiCheckP or rsiCheckS or emaCheckP or emaCheckS or macdCheckP or macdCheckS or stochCheckP or stochCheckS or macdThresholdCheckP or macdThresholdCheckS or useStochRangePC3 or useStochRangeSC3 or useVWAP or useMACDHistC3_P or useMACDHistC3_S
    if not anyToggled
        false
    else
        // ── Build array of active signals ─────────────────────────
        signals = array.new_bool(0)

        // Only push a condition if the toggle is enabled
        if rsiCheckP
            array.push(signals, longDir ? rsiPrimary > rsiPrimaryMA : rsiPrimary < rsiPrimaryMA)
        if rsiCheckS
            array.push(signals, longDir ? rsiSecondary > rsiSecondaryMA : rsiSecondary < rsiSecondaryMA)

        if emaCheckP
            array.push(signals, longDir ? emaPrimaryAlpha > emaPrimaryBeta : emaPrimaryAlpha < emaPrimaryBeta)
        if emaCheckS
            array.push(signals, longDir ? emaSecondaryAlpha > emaSecondaryBeta : emaSecondaryAlpha < emaSecondaryBeta)

        if macdCheckP
            array.push(signals, longDir ? macdP > sigP : macdP < sigP)
        if macdCheckS
            array.push(signals, longDir ? macdS > sigS : macdS < sigS)

        if stochCheckP
            array.push(signals, longDir ? stochK_P > stochD_P : stochK_P < stochD_P)
        if stochCheckS
            array.push(signals, longDir ? stochK_S > stochD_S : stochK_S < stochD_S)

        // Stochastic Range is now a separate count
        if useStochRangePC3
            array.push(signals, stochInRange(stochK_P, stochLongMinK_P, stochLongMaxK_P))
        if useStochRangeSC3
            array.push(signals, stochInRange(stochK_S, stochLongMinK_S, stochLongMaxK_S))

        if useVWAP
            array.push(signals, longDir ? close > vwapValue : close < vwapValue)

        if macdThresholdCheckP
            if macdCheckP
                primaryThresholdOK = longDir ? macdP <= macdLongThreshold : macdP >= macdShortThreshold
                array.push(signals, primaryThresholdOK)

        if macdThresholdCheckS
            if macdCheckS
                secondaryThresholdOK = longDir ? macdS <= macdLongThreshold2 : macdS >= macdShortThreshold2
                array.push(signals, secondaryThresholdOK)

        if useMACDHistC3_P
            array.push(signals, longDir ? macdHistRisingP : macdHistFallingP)
        if useMACDHistC3_S
            array.push(signals, longDir ? macdHistRisingS : macdHistFallingS)

        // ── Count the number of true signals ───────────────────────
        trueCount = 0
        for i = 0 to array.size(signals)-1
            trueCount += array.get(signals, i) ? 1 : 0

        // ── Return true if trueCount meets or exceeds requiredTrue ──
        trueCount >= requiredTrue

     
//////////////////////////
// Evaluate Confluence 1
///////////////////////////
long1  = confluence(true,  rsiCheckP=useRSIPrimaryC1, rsiCheckS=useRSISecondaryC1, emaCheckP=useEMAPrimaryC1, emaCheckS=useEMASecondaryC1, macdCheckP=useMACDPrimaryC1, macdCheckS=useMACDSecondaryC1, stochCheckP=useStochP_C1, stochCheckS=useStochS_C1, filterMACDP=filterMACD_P_C1, filterMACDS=filterMACD_S_C1, useStochRangePC1=useStochRangePC1, useStochRangeSC1=useStochRangeSC1, useVWAP=useVWAP_C1, useMACDHistC1_P=useMACDHistC1_P, useMACDHistC1_S=useMACDHistC1_S)
short1 = confluence(false, rsiCheckP=useRSIPrimaryC1, rsiCheckS=useRSISecondaryC1, emaCheckP=useEMAPrimaryC1, emaCheckS=useEMASecondaryC1, macdCheckP=useMACDPrimaryC1, macdCheckS=useMACDSecondaryC1, stochCheckP=useStochP_C1, stochCheckS=useStochS_C1, filterMACDP=filterMACD_P_C1, filterMACDS=filterMACD_S_C1, useStochRangePC1=useStochRangePC1, useStochRangeSC1=useStochRangeSC1, useVWAP=useVWAP_C1, useMACDHistC1_P=useMACDHistC1_P, useMACDHistC1_S=useMACDHistC1_S)

///////////////////////////
// Evaluate Confluence 2
///////////////////////////
long2  = confluence(true,  rsiCheckP=useRSIPrimaryC2, rsiCheckS=useRSISecondaryC2, emaCheckP=useEMAPrimaryC2, emaCheckS=useEMASecondaryC2, macdCheckP=useMACDPrimaryC2, macdCheckS=useMACDSecondaryC2, stochCheckP=useStochP_C2, stochCheckS=useStochS_C2, filterMACDP=filterMACD_P_C2, filterMACDS=filterMACD_S_C2, useStochRangePC2=useStochRangePC2, useStochRangeSC2=useStochRangeSC2, useVWAP=useVWAP_C2, useMACDHistC2_P=useMACDHistC2_P, useMACDHistC2_S=useMACDHistC2_S)
short2 = confluence(false, rsiCheckP=useRSIPrimaryC2, rsiCheckS=useRSISecondaryC2, emaCheckP=useEMAPrimaryC2, emaCheckS=useEMASecondaryC2, macdCheckP=useMACDPrimaryC2, macdCheckS=useMACDSecondaryC2, stochCheckP=useStochP_C2, stochCheckS=useStochS_C2, filterMACDP=filterMACD_P_C2, filterMACDS=filterMACD_S_C2, useStochRangePC2=useStochRangePC2, useStochRangeSC2=useStochRangeSC2, useVWAP=useVWAP_C2, useMACDHistC2_P=useMACDHistC2_P, useMACDHistC2_S=useMACDHistC2_S)

///////////////////////////
// Evaluate Confluence 3
///////////////////////////
long3  = confluence3(true, rsiCheckP=useRSIPrimaryC3, rsiCheckS=useRSISecondaryC3, emaCheckP=useEMAPrimaryC3, emaCheckS=useEMASecondaryC3, macdCheckP=useMACDPrimaryC3, macdCheckS=useMACDSecondaryC3, stochCheckP=useStochP_C3, stochCheckS=useStochS_C3, macdThresholdCheckP=filterMACD_P_C3, macdThresholdCheckS=filterMACD_S_C3, requiredTrue=requiredTrueC3, useStochRangePC3=useStochRangePC3, useStochRangeSC3=useStochRangeSC3, useVWAP=useVWAP_C3, useMACDHistC3_P=useMACDHistC3_P, useMACDHistC3_S=useMACDHistC3_S)
short3 = confluence3(false, rsiCheckP=useRSIPrimaryC3, rsiCheckS=useRSISecondaryC3, emaCheckP=useEMAPrimaryC3, emaCheckS=useEMASecondaryC3, macdCheckP=useMACDPrimaryC3, macdCheckS=useMACDSecondaryC3, stochCheckP=useStochP_C3, stochCheckS=useStochS_C3, macdThresholdCheckP=filterMACD_P_C3, macdThresholdCheckS=filterMACD_S_C3, requiredTrue=requiredTrueC3, useStochRangePC3=useStochRangePC3, useStochRangeSC3=useStochRangeSC3, useVWAP=useVWAP_C3, useMACDHistC3_P=useMACDHistC3_P, useMACDHistC3_S=useMACDHistC3_S)

// --- Baseline Logic
baselineLogic = switch colorTrigger
    "Off"                   => 0
    "EMA Cross - Primary"   => emaPrimaryAlpha > emaPrimaryBeta ? 1 : emaPrimaryAlpha < emaPrimaryBeta ? -1 : 0
    "EMA Cross - Secondary" => emaSecondaryAlpha > emaSecondaryBeta ? 1 : emaSecondaryAlpha < emaSecondaryBeta ? -1 : 0
    "Confluence 1"          => long1 ? 1 : short1 ? -1 : 0
    "Confluence 2"          => long2 ? 1 : short2 ? -1 : 0
    "Confluence 3"          => long3 ? 1 : short3 ? -1 : 0

// --- Neutral color (semi-transparent gray)
neutralCol = color.new(color.gray, 90)

// --- Preliminary Candle Color
preColor = baselineLogic == 1 and close > open ? color.new(#2c6457, 10) : 
           baselineLogic == -1 and close < open ? color.new(#b22d5b, 10) : 
           neutralCol

// --- Final Color Assignment
var color finalColor = na

if colorTrigger == "Off"
    finalColor := na  // default candles
else
    tmpColor = preColor
    // Apply Direction Filter
    if directionFilter == "Bullish Only" and tmpColor == color.new(#b22d5b, 10) //Used to keep candle states. Should be the same as baseline to be invisible in Style Tab
        tmpColor := neutralCol
    else if directionFilter == "Bearish Only" and tmpColor == color.new(#2c6457, 10) //Used to keep candle states. Should be the same as baseline to be invisible in Style Tab
        tmpColor := neutralCol
    finalColor := tmpColor

// --- Apply Coloring
barcolor(finalColor, title="Enhanced Candle Color")

///////////////////////////
// Plot Shapes
///////////////////////////
plotshape(long1,  title="Confluence 1 Long",  style=shape.triangleup,   location=location.belowbar, color=color.green, size=size.normal)
plotshape(short1, title="Confluence 1 Short", style=shape.triangledown, location=location.abovebar, color=color.red,   size=size.normal)
plotshape(long2,  title="Confluence 2 Long",  style=shape.triangleup,   location=location.belowbar, color=color.green, size=size.small)
plotshape(short2, title="Confluence 2 Short", style=shape.triangledown, location=location.abovebar, color=color.red,   size=size.small)
plotshape(long3,  title="Confluence 3 Long",  style=shape.triangleup,   location=location.belowbar, color=color.green, size=size.tiny)
plotshape(short3, title="Confluence 3 Short", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny)

////////////////////////////
// Alert Signal Aggregator
// (Post-processing layer)
// Uses existing Confluence 1/2/3 outputs only
////////////////////////////

// ─── User Selection ──────────────────────────────
alertSignalMode = input.string(
     "None",
     title = "Alert Signal Mode",
     options = [
         "None",
         "Any",
         "Any Bullish",
         "Any Bearish",
         "Multiple (same direction)",
         "Multiple Bullish",
         "Multiple Bearish",
         "Triple Confluence"
     ],
     group = "Alert Signal Logic",
     tooltip =  "Optional Alert Conditions do not change function or filtering, but allow for added utility in Trading View's Alert system."
)

// ─── Count Active Signals ────────────────────────
bullCount = (long1 ? 1 : 0) + (long2 ? 1 : 0) + (long3 ? 1 : 0)
bearCount = (short1 ? 1 : 0) + (short2 ? 1 : 0) + (short3 ? 1 : 0)
totalCount = bullCount + bearCount

// ─── Direction Consistency ───────────────────────
allBullish = bullCount >= 2 and bearCount == 0
allBearish = bearCount >= 2 and bullCount == 0

// ─── Mode Evaluation ─────────────────────────────
alertSignal =
     alertSignalMode == "None" ? false :

     alertSignalMode == "Any" ?
         totalCount >= 1 :

     alertSignalMode == "Any Bullish" ?
         bullCount >= 1 :

     alertSignalMode == "Any Bearish" ?
         bearCount >= 1 :

     alertSignalMode == "Multi-Match" ?
         (bullCount >= 2 and bearCount == 0) or
         (bearCount >= 2 and bullCount == 0) :

     alertSignalMode == "Multi-Match Bullish" ?
         bullCount >= 2 and bearCount == 0 :

     alertSignalMode == "Multi-Match Bearish" ?
         bearCount >= 2 and bullCount == 0 :

     alertSignalMode == "Triple Confluence" ?
         (bullCount == 3) or (bearCount == 3) :

     false

// ─── Optional: Alert Hook ────────────────────────
alertcondition(alertSignal, title="Confluence Alert Signal", message="Selected confluence alert condition met.")
