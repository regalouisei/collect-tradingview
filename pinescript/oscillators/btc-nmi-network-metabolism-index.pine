// ==========================================
// █▀█ █▀█ █▄▄   █▀▄▀█ ▄▀█ ▀█▀ █▄█ █▀
// █▀▄ █▄█ █▄█   █░▀░█ █▀█ ░█░ █░█ ▄█
// ==========================================
// Series : BTC - Fundamental Valuation
// BTC - Network Metabolism Index | RM
// ==========================================
//@version=6
indicator("BTC - NMI: Network Metabolism | RM", overlay=false, precision=2)

// ==========================================
// 1. DATA INPUTS
// ==========================================
grp_net  = "Network Metabolism Inputs (Glassnode)"
src_diff = input.string("GLASSNODE:BTC_DIFFICULTY", "Security Proxy (Difficulty)", group=grp_net)
src_addr = input.string("GLASSNODE:BTC_ACTIVEADDRESSES", "Utility Proxy (Addresses)", group=grp_net)
src_mcap = input.string("GLASSNODE:BTC_MARKETCAP", "Live Network Value (Market Cap)", group=grp_net)

grp_val  = "Valuation Parameters"
metcalfe_exp = input.float(2.0, "Metcalfe Exponent", minval=1.0, maxval=3.0, step=0.1, group=grp_val)
smooth_len   = input.int(14, "Smoothing (LSMA)", minval=1, group=grp_val)

// ==========================================
// 2. METABOLIC ENGINE
// ==========================================
// Fetching Live On-Chain Data
diff_val = request.security(src_diff, "D", close)
addr_val = request.security(src_addr, "D", close)
btc_mcap = request.security(src_mcap, "D", close)

// Formula: Fair Value Proxy (FVP)
// FVP = sqrt(Difficulty) * (Active Addresses ^ Exponent)
// We calculate intrinsic health based on security and network usage
float fvp = math.pow(addr_val, metcalfe_exp) * math.sqrt(diff_val)

// The NMI Calculation: Log-Ratio of Market Value to Network Health
// This identifies the distance between the "Organism's Price" and its "Metabolic Truth"
float nmi_raw = math.log(btc_mcap / fvp)
float nmi_smooth = ta.linreg(nmi_raw, smooth_len, 0)

// ==========================================
// 3. VISUALS 
// ==========================================
// Defining Dynamic Deviation Bands (1.5 Sigma)
float nmi_mean = ta.sma(nmi_smooth, 365)
float nmi_std  = ta.stdev(nmi_smooth, 365)
float fever_th = nmi_mean + (1.5 * nmi_std)
float starv_th = nmi_mean - (1.5 * nmi_std)

// Dynamic Color Assignment
color c_nmi = nmi_smooth > fever_th ? #ff1100 : nmi_smooth < starv_th ? #00ffbb : #909497

// Main Curve Plot
plot(nmi_smooth, "NMI Oscillator", color=color.new(c_nmi, 0), linewidth=3)

// Invisible plots for the fill engine
p_nmi   = plot(nmi_smooth, display=display.none)
p_fever = plot(fever_th, "Metabolic Fever", color=color.new(#ff1100, 50), style=plot.style_linebr)
p_starv = plot(starv_th, "Metabolic Starvation", color=color.new(#007bff, 34), style=plot.style_linebr)

// Filling the extreme zones
fill(p_nmi, p_fever, color = nmi_smooth > fever_th ? color.new(#ff1100, 85) : na, title="Fever Fill")
fill(p_nmi, p_starv, color = nmi_smooth < starv_th ? color.new(#00ffbb, 85) : na, title="Starvation Fill")

// Audit Table
if barstate.islast
    var table rm_table = table.new(position.top_right, 2, 4, bgcolor=color.rgb(15, 15, 15), border_width=1)
    table.cell(rm_table, 0, 0, "NMI SCORE", text_color=color.white, text_size=size.small)
    table.cell(rm_table, 1, 0, str.tostring(nmi_smooth, "#.##"), text_color=c_nmi, text_size=size.small)
    
    string audit = nmi_smooth > fever_th ? "OVERVALUED" : nmi_smooth < starv_th ? "UNDERVALUED" : "NEUTRAL"
    table.cell(rm_table, 0, 1, "REGIME AUDIT", text_color=color.white, text_size=size.small)
    table.cell(rm_table, 1, 1, audit, text_color=c_nmi, text_size=size.small)
