//TABELA DESENVOLVIDA POR LUIZ GOMES, DISTRIBUIÇÃO PERMITIDA COM DEVIDA AUTORIZAÇÃO PREVIA. VENDA PROIBIDA.
//@version=6
indicator("Tabela RSI & Níveis D/S (LGomes)", overlay=true)

// === INPUTS DE DADOS ===
rsiLength = input.int(14, "PERIODO RSI", group="Configurações RSI")
SCRSI     = input.int(30, "VALOR RSI SOBRE VENDA", group="Configurações RSI")
SVRSI     = input.int(70, "VALOR RSI SOBRE COMPRA", group="Configurações RSI")

// === INPUTS DA TABELA ===
showTable  = input.bool(true, "Exibir Tabela", group="Tabela")
tablePos   = input.string("Inferior Direito", "Posição da Tabela", options=["Superior Esquerdo", "Superior Centro", "Superior Direito", "Meio Esquerdo", "Meio Centro", "Meio Direito", "Inferior Esquerdo", "Inferior Centro", "Inferior Direito"], group="Tabela")
showRSI30  = input.bool(true, "Mostrar Coluna RSI=30", group="Tabela")
showRSI70  = input.bool(true, "Mostrar Coluna RSI=70", group="Tabela")
showCandleCol = input.bool(true, "Mostrar Cor do Candle (C)", group="Tabela")
precision  = input.int(5, "Casas Decimais (2-10)", minval=2, maxval=10, group="Tabela")
colorTitle = input.color(color.yellow, "Cor Título Tabela", group="Tabela")

// Função para converter string em posição real da tabela
getPos(_p) =>
    switch _p
        "Superior Esquerdo" => position.top_left
        "Superior Centro"   => position.top_center
        "Superior Direito"  => position.top_right
        "Meio Esquerdo"     => position.middle_left
        "Meio Centro"       => position.middle_center
        "Meio Direito"      => position.middle_right
        "Inferior Esquerdo" => position.bottom_left
        "Inferior Centro"   => position.bottom_center
        => position.bottom_right

// === INPUTS: EXIBIR/OCULTAR LINHAS DA TABELA ===
show1m  = input.bool(true, "Exibir 1min", group="Visibilidade Tabela")
show3m  = input.bool(true, "Exibir 3min", group="Visibilidade Tabela")
show5m  = input.bool(true, "Exibir 5min", group="Visibilidade Tabela")
show15m = input.bool(true, "Exibir 15min", group="Visibilidade Tabela")
show1h  = input.bool(true, "Exibir 1h", group="Visibilidade Tabela")
show4h  = input.bool(true, "Exibir 4h", group="Visibilidade Tabela")
show1D  = input.bool(true, "Exibir Diário", group="Visibilidade Tabela")
show1S  = input.bool(true, "Exibir Semanal", group="Visibilidade Tabela")
show1M  = input.bool(true, "Exibir Mensal", group="Visibilidade Tabela")

// === INPUTS VISUAIS, CORES E ESTILO ===
showLinesDAnt = input.bool(true, "Exibir Dia Anterior (D Anterior)", group="Visual Gráfico")
colorLevelAnt = input.color(color.aqua, "Cor Dia Anterior", group="Visual Gráfico")
showLinesDAtu = input.bool(true, "Exibir Dia Atual (D Atual)", group="Visual Gráfico")
colorLevelAtu = input.color(color.lime, "Cor Dia Atual", group="Visual Gráfico")
showLinesW    = input.bool(true, "Exibir Semana Atual", group="Visual Gráfico")
colorLevelW   = input.color(color.white, "Cor Semanal", group="Visual Gráfico")

lineStyleInput = input.string("Tracejada", "Estilo da Linha", options=["Sólida", "Tracejada", "Pontilhada"], group="Visual Gráfico")
lineWidthInput = input.int(1, "Espessura da Linha", minval=1, maxval=5, group="Visual Gráfico")
showLabels    = input.bool(true, "Exibir Textos (Labels)", group="Visual Gráfico")
posLabels     = input.string("Direita", "Posição dos Labels", options=["Esquerda", "Direita"], group="Visual Gráfico")

// === LÓGICA DE PROJEÇÃO ===
getLineStyle(_style) =>
    switch _style
        "Sólida"     => line.style_solid
        "Tracejada"  => line.style_dashed
        "Pontilhada" => line.style_dotted
        => line.style_dashed

isDailyOrHigher = timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly
[hAnt, lAnt, tAnt] = request.security(syminfo.tickerid, "D", [high[1], low[1], time[1]], lookahead=barmerge.lookahead_on)
[hAtu, lAtu, tAtu] = request.security(syminfo.tickerid, "D", [high[0], low[0], time[0]], lookahead=barmerge.lookahead_on)
[hSem, lSem, tSem] = request.security(syminfo.tickerid, "W", [high[0], low[0], time[0]], lookahead=barmerge.lookahead_on)

var int dayEnd = na
if barstate.islast
    dayEnd := tAtu + (24 * 60 * 60 * 1000)

f_format(_val) =>
    zeros = ""
    for i = 1 to precision
        zeros += "0"
    str.tostring(_val, "0." + zeros)

// === FUNÇÃO DE DESENHO COM DESLOCAMENTO DE LINHA ===
f_draw_final(tOp, hP, lP, col, txt, visible) =>
    var line lH = line.new(na, na, na, na, xloc=xloc.bar_time, color=col, style=getLineStyle(lineStyleInput), width=lineWidthInput)
    var line lL = line.new(na, na, na, na, xloc=xloc.bar_time, color=col, style=getLineStyle(lineStyleInput), width=lineWidthInput)
    lblStyle = posLabels == "Direita" ? label.style_label_left : label.style_label_right
    var label lbH = label.new(na, na, "", xloc=xloc.bar_time, color=color.new(color.black, 100), textcolor=col, style=lblStyle, size=size.normal)
    var label lbL = label.new(na, na, "", xloc=xloc.bar_time, color=color.new(color.black, 100), textcolor=col, style=lblStyle, size=size.normal)
    
    string prefixo = ""
    if txt == "D ATUAL   " and (hAtu == hAnt or lAtu == lAnt)
        prefixo := "\n"
    if txt == "SEMANA   " and (hSem == hAtu or hSem == hAnt or lSem == lAtu or lSem == lAnt)
        prefixo := "\n\n"

    if barstate.islast and visible
        int timeDiff = time - time[1]
        int xEnd = dayEnd
        int posX = posLabels == "Direita" ? (xEnd + (timeDiff * 2)) : (tOp - (timeDiff * 5))
        line.set_xy1(lH, tOp, hP), line.set_xy2(lH, xEnd, hP)
        line.set_xy1(lL, tOp, lP), line.set_xy2(lL, xEnd, lP)
        line.set_color(lH, col), line.set_color(lL, col)
        line.set_style(lH, getLineStyle(lineStyleInput)), line.set_style(lL, getLineStyle(lineStyleInput))
        line.set_width(lH, lineWidthInput), line.set_width(lL, lineWidthInput)
        if showLabels
            label.set_xy(lbH, posX, hP)
            label.set_text(lbH, prefixo + "MAX. " + txt + " " + f_format(hP))
            label.set_textcolor(lbH, col)
            label.set_xy(lbL, posX, lP)
            label.set_text(lbL, prefixo + "MIN. " + txt + " " + f_format(lP))
            label.set_textcolor(lbL, col)
    else
        line.set_xy1(lH, na, na), line.set_xy2(lH, na, na)
        label.set_xy(lbH, na, na), label.set_xy(lbL, na, na)

f_draw_final(tAnt, hAnt, lAnt, colorLevelAnt, "D ANT.   ", showLinesDAnt and not isDailyOrHigher)
f_draw_final(tAtu, hAtu, lAtu, colorLevelAtu, "D ATUAL   ", showLinesDAtu and not isDailyOrHigher)
f_draw_final(tSem, hSem, lSem, colorLevelW, "SEMANA   ", showLinesW)

// === CÁLCULOS RSI E TENDÊNCIA ===
calcPriceTarget(targetRSI, avgG, avgL, prevClose) =>
    rsT = targetRSI / (100 - targetRSI)
    sumG = avgG * (rsiLength - 1), sumL = avgL * (rsiLength - 1)
    rsNow = avgG / math.max(avgL, 0.00001)
    rsT >= rsNow ? prevClose + (rsT * sumL - sumG) : prevClose - (sumG / rsT - sumL)

getTFData() => [ta.rsi(close, rsiLength), ta.rma(math.max(close - close[1], 0), rsiLength), ta.rma(math.max(close[1] - close, 0), rsiLength), close, open]

[r1, g1, l1, c1, o1] = request.security(syminfo.tickerid, "1", getTFData())
[r3, g3, l3, c3, o3] = request.security(syminfo.tickerid, "3", getTFData())
[r5, g5, l5, c5, o5] = request.security(syminfo.tickerid, "5", getTFData())
[r15, g15, l15, c15, o15] = request.security(syminfo.tickerid, "15", getTFData())
[r60, g60, l60, c60, o60] = request.security(syminfo.tickerid, "60", getTFData())
[r240, g240, l240, c240, o240] = request.security(syminfo.tickerid, "240", getTFData())
[rD, gD, lD, cD, oD] = request.security(syminfo.tickerid, "D", getTFData())
[rW, gW, lW, cW, oW] = request.security(syminfo.tickerid, "W", getTFData())
[rM, gM, lM, cM, oM] = request.security(syminfo.tickerid, "M", getTFData())

// === TABELA FINAL ===
var table t = table.new(getPos(tablePos), 5, 11, bgcolor=color.black, border_width=1, frame_color=color.gray)
if barstate.islast and showTable
    table.set_position(t, getPos(tablePos))
    table.cell(t, 0, 0, "Time", text_color=colorTitle, bgcolor=color.rgb(50, 50, 50))
    table.cell(t, 1, 0, "RSI",  text_color=colorTitle, bgcolor=color.rgb(50, 50, 50))
    if showRSI30
        table.cell(t, 2, 0, "V. RSI " + str.tostring(SCRSI), text_color=colorTitle, bgcolor=color.rgb(50, 50, 50))
    if showRSI70
        table.cell(t, 3, 0, "V. RSI " + str.tostring(SVRSI), text_color=colorTitle, bgcolor=color.rgb(50, 50, 50))
    if showCandleCol
        table.cell(t, 4, 0, "Cor", text_color=colorTitle, bgcolor=color.rgb(50, 50, 50))

    tfs    = array.from("1m", "3m", "5m", "15m", "1h", "4h", "1D", "1S", "1M")
    rsis   = array.from(r1, r3, r5, r15, r60, r240, rD, rW, rM)
    gs     = array.from(g1, g3, g5, g15, g60, g240, gD, gW, gM)
    ls     = array.from(l1, l3, l5, l15, l60, l240, lD, lW, lM)
    closes = array.from(c1, c3, c5, c15, c60, c240, cD, cW, cM)
    opens  = array.from(o1, o3, o5, o15, o60, o240, oD, oW, oM)
    shows  = array.from(show1m, show3m, show5m, show15m, show1h, show4h, show1D, show1S, show1M)

    int row_idx = 1
    for i = 0 to 8
        if array.get(shows, i)
            r_v = array.get(rsis, i), g_v = array.get(gs, i), l_v = array.get(ls, i), c_v = array.get(closes, i), o_v = array.get(opens, i)
            table.cell(t, 0, row_idx, array.get(tfs, i), text_color=color.white)
            table.cell(t, 1, row_idx, str.tostring(r_v, "0.00"), text_color=(r_v <= SCRSI ? color.green : r_v >= SVRSI ? color.red : color.white))
            if showRSI30
                v30 = calcPriceTarget(SCRSI, g_v, l_v, c_v)
                table.cell(t, 2, row_idx, f_format(v30), text_color=color.white)
            if showRSI70
                v70 = calcPriceTarget(SVRSI, g_v, l_v, c_v)
                table.cell(t, 3, row_idx, f_format(v70), text_color=color.white)
            if showCandleCol
                cColor = c_v >= o_v ? color.lime : color.red
                table.cell(t, 4, row_idx, " ", bgcolor=cColor)
            row_idx += 1
