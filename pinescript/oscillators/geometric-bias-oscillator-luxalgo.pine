// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© LuxAlgo

//@version=6
indicator("Geometric Bias Oscillator [LuxAlgo]", "LuxAlgo - GBO", overlay = false)

//---------------------------------------------------------------------------------------------------------------------}
// Settings
//---------------------------------------------------------------------------------------------------------------------{
lengthInput     = input.int(100, "Window Size", minval = 10, maxval = 500, tooltip = "Number of recent bars to apply the RDP algorithm to.")
multInput       = input.float(2.0, "ATR Multiplier", minval = 0.1, step = 0.1, tooltip = "The threshold distance for point simplification. Higher values result in more simplification.")
atrLengthInput  = input.int(14, "ATR Length", minval = 1)
smoothInput     = input.int(1, "Smoothing", minval = 1)

STYLE_GROUP     = "Style"
bullColorInput  = input.color(#089981, "Bullish Color", group = STYLE_GROUP)
bearColorInput  = input.color(#f23645, "Bearish Color", group = STYLE_GROUP)

//---------------------------------------------------------------------------------------------------------------------}
// Types
//---------------------------------------------------------------------------------------------------------------------{
// @type Internal point for RDP calculations with normalized coordinates
type Point
    float x
    float y

//---------------------------------------------------------------------------------------------------------------------}
// Functions
//---------------------------------------------------------------------------------------------------------------------{
// @function Calculates the perpendicular distance from a point to a line segment
get_distance(Point p1, Point p2, Point p0) =>
    float x1 = p1.x
    float y1 = p1.y
    float x2 = p2.x
    float y2 = p2.y
    float x0 = p0.x
    float y0 = p0.y
    
    float dx = x2 - x1
    float dy = y2 - y1
    
    float numerator = math.abs(dy * x0 - dx * y0 + x2 * y1 - y2 * x1)
    float denominator = math.sqrt(dy * dy + dx * dx)
    
    denominator == 0 ? 0 : numerator / denominator

//---------------------------------------------------------------------------------------------------------------------}
// Calculations
//---------------------------------------------------------------------------------------------------------------------{
float atr = ta.atr(atrLengthInput)
float threshold = multInput

// Structural calculation
float smiValue = 0.0

if not na(atr) and atr > 0
    Point[] normPoints = array.new<Point>(lengthInput)
    float[] prices     = array.new_float(lengthInput)
    
    // 1. Gather points and prices
    for i = 0 to lengthInput - 1
        float p = close[lengthInput - 1 - i]
        prices.set(i, p)
        normPoints.set(i, Point.new(i, p / atr))
    
    int n = normPoints.size()
    bool[] keep = array.new_bool(n, false)
    keep.set(0, true)
    keep.set(n - 1, true)
    
    // 2. Iterative RDP
    int[] stack = array.new_int()
    stack.push(0)
    stack.push(n - 1)
    
    while stack.size() > 0
        int lastIdx = stack.pop()
        int firstIdx = stack.pop()
        
        float max_dist = 0.0
        int index = firstIdx
        
        Point pFirst = normPoints.get(firstIdx)
        Point pLast  = normPoints.get(lastIdx)
        
        for i = firstIdx + 1 to lastIdx - 1
            float d = get_distance(pFirst, pLast, normPoints.get(i))
            if d > max_dist
                max_dist := d
                index := i
        
        if max_dist > threshold
            keep.set(index, true)
            stack.push(index)
            stack.push(lastIdx)
            stack.push(firstIdx)
            stack.push(index)
    
    // 3. Sum Magnitudes of Bullish vs Bearish segments
    float bullSum = 0.0
    float bearSum = 0.0
    int lastKeptIdx  = 0
    
    for i = 1 to n - 1
        if keep.get(i)
            float currentPrice = prices.get(i)
            float prevPrice    = prices.get(lastKeptIdx)
            float diff         = currentPrice - prevPrice
            
            if diff > 0
                bullSum += diff
            else if diff < 0
                bearSum += math.abs(diff)
            
            lastKeptIdx := i
            
    float totalMagnitude = bullSum + bearSum
    smiValue := totalMagnitude > 0 ? ((bullSum - bearSum) / totalMagnitude) * 100.0 : 0.0

// Smoothing
float smiSeries = ta.sma(smiValue, smoothInput)

//---------------------------------------------------------------------------------------------------------------------}
// Visuals
//---------------------------------------------------------------------------------------------------------------------{
plotColor = smiSeries >= 0 ? bullColorInput : bearColorInput
plotId    = plot(smiSeries, "Geometric Bias", color = plotColor, linewidth = 2)
zeroId    = plot(0, "Zero Line", color = chart.fg_color)

// Bullish Gradient Fill
fill(plotId, zeroId, 
     top_value    = 100, 
     bottom_value = 0, 
     top_color    = color.new(bullColorInput, 50), 
     bottom_color = color.new(bullColorInput, 100), 
     title        = "Bullish Structural Weight")

// Bearish Gradient Fill
fill(plotId, zeroId, 
     top_value    = 0, 
     bottom_value = -100, 
     top_color    = color.new(bearColorInput, 100), 
     bottom_color = color.new(bearColorInput, 50), 
     title        = "Bearish Structural Weight")

hline(80, "Overbought")
hline(-80, "Oversold")

//---------------------------------------------------------------------------------------------------------------------}
