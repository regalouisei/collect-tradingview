//@version=6
indicator("B + A + D v1", overlay=false, precision=2)

//=========================
// === 1. BXtrender     ===
//=========================
groupBX = " === B-Xtrender === "
short_l1 = input.int(5 , title="Short - L1", group=groupBX)
short_l2 = input.int(20, title="Short - L2", group=groupBX)
short_l3 = input.int(15, title="Short - L3", group=groupBX)

long_l1  = input.int(20, title="Long - L1", group=groupBX)
long_l2  = input.int(15, title="Long - L2", group=groupBX)

shortTermXtrender = ta.rsi(ta.ema(close, short_l1) - ta.ema(close, short_l2), short_l3) - 50
longTermXtrender  = ta.rsi(ta.ema(close, long_l1), long_l2) - 50

shortXtrenderCol = shortTermXtrender > 0 ? (shortTermXtrender > shortTermXtrender[1] ? color.rgb(0, 230, 119, 100) : #228b2200) : (shortTermXtrender > shortTermXtrender[1] ? color.rgb(255, 82, 82, 100) : #8b000000)
plot(shortTermXtrender, color=shortXtrenderCol, style=plot.style_columns, linewidth=1, title="B-Xtrender Osc.")

t3(src, len) =>
    xe1 = ta.ema(src,    len)
    xe2 = ta.ema(xe1,  len)
    xe3 = ta.ema(xe2,  len)
    xe4 = ta.ema(xe3,  len)
    xe5 = ta.ema(xe4,  len)
    xe6 = ta.ema(xe5,  len)
    b = 0.7
    c1 = -b*b*b
    c2 = 3*b*b+3*b*b*b
    c3 = -6*b*b-3*b-3*b*b*b
    c4 = 1+3*b+b*b*b+3*b*b
    c1 * xe6 + c2 * xe5 + c3 * xe4 + c4 * xe3

maShortTermXtrender = t3(shortTermXtrender, 5)
colShortTermXtrender = maShortTermXtrender > maShortTermXtrender[1] ? color.rgb(0, 230, 119, 100) : color.rgb(255, 82, 82, 100)
plot(maShortTermXtrender, color=#00000000, style=plot.style_line, linewidth=5, title="B-X Shadow")
plot(maShortTermXtrender, color=colShortTermXtrender, style=plot.style_line, linewidth=3, title="B-X Color")

//=========================
// === 2. ADX + DI       ===
//=========================
groupADX = " === ADX & DI === "
len = input.int(14, "ADX Length", group=groupADX)
th  = input.float(20, "ADX Threshold", group=groupADX)

TrueRange = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs(low - nz(close[1])))
DirectionalMovementPlus = high - nz(high[1]) > nz(low[1]) - low ? math.max(high - nz(high[1]), 0) : 0
DirectionalMovementMinus = nz(low[1]) - low > high - nz(high[1]) ? math.max(nz(low[1]) - low, 0) : 0

var float SmoothedTrueRange = 0.0
SmoothedTrueRange := nz(SmoothedTrueRange[1]) - (nz(SmoothedTrueRange[1]) / len) + TrueRange

var float SmoothedDirectionalMovementPlus = 0.0
SmoothedDirectionalMovementPlus := nz(SmoothedDirectionalMovementPlus[1]) - (nz(SmoothedDirectionalMovementPlus[1]) / len) + DirectionalMovementPlus

var float SmoothedDirectionalMovementMinus = 0.0
SmoothedDirectionalMovementMinus := nz(SmoothedDirectionalMovementMinus[1]) - (nz(SmoothedDirectionalMovementMinus[1]) / len) + DirectionalMovementMinus

DIPlus  = SmoothedDirectionalMovementPlus  / SmoothedTrueRange * 100
DIMinus = SmoothedDirectionalMovementMinus / SmoothedTrueRange * 100
DX      = math.abs(DIPlus - DIMinus) / (DIPlus + DIMinus) * 100
ADX     = ta.sma(DX, len)

plot(DIPlus,  color=color.green, title="DI+")
plot(DIMinus, color=color.red,   title="DI-")
plot(ADX,     color=color.navy,  title="ADX")
hline(th, color=color.gray)

//=========================
// === 3. TREND STEP     ===
//=========================
groupTrend = " === Trend Step === "
maLengthInput = input.int(25, "MA Length", group=groupTrend)
volatility = input.int(200, "Volatility (ATR Period)", group=groupTrend)
trendWidth = input.float(2, "Channel Width", step=0.1, group=groupTrend)

var trendDirection = bool(na)
var trendBand = float(na)

atr = ta.atr(volatility)
MaUp = ta.sma(close, maLengthInput) + atr
MaDn = ta.sma(close, maLengthInput) - atr

upperBand = trendBand + atr * trendWidth
lowerBand = trendBand - atr * trendWidth

if bar_index < 300
    if close >= MaUp
        trendDirection := true
    if close <= MaDn
        trendDirection := false
else
    if low >= upperBand
        trendDirection := true
    if high <= lowerBand
        trendDirection := false

if trendDirection
    trendBand := math.max(nz(trendBand), hl2)
else
    trendBand := math.min(nz(trendBand), hl2)

// Prosta linia na poziomie 0 pokazująca kierunek trendu
trendLineColor = trendDirection ? color.white : color.black
plot(0, "Trend Line", color=trendLineColor, linewidth=3, style=plot.style_line)

//=========================
// === 4. EMA CORE       ===
//=========================
groupEMA = " === EMA Core === "
emaLength = input.int(50, "EMA Length", minval=1, group=groupEMA)
emaSource = input.source(close, "EMA Source", group=groupEMA)
colorSmooth = input.int(3, "Color Smoothing", minval=1, group=groupEMA)
showEmaLine = input.bool(true, "Show EMA Line", group=groupEMA)

// Calculate EMA
ema = ta.ema(emaSource, emaLength)

// Calculate EMA acceleration for gradient color
emaChange = ema - ema[1]
emaAccel = ta.ema(emaChange, colorSmooth)

// Manual tanh function for normalization
tanh(x) =>
    ex = math.exp(2 * x)
    (ex - 1) / (ex + 1)

accelNorm = tanh(emaAccel / (ta.atr(14) * 0.01))

// Map normalized accel to hue (60 = green, 120 = yellow/red)
hueRaw = 60 + accelNorm * 60
hue = na(hueRaw[1]) ? hueRaw : (hueRaw + hueRaw[1]) / 2
sat = 1.0
val = 1.0

// HSV to RGB conversion
hsv_to_rgb(h, s, v) =>
    c = v * s
    x = c * (1 - math.abs((h / 60) % 2 - 1))
    m = v - c
    r = 0.0
    g = 0.0
    b = 0.0
    if (h < 60)
        r := c
        g := x
        b := 0
    else if (h < 120)
        r := x
        g := c
        b := 0
    else if (h < 180)
        r := 0
        g := c
        b := x
    else if (h < 240)
        r := 0
        g := x
        b := c
    else if (h < 300)
        r := x
        g := 0
        b := c
    else
        r := c
        g := 0
        b := x
    color.rgb(int((r + m) * 255), int((g + m) * 255), int((b + m) * 255))

emaColor = hsv_to_rgb(hue, sat, val)

// Determine EMA trend direction
emaTrend = ema > ema[1] ? 1 : ema < ema[1] ? -1 : 0

// Display EMA as a flat line at -10 level (below trend line at 0)
emaLineLevel = -10

// Plot EMA as straight horizontal line with gradient color
plot(showEmaLine ? emaLineLevel : na, "EMA Core", color=emaColor, linewidth=3, style=plot.style_line)

//=========================
// === 5. COMBINED SIGNALS ===
//=========================
longXtrenderCol = longTermXtrender > 0 ? (longTermXtrender > longTermXtrender[1] ? color.rgb(255, 255, 255, 73) : #77777749) : (longTermXtrender > longTermXtrender[1] ? color.rgb(151, 151, 151, 73) : #0000003f)
macollongXtrenderCol = longTermXtrender > longTermXtrender[1] ? color.rgb(0, 230, 119, 100) : color.rgb(255, 82, 82, 100)
plot(longTermXtrender, color=longXtrenderCol, style=plot.style_histogram, linewidth=2, title="B-X Trend Hist")
plot(longTermXtrender, color=#00000000, style=plot.style_line, linewidth=5, title="B-X Trend Line")
plot(longTermXtrender, color=macollongXtrenderCol, style=plot.style_line, linewidth=3, title="B-X Trend Color")

//=========================
// === 6. DI CROSSOVER WITH DELAYED HISTOGRAM CONFIRMATION ===
//=========================

// Detect DI crossovers
diCrossUp = ta.crossover(DIPlus, DIMinus)
diCrossDown = ta.crossunder(DIPlus, DIMinus)

// Store pending signals (waiting for histogram confirmation)
var bool pendingBullSignal = false
var bool pendingBearSignal = false

// When DI crosses, store the pending signal
if diCrossUp
    pendingBullSignal := true
    pendingBearSignal := false  // Cancel opposite signal

if diCrossDown
    pendingBearSignal := true
    pendingBullSignal := false  // Cancel opposite signal

// Check histogram confirmation (candle closes with histogram in correct zone)
// BULL: Pending bull signal AND histogram closes above 0
bullConditions = pendingBullSignal and longTermXtrender > 0

// BEAR: Pending bear signal AND histogram closes below 0
bearConditions = pendingBearSignal and longTermXtrender < 0

// Śledzenie ostatniego sygnału (zapobiega powtarzaniu tego samego typu sygnału)
var int lastSignalType = 0  // 0 = brak, 1 = bull, -1 = bear

// Sygnał pojawia się tylko jeśli poprzedni sygnał był innego typu
bullReversalCondition = bullConditions and lastSignalType != 1
bearReversalCondition = bearConditions and lastSignalType != -1

// Aktualizacja ostatniego sygnału i reset pending
if bullReversalCondition
    lastSignalType := 1
    pendingBullSignal := false  // Signal fired, clear pending

if bearReversalCondition
    lastSignalType := -1
    pendingBearSignal := false  // Signal fired, clear pending

// Visual markers for signals
plotshape(bullReversalCondition ? maShortTermXtrender : na,
     style=shape.circle, color=color.rgb(255, 255, 255), size=size.tiny, location=location.absolute, title="Bull Reversal")
plotshape(bearReversalCondition ? maShortTermXtrender : na,
     style=shape.circle, color=color.rgb(5, 0, 0), size=size.tiny, location=location.absolute, title="Bear Reversal")

// Visual indicators for pending signals (optional - shows when waiting for histogram)
bgcolor(pendingBullSignal and not bullReversalCondition ? color.new(color.green, 95) : na, title="Pending Bull")
bgcolor(pendingBearSignal and not bearReversalCondition ? color.new(color.red, 95) : na, title="Pending Bear")

// Jeden alert - zmiana stanu (bull lub bear)
stateChange = bullReversalCondition or bearReversalCondition
alertcondition(stateChange, title="Signal Confirmed", message="HISTOGRAM CONFIRMED: {{ticker}} - {{interval}}")
