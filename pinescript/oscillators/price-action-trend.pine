// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SimpleCryptoLife
//@version=6
indicator('Price Action Trend', shorttitle = 'PA Trend', overlay = false)

// ============================== SETUP ==================================

enum ColourMode
    classic
    gradient

enum Trend
    up
    down
    neutral

enum PanePlotMode
    trend
    overboughtSold

enum PriceAverageSmoothing
    sma
    ema
    rma

// ============================== PA OVERLAY INPUTS ==================================

const string G_SETTINGS = "Settings"
const string G_DISPLAY  = "Display"
const string G_PRICE_AVERAGE = "Price Average"
const string G_ADVANCED = "Advanced"

// Tooltips
// SETTINGS
const string TT_PANE_PLOT_MODE           = "Select which value to plot in the indicator pane.\n\nTrend: plots the PA trend average.\nOverbought/Oversold: plots the PA OB/OS chosen line plus its dynamic levels (if enabled)."
const string TT_SMMA_LENGTH_TREND        = "Controls the smoothing period used to build the PA channel (SMMA/RMA of high and low).\n\nLower values react faster but can be noisier.\nHigher values are smoother but lag more."
const string TT_SHOW_OVERBOUGHT_SOLD     = "Shows the overbought/oversold triangle markers on the main chart."
const string TT_SMMA_LENGTH_OVERBOUGHT   = "Controls the smoothing period used to build the PA channel for overbought/oversold detection.\n\nLower values = more sensitive.\nHigher values = steadier signals."
const string TT_RSI_OVERBOUGHT_MA_LENGTH = "Smoothing length for the dynamic overbought/oversold levels (Williams pivot EMA).\n\nLower values track recent pivots more closely.\nHigher values create slower, smoother dynamic levels."

// DISPLAY
const string TT_CANDLE_TRANSP   = "Transparency applied to the main chart bar colours.\n\n0 = fully opaque, 100 = invisible.\n\nOnly affects Gradient mode."
const string TT_RSI_COLOUR_MODE = "Classic: simple up/down/neutral colours.\nGradient: colour intensity varies with the PA trend value."

// PRICE AVERAGE
const string TT_SHOW_PRICE_AVERAGE     = "Shows/hides the price-average line on the main chart.\n\nThis is a simple smoothed average of OHLC4, so you can see its interaction with the PA channel."
const string TT_COLOUR_CHANNEL_BY_PRICE = "When enabled, colours the PA channel (top/bottom lines and the filled band) based on where the price-average line sits:\n\n- Neutral: between the channel lines\n- Green: above the channel\n- Red: below the channel"
const string TT_PRICE_AVERAGE_LOOKBACK = "Lookback length used for the price-average smoothing.\n\nLower values react faster.\nHigher values are smoother but lag more."
const string TT_PRICE_AVERAGE_SMOOTHING = "Smoothing method used for the price-average line.\n\nSMA: simple average.\nEMA: faster-reacting.\nRMA: Wilder-style smoothing (same family as the PA channel smoothing)."

// ADVANCED
const string TT_RSI_NEUTRAL_UPPER = "Upper bound of the neutral zone.\n\nPA trend is Up when above this level, Neutral between the thresholds, and Down when below the lower threshold.\n\nAlso used as the minimum level for qualifying Williams highs in the dynamic overbought calculation."
const string TT_RSI_NEUTRAL_LOWER = "Lower bound of the neutral zone.\n\nPA trend is Down when below this level, Neutral between the thresholds, and Up when above the upper threshold.\n\nAlso used as the maximum level for qualifying Williams lows in the dynamic oversold calculation."
const string TT_PA_RSI_LENGTH_MODE = "Controls the RSI length used by the PA calculations.\n\nFixed (14): classic RSI length.\nMatch Trend Lookback: uses the Trend Lookback Period as the RSI length, making the PA trend smoother but typically more laggy."
const string TT_SHOW_RSI_PLOT     = "Plots the standard RSI of close for reference so you can see how PA Trend differs."
const string TT_RSI_LENGTH        = "Length used for the standard RSI(close) plot."

// SETTINGS
panePlotModeInput     = input.string(defval = "Trend", title = "Pane Plot Mode", options = ["Trend", "Overbought/Oversold"], tooltip = TT_PANE_PLOT_MODE, group = G_SETTINGS)
smmaLengthTrend       = input.int(   defval = 33, minval = 1, title = "Trend Lookback Period", tooltip = TT_SMMA_LENGTH_TREND, group = G_SETTINGS)
showOverboughtSold    = input.bool(  defval = true, title = "Show Overbought & Oversold Shapes", tooltip = TT_SHOW_OVERBOUGHT_SOLD, group = G_SETTINGS)
smmaLengthOverbought  = input.int(   defval = 5, minval = 1, title = "Overbought/sold Lookback Period", tooltip = TT_SMMA_LENGTH_OVERBOUGHT, group = G_SETTINGS)
rsiOverboughtMaLength = input.int(   defval = 12, minval = 2, maxval = 200, title = "Overbought/sold Adaptive Length", tooltip = TT_RSI_OVERBOUGHT_MA_LENGTH, group = G_SETTINGS)

// DISPLAY
candleTransp       = input.int(   defval = 0, step = 5, minval = 0, maxval = 100, title = "Transparency for the candle colour", tooltip = TT_CANDLE_TRANSP, group = G_DISPLAY)
rsiColourModeInput = input.string(defval = "Gradient", title = "Trend Colour Mode", options = ["Classic", "Gradient"], tooltip = TT_RSI_COLOUR_MODE, group = G_DISPLAY)

// PRICE AVERAGE
showPriceAverage = input.bool(defval = true, title = "Show Price Average", tooltip = TT_SHOW_PRICE_AVERAGE, group = G_PRICE_AVERAGE, inline = "PA_1")
priceAverageLength = input.int(defval = 5, minval = 1, maxval = 200, title = "Lookback", tooltip = TT_PRICE_AVERAGE_LOOKBACK, group = G_PRICE_AVERAGE, inline = "PA_1")
priceAverageSmoothingInput = input.string(defval = "RMA", title = "Smoothing", options = ["SMA", "EMA", "RMA"], tooltip = TT_PRICE_AVERAGE_SMOOTHING, group = G_PRICE_AVERAGE)
colourChannelByPriceAverage = input.bool(defval = true, title = "Colour Channel by Price Average", tooltip = TT_COLOUR_CHANNEL_BY_PRICE, group = G_PRICE_AVERAGE)

// ADVANCED
rsiNeutralUpper = input.float(defval = 51.5, minval = 50, maxval = 55, step = 0.1, title = "Trend Upper Neutral Threshold", tooltip = TT_RSI_NEUTRAL_UPPER, group = G_ADVANCED)
rsiNeutralLower = input.float(defval = 48.5, maxval = 50, minval = 45, step = 0.1, title = "Trend Lower Neutral Threshold", tooltip = TT_RSI_NEUTRAL_LOWER, group = G_ADVANCED)
paRsiLengthModeInput = input.string(defval = "Fixed (14)", title = "PA RSI Length", options = ["Fixed (14)", "Match Trend Lookback"], tooltip = TT_PA_RSI_LENGTH_MODE, group = G_ADVANCED)
showRsiPlot     = input.bool( defval = false, title = "Show RSI (close)", tooltip = TT_SHOW_RSI_PLOT, group = G_ADVANCED, inline = "ADV_1")
rsiLength       = input.int(  defval = 14, minval = 1, maxval = 200, title = "Length", tooltip = TT_RSI_LENGTH, group = G_ADVANCED, inline = "ADV_1")


ColourMode rsiColourMode = switch rsiColourModeInput
    "Classic" => ColourMode.classic
    "Gradient" => ColourMode.gradient
    => na
if na(rsiColourMode)
    runtime.error("Unsupported Trend Colour Mode: " + rsiColourModeInput)

PanePlotMode panePlotMode = switch panePlotModeInput
    "Trend" => PanePlotMode.trend
    "Overbought/Oversold" => PanePlotMode.overboughtSold
    => na
if na(panePlotMode)
    runtime.error("Unsupported Pane Plot Mode: " + panePlotModeInput)

PriceAverageSmoothing priceAverageSmoothing = switch priceAverageSmoothingInput
    "SMA" => PriceAverageSmoothing.sma
    "EMA" => PriceAverageSmoothing.ema
    "RMA" => PriceAverageSmoothing.rma
    => na
if na(priceAverageSmoothing)
    runtime.error("Unsupported Price Average Smoothing: " + priceAverageSmoothingInput)

int paRsiLength = switch paRsiLengthModeInput
    "Fixed (14)" => 14
    "Match Trend Lookback" => smmaLengthTrend
    => na
if na(paRsiLength)
    runtime.error("Unsupported PA RSI Length: " + paRsiLengthModeInput)



// ============================== RSI PA: COMMON CALCULATIONS ==================================

// This function calculates the channels and the PA delta so we can call it separately for the trend and for overbought.
functionRsiPa(source, length, rsiLength) =>
    smmaHigh = ta.rma(high, length)
    smmaLow = ta.rma(low, length)
    halfRange = (smmaHigh - smmaLow) / 2
    float _rsiPaRaw = ta.rsi((source - (smmaLow + halfRange)) / halfRange, rsiLength)
    float _rsiPa = na(halfRange) or halfRange == 0 ? na : _rsiPaRaw
    [smmaHigh, smmaLow, _rsiPa]

// ============================== RSI PA: TREND ==================================

// Calculate the lines to be used for Average modes
[smmaHighTrend, smmaLowTrend, rsiPaHighTrend] = functionRsiPa(high, smmaLengthTrend, paRsiLength)
halfRangeTrend = (smmaHighTrend - smmaLowTrend) / 2
float rsiPaLowTrend = ta.rsi((low - (smmaLowTrend + halfRangeTrend)) / halfRangeTrend, paRsiLength)
if na(halfRangeTrend) or halfRangeTrend == 0
    rsiPaLowTrend := na
rsiPaAverageTrend = (rsiPaHighTrend + rsiPaLowTrend) / 2


// == Get the logical trend ==

functionRsiLineTrend(rsiValue) =>
    Trend _rsiLineTrend = switch true
        rsiValue < rsiNeutralUpper and rsiValue > rsiNeutralLower => Trend.neutral
        rsiValue > rsiNeutralUpper => Trend.up
        rsiValue < rsiNeutralLower => Trend.down
        => na
    _rsiLineTrend

f_switchOnOff(bool _onSwitch, bool _offSwitch, bool _self) =>
    // This function returns true when _onSwitch is true, and stays true until the _offSwitch is true. Then it stays false until _onSwitch is true again.
    // You need to provide the output back into the function so it can persist it properly. Then the function itself is reusable.
    bool _output = _self
    _output := _offSwitch ? false : _onSwitch ? true : _output[1]

rsiTrend = functionRsiLineTrend(rsiPaAverageTrend)

// Store and flip the trend for alerts. This ignores any intervening neutral bars.
var bool isRed = false
var bool isGreen = false
bool isBull = rsiTrend == Trend.up
bool isBear = rsiTrend == Trend.down
isRed := isBear ? true : isBull ? false : isRed
isGreen := isBull ? true : isBear ? false : isGreen


// == Get the colour from the trend ==

functionRsiColourFromTrendClassic(rsiTrend) =>
    switch rsiTrend
        Trend.up => color.green
        Trend.down => color.red
        Trend.neutral => color.gray
        => na

// Choose the appropriate source for RSI for gradient value (and for plotting!)
rsiChosenTrend = rsiPaAverageTrend

method t(color _colour, int _transp) =>
    color.new(_colour, _transp)

functionRsiColourFromTrendGradient(rsiTrend, rsiValue, transp) =>
    float _rsi = rsiValue
    switch
        rsiTrend == Trend.neutral => color.gray
        _rsi > 50 and _rsi < 54 => #548754.t(transp)
        _rsi > 54 and _rsi < 56 => #4a964a.t(transp)
        _rsi > 56 and _rsi < 58 => #3fa53f.t(transp)
        _rsi > 58 and _rsi < 60 => #34b434.t(transp)
        _rsi > 60 and _rsi < 62 => #2ac32a.t(transp)
        _rsi > 62 and _rsi < 64 => #20d220.t(transp)
        _rsi > 64 and _rsi < 66 => #15e115.t(transp)
        _rsi > 66 and _rsi < 68 => #0af00a.t(transp)
        _rsi > 68 and _rsi < 70 => #05f805.t(transp)
        _rsi > 70 and _rsi < 100 => #00ff00.t(transp)
        _rsi < 50 and _rsi > 46 => #805959.t(transp)
        _rsi < 46 and _rsi > 44 => #8e4f4f.t(transp)
        _rsi < 44 and _rsi > 42 => #9e4444.t(transp)
        _rsi < 42 and _rsi > 40 => #ac3a3a.t(transp)
        _rsi < 40 and _rsi > 38 => #bc2f2f.t(transp)
        _rsi < 38 and _rsi > 36 => #ca2525.t(transp)
        _rsi < 36 and _rsi > 34 => #da1a1a.t(transp)
        _rsi < 34 and _rsi > 32 => #e81010.t(transp)
        _rsi < 32 and _rsi > 30 => #f80505.t(transp)
        _rsi < 30 and _rsi > 0 => #ff0000.t(transp)
        => na

rsiColour = switch rsiColourMode
    ColourMode.classic => functionRsiColourFromTrendClassic(rsiTrend)
    ColourMode.gradient => functionRsiColourFromTrendGradient(rsiTrend, rsiChosenTrend, candleTransp)
    => na

color rsiTrendLineColour = switch rsiColourMode
    ColourMode.classic => functionRsiColourFromTrendClassic(rsiTrend)
    ColourMode.gradient => functionRsiColourFromTrendGradient(rsiTrend, rsiChosenTrend, 0)
    => na

// Colour the main bars according to the trend, if selected
barcolor(rsiColour, title = 'Trend Colour for Bars on Main Chart')


// ============================== RSI PA: OVERBOUGHT/SOLD ==================================

[_, _, rsiPaHighOverbought] = functionRsiPa(high, smmaLengthOverbought, paRsiLength)
[_, _, rsiPaLowOverbought] = functionRsiPa(low, smmaLengthOverbought, paRsiLength)
rsiMaxOverbought = math.max(rsiPaHighOverbought, rsiPaLowOverbought)
rsiMinOverbought = math.min(rsiPaHighOverbought, rsiPaLowOverbought)

// Choose the Max or Min value to plot based on whether they're above or below the midline
var float rsiChosenOverbought = 0.0
functionRsiChosenOverbought() =>
    maxDiff = math.abs(rsiMaxOverbought - 50)
    minDiff = math.abs(rsiMinOverbought - 50)
    maxDiff < minDiff ? rsiMaxOverbought : rsiMinOverbought
bool _areBothAboveMidline = rsiMaxOverbought > 50 and rsiMinOverbought > 50
bool _areBothBelowMidline = rsiMaxOverbought < 50 and rsiMinOverbought < 50
if _areBothAboveMidline
    rsiChosenOverbought := rsiMaxOverbought
else if _areBothBelowMidline
    rsiChosenOverbought := rsiMinOverbought
else if not _areBothAboveMidline and not _areBothBelowMidline
    rsiChosenOverbought := functionRsiChosenOverbought()


// Get a series that contains the Williams Highs above 55 and Lows below 45
functionRsiIsWilliamsHigh() =>
    int _highIndexLocal = 3
    bool _isWilliamsHigh = rsiChosenOverbought[_highIndexLocal] >= ta.highest(rsiChosenOverbought, 8)
    float _highPrice = _isWilliamsHigh ? rsiChosenOverbought[_highIndexLocal] : na
    [_isWilliamsHigh, _highPrice]

functionRsiIsWilliamsLow() =>
    int _lowIndexLocal = 3
    bool _isWilliamsLow = rsiChosenOverbought[_lowIndexLocal] <= ta.lowest(rsiChosenOverbought, 8)
    float _lowPrice = _isWilliamsLow ? rsiChosenOverbought[_lowIndexLocal] : na
    [_isWilliamsLow, _lowPrice]

[rsiIsWilliamsHigh, rsiWilliamsHighPrice] = functionRsiIsWilliamsHigh()
[rsiIsWilliamsLow, rsiWilliamsLowPrice] = functionRsiIsWilliamsLow()

// Calculate the EMA of all Williams Highs above the neutral zone
var rsiWilliamsAlpha = 2 / (rsiOverboughtMaLength + 1)
var float rsiWilliamsHighEma = na
// You get the condition rsiIsWilliamsHigh only x bars AFTER the actual high. So you CANNOT use current bar values. You must use the values from the function.
if rsiWilliamsHighPrice > rsiNeutralUpper and rsiIsWilliamsHigh
    rsiWilliamsHighEma := rsiWilliamsAlpha * rsiWilliamsHighPrice + (1 - rsiWilliamsAlpha) * nz(rsiWilliamsHighEma[1], rsiWilliamsHighPrice)
var float rsiWilliamsLowEma = na
if rsiWilliamsLowPrice < rsiNeutralLower and rsiIsWilliamsLow
    rsiWilliamsLowEma := rsiWilliamsAlpha * rsiWilliamsLowPrice + (1 - rsiWilliamsAlpha) * nz(rsiWilliamsLowEma[1], rsiWilliamsLowPrice)

// Plot the overbought and oversold lines (except if they're zero)
float rsiOverboughtLine = na
if rsiWilliamsHighEma > 0
    rsiOverboughtLine := rsiWilliamsHighEma
float rsiOversoldLine = na
if rsiWilliamsLowEma > 0
    rsiOversoldLine := rsiWilliamsLowEma

bool isPaneTrend = panePlotMode == PanePlotMode.trend
bool isPaneOverboughtSold = panePlotMode == PanePlotMode.overboughtSold

float priceAverageSma = ta.sma(ohlc4, priceAverageLength)
float priceAverageEma = ta.ema(ohlc4, priceAverageLength)
float priceAverageRma = ta.rma(ohlc4, priceAverageLength)
float priceAverage = switch priceAverageSmoothing
    PriceAverageSmoothing.sma => priceAverageSma
    PriceAverageSmoothing.ema => priceAverageEma
    PriceAverageSmoothing.rma => priceAverageRma
    => na

bool isChannelColourable = not na(smmaHighTrend) and not na(smmaLowTrend) and not na(priceAverage)
color channelColour = not isChannelColourable ? color.gray : priceAverage > smmaHighTrend ? #34b434 : priceAverage < smmaLowTrend ? #bc2f2f : priceAverage >= smmaLowTrend and priceAverage <= smmaHighTrend ? color.gray : color.gray

color channelHighColour = colourChannelByPriceAverage ? channelColour : color.green
color channelLowColour = colourChannelByPriceAverage ? channelColour : color.red

channelHighPlot = plot(smmaHighTrend, title = "Trend SMMA High", color = channelHighColour, force_overlay = true)
channelLowPlot = plot(smmaLowTrend, title = "Trend SMMA Low", color = channelLowColour, force_overlay = true)

fill(channelHighPlot, channelLowPlot, title = "Trend Channel Fill", color = colourChannelByPriceAverage ? color.new(channelColour, 85) : na)

plot(showPriceAverage ? priceAverage : na, title = "Price Average (OHLC4)", color = chart.fg_color, linewidth = 2, force_overlay = true)

trendPanePlot = plot(isPaneTrend ? rsiChosenTrend : na, title = "PA Trend (RSI PA Average)", color = rsiTrendLineColour, linewidth = 2)
plot(isPaneOverboughtSold ? rsiChosenOverbought : na, title = "PA Overbought/Oversold (RSI PA Chosen)", color = chart.fg_color, linewidth = 2)
plot(isPaneOverboughtSold ? rsiOverboughtLine : na, title = "Dynamic Overbought Level", color = color.red)
plot(isPaneOverboughtSold ? rsiOversoldLine : na, title = "Dynamic Oversold Level", color = color.green)

float rsiClose = ta.rsi(close, rsiLength)
plot(showRsiPlot ? rsiClose : na, title = "RSI (close)", color = chart.fg_color)

hline(50, title = "Midline (50)", color = color.gray, linestyle = hline.style_dotted)
hline(70, title = "Overbought (70)", color = color.gray, linestyle = hline.style_dotted)
hline(30, title = "Oversold (30)", color = color.gray, linestyle = hline.style_dotted)
upperNeutralPanePlot = plot(isPaneTrend ? rsiNeutralUpper : na, title = "Upper Neutral Threshold", color = color.gray)
lowerNeutralPanePlot = plot(isPaneTrend ? rsiNeutralLower : na, title = "Lower Neutral Threshold", color = color.gray)

bool isTrendAboveNeutral = isPaneTrend and not na(rsiChosenTrend) and rsiChosenTrend > rsiNeutralUpper
bool isTrendBelowNeutral = isPaneTrend and not na(rsiChosenTrend) and rsiChosenTrend < rsiNeutralLower
bool isTrendBetweenNeutral = isPaneTrend and not na(rsiChosenTrend) and rsiChosenTrend >= rsiNeutralLower and rsiChosenTrend <= rsiNeutralUpper

float trendDistToUpper = math.abs(rsiChosenTrend - rsiNeutralUpper)
float trendDistToLower = math.abs(rsiChosenTrend - rsiNeutralLower)
bool isUpperCloser = not na(trendDistToUpper) and not na(trendDistToLower) and trendDistToUpper <= trendDistToLower
bool isLowerCloser = not na(trendDistToUpper) and not na(trendDistToLower) and trendDistToLower < trendDistToUpper

bool isTrendFillToUpper = isTrendAboveNeutral or (isTrendBetweenNeutral and isUpperCloser)
bool isTrendFillToLower = isTrendBelowNeutral or (isTrendBetweenNeutral and isLowerCloser)

trendFillUpperTrendPlot = plot(isTrendFillToUpper ? rsiChosenTrend : na, title = "Trend Fill Upper (Trend)", color = na, display = display.none)
trendFillUpperNeutralPlot = plot(isTrendFillToUpper ? rsiNeutralUpper : na, title = "Trend Fill Upper (Neutral)", color = na, display = display.none)
trendFillLowerTrendPlot = plot(isTrendFillToLower ? rsiChosenTrend : na, title = "Trend Fill Lower (Trend)", color = na, display = display.none)
trendFillLowerNeutralPlot = plot(isTrendFillToLower ? rsiNeutralLower : na, title = "Trend Fill Lower (Neutral)", color = na, display = display.none)

color c_trendFillGreenBright = #00ff00
color c_trendFillRedBright = #ff0000
color c_trendFillGreenTransparent = color.new(c_trendFillGreenBright, 100)
color c_trendFillRedTransparent = color.new(c_trendFillRedBright, 100)

fill(trendFillUpperTrendPlot, trendFillUpperNeutralPlot, rsiChosenTrend, rsiNeutralUpper, c_trendFillGreenBright, c_trendFillGreenTransparent, title = "Trend Gradient Fill (Up)")
fill(trendFillLowerNeutralPlot, trendFillLowerTrendPlot, rsiNeutralLower, rsiChosenTrend, c_trendFillRedTransparent, c_trendFillRedBright, title = "Trend Gradient Fill (Down)")

// Plot a little down arrow when overbought and an up arrow when oversold.
bool isOverbought = not na(rsiOverboughtLine) and rsiChosenOverbought > rsiOverboughtLine
bool isOversold = not na(rsiOversoldLine) and rsiChosenOverbought < rsiOversoldLine
bool plotTrianglesOverbought = showOverboughtSold and isOverbought
bool plotTrianglesOversold = showOverboughtSold and isOversold
plotshape(plotTrianglesOverbought, title = 'PA Trend Red Overbought Triangles', style = shape.triangledown, location = location.abovebar, color = color.new(color.red, 10), size = size.tiny, force_overlay = true)
plotshape(plotTrianglesOversold, title = 'PA Trend Green Oversold Triangles', style = shape.triangleup, location = location.belowbar, color = color.new(color.green, 10), size = size.tiny, force_overlay = true)

// ============================== RSI PA: ALERTS ==================================

alertcondition(isOverbought, title = ".Overbought PA Trend", message = "Overbought [PA Trend] - on close/intra-candle")
alertcondition(isOversold, title = ".Oversold PA Trend", message = "Oversold [PA Trend] - on close/intra-candle")

bool alertRedToGreen = isRed[1] == true and isGreen == true
bool alertGreenToRed = isGreen[1] == true and isRed == true

alertcondition(alertRedToGreen, title = ".Trend flips up", message = "PA flipped to uptrend [PA Trend] - on close/intra-candle")
alertcondition(alertGreenToRed, title = ".Trend flips down", message = "PA flipped to downtrend [PA Trend] - on close/intra-candle")

// Alert on first red candle after loss of overbought.
bool eventLostOverbought = isOverbought[1] and not isOverbought
var bool resetIsLostOverbought = false
var bool eventConfirmLostOverbought = false
resetIsLostOverbought := isOverbought or eventConfirmLostOverbought[1]
var bool isLostOverbought = false
isLostOverbought := f_switchOnOff(eventLostOverbought, resetIsLostOverbought, isLostOverbought)
eventConfirmLostOverbought := isLostOverbought and close < close[1]

// Alert on first green candle after loss of oversold.
bool eventLostOversold = isOversold[1] and not isOversold
var bool resetIsLostOversold = false
var bool eventConfirmLostOversold = false
resetIsLostOversold := isOversold or eventConfirmLostOversold[1]
var bool isLostOversold = false
isLostOversold := f_switchOnOff(eventLostOversold, resetIsLostOversold, isLostOversold)
eventConfirmLostOversold := isLostOversold and close > close[1]

alertcondition(eventConfirmLostOverbought, title = ".Lost overbought", message = "PA overbought condition ended [PA Trend]. Set this alert on close to avoid false alerts.")
alertcondition(eventConfirmLostOversold, title = ".Lost oversold", message = "PA oversold condition ended [PA Trend]. Set this alert on close to avoid false alerts.")
