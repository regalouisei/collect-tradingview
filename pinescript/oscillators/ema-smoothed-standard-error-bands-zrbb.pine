//@version=5
indicator("EMA Smoothed Standard Error Bands", overlay=true)

// 输入参数
length = input.int(10, "计算周期", minval=1)
smoothPeriod = input.int(60, "EMA平滑周期", minval=1)  // 重点修改1：独立平滑参数
stdDevMult = input.float(5, "标准差倍数", minval=0.1)
decay = input.float(1, "衰减因子", minval=0.1, maxval=1.0, step=0.1)

// 指数加权线性回归计算
var float sumX = 0.0
var float sumY = 0.0
var float sumXSq = 0.0
var float sumXY = 0.0
var float sumW = 0.0

sumX := 0.0
sumY := 0.0
sumXSq := 0.0
sumXY := 0.0
sumW := 0.0

for i = 0 to length - 1
    weight = math.pow(decay, i)
    x = i + 1
    sumX += x * weight
    sumY += close[i] * weight
    sumXSq += (x * x) * weight
    sumXY += (x * close[i]) * weight
    sumW += weight

// 加权最小二乘法
slope = (sumW * sumXY - sumX * sumY) / (sumW * sumXSq - sumX * sumX)
intercept = (sumY - slope * sumX) / sumW
linreg = intercept + slope * (length + 1) / 2

// 回归线EMA平滑
linregSmooth = ta.ema(linreg, smoothPeriod)  // 使用EMA

// 标准误差计算（核心逻辑不变）
var float errorSum = 0.0
errorSum := 0.0
for i = 0 to length - 1
    predicted = intercept + slope * (i + 1)
    errorSum += math.pow(close[i] - predicted, 2)
stdError = math.sqrt(errorSum / (length - 2))

// 重点修改2：标准误差的EMA平滑
stdErrorSmooth = ta.ema(stdError, smoothPeriod)  // SMA改为EMA

// 通道计算
upperBand = linregSmooth + stdDevMult * stdErrorSmooth
lowerBand = linregSmooth - stdDevMult * stdErrorSmooth
upperBand2 = linregSmooth + (stdDevMult + 5) * stdErrorSmooth
lowerBand2 = linregSmooth - (stdDevMult + 5) * stdErrorSmooth

// 可视化
plot(linregSmooth, "平滑中线", color.new(#2962FF, 0), 2)
plot(upperBand, "上轨", color.new(#2962FF, 0), 1)
plot(lowerBand, "下轨", color.new(#2962FF, 0), 1)
plot(upperBand2, "上轨2", color.new(#FF0000, 0), 1)
plot(lowerBand2, "下轨2", color.new(#FF0000, 0), 1)
