// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© mrfac

//@version=6
indicator('Quadro v6', overlay = false, dynamic_requests = true)

import raf_mak/libpublic/1 as lib //my library elements

bool logging = false
bool loggingGeneral = false
bool loggingQuadro = false
bool loggingReq = false

//divergence
p_plFound = array.new_bool(6)
p_phFound = array.new_bool(6)
p_divPower = array.new_float(6)
p_plFoundHidd = array.new_bool(6)
p_phFoundHidd = array.new_bool(6)
p_testPrice = array.new_float(6)
p_bullCond = array.new_bool(6)
p_bearCond = array.new_bool(6)
p_bullHiddCond = array.new_bool(6)
p_bearHiddCond = array.new_bool(6)

tf_label = array.new_string(4)
var tf_bias = array.new_string(4)
tf_for_bias = array.new_string(4)

assetPreSet = input.string('POPCAT', title = 'Settings for asset', options = ['POPCAT', '1000PEPE'], group = 'Asset pre-set')

p1_c = input.color(color.rgb(255, 82, 82, 35), '1', inline = '1', group = 'Quadro')
p1_wt = input.bool(false, 'â¬³', inline = '1', group = 'Quadro')
p1_len = input.int(9, '', inline = '1', group = 'Quadro')
p1_smooth = input.int(3, '', inline = '1', group = 'Quadro')
p1_div = input.bool(false, 'á´–', inline = '1', group = 'Quadro')
p1_cond = input.bool(false, 'âŸ´', 'â¬³ Show/Hide | Length | Smooting | á´– Show divergences | âŸ´ Show POI |', inline = '1', group = 'Quadro')

p2_c = input.color(color.rgb(255, 235, 59, 35), '2', inline = '2', group = 'Quadro')
p2_wt = input.bool(true, 'â¬³', inline = '2', group = 'Quadro')
p2_len = input.int(14, '', inline = '2', group = 'Quadro')
p2_smooth = input.int(3, '', inline = '2', group = 'Quadro')
p2_div = input.bool(true, 'á´–', inline = '2', group = 'Quadro')
p2_cond = input.bool(true, 'âŸ´', inline = '2', group = 'Quadro')
p2_pwr = input.bool(false, 'âž ', 'â¬³ Show/Hide | Length | Smooting | á´– Show divergences | âŸ´ Show Hint | âž  Divergence strength |', inline = '2', group = 'Quadro')

p3_c = input.color(color.rgb(0, 187, 212, 35), '3', inline = '3', group = 'Quadro')
p3_wt = input.bool(true, 'â¬³', inline = '3', group = 'Quadro')
p3_len = input.int(40, '', inline = '3', group = 'Quadro')
p3_smooth = input.int(4, '', inline = '3', group = 'Quadro')
p3_div = input.bool(true, 'á´–', inline = '3', group = 'Quadro')
p3_cond = input.bool(true, 'âŸ´', inline = '3', group = 'Quadro')
p3_pwr = input.bool(false, 'âž ', 'â¬³ Show/Hide | Length | Smooting | á´– Show divergences | âŸ´ Show Hint | âž  Divergence strength |', inline = '3', group = 'Quadro')

p4_c = input.color(color.rgb(255, 255, 255, 35), '4', inline = '4', group = 'Quadro')
p4_wt = input.bool(true, 'â¬³', inline = '4', group = 'Quadro')
p4_len = input.int(60, '', inline = '4', group = 'Quadro')
p4_smooth = input.int(10, '', inline = '4', group = 'Quadro')
p4_div = input.bool(false, 'á´–', inline = '4', group = 'Quadro')
p4_cond = input.bool(true, 'âŸ´', inline = '4', group = 'Quadro')
p4_pwr = input.bool(false, 'âž ', 'â¬³ Show/Hide | Length | Smooting | á´– Show divergences | âŸ´ Show Hint | âž  Divergence strength |', inline = '4', group = 'Quadro')

ct_ticker = input.symbol('BYBIT:BTCUSD.P', 'Symbol', inline = '20', group = 'Correlated Ticker')
ct1_c = input.color(color.rgb(240, 125, 25), title = '', inline = '20', group = 'Correlated Ticker')
ct1_wt = input.bool(false, 'â¬³', inline = '20', group = 'Correlated Ticker')
ct1_i = input.bool(false, 'ðŸ›ˆ', 'â¬³ Show/Hide | â¬¿ Smooth the line | ðŸ›ˆ Add to info table', inline = '20', group = 'Correlated Ticker')

merge_lines_c = input.color(color.rgb(255, 82, 82), 'Merge color', inline = '10', group = 'Assist')
merge_lines = input.bool(true, 'Merge lines when near', inline = '10', group = 'Assist')
mf_wt = input.bool(true, 'Money Flow', inline = '11', group = 'Assist')
mf_c_up = input.color(color.new(#3FFB03, 75), '', inline = '11', group = 'Assist')
mf_c_do = input.color(color.new(#FE1000, 75), '', inline = '11', group = 'Assist')
mf_style = input.string('Area', 'Style:', options = ['Area', 'Line'], inline = '11', group = 'Assist')
alert = input.bool(false, title = 'Alerts', group = 'Assist')

jma_src = input.source(close, 'Wave Type', inline = '6', group = 'Global Settings')
jma_return = input.bool(true, 'K-line â‡” D-line', 'Checked returns K-line / Unchecked return D-line', inline = '6', group = 'Global Settings')

//Divergences input
divS_lbR = input(4, title = 'Pivot Lookback Right', group = 'Divergences')
divS_lbL = input(4, title = 'Pivot Lookback Left', group = 'Divergences')
divS_rangeUpper = input(50, title = 'Max of Lookback Range', group = 'Divergences')
divS_rangeLower = input(1, title = 'Min of Lookback Range', group = 'Divergences')
divS_HiddenOpacity = input(50, 'Opacity level for Hidden Divergences', group = 'Divergences')
divS_plotBull = input(true, title = 'Plot Bullish', group = 'Divergences')
divS_plotBear = input(true, title = 'Plot Bearish', group = 'Divergences')
divS_plotHiddenBull = input(false, title = 'Plot Hidden Bullish', group = 'Divergences')
divS_plotHiddenBear = input(false, title = 'Plot Hidden Bearish', group = 'Divergences')

showTable = input.bool(true, 'Show Info Table', inline = '70', group = 'Info')
tablePosition = input.string(defval = 'Middle Left', title = 'Table Position', options = ['Top Right', 'Middle Right', 'Bottom Right', 'Bottom Center', 'Top Left', 'Middle Left', 'Bottom Left'], group = 'Info')
tableTxtSize = input.string(defval = 'Small', title = 'Table Text Size', options = ['Small', 'Large', 'Normal'], group = 'Info')

// -- Function
viewingTF() =>
    _viewingTF = lib.tfToInt(timeframe.period) < 60 ? true : false
    _viewingTF

type coinTemplate
    float ltf_obLvl = na
    float ltf_obLvl_l = na
    float htf_obLvl = na
    float htf_obLvl_l = na
    float ltf_osLvl = na
    float ltf_osLvl_h = na
    float htf_osLvl = na
    float htf_osLvl_h = na
    float pwr1_bull = na
    float pwr1_bear = na
    float pwr3_bull = na
    float pwr3_bear = na
    float ltf_mergeLines = na
    float htf_mergeLines = na
    //HTF ranges

assetChoose() =>
    coinTemplate coinSelected = na
    if assetPreSet == 'POPCAT'
        coinSelected := coinTemplate.new(ltf_obLvl = 94, ltf_obLvl_l = 70, htf_obLvl = 94, htf_obLvl_l = 70, ltf_osLvl = 6, ltf_osLvl_h = 23, htf_osLvl = 6, htf_osLvl_h = 23, pwr1_bull = 4.5, pwr1_bear = 2.5, pwr3_bull = 1, pwr3_bear = 1.5, ltf_mergeLines = 3.5, htf_mergeLines = 4.5)
        coinSelected
    if assetPreSet == '1000PEPE'
        coinSelected := coinTemplate.new(ltf_obLvl = 94, ltf_obLvl_l = 79, htf_obLvl = 94, htf_obLvl_l = 79, ltf_osLvl = 6, ltf_osLvl_h = 31.5, htf_osLvl = 6, htf_osLvl_h = 31.5, pwr1_bull = 4.5, pwr1_bear = 2.5, pwr3_bull = 1, pwr3_bear = 1.5, ltf_mergeLines = 3.5, htf_mergeLines = 4.5)
        coinSelected

    coinSelected

coin = assetChoose()

proccessCoin(_coin) =>
    _viewingTF = viewingTF()
    float obLvl = _viewingTF ? _coin.ltf_obLvl : _coin.htf_obLvl
    float obLvl_l = _viewingTF ? _coin.ltf_obLvl_l : _coin.htf_obLvl_l
    float osLvl = _viewingTF ? _coin.ltf_osLvl : _coin.htf_osLvl
    float osLvl_h = _viewingTF ? _coin.ltf_osLvl_h : _coin.htf_osLvl_h
    float pwr1_bull = coin.pwr1_bull
    float pwr1_bear = coin.pwr1_bear
    float pwr3_bull = coin.pwr3_bull
    float pwr3_bear = coin.pwr3_bear
    float mergeLinesRng = _viewingTF ? _coin.ltf_mergeLines : _coin.htf_mergeLines

    [obLvl, obLvl_l, osLvl, osLvl_h, pwr1_bull, pwr1_bear, pwr3_bull, pwr3_bear, mergeLinesRng]

[obLvl, obLvl_l, osLvl, osLvl_h, pwr1_bull, pwr1_bear, pwr3_bull, pwr3_bear, mergeLinesRng] = proccessCoin(coin)

inObOsRange(float _val, bool _extreme = false) =>
    string _isOsOb = '-'
    if _extreme
        if _val < osLvl
            _isOsOb := 'os'
            _isOsOb
        else if _val > obLvl
            _isOsOb := 'ob'
            _isOsOb
    else
        if _val < osLvl_h
            _isOsOb := 'os'
            _isOsOb
        else if _val > obLvl_l
            _isOsOb := 'ob'
            _isOsOb

    if logging
        log.info('checkLvl:_val:{0}|_isOsOb:{1}', _val, _isOsOb)

    returnval = _isOsOb
    returnval

req(string _symbol, float _tf, _exp, bool _raw = false, _gapsoff = barmerge.gaps_off, _lookahead = barmerge.lookahead_on) =>
    tfCal = _tf
    string tf = na
    int tfAndPeriod = 0
    //raw - don' calculate len    
    if _raw
        tf := str.tostring(_tf)
        tf
    else
        if not na(_tf)
            tfAndPeriod := lib.tfCurrentView(_tf)
            tfCal := tfAndPeriod > 1 ? int(_tf / tfAndPeriod) : _tf
            tf := str.tostring(tfCal)
            tf
    if not na(tf)
        //[barstate.isrealtime ? 1 : 0]//[barstate.isrealtime ? 0 : 1]
        request.security(_symbol, tf, _exp, _gapsoff, _lookahead)

//custom Jurik MA
periodK = 0
smoothK = 0
phaseK = 0
c_jma(_tf, bool doubleSmooth = false, bool _raw = false, int _lenCal = 0, int _smoothK = 0) =>
    _tfAndPeriod = lib.tfCurrentView(_tf)
    int lenCal_val = 0
    int smoothK_val = 0
    if _raw
        lenCal_val := _lenCal
        smoothK_val := _smoothK
        smoothK_val
    else
        lenCal_val := periodK * _tfAndPeriod
        smoothK_val := smoothK
        if lenCal_val > 5000
            lenCal_val := 5000
            lenCal_val
    stch = ta.stoch(jma_src, high, low, lenCal_val)
    if logging and loggingGeneral
        log.info('c_jma:_tf:{0}|stch:{1}|smoothK:{2}|phaseK:{3}|lenCal:{4}|ds:{5}|', _tf, stch, smoothK, phaseK, lenCal_val, doubleSmooth)
    k = lib.jma(stch, smoothK_val, phaseK)
    //Get Smooth
    k := doubleSmooth ? lib.jma(k, 6, -50) : k
    d = 0.05 + 0.95 * nz(k[1]) //Use a multiplier of 0.95 as per Ehler's Stochastic.
    d := d > 105 ? 105 : d < -5 ? -5 : d
    k := k > 105 ? 105 : k < -5 ? -5 : k
    returnVal = jma_return ? k : d
    returnVal

// Divergences
bearColor = color.red
bullColor = color.green
hiddenBullColor = color.new(color.green, 50)
hiddenBearColor = color.new(color.red, 50)
noneColor = color.new(color.black, 100)

_inRange(cond) =>
    bars = ta.barssince(cond == true)
    divS_rangeLower <= bars and bars <= divS_rangeUpper

divergence(_ma, int _i, bool _showOnlyRegular = true) =>

    plFound = na(ta.pivotlow(_ma, divS_lbL, divS_lbR)) ? false : true
    phFound = na(ta.pivothigh(_ma, divS_lbL, divS_lbR)) ? false : true
    plFoundHidd = na(ta.pivotlow(_ma, divS_lbL, divS_lbR)) ? false : true
    phFoundHidd = na(ta.pivothigh(_ma, divS_lbL, divS_lbR)) ? false : true

    float divPivot = 0
    float divPower = 0
    bool hiddenBullCond = false
    bool hiddenBearCond = false

    oscHL = _ma[divS_lbR] > ta.valuewhen(plFound, _ma[divS_lbR], 1) and _inRange(plFound[1])
    // Price: Lower Low
    priceLL = low[divS_lbR] < ta.valuewhen(plFound, low[divS_lbR], 1)
    bullCond = priceLL and oscHL and plFound
    divPivot := plFound ? ta.valuewhen(plFound, _ma[divS_lbR], 1) : 0 // poprzdni szczyt
    if bullCond
        divPower := lib.f_round(_ma[divS_lbR] - divPivot, 2)
        divPower

    // Regular Bearish
    // Osc: Lower High
    oscLH = _ma[divS_lbR] < ta.valuewhen(phFound, _ma[divS_lbR], 1) and _inRange(phFound[1])
    // Price: Higher High
    priceHH = high[divS_lbR] > ta.valuewhen(phFound, high[divS_lbR], 1)
    bearCond = priceHH and oscLH and phFound
    divPivot := phFound ? ta.valuewhen(phFound, _ma[divS_lbR], 1) : 0 // poprzdni szczyt
    if bearCond
        divPower := lib.f_round(divPivot - _ma[divS_lbR], 2)
        divPower

    // Hidden Bullish
    if not _showOnlyRegular
        // Osc: Lower Low
        oscLL_h = _ma[divS_lbR] < ta.valuewhen(plFoundHidd, _ma[divS_lbR], 1) and _inRange(plFoundHidd[1])
        // Price: Higher Low
        priceHL_h = low[divS_lbR] > ta.valuewhen(plFoundHidd, low[divS_lbR], 1)
        hiddenBullCond := priceHL_h and oscLL_h and plFoundHidd

        // Hidden Bearish
        // Osc: Higher High
        oscHH_h = _ma[divS_lbR] > ta.valuewhen(phFoundHidd, _ma[divS_lbR], 1) and _inRange(phFoundHidd[1])
        // Price: Lower High
        priceLH_h = high[divS_lbR] < ta.valuewhen(phFoundHidd, high[divS_lbR], 1)
        hiddenBearCond := priceLH_h and oscHH_h and phFoundHidd
        hiddenBearCond

    array.set(p_plFound, _i, plFound)
    array.set(p_phFound, _i, phFound)
    array.set(p_plFoundHidd, _i, plFoundHidd)
    array.set(p_phFoundHidd, _i, phFoundHidd)
    array.set(p_divPower, _i, divPower)
    array.set(p_bullCond, _i, bullCond)
    array.set(p_bearCond, _i, bearCond)
    array.set(p_bullHiddCond, _i, hiddenBullCond)
    array.set(p_bearHiddCond, _i, hiddenBearCond)

    _i

// Heikin Ashi calculations Money FLow
heikinAshiClose = (open + high + low + close) / 4
var heikinAshiOpen = array.new_float(1, (open + close) / 2)
if bar_index > 0
    array.set(heikinAshiOpen, 0, (array.get(heikinAshiOpen, 0) + heikinAshiClose[1]) / 2)
heikinAshiHigh = math.max(high, array.get(heikinAshiOpen, 0), heikinAshiClose)
heikinAshiLow = math.min(low, array.get(heikinAshiOpen, 0), heikinAshiClose)
// Calculating Money Flow using Heikin Ashi
moneyFlow(int period, int mult, float y) =>
    ta.sma((heikinAshiClose - array.get(heikinAshiOpen, 0)) / (heikinAshiHigh - heikinAshiLow) * mult, period) - y

// Prepare blueWaves mc
prepareBlueWaves(_offset, tf) =>

    string _tf_bias = na
    tfCal = 0
    _tf = lib.tfToInt(tf)
    int tfAndPeriod = 0
    tfAndPeriod := lib.tfCurrentView(_tf)
    tfCal := tfAndPeriod > 1 ? int(_tf / tfAndPeriod) : _tf
    len = 9 * tfCal
    smooth = 8

    [bw1, bw2, vwap] = lib.blueWaves(hlc3, len, smooth)

    if ta.crossover(bw1, bw2)
        _tf_bias := 'u'
        _tf_bias
    if ta.crossunder(bw1, bw2)
        _tf_bias := 'd'
        _tf_bias

    [bw1, bw2, _tf_bias]

array.set(tf_for_bias, 0, '15')
array.set(tf_for_bias, 1, '1h')
array.set(tf_for_bias, 2, '4h')
array.set(tf_for_bias, 3, '1d')

array.set(tf_label, 0, '15m')
array.set(tf_label, 1, '1h')
array.set(tf_label, 2, '4h')
array.set(tf_label, 3, '1d')

string tf_bias_r = na
tf = str.tostring(lib.tfToInt(array.get(tf_for_bias, 0)))
[_, _, _tf_bias0] = request.security(syminfo.tickerid, tf, prepareBlueWaves(0, tf))
if _tf_bias0 == 'u' or _tf_bias0 == 'd'
    array.set(tf_bias, 0, _tf_bias0)

tf := str.tostring(lib.tfToInt(array.get(tf_for_bias, 1)))
[_, _, _tf_bias1] = request.security(syminfo.tickerid, tf, prepareBlueWaves(0, tf))
if _tf_bias1 == 'u' or _tf_bias1 == 'd'
    array.set(tf_bias, 1, _tf_bias1)

tf := str.tostring(lib.tfToInt(array.get(tf_for_bias, 2)))
[_, _, _tf_bias2] = request.security(syminfo.tickerid, tf, prepareBlueWaves(0, tf))
if _tf_bias2 == 'u' or _tf_bias2 == 'd'
    array.set(tf_bias, 2, _tf_bias2)

tf := str.tostring(lib.tfToInt(array.get(tf_for_bias, 3)))
[_, _, _tf_bias3] = request.security(syminfo.tickerid, tf, prepareBlueWaves(0, tf))
if _tf_bias3 == 'u' or _tf_bias3 == 'd'
    array.set(tf_bias, 3, _tf_bias3)

plotTable(tbl, txtSize) =>
    for i = 0 to 3 by 1
        table.cell(tbl, 0, i, text = array.get(tf_label, i), text_color = color.white, text_size = txtSize, bgcolor = color.rgb(20, 20, 30, 50))
        [char, charC] = lib.getTendChar(array.get(tf_bias, i))
        table.cell(tbl, 1, i, text = char, text_color = charC, text_size = txtSize, bgcolor = #2828424d)

// Creating Tables
var table infoTable = table.new(lib.getTablePos(tablePosition), 3, 14, na, color.gray, 0, color.gray, 0)
// END functions

waveZero = 50

wt = plot(obLvl, 'Top', color.new(#c7c8ce80, 50), 1, editable = false, display = display.pane)
wb = plot(osLvl, 'Bottom', color.new(#c7c8ce80, 50), 1, editable = false, display = display.pane)
wu = plot(obLvl_l, 'Upper Band', color.new(#787B86, 25), 1, editable = false, display = display.none)
wz = plot(waveZero, 'Middle Band', color.new(#c7c8ce80, 50), 1, editable = false, display = display.pane)
wl = plot(osLvl_h, 'Lower Band', color.new(#787B86, 50), 1, editable = false, display = display.none)
fill(wu, wl, color.rgb(33, 150, 243, 80), title = 'Plot background')

moneyFlow = moneyFlow(60, 200, 2.25)

if moneyFlow < 0
    moneyFlow := 50 - moneyFlow / 2 * -1
    moneyFlow
else
    moneyFlow := 50 + moneyFlow / 2
    moneyFlow

moneyFlow := moneyFlow < 0 ? 0 : moneyFlow > 100 ? 100 : moneyFlow

//moneyflow
money_c = color.white
if moneyFlow > 50
    money_c := mf_c_up
    if moneyFlow > 100
        money_c := color.new(#3FFB03, 0)
        money_c
if moneyFlow < 50
    money_c := mf_c_do
    if moneyFlow < 0
        money_c := color.new(#FE1000, 0)
        money_c

moneyLine = plot(moneyFlow, 'Money Flow Area', money_c, 2, plot.style_line, display = mf_wt and mf_style == 'Area' ? display.all : display.none)
fill(wz, moneyLine, money_c, title = 'Money background', display = mf_wt and mf_style == 'Area' ? display.all : display.none)
plot(moneyFlow, 'Money Flow Line', money_c, 2, plot.style_line, display = mf_wt and mf_style == 'Line' ? display.all : display.none)

float p1_req = na
float p2_req = na
float p3_req = na
float p4_req = na

float ct1_req = na

//QUADRO - hints
p1_req := c_jma(1, false, true, p1_len, p1_smooth)
div_1 = divergence(p1_req, 0)
p2_req := c_jma(1, false, true, p2_len, p2_smooth)
div_2 = divergence(p2_req, 1)
p3_req := c_jma(1, false, true, p3_len, p3_smooth)
div_3 = divergence(p3_req, 2)
p4_req := c_jma(1, false, true, p4_len, p4_smooth)
div_4 = divergence(p4_req, 3)

//log.info("test:{0}",lib.tfToInt(timeframe.period))

ct1_req := req(ct_ticker, lib.tfToInt(timeframe.period), c_jma(1, false, true, p4_len, p4_smooth), true)

bool lines_inZone = false
bool lines_inZoneBullish = false
bool lines_inZoneBearish = false
if merge_lines

    base_p2_c = p2_c
    base_p3_c = p3_c
    base_p4_c = p4_c

    if inObOsRange(p2_req, true) == 'ob' and inObOsRange(p3_req, true) == 'ob' or inObOsRange(p2_req, true) == 'os' and inObOsRange(p3_req, true) == 'os'
        if p1_req < p2_req + mergeLinesRng and p1_req > p2_req - mergeLinesRng
            if p2_req < p3_req + mergeLinesRng and p2_req > p3_req - mergeLinesRng
                if p3_req < p4_req + mergeLinesRng and p3_req > p4_req - mergeLinesRng
                    p2_c := merge_lines_c
                    p3_c := merge_lines_c
                    p4_c := merge_lines_c
                    lines_inZone := true
                    lines_inZone
        else
            p2_c := base_p2_c
            p3_c := base_p3_c
            p4_c := base_p4_c
            lines_inZone := false
            lines_inZone

    if inObOsRange(p4_req, true) == 'os' and lines_inZone
        lines_inZoneBullish := true
        lines_inZoneBullish

    if inObOsRange(p4_req, true) == 'ob' and lines_inZone
        lines_inZoneBearish := true
        lines_inZoneBearish

// //rsi's
plot(p4_req, title = 'Wave 4', linewidth = 2, color = p4_c, display = p4_wt ? display.all : display.status_line + display.price_scale)
plot(p3_req, title = 'Wave 3', linewidth = 1, color = p3_c, display = p3_wt ? display.all : display.status_line + display.price_scale)
plot(p2_req, title = 'Wave 2', linewidth = 1, color = p2_c, display = p2_wt ? display.all : display.status_line + display.price_scale)
plot(p1_req, title = 'Wave 1', linewidth = 1, color = p1_c, display = p1_wt ? display.all : display.status_line)

plot(ct1_req, title = 'Correlated Ticker', linewidth = 1, color = ct1_c, display = ct1_wt ? display.all : display.status_line + display.price_scale)

//divergences - regular
//plot(array.get(p_plFound,0) ? p1_req[divS_lbR] : na, offset=-divS_lbR, title='P1 Regular Bullish', linewidth=1, color=(array.get(p_bullCond,0) ? color.new(p1_c,0) : noneColor),editable=false,display = p1_div and divS_plotBull ? display.pane : display.none )
//plot(array.get(p_phFound,0) ? p1_req[divS_lbR] : na, offset=-divS_lbR, title='P1 Regular Bearish', linewidth=1, color=(array.get(p_bearCond,0) ? color.new(p1_c,0) : noneColor),editable=false,display = p1_div and divS_plotBear ? display.pane : display.none )

plot(array.get(p_plFound, 1) ? p2_req[divS_lbR] : na, offset = -divS_lbR, title = 'P2 Regular Bullish', linewidth = 1, color = array.get(p_bullCond, 1) ? color.new(p2_c, 0) : noneColor, editable = false, display = p2_div and divS_plotBull ? display.pane : display.none)
plot(array.get(p_phFound, 1) ? p2_req[divS_lbR] : na, offset = -divS_lbR, title = 'P2 Regular Bearish', linewidth = 1, color = array.get(p_bearCond, 1) ? color.new(p2_c, 0) : noneColor, editable = false, display = p2_div and divS_plotBear ? display.pane : display.none)

plot(array.get(p_plFound, 2) ? p3_req[divS_lbR] : na, offset = -divS_lbR, title = 'P3 Regular Bullish', linewidth = 1, color = array.get(p_bullCond, 2) ? color.new(p3_c, 0) : noneColor, editable = false, display = p3_div and divS_plotBull ? display.pane : display.none)
plot(array.get(p_phFound, 2) ? p3_req[divS_lbR] : na, offset = -divS_lbR, title = 'P3 Regular Bearish', linewidth = 1, color = array.get(p_bearCond, 2) ? color.new(p3_c, 0) : noneColor, editable = false, display = p3_div and divS_plotBear ? display.pane : display.none)

plot(array.get(p_plFound, 3) ? p4_req[divS_lbR] : na, offset = -divS_lbR, title = 'P4 Regular Bullish', linewidth = 1, color = array.get(p_bullCond, 3) ? bullColor : noneColor, editable = false, display = p4_div and divS_plotBull ? display.pane : display.none)
plot(array.get(p_phFound, 3) ? p4_req[divS_lbR] : na, offset = -divS_lbR, title = 'P4 Regular Bearish', linewidth = 1, color = array.get(p_bearCond, 3) ? bearColor : noneColor, editable = false, display = p4_div and divS_plotBear ? display.pane : display.none)

//divergences - hidden
// plot(array.get(p_plFoundHidd,1) ? p2_req[divS_lbR] : na, offset=-divS_lbR, title='Hidden Bullish', linewidth=1, color=(array.get(p_bullHiddCond,1) ? color.new(p2_c,divS_HiddenOpacity) : noneColor), editable = false, display = p2_div and divS_plotHiddenBull ? display.pane : display.none )
// plot(array.get(p_phFoundHidd,1) ? p2_req[divS_lbR] : na, offset=-divS_lbR, title='Hidden Bearish', linewidth=1, color=(array.get(p_bearHiddCond,1) ? color.new(p2_c,divS_HiddenOpacity) : noneColor), editable = false, display = p2_div and divS_plotHiddenBear ? display.pane : display.none )

// plot(array.get(p_plFoundHidd,2) ? p3_req[divS_lbR] : na, offset=-divS_lbR, title='Hidden Bullish', linewidth=1, color=(array.get(p_bullHiddCond,2) ? color.new(p3_c,divS_HiddenOpacity) : noneColor), editable = false, display = p3_div and divS_plotHiddenBull ? display.pane : display.none )
// plot(array.get(p_phFoundHidd,2) ? p3_req[divS_lbR] : na, offset=-divS_lbR, title='Hidden Bearish', linewidth=1, color=(array.get(p_bearHiddCond,2) ? color.new(p3_c,divS_HiddenOpacity) : noneColor), editable = false, display = p3_div and divS_plotHiddenBear ? display.pane : display.none )

// plot(array.get(p_plFoundHidd,3) ? p4_req[divS_lbR] : na, offset=-divS_lbR, title='Hidden Bullish', linewidth=1, color=(array.get(p_bullHiddCond,3) ? color.new(p4_c,divS_HiddenOpacity) : noneColor), editable = false, display = p4_div and divS_plotHiddenBull ? display.pane : display.none )
// plot(array.get(p_phFoundHidd,3) ? p4_req[divS_lbR] : na, offset=-divS_lbR, title='Hidden Bearish', linewidth=1, color=(array.get(p_bearHiddCond,3) ? color.new(p4_c,divS_HiddenOpacity) : noneColor), editable = false, display = p4_div and divS_plotHiddenBear ? display.pane : display.none )

//power indicator - regular
plot(array.get(p_plFound, 1) ? array.get(p_divPower, 1) : na, offset = -divS_lbR, title = 'Bullish power', linewidth = 1, color = array.get(p_bullCond, 1) ? p2_c : noneColor, editable = false, display = p2_pwr ? display.pane : display.status_line)
plot(array.get(p_phFound, 1) ? array.get(p_divPower, 1) : na, offset = -divS_lbR, title = 'Bearish power', linewidth = 1, color = array.get(p_bearCond, 1) ? p2_c : noneColor, editable = false, display = p2_pwr ? display.pane : display.status_line)

plot(array.get(p_plFound, 2) ? array.get(p_divPower, 2) : na, offset = -divS_lbR, title = 'Bullish power', linewidth = 1, color = array.get(p_bullCond, 2) ? p3_c : noneColor, editable = false, display = p3_pwr ? display.pane : display.status_line)
plot(array.get(p_phFound, 2) ? array.get(p_divPower, 2) : na, offset = -divS_lbR, title = 'Bearish power', linewidth = 1, color = array.get(p_bearCond, 2) ? p3_c : noneColor, editable = false, display = p3_pwr ? display.pane : display.status_line)

plot(array.get(p_plFound, 3) ? array.get(p_divPower, 3) : na, offset = -divS_lbR, title = 'Bullish power', linewidth = 1, color = array.get(p_bullCond, 3) ? bullColor : noneColor, editable = false, display = p4_pwr ? display.pane : display.status_line)
plot(array.get(p_phFound, 3) ? array.get(p_divPower, 3) : na, offset = -divS_lbR, title = 'Bearish power', linewidth = 1, color = array.get(p_bearCond, 3) ? bearColor : noneColor, editable = false, display = p4_pwr ? display.pane : display.status_line)

plotshape(lines_inZoneBullish ? -5 : na, 'Lines in Zone', shape.xcross, location.absolute, merge_lines_c, size = size.tiny, display = merge_lines ? display.pane : display.none)
plotshape(lines_inZoneBearish ? 105 : na, 'Lines in zone', shape.xcross, location.absolute, merge_lines_c, size = size.tiny, display = merge_lines ? display.pane : display.none)

//Divergence QUADRO CONDITION
bullCondMark_1 = false
bearCondMark_1 = false
bullCondMark_2 = false
bearCondMark_2 = false
bullCondMark_3 = false
bearCondMark_3 = false

//rsi-2 condition
if p1_req[divS_lbR] < osLvl_h and p2_req[divS_lbR] < osLvl_h and p4_req[divS_lbR] < osLvl_h and (array.get(p_divPower, 1) > coin.pwr1_bull or array.get(p_divPower, 1) < 0.2)
    bullCondMark_1 := true
    bullCondMark_1
if p2_req[divS_lbR] > obLvl_l and p3_req[divS_lbR] > obLvl_l and array.get(p_divPower, 1) > coin.pwr1_bear
    bearCondMark_1 := true
    bearCondMark_1

//rsi-3 condition
if p1_req[divS_lbR] < osLvl_h and p2_req[divS_lbR] < osLvl_h and p3_req[divS_lbR] < osLvl_h and p4_req[divS_lbR] < osLvl_h and array.get(p_divPower, 2) > coin.pwr3_bull
    bullCondMark_2 := true
    bullCondMark_2
if p3_req[divS_lbR] > obLvl_l and p4_req[divS_lbR] > obLvl_l and array.get(p_divPower, 2) > coin.pwr3_bear
    bearCondMark_2 := true
    bearCondMark_2

//rsi-4 condition
if p1_req[divS_lbR] < osLvl_h and p2_req[divS_lbR] < osLvl_h and p4_req[divS_lbR] < osLvl_h and array.get(p_divPower, 3) > coin.pwr3_bull
    bullCondMark_3 := true
    bullCondMark_3
if p2_req[divS_lbR] > obLvl_l and p4_req[divS_lbR] > obLvl_l and array.get(p_divPower, 3) > coin.pwr3_bear
    bearCondMark_3 := true
    bearCondMark_3

if showTable
    plotTable(infoTable, lib.getTxtSize(tableTxtSize))

if alert
    string alertMsg = ''
    if array.get(p_plFound, 3) and array.get(p_bullCond, 3) and bullCondMark_3
        alertMsg := 'Bull signal: ' + str.tostring(syminfo.tickerid)
        alertMsg
    else if array.get(p_phFound, 3) and array.get(p_bearCond, 3) and bearCondMark_3
        alertMsg := 'Bear signal: ' + str.tostring(syminfo.tickerid)
        alertMsg

    if alertMsg != ''
        if logging
            log.info('alertMsg:{0}', alertMsg)
        alert(alertMsg)
