// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=6
indicator("Trend Pressure Prism [LuxAlgo]", "LuxAlgo - Trend Pressure Prism", overlay = false, precision = 2)

//---------------------------------------------------------------------------------------------------------------------}
// Constants
//---------------------------------------------------------------------------------------------------------------------{
// Table Constants
color DATA             = #DBDBDB
color HEADERS          = #808080
color BACKGROUND       = #161616
color BORDERS          = #2E2E2E

string TOP_RIGHT       = 'Top Right'
string BOTTOM_RIGHT    = 'Bottom Right'
string BOTTOM_LEFT     = 'Bottom Left'

string TINY            = 'Tiny'
string SMALL           = 'Small'
string NORMAL          = 'Normal'
string LARGE           = 'Large'
string HUGE            = 'Huge'

//---------------------------------------------------------------------------------------------------------------------}
// User Defined Functions
//---------------------------------------------------------------------------------------------------------------------{
// Manual Tanh approximation
tanh(float x) => 
    float e2x = math.exp(2 * x)
    (e2x - 1) / (e2x + 1)

// Manual Clamp
clamp(float x, float minVal, float maxVal) => math.max(minVal, math.min(maxVal, x))

//---------------------------------------------------------------------------------------------------------------------}
// Inputs
//---------------------------------------------------------------------------------------------------------------------{
group_calc             = "Calculation Settings"
lenInput               = input.int(20, "Lookback Period", minval = 5, group = group_calc)
sensitivityInput       = input.float(1.5, "Prism Sensitivity", minval = 0.1, step = 0.1, group = group_calc)
signalLenInput         = input.int(9, "Signal Line Period", minval = 2, group = group_calc)
minRvolInput           = input.float(1.2, "Min Signal RVOL", minval = 0.5, step = 0.1, group = group_calc, tooltip = "Filters signals based on Relative Volume. 1.0 means volume must be at least average.")
minAgreementInput      = input.float(0.6, "Min Signal Agreement", minval = 0, maxval = 1.0, step = 0.05, group = group_calc, tooltip = "Filters signals based on the unity of the 3 prism forces.")

group_visual           = "Visual Settings"
opacityInput           = input.int(60, "Prism Opacity", minval = 0, maxval = 100, group = group_visual)

group_style            = "Style Settings"
bullLightInput         = input.color(#00e5ff, "Bullish Light", group = group_style)
bullDeepInput          = input.color(#006064, "Bullish Deep", group = group_style)
bearLightInput         = input.color(#ff5252, "Bearish Light", group = group_style)
bearDeepInput          = input.color(#bf360c, "Bearish Deep", group = group_style)
neutralInput           = input.color(#787b86, "Neutral", group = group_style)
exhaustionInput        = input.color(#9c27b0, "Exhaustion", group = group_style)

DASHBOARD_GROUP        = 'Dashboard'
dashboardInput         = input.bool(true, 'Enable Dashboard', group = DASHBOARD_GROUP)
dashboardPositionInput = input.string(TOP_RIGHT, 'Position', group = DASHBOARD_GROUP, options = [TOP_RIGHT, BOTTOM_RIGHT, BOTTOM_LEFT])
dashboardSizeInput     = input.string(SMALL, 'Size', group = DASHBOARD_GROUP, options = [TINY, SMALL, NORMAL, LARGE, HUGE])

//---------------------------------------------------------------------------------------------------------------------}
// Calculations
//---------------------------------------------------------------------------------------------------------------------{
// 1. Momentum Drive: Aggression of movement
momROC                 = ta.roc(close, lenInput)
momStd                 = ta.stdev(momROC, lenInput)
momDrive               = ta.ema(momROC / (momStd + syminfo.mintick), 5)

// 2. Structural Alignment: Support of trend
emaFast                = ta.ema(close, lenInput)
emaSlow                = ta.ema(close, lenInput * 2)
structVal              = (close - emaSlow) / (emaFast - emaSlow + syminfo.mintick)
structAlign            = ta.ema(clamp(structVal, -2, 2), 5)

// 3. Pullback Quality: Health of retracements
highest                = ta.highest(high, lenInput)
lowest                 = ta.lowest(low, lenInput)
range_                 = highest - lowest
pullback               = range_ != 0 ? (close - lowest) / range_ : 0.5
pbQuality              = (pullback - 0.5) * 2 

// 4. Component Normalization
normMom                = tanh(momDrive * sensitivityInput)
normStruct             = tanh(structAlign * sensitivityInput)
normPB                 = tanh(pbQuality * sensitivityInput)

// 5. Volume Metrics
avgVol                 = ta.sma(volume, 20)
rvol                   = volume / (avgVol + syminfo.mintick)

// 6. Agreement Metric
agreement              = 1.0 - math.abs(normMom - normStruct) * 0.3 - math.abs(normStruct - normPB) * 0.3

// 7. Composite Pressure Score
composite              = (normMom + normStruct + normPB) / 3
compScore              = composite * 100

// 8. Signal Line & Filtered Crossovers
sigLine                = ta.ema(compScore, signalLenInput)
bullCrossRaw           = ta.crossover(compScore, sigLine)
bearCrossRaw           = ta.crossunder(compScore, sigLine)

bullCross              = bullCrossRaw and rvol > minRvolInput and agreement > minAgreementInput and compScore < 40
bearCross              = bearCrossRaw and rvol > minRvolInput and agreement > minAgreementInput and compScore > -40

//---------------------------------------------------------------------------------------------------------------------}
// Logic & State
//---------------------------------------------------------------------------------------------------------------------{
// Determine base color based on direction and agreement
color prismTop         = neutralInput
color prismBottom      = neutralInput

if composite > 0
    prismTop           := color.from_gradient(agreement, 0.4, 1.0, bullDeepInput, bullLightInput)
    prismBottom        := color.from_gradient(agreement, 0.4, 1.0, color.new(bullDeepInput, 50), bullDeepInput)
else
    prismTop           := color.from_gradient(agreement, 0.4, 1.0, bearDeepInput, bearLightInput)
    prismBottom        := color.from_gradient(agreement, 0.4, 1.0, color.new(bearDeepInput, 50), bearDeepInput)

// Apply "Glass" effect opacity
int opacity            = 100 - opacityInput
color tCol             = color.new(prismTop, opacity)
color bCol             = color.new(prismBottom, opacity)

// State Logic for Dashboard
string state           = "Neutral"
color stateColor       = neutralInput
string action          = "Wait"

if bullCross
    action             := "Bullish Cross"
else if bearCross
    action             := "Bearish Cross"
else
    action             := composite > 0.4 and agreement > 0.7 ? "Hold Long" : composite < -0.4 and agreement > 0.7 ? "Hold Short" : agreement < 0.5 ? "Exhaustion" : "Wait"

if compScore > 40 and agreement > 0.7
    state              := "Bullish Conviction"
    stateColor         := bullLightInput
else if compScore < -40 and agreement > 0.7
    state              := "Bearish Conviction"
    stateColor         := bearLightInput
else if agreement < 0.5
    state              := "Exhaustion"
    stateColor         := exhaustionInput
else
    state              := "Glass / Neutral"
    stateColor         := neutralInput

//---------------------------------------------------------------------------------------------------------------------}
// Dashboard Components
//---------------------------------------------------------------------------------------------------------------------{
var parsedDashboardPosition = switch dashboardPositionInput
    TOP_RIGHT      => position.top_right
    BOTTOM_RIGHT   => position.bottom_right
    BOTTOM_LEFT    => position.bottom_left

var parsedDashboardSize = switch dashboardSizeInput
    TINY           => size.tiny
    SMALL          => size.small
    NORMAL         => size.normal
    LARGE          => size.large
    HUGE           => size.huge

cell(table t_able, int column, int row, string data, color = #FFFFFF, align = text.align_right, color background = na, float height = 0) => 
    t_able.cell(column, row, data, text_color = color, text_size = parsedDashboardSize, text_halign = align, bgcolor = background, height = height)

divider(table t_able, int row, int lastColumn) =>    
    string rowDivider = '━━━━━━━━━━━━━━━━━━━━━━'
    t_able.merge_cells(0, row, lastColumn, row)
    cell(t_able, 0, row, rowDivider, align = text.align_center, height = 0.5, color = BORDERS)

var table t_able    = table.new(parsedDashboardPosition, 2, 9, bgcolor = BACKGROUND, border_width = 0, frame_color = BORDERS, frame_width = 1, force_overlay = true)

if dashboardInput and barstate.islast
    t_able.merge_cells(0, 0, 1, 0)
    cell(t_able, 0, 0, 'Trend Pressure Prism', color = DATA, align = text.align_center)     

    divider(t_able, 1, 1)
    cell(t_able, 0, 2, 'Current State', color = HEADERS, align = text.align_left)            
    cell(t_able, 1, 2, state, color = stateColor)

    divider(t_able, 3, 1)
    cell(t_able, 0, 4, 'Action', color = HEADERS, align = text.align_left)            
    cell(t_able, 1, 4, action, color = stateColor)

    divider(t_able, 5, 1)
    cell(t_able, 0, 6, 'Pressure Score', color = HEADERS, align = text.align_left)   
    cell(t_able, 1, 6, str.tostring(compScore, "0.00"), color = DATA)

    divider(t_able, 7, 1)
    cell(t_able, 0, 8, 'Agreement', color = HEADERS, align = text.align_left)   
    cell(t_able, 1, 8, str.tostring(agreement * 100, "0.0") + "%", color = DATA)

//---------------------------------------------------------------------------------------------------------------------}
// Visuals (Oscillator Pane)
//---------------------------------------------------------------------------------------------------------------------{
// Reference Lines
h100 = hline(100, "Max Bound", display = display.none)
h80  = hline(80, "Upper Bound", color = color.new(chart.fg_color, 85), linestyle = hline.style_dashed)
h0   = hline(0, "Neutral", display = display.none)
hM80 = hline(-80, "Lower Bound", color = color.new(chart.fg_color, 85), linestyle = hline.style_dashed)
hM100= hline(-100, "Min Bound", display = display.none)

// Zone Fills
fill(h80, h100, top_color = color.new(bullLightInput, 85), bottom_color = color.new(bullLightInput, 95), title = "Bullish Extreme Zone")
fill(hM80, hM100, top_color = color.new(bearLightInput, 95), bottom_color = color.new(bearLightInput, 85), title = "Bearish Extreme Zone")

// Signal Line
plot(sigLine, "Signal Line", color = color.new(chart.fg_color, 60), style = plot.style_linebr)

// Main Prismatic Ribbon
p1 = plot(compScore, "Core Pressure", color = tCol, linewidth = 3)

// Background Conviction Glow
p0 = plot(0, "Zero Axis", color = color.new(chart.fg_color, 80), style = plot.style_linebr)
fill(p1, p0, top_value = 100, bottom_value = -100, 
     top_color = compScore > 0 ? color.new(bullLightInput, 92) : color.new(bearLightInput, 100), 
     bottom_color = compScore > 0 ? color.new(bullLightInput, 100) : color.new(bearLightInput, 92), 
     title = "Conviction Glow")

// Crossover Signals (Filtered)
if bullCross or bearCross
    string circleSize = rvol > 2.2 ? size.normal : rvol > 1.6 ? size.small : size.tiny
    color  circleCol  = color.new(bullCross ? bullLightInput : bearLightInput, rvol > 2.0 ? 10 : 40)
    
    label.new(bar_index, compScore, 
         text          = "", 
         color         = circleCol, 
         style         = label.style_circle, 
         size          = circleSize, 
         force_overlay = false)

//---------------------------------------------------------------------------------------------------------------------}
