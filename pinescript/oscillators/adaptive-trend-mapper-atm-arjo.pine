// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ARJO_2019

//@version=6
indicator("Adaptive Trend Mapper-ATM [Arjo]", shorttitle="ATM [Arjo]", format=format.price, precision=2)

// ============= INPUT PARAMETERS =============

// --- Core Indicator Inputs ---
adxlen = input.int(5, "ADX Smoothing", display = display.none)
dilen = input.int(10, "DI Length", display = display.none)
len = input.int(10, "RSI Length", minval=1, display = display.none)
src = input.source(close, "Source")

// --- Zone Levels ---
choppyLine = input.float(15, "Choppy Line", minval=0, step=5, display = display.none)

// --- Signal Thresholds ---
adxThreshold = input.int(15, "ADX Signal Threshold", minval=10, maxval=50, display = display.none)
squeezeLookback = input.int(20, "Squeeze Detection Period", minval=5, maxval=50, display = display.none)

// --- Squeeze Parameters ---
squeezeAdxThreshold = input.int(15, "Squeeze ADX Threshold", minval=10, maxval=30, group="Squeeze Settings", display = display.none)
squeezeConvergenceThreshold = input.float(10.0, "Convergence Threshold", minval=1.0, maxval=30.0, step=0.5, group="Squeeze Settings", display = display.none)
squeezeConvergencePeriod = input.int(10, "Convergence Period", minval=3, maxval=30, group="Squeeze Settings", display = display.none)

// --- Display Options ---
showSqueeze = input.bool(true, "Show Squeeze Detection")
useDynamicColors = input.bool(true, "Use Dynamic Colors")

// ============= SMOOTHING OPTIONS =============
useSmoothing = input.bool(false, "Enable Smoothing", group="Smoothing Settings")
smoothingLength = input.int(5, "Smoothing Length", minval=1, group="Smoothing Settings", display = display.none)
smoothingType = input.string("SMA", "Smoothing Type", options=["SMA", "EMA", "WMA", "RMA"], group="Smoothing Settings", display = display.none)
smoothRSILength = input.int(10, "Smoothing RSI Length", minval=1, group="Smoothing Settings", display = display.none)

// ============= CALCULATIONS =============

// --- RSI Calculations ---
up = ta.rma(math.max(ta.change(src), 0), len)
down = ta.rma(-math.min(ta.change(src), 0), len)
rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))
rsiInverse = up == 0 ? 100 : down == 0 ? 0 : 100 - (100 / (1 + down / up))


// --- ADX Calculations ---
[plusDI, minusDI, adxValue] = ta.dmi(dilen, adxlen)
//================================
// --- Bull and Bear Indices------ ---
rawBearIndex = 100 * (adxValue / (rsi + adxValue))
rawBullIndex = 100 * (adxValue / (rsiInverse + adxValue))

// ============= SMOOTHING LOGIC =============
getMA(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "WMA" => ta.wma(source, length)
        "RMA" => ta.rma(source, length)
        => ta.sma(source, length) // Default to SMA

// Apply smoothing if enabled. These variables will be used for plotting and signals.
plotBullIndex = useSmoothing ? getMA(rawBullIndex, smoothingLength, smoothingType) : rawBullIndex
plotBearIndex = useSmoothing ? getMA(rawBearIndex, smoothingLength, smoothingType) : rawBearIndex


// ============= SQUEEZE DETECTION =============
indexDifference = math.abs(plotBullIndex - plotBearIndex)

// Calculate if the indices are converging (difference decreasing over time)
avgDifference = ta.sma(indexDifference, squeezeConvergencePeriod)
prevAvgDifference = ta.sma(indexDifference, squeezeConvergencePeriod)[1]
isConverging = avgDifference < prevAvgDifference

// ---------------------------------------------------------------
isSqueeze = adxValue < squeezeAdxThreshold and 
             indexDifference < squeezeConvergenceThreshold and 
             isConverging
// ============= COLOR SCHEMES =============
colorBull = useDynamicColors ? 
     (rsi > 80 ? color.new(color.fuchsia, 0) : 
      rsi > 55 ? color.new(color.teal, 0) : 
      color.new(color.lime, 0)) : color.new(color.green, 0)

colorBear = useDynamicColors ? 
     (rsiInverse > 75 ? color.new(color.navy, 20) : 
      rsiInverse > 50 ? color.new(color.red, 0) : 
      color.new(color.orange, 0)) : color.new(color.red, 0)

// Background colors based on ADX and squeeze
bgColor = 
     isSqueeze and showSqueeze ? color.new(color.yellow, 85) :
     adxValue < 15 ? color.new(color.teal, 85) :
     adxValue > adxThreshold ? color.new(color.blue, 90) :
     na
//------------------------------------------------ 
// Background
bgcolor(color = bgColor, title="Background Color")

// ============= ZONE LINES =============
hline(choppyLine, 'Choppy Line', color=color.new(color.red,40), linestyle=hline.style_solid, linewidth=3)


// ============= ADDITIONAL FEATURES =============
hline(adxThreshold, "ADX Threshold", color=color.new(color.purple, 30), linestyle=hline.style_dotted)
hline(squeezeAdxThreshold, "Squeeze ADX Threshold", color=color.new(color.orange, 10), linestyle=hline.style_dotted, editable = false)
//-------------------------------------------------------------------------------------------------------------------------------
// Input for strike interval
stepNumber = input.int(5, 'Step Number', minval = 1, display = display.none)
//-----------------------------------------------------------------------

// Function to round to the nearest strike
roundToNearestValue(price, stepNumber) =>
    math.round(price / stepNumber) * stepNumber

steppedBearIndex = roundToNearestValue(plotBearIndex, stepNumber)
steppedBullIndex = roundToNearestValue(plotBullIndex, stepNumber)

plot(steppedBearIndex, title="Bear Index", color=colorBear, linewidth=20,style = plot.style_columns, editable = false)
plot(steppedBullIndex, title="Bull Index", color=colorBull, linewidth=20, style = plot.style_columns, editable = false)
//----------------------------------------------------------------
// === Trend Finder Settings ===
enable_ema_50 = input(true, title="Enable EMA 50", group='EMA 50', inline="P")

//-----------------------------------------------------------
// EMA 50
EMA50 = ta.ema(close, 50)
ema_50_color = close[1] > EMA50 and close > EMA50 ? color.green : color.red
plot(enable_ema_50 ? EMA50 : na, title="EMA50", color=color.new(ema_50_color, 50), style=plot.style_cross, linewidth=1, force_overlay=true)
//==================================================================================================================
//  Smoothing FUNCTION 
// =======================================================================
superSmoother(src) =>
    a1 = math.exp(-1.414 * math.pi / 10.0)
    b1 = 2.0 * a1 * math.cos(1.414 * math.pi / 10.0)
    c2 = b1
    c3 = -a1 * a1
    c1 = 1.0 - c2 - c3

    var float filt = na
    filt := c1 * (src + nz(src[1])) / 2 + c2 * nz(filt[1]) + c3 * nz(filt[2])
    filt
    //---------------------------------------------------------------------------
offsetInput = input.int(1, 'Trend Offset', display = display.none)
maLength = input.int(10, title = 'MA Length', minval = 1, display = display.none)

// --- 1. Apply SuperSmoother ---
smoothPrice = superSmoother(close)
//-----------------------------------------------------------
c_up = input.color(#00b8a5, 'Up Color', group = 'Color Settings', inline = 'A')
c_dn = input.color(#b80090, 'Down Color', group = 'Color Settings', inline = 'A')

filtered_smoothPrice = ta.ema(smoothPrice, maLength)

// =======================================================================
isUp = filtered_smoothPrice > filtered_smoothPrice[offsetInput]
lineColor = isUp ? c_up : c_dn
bandColor = isUp ? color.new(c_up, 80) : color.new(c_dn, 80)
//----------------------------------------------------------------
plot(smoothPrice, force_overlay = true, color = color.new(color.black, 70), linewidth = 1)
plot(filtered_smoothPrice, color = color.new(lineColor, 70), linewidth = 2, force_overlay = true)
plot(filtered_smoothPrice, color = color.new(bandColor, 80), linewidth = 20, force_overlay = true)
