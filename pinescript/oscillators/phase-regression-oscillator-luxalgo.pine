// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© LuxAlgo

//@version=6
indicator("Phase Regression Oscillator [LuxAlgo]", "LuxAlgo - Phase Regression Oscillator", overlay = false, calc_bars_count = 5000)


//---------------------------------------------------------------------------------------------------------------------}
// Constants & Inputs
//---------------------------------------------------------------------------------------------------------------------{
color BULL_COLOR = #089981
color BEAR_COLOR = #f23645

int nInput          = input.int(20, "Window Size (N)", minval = 5, tooltip = "The lookback window size for the sine wave fit.")
float periodPctInput = input.float(100.0, "Period % of Window", minval = 5, maxval = 200, tooltip = "The fixed period P expressed as a percentage of the window size N.")


// OB/OS Levels
float obLevelInput  = input.float(0.8, "Overbought Level", minval = 0, step = 0.1, group = "Levels")
float osLevelInput  = input.float(-0.8, "Oversold Level", maxval = 0, step = 0.1, group = "Levels")

// Style Settings
color bullColorInput = input.color(BULL_COLOR, "Bullish Color", group = "Style")
color bearColorInput = input.color(BEAR_COLOR, "Bearish Color", group = "Style")
color cosColorInput  = input.color(#808080, "Cosine Color", group = "Style")
color zeroColorInput = input.color(#303030, "Zero Line Color", group = "Style")

//---------------------------------------------------------------------------------------------------------------------}
// User-Defined Functions
//---------------------------------------------------------------------------------------------------------------------{

// @function Manually calculates atan2(y, x)
atan2(float y, float x) =>
    float phi = 0.0
    if x > 0
        phi := math.atan(y / x)
    else if x < 0
        if y >= 0
            phi := math.atan(y / x) + math.pi
        else
            phi := math.atan(y / x) - math.pi
    else // x == 0
        if y > 0
            phi := math.pi / 2.0
        else if y < 0
            phi := -math.pi / 2.0
        else
            phi := na
    phi

// @function Solves a 3x3 system of linear equations using Cramer's rule
solve3x3(float a1, float b1, float c1, float d1, 
         float a2, float b2, float c2, float d2, 
         float a3, float b3, float c3, float d3) =>
    float det = a1 * (b2 * c3 - b3 * c2) - b1 * (a2 * c3 - a3 * c2) + c1 * (a2 * b3 - a3 * b2)
    if math.abs(det) < 1e-12
        [0.0, 0.0, 0.0]
    else
        float dx = d1 * (b2 * c3 - b3 * c2) - b1 * (d2 * c3 - d3 * c2) + c1 * (d2 * b3 - d3 * b2)
        float dy = a1 * (d2 * c3 - d3 * c2) - d1 * (a2 * c3 - a3 * c2) + c1 * (a2 * d3 - a3 * d2)
        float dz = a1 * (b2 * d3 - b3 * d2) - b1 * (a2 * d3 - a3 * d2) + d1 * (a2 * b3 - a3 * b2)
        [dx / det, dy / det, dz / det]

//---------------------------------------------------------------------------------------------------------------------}
// Core Calculations
//---------------------------------------------------------------------------------------------------------------------{

float osc    = 0.0
float oscCos = 0.0

if bar_index >= nInput
    // 1. Determine the fixed period P as a % of window N
    float P = nInput * (periodPctInput / 100.0)
    float omega = 2.0 * math.pi / P
    
    // 2. Setup Linear Least Squares for model: y = a*sin(wx) + b*cos(wx) + c
    float s_s   = 0.0, float s_c   = 0.0
    float s_ss  = 0.0, float s_cc  = 0.0, float s_sc  = 0.0
    float s_ys  = 0.0, float s_yc  = 0.0, float s_y   = 0.0
    
    for i = 0 to nInput - 1
        float val = close[i]
        float x   = -i
        float sn  = math.sin(omega * x)
        float cs  = math.cos(omega * x)
        
        s_s  += sn
        s_c  += cs
        s_ss += sn * sn
        s_cc += cs * cs
        s_sc += sn * cs
        s_y  += val
        s_ys += val * sn
        s_yc += val * cs
    
    // 3. Solve the Normal Equations
    [a, b, c] = solve3x3(s_ss, s_sc, s_s, s_ys, 
                         s_sc, s_cc, s_c, s_yc, 
                         s_s,  s_c,  float(nInput), s_y)
    
    // 4. Extract analytical phase phi at current bar (x=0)
    float phi = atan2(b, a)
    
    // Final components
    osc    := math.sin(phi)
    oscCos := math.cos(phi)

//---------------------------------------------------------------------------------------------------------------------}
// Visuals
//---------------------------------------------------------------------------------------------------------------------{

oscPlot    = plot(osc, "Sine Component", color.new(chart.fg_color, 100), 1, display = display.none)
oscCosPlot = plot(oscCos, "Cosine Component", cosColorInput, 1, plot.style_line, linestyle = plot.linestyle_dotted)

zeroPlot   = plot(0, "Zero Line", zeroColorInput, 1)

// Dynamic Color Sine Oscillator
oscColor = osc > 0 ? bullColorInput : bearColorInput
plot(osc, "Sine Oscillator", oscColor, 2)

// OB/OS Levels
hline(obLevelInput, "Overbought", color.new(bearColorInput, 60), hline.style_dashed)
hline(osLevelInput, "Oversold", color.new(bullColorInput, 60), hline.style_dashed)

// Vertical Gradient Fill
fill(oscPlot, zeroPlot, 
  top_value    = math.max(osc, 0), 
  bottom_value = math.min(osc, 0), 
  top_color    = osc > 0 ? color.new(bullColorInput, 50) : color.new(bearColorInput, 100), 
  bottom_color = osc > 0 ? color.new(bullColorInput, 100) : color.new(bearColorInput, 50), 
  title        = "Oscillator Fill")

//---------------------------------------------------------------------------------------------------------------------}
