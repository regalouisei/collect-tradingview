// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© PhenLabs


//   _____                     __                     __           
//  / ___/____  ___  ___  ____/ /___  ____ ___  ___  / /____  _____
//  \__ \/ __ \/ _ \/ _ \/ __  / __ \/ __ `__ \/ _ \/ __/ _ \/ ___/
// ___/ / /_/ /  __/  __/ /_/ / /_/ / / / / / /  __/ /_/  __/ /    
///____/ .___/\___/\___/\__,_/\____/_/ /_/ /_/\___/\__/\___/_/     
//    /_/                                                          
//                          @PhenLabs - VERSION ONE

//@version=6
indicator('Advanced Speedometer Gauge [PhenLabs]', shorttitle = 'ASG - PhenLabs', overlay = true)

// ============================================================================
// USER INPUTS
// ============================================================================

// Metric Selection
metric_select = input.string('RSI', 'Select Metric', options = ['RSI', 'Stochastic', 'Volume %', 'ATR Percentile', 'Momentum', 'MFI (Money Flow)', 'CCI (Commodity Channel)', 'Williams %R', 'Volatility Rank', 'Trend Strength', 'Choppiness Index', 'Volume Trend', 'Price Distance'])

// Metric Parameters
rsi_length = input.int(14, 'RSI Length', minval = 1, group = 'Metric Settings')
stoch_length = input.int(14, 'Stochastic Length', minval = 1, group = 'Metric Settings')
stoch_smooth = input.int(3, 'Stochastic Smooth', minval = 1, group = 'Metric Settings')
vol_length = input.int(20, 'Volume MA Length', minval = 1, group = 'Metric Settings')
atr_length = input.int(14, 'ATR Length', minval = 1, group = 'Metric Settings')
atr_lookback = input.int(100, 'ATR Percentile Lookback', minval = 20, group = 'Metric Settings')
mom_length = input.int(10, 'Momentum Length', minval = 1, group = 'Metric Settings')

// New Metric Parameters
mfi_length = input.int(14, 'MFI Length', minval = 1, group = 'Metric Settings')
cci_length = input.int(20, 'CCI Length', minval = 1, group = 'Metric Settings')
willr_length = input.int(14, 'Williams %R Length', minval = 1, group = 'Metric Settings')
vr_lookback = input.int(252, 'Volatility Rank Lookback (Days)', minval = 50, group = 'Metric Settings')
trend_length = input.int(20, 'Trend Strength Length', minval = 5, group = 'Metric Settings')
chop_length = input.int(14, 'Choppiness Index Length', minval = 5, group = 'Metric Settings')
vol_trend_length = input.int(20, 'Volume Trend Length', minval = 5, group = 'Metric Settings')
price_dist_length = input.int(50, 'Price Distance MA Length', minval = 10, group = 'Metric Settings')

// Visual Settings
table_position = input.string('Top Right', 'Position', options = ['Top Left', 'Top Right', 'Bottom Left', 'Bottom Right', 'Middle Right'], group = 'Visual Settings')
gauge_size = input.string('Normal', 'Size', options = ['Small', 'Normal', 'Large'], group = 'Visual Settings')

// Color Zones
green_color = input.color(#00FF00, 'Low Zone Color (0-40)', group = 'Colors')
yellow_color = input.color(#FFFF00, 'Medium Zone Color (40-70)', group = 'Colors')
red_color = input.color(#FF0000, 'High Zone Color (70-100)', group = 'Colors')
bg_color = input.color(color.new(#1a1a1a, 10), 'Background Color', group = 'Colors')
text_color = input.color(#FFFFFF, 'Text Color', group = 'Colors')

// ============================================================================
// METRIC CALCULATIONS & NORMALIZATION (0-100 SCALE)
// ============================================================================

// Calculate all metrics outside the conditional scope (fixes warnings)
rsi_value = ta.rsi(close, rsi_length)

stoch_k = ta.stoch(close, high, low, stoch_length)
stoch_value = ta.sma(stoch_k, stoch_smooth)

vol_avg = ta.sma(volume, vol_length)
vol_ratio = vol_avg != 0 ? volume / vol_avg * 100 : 0
vol_value = math.min(vol_ratio / 2, 100)

atr_current = ta.atr(atr_length)
atr_highest = ta.highest(atr_current, atr_lookback)
atr_lowest = ta.lowest(atr_current, atr_lookback)
atr_range = atr_highest - atr_lowest
atr_value = atr_range != 0 ? (atr_current - atr_lowest) / atr_range * 100 : 50

roc = mom_length > 0 ? (close - close[mom_length]) / close[mom_length] * 100 : 0
mom_value = math.max(0, math.min(100, roc + 50))

// ============================================================================
// NEW METRICS - DEEPLY INSIGHTFUL & NON-OVERLAPPING
// ============================================================================

// 1. MFI (Money Flow Index) - Volume-weighted RSI, measures buying/selling pressure
// Ranges 0-100, shows money flow strength (different from volume % which shows relative size)
mfi_value = ta.mfi(close, mfi_length)

// 2. CCI (Commodity Channel Index) - Measures deviation from statistical mean
// Normalized to 0-100 scale (typical range -200 to +200, scaled to 0-100)
cci_raw = ta.cci(close, cci_length)
cci_value = math.max(0, math.min(100, (cci_raw + 200) / 4))

// 3. Williams %R - Measures overbought/oversold on different scale than RSI
// Ranges -100 to 0, converted to 0-100 (inverted so 100 = overbought)
willr_raw = ta.wpr(willr_length)
willr_value = 100 + willr_raw // Convert -100,0 range to 0,100

// 4. Volatility Rank - Current volatility position within historical range
// Different from ATR Percentile: uses Close-to-Close volatility, longer lookback
close_to_close_vol = math.abs(close - close[1]) / close[1] * 100
vol_sma = ta.sma(close_to_close_vol, 10)
vol_highest = ta.highest(vol_sma, vr_lookback)
vol_lowest = ta.lowest(vol_sma, vr_lookback)
vol_rank_range = vol_highest - vol_lowest
vr_value = vol_rank_range != 0 ? (vol_sma - vol_lowest) / vol_rank_range * 100 : 50

// 5. Trend Strength (ADX-style) - Measures trend strength regardless of direction
// Uses directional movement to quantify trend intensity (0-100)
up_move = high - high[1]
down_move = low[1] - low
plus_dm = up_move > down_move and up_move > 0 ? up_move : 0
minus_dm = down_move > up_move and down_move > 0 ? down_move : 0
tr = math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))
plus_di = 100 * ta.sma(plus_dm, trend_length) / ta.sma(tr, trend_length)
minus_di = 100 * ta.sma(minus_dm, trend_length) / ta.sma(tr, trend_length)
dx = 100 * math.abs(plus_di - minus_di) / (plus_di + minus_di)
trend_strength_value = ta.sma(dx, trend_length)

// 6. Choppiness Index - Measures market choppiness vs trending (inverted from trend)
// 0 = strong trend, 100 = choppy/ranging market
atr_sum = math.sum(ta.atr(1), chop_length)
high_low_range = ta.highest(high, chop_length) - ta.lowest(low, chop_length)
chop_raw = high_low_range != 0 ? 100 * math.log10(atr_sum / high_low_range) / math.log10(chop_length) : 50
chop_value = math.max(0, math.min(100, chop_raw))

// 7. Volume Trend - Cumulative volume direction (different from volume %)
// Measures whether volume is flowing into up moves or down moves
vol_up = close > close[1] ? volume : 0
vol_down = close < close[1] ? volume : 0
vol_up_ma = ta.sma(vol_up, vol_trend_length)
vol_down_ma = ta.sma(vol_down, vol_trend_length)
vol_total = vol_up_ma + vol_down_ma
vol_trend_value = vol_total != 0 ? vol_up_ma / vol_total * 100 : 50

// 8. Price Distance from MA - Measures over-extension (different from momentum)
// Shows current deviation from mean as percentage (0 = at MA, 100 = far above/below)
price_ma = ta.sma(close, price_dist_length)
price_std = ta.stdev(close, price_dist_length)
price_distance = price_std != 0 ? math.abs(close - price_ma) / price_std : 0
// Normalize: 2 standard deviations or more = 100
price_dist_value = math.min(100, price_distance / 2 * 100)

// Select active metric
metric_value = switch metric_select
    'RSI' => rsi_value
    'Stochastic' => stoch_value
    'Volume %' => vol_value
    'ATR Percentile' => atr_value
    'Momentum' => mom_value
    'MFI (Money Flow)' => mfi_value
    'CCI (Commodity Channel)' => cci_value
    'Williams %R' => willr_value
    'Volatility Rank' => vr_value
    'Trend Strength' => trend_strength_value
    'Choppiness Index' => chop_value
    'Volume Trend' => vol_trend_value
    'Price Distance' => price_dist_value
    => 0

current_value = na(metric_value) ? 0 : metric_value

// ============================================================================
// TABLE POSITIONING
// ============================================================================

table_pos = switch table_position
    'Top Left' => position.top_left
    'Top Right' => position.top_right
    'Bottom Left' => position.bottom_left
    'Bottom Right' => position.bottom_right
    'Middle Right' => position.middle_right
    => position.top_right

// ============================================================================
// SIZE CONFIGURATION
// ============================================================================

cell_size = switch gauge_size
    'Small' => size.small
    'Normal' => size.normal
    'Large' => size.large
    => size.normal

text_size = switch gauge_size
    'Small' => size.small
    'Normal' => size.normal
    'Large' => size.large
    => size.normal

// Gauge visual parameters
arc_segments = 21 // Odd number for center point

// ============================================================================
// CREATE TABLE
// ============================================================================

var table gauge_table = table.new(table_pos, columns = arc_segments, rows = 8, border_width = 1, border_color = color.new(text_color, 70))

if barstate.islast

    // Clear table
    table.clear(gauge_table, 0, 0, arc_segments - 1, 7)

// ========================================================================
// ROW 0: TITLE
// ========================================================================

    table.merge_cells(gauge_table, 0, 0, arc_segments - 1, 0)
    table.cell(gauge_table, 0, 0, 'ð“„€ PhenLabs ' + metric_select, bgcolor = bg_color, text_color = text_color, text_size = text_size, text_font_family = font.family_monospace)

// ========================================================================
// ROW 1: CURRENT VALUE (LARGE)
// ========================================================================

    table.merge_cells(gauge_table, 0, 1, arc_segments - 1, 1)
    value_text = str.tostring(current_value, '#.##')
    table.cell(gauge_table, 0, 1, value_text, bgcolor = bg_color, text_color = text_color, text_size = gauge_size == 'Small' ? size.normal : size.large, text_font_family = font.family_monospace)

// ========================================================================
// ROW 2: SPACING
// ========================================================================

    table.merge_cells(gauge_table, 0, 2, arc_segments - 1, 2)
    table.cell(gauge_table, 0, 2, '', bgcolor = bg_color, height = 0.3)

// ========================================================================
// ROW 3-4: SEMI-CIRCULAR ARC (2 rows for thickness)
// ========================================================================

    for row = 3 to 4 by 1
        for col = 0 to arc_segments - 1 by 1
            // Calculate position along arc (0 = left/green, 1 = right/red)
            progress = col / (arc_segments - 1)
            value_pct = progress * 100

            // Calculate if this cell should be part of the arc
            // Create semi-circle shape: middle columns are "higher" (earlier rows)
            center_col = (arc_segments - 1) / 2.0
            distance_from_center = math.abs(col - center_col) / center_col

            // Semi-circle formula: cells closer to center appear in earlier rows
            // This creates the curved appearance
            show_in_row = distance_from_center > 0.4 ? 3 : 4

            if row >= show_in_row
                // Determine color based on value percentage
                cell_color = value_pct < 40 ? green_color : value_pct < 70 ? yellow_color : red_color

                table.cell(gauge_table, col, row, 'â–ˆ', bgcolor = color.new(bg_color, 50), text_color = cell_color, text_size = text_size)
            else
                table.cell(gauge_table, col, row, '', bgcolor = color.new(bg_color, 90))

// ========================================================================
// ROW 5: NEEDLE INDICATOR
// ========================================================================

    // Calculate needle position (0-100 maps to columns 0 to arc_segments-1)
    needle_col = int(current_value / 100 * (arc_segments - 1))
    needle_col := math.max(0, math.min(arc_segments - 1, needle_col))

    for col = 0 to arc_segments - 1 by 1
        if col == needle_col
            table.cell(gauge_table, col, 5, 'â–¼', bgcolor = color.new(bg_color, 90), text_color = text_color, text_size = text_size)
        else
            table.cell(gauge_table, col, 5, '', bgcolor = color.new(bg_color, 90))

// ========================================================================
// ROW 6: SCALE MARKERS
// ========================================================================

    for col = 0 to arc_segments - 1 by 1
        progress = col / (arc_segments - 1)
        value_at_col = progress * 100

        // Show scale at 0, 25, 50, 75, 100
        show_scale = value_at_col < 2 or value_at_col > 23 and value_at_col < 27 or value_at_col > 48 and value_at_col < 52 or value_at_col > 73 and value_at_col < 77 or value_at_col > 98

        if show_scale
            table.cell(gauge_table, col, 6, '|', bgcolor = color.new(bg_color, 90), text_color = color.new(text_color, 40), text_size = size.tiny)
        else
            table.cell(gauge_table, col, 6, '', bgcolor = color.new(bg_color, 90))

// ========================================================================
// ROW 7: SCALE LABELS
// ========================================================================

    // Position labels at specific columns
    label_positions = array.from(0, 5, 10, 15, 20) // Columns for 0, 25, 50, 75, 100
    label_values = array.from('0', '25', '50', '75', '100')

    for col = 0 to arc_segments - 1 by 1
        label_text = ''

        // Check if this column should have a label
        for i = 0 to 4 by 1
            label_col = array.get(label_positions, i)
            if col == label_col
                label_text := array.get(label_values, i)
                label_text

        table.cell(gauge_table, col, 7, label_text, bgcolor = color.new(bg_color, 90), text_color = color.new(text_color, 40), text_size = size.tiny)
