//@version=6
indicator(title = 'WT Cross Modifiziert – Step Buy Step Edition (v4)', shorttitle = 'WTC_StepBuyStep_Edition 2', overlay = false)

// === Inputs (WT) ===
n1 = input(10, 'Channel Length')
n2 = input(21, 'Average Length')
obLevel1 = input(60, 'Over Bought Level 1')
obLevel2 = input(53, 'Over Bought Level 2')
osLevel1 = input(-60, 'Over Sold Level 1')
osLevel2 = input(-53, 'Over Sold Level 2')

// === WaveTrend (v4) ===
ap = hlc3
esa = ta.ema(ap, n1)
d = ta.ema(math.abs(ap - esa), n1)
ci = (ap - esa) / (0.015 * d)
tci = ta.ema(ci, n2)

wt1 = tci
wt2 = ta.sma(wt1, 4)

// === Level-Linien (WT) ===
plot(0, color = color.new(color.gray, 0))
plot(obLevel1, title = 'OB Level 1', color = color.new(color.red, 0))
plot(obLevel2, title = 'OB Level 2', color = color.new(color.orange, 0))
plot(osLevel1, title = 'OS Level 1', color = color.new(color.green, 0))
plot(osLevel2, title = 'OS Level 2', color = color.new(color.blue, 0))

// === WT Plots ===
plot(wt1, title = 'WT1', color = color.new(color.yellow, 0), linewidth = 2)
plot(wt2, title = 'WT2', color = color.new(color.purple, 0), linewidth = 2)
plot(wt1 - wt2, title = 'WT1-WT2', color = color.new(color.blue, 85), style = plot.style_area)

// === Cross-Signale ===
crossUp = ta.crossover(wt1, wt2)
crossDown = ta.crossunder(wt1, wt2)
crossAny = crossUp or crossDown

plot(series = crossAny ? wt2 : na, title = 'Cross Marker Outer', style = plot.style_circles, linewidth = 3, color = color.new(color.black, 0))
plot(series = crossAny ? wt2 : na, title = 'Cross Marker Inner', style = plot.style_circles, linewidth = 2, color = crossUp ? color.lime : color.red)

// ======================================================================
// ==============   WT SignalZone (LonLev / ShoLev Panel)   ==============
// ======================================================================

// --- Benutzer-Option: Basis der Levels ---
sbs_levelMode = input.string(defval = 'Pullback 50%', title = 'Level-Basis', options = ['Pullback 50%', 'Close', 'Nächstes Open'])

// 1) Signaldefinition (robust wie im WT Treffer-Finder)
sbs_longSig = crossUp and wt1 < osLevel2
sbs_shortSig = crossDown and wt1 > obLevel2

// 2) Referenz-Level je Signal
sbs_sigMid() =>
    (high + low) / 2.0

// 3) Letzte 3 Levels je Richtung (v4-konform einzeln deklariert)
var float sbs_lon0 = na
var float sbs_lon1 = na
var float sbs_lon2 = na
var float sbs_sho0 = na
var float sbs_sho1 = na
var float sbs_sho2 = na

// --- Pending-Mechanik für "Nächstes Open"
var bool sbs_waitLong = false
var bool sbs_waitShort = false
var int sbs_waitLongBar = na
var int sbs_waitShortBar = na

// ---------------- Signal-Verarbeitung ----------------

// LONG-Signal auf bestätigter Bar
if barstate.isconfirmed and sbs_longSig
    if sbs_levelMode == 'Nächstes Open'
        sbs_waitLong := true
        sbs_waitLongBar := bar_index
        sbs_waitLongBar
    else
        _valLong = sbs_levelMode == 'Close' ? close : sbs_sigMid()
        sbs_lon2 := sbs_lon1
        sbs_lon1 := sbs_lon0
        sbs_lon0 := _valLong
        sbs_lon0

// SHORT-Signal auf bestätigter Bar
if barstate.isconfirmed and sbs_shortSig
    if sbs_levelMode == 'Nächstes Open'
        sbs_waitShort := true
        sbs_waitShortBar := bar_index
        sbs_waitShortBar
    else
        _valShort = sbs_levelMode == 'Close' ? close : sbs_sigMid()
        sbs_sho2 := sbs_sho1
        sbs_sho1 := sbs_sho0
        sbs_sho0 := _valShort
        sbs_sho0

// Pending-Entries am Folgebalken eintragen
if sbs_levelMode == 'Nächstes Open'
    if sbs_waitLong and bar_index == sbs_waitLongBar + 1
        sbs_lon2 := sbs_lon1
        sbs_lon1 := sbs_lon0
        sbs_lon0 := open
        sbs_waitLong := false
        sbs_waitLong
    if sbs_waitShort and bar_index == sbs_waitShortBar + 1
        sbs_sho2 := sbs_sho1
        sbs_sho1 := sbs_sho0
        sbs_sho0 := open
        sbs_waitShort := false
        sbs_waitShort

// 4) Kompakte Anzeige oben rechts (skalenunabhängig via table)
var table sbs_levT = table.new(position.top_right, 1, 3, border_width = 1, frame_color = color.new(color.white, 70))

// --- v4-kompatible Format-Funktion ---
sbs_fmt3(a0, a1, a2) =>
    _out = '—'
    if not na(a0)
        if na(a1)
            _out := str.tostring(a0)
            _out
        else if na(a2)
            _out := str.tostring(a0) + ' | ' + str.tostring(a1)
            _out
        else
            _out := str.tostring(a0) + ' | ' + str.tostring(a1) + ' | ' + str.tostring(a2)
            _out
    _out

// Panel aktualisieren (klein, nicht störend)
if barstate.islast
    table.cell(sbs_levT, 0, 0, 'WT SignalZone (' + str.tostring(timeframe.period) + ')', text_color = color.white, bgcolor = color.new(color.black, 0))
    table.cell(sbs_levT, 0, 1, 'LonLev: ' + sbs_fmt3(sbs_lon0, sbs_lon1, sbs_lon2), text_color = color.lime, bgcolor = color.new(#363a45, 0))
    table.cell(sbs_levT, 0, 2, 'ShoLev: ' + sbs_fmt3(sbs_sho0, sbs_sho1, sbs_sho2), text_color = color.red, bgcolor = color.new(color.black, 0))
