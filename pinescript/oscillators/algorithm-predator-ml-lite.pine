//@version=5
indicator("Algorithm Predator - ML-lite", shorttitle="ğŸ¯-AP-ML", overlay=true, 
     max_lines_count=500, max_labels_count=100, max_boxes_count=500, max_bars_back=500)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ MASTER CONTROLS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
mode = input.string("Balanced", "Trading Mode", options=["Conservative", "Balanced", "Aggressive", "Elite", "Adaptive"], group="âš™ï¸ Core Settings", tooltip='ğŸ¯ WHAT IT IS: Pre-configured parameter sets optimizing for different trading styles.\n\nâš¡ MODE CHARACTERISTICS:\n\nğŸ›¡ï¸ CONSERVATIVE: 4-bar confirmation, 15-bar cooldown, 85% consensus\nâ€¢ Best for: Swing trading, new users\nâ€¢ Expected: 60-70% win rate, 3-8 signals/week\n\nâš–ï¸ BALANCED: 3-bar confirmation, 10-bar cooldown, 70% consensus\nâ€¢ Best for: Day trading, most traders\nâ€¢ Expected: 55-65% win rate, 8-15 signals/week\n\nâš¡ AGGRESSIVE: 2-bar confirmation, 5-bar cooldown, 60% consensus\nâ€¢ Best for: Scalping, high-frequency\nâ€¢ Expected: 50-58% win rate, 15-30 signals/week\n\nğŸ’¡ PRO TIP: Start with Balanced. Move to Conservative if too many false signals.')
i_consensus = mode == "Conservative" ? 85 : mode == "Balanced" ? 70 : mode == "Aggressive" ? 60 : mode == "Elite" ? 75 : 65
i_cooldown = mode == "Conservative" ? 15 : mode == "Balanced" ? 10 : mode == "Aggressive" ? 5 : mode == "Elite" ? 12 : 8
i_confirmation = mode == "Conservative" ? 4 : mode == "Balanced" ? 3 : mode == "Aggressive" ? 2 : mode == "Elite" ? 3 : 2
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ AGENT SENSITIVITY
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
i_spoof = input.float(1.0, "ğŸ­ Spoofing Detector", minval=0.5, maxval=2.0, step=0.1, group="ğŸ¯ Agent Tuning", tooltip='Detection threshold for institutional order manipulation and iceberg patterns.\n\nâ€¢ 0.5-0.8: Highly selective\nâ€¢ 0.9-1.2: Balanced\nâ€¢ 1.3-2.0: Aggressive\n\nğŸ’¡ Increase if agent has >65% win rate but low triggers.')
i_momentum = input.float(1.0, "âš¡ Exhaustion Detector", minval=0.5, maxval=2.0, step=0.1, group="ğŸ¯ Agent Tuning", tooltip='Detection threshold for momentum failure and trend exhaustion.\n\nâ€¢ 0.5-0.8: Conservative\nâ€¢ 0.9-1.2: Balanced\nâ€¢ 1.3-2.0: Aggressive\n\nğŸ’¡ Best in trending markets reaching climax.')
i_liquidity = input.float(1.0, "ğŸ’§ Liquidity Void Detector", minval=0.5, maxval=2.0, step=0.1, group="ğŸ¯ Agent Tuning", tooltip='Detection threshold for thin liquidity zones and stop hunts.\n\nâ€¢ 0.5-0.8: Conservative\nâ€¢ 0.9-1.2: Balanced\nâ€¢ 1.3-2.0: Aggressive\n\nğŸ’¡ Excellent for range-bound pre-breakout setups.')
i_statarb = input.float(1.0, "ğŸ“Š Mean Reversion", minval=0.5, maxval=2.0, step=0.1, group="ğŸ¯ Agent Tuning", tooltip='Detection threshold for statistical mean-reversion.\n\nâ€¢ 0.5-0.8: Conservative (>2Ïƒ only)\nâ€¢ 0.9-1.2: Balanced\nâ€¢ 1.3-2.0: Aggressive\n\nğŸ’¡ Dominant in range-bound, low-volatility markets.')
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– ADAPTIVE MULTI-ARMED BANDIT SYSTEM
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
auto_enable = input.bool(true, "ğŸ¤– Enable Adaptive Learning", group="ğŸ¤– Bandit System", tooltip='Activates multi-armed bandit for automatic agent selection.\n\nLearns which agents perform best and adapts automatically.\n\nğŸ’¡ Enable after observing 20-30 signals in manual mode.')
auto_mode = input.string("Blend", "Selection Mode", options=["Switch","Blend"], group="ğŸ¤– Bandit System", tooltip='SWITCH: Uses ONE best agent\nBLEND: Weighted combination of all agents\n\nğŸ’¡ Start with Blend (more stable).')
lock_agent = input.bool(false, "ğŸ”’ Lock Agent Selection", group="ğŸ¤– Bandit System", tooltip='Disables dynamic switchingâ€”forces one specific agent.\n\nOnly applies in Switch mode.\n\nğŸ’¡ Use after identifying which agent dominates your instrument.')
locked_agent_choice = input.string("Spoofing Detector", "Locked Agent", options=["Spoofing Detector", "Exhaustion Detector", "Liquidity Void", "Mean Reversion"], group="ğŸ¤– Bandit System", tooltip='Which agent to use when locked.\n\nğŸ­ Spoofing: Consolidations, institutional windows\nâš¡ Exhaustion: Trend climax reversals\nğŸ’§ Liquidity: Range-bound, pre-breakout\nğŸ“Š Mean Reversion: Low volatility, algo-heavy')
auto_algorithm = input.string("Thompson Sampling", "Learning Algorithm", options=["UCB1", "Thompson Sampling", "Epsilon-Greedy", "Gradient"], group="ğŸ¤– Bandit System", tooltip='âš ï¸ LITE VERSION: Approximated Thompson Sampling (pseudo-random via price noise)\n\nThompson: Best all-around (recommended)\nUCB1: Deterministic, stable\nEpsilon: Simple, tune exploration rate\nGradient: Best for Blend mode')
auto_epsilon = input.float(0.1, "Epsilon (Exploration)", minval=0.01, maxval=0.5, step=0.01, group="ğŸ¤– Bandit System", tooltip='For Epsilon-Greedy: probability of random exploration.\n\nâ€¢ 0.10: Standard\nâ€¢ 0.25: High exploration (volatile markets)\n\nğŸ’¡ Increase if regime changes and system slow to adapt.')
auto_temperature = input.float(0.5, "Blend Temperature", minval=0.1, maxval=2.0, step=0.1, group="ğŸ¤– Bandit System", tooltip='Controls blending smoothness.\n\nâ€¢ 0.3: Sharp (best agent dominates)\nâ€¢ 0.5: Balanced\nâ€¢ 1.0: Smooth (equal weighting)\n\nğŸ’¡ Lower in trending markets, raise in choppy conditions.')
auto_decay = input.float(0.95, "Memory Decay", minval=0.8, maxval=0.99, step=0.01, group="ğŸ¤– Bandit System", tooltip='How fast to forget old performance.\n\nâ€¢ 0.90: Fast adaptation\nâ€¢ 0.95: Balanced\nâ€¢ 0.97: Long memory\n\nğŸ’¡ Keep at 0.95 for most instruments.')
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š MARKET MICROSTRUCTURE ANALYSIS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
microstructure_enabled = input.bool(true, "ğŸ“Š Enable Microstructure Metrics", group="ğŸ“Š Order Flow Analysis", tooltip='âš ï¸ LITE VERSION: Simplified approximations\n\nPro version includes true VPIN, Kyle Lambda, Hawkes Process.\n\nDetects institutional activity and informed trading.\n\nğŸ’¡ Keep enabled for liquid instruments (>100k volume).')
i_use_vpin = input.bool(true, "Order Flow Toxicity", group="ğŸ“Š Order Flow Analysis", tooltip='âš ï¸ SIMPLIFIED VPIN approximation\n\nMeasures informed vs uninformed trading.\n\n>0.4 = toxic (informed traders active)\n<0.4 = safe (balanced flow)')
i_use_kyle = input.bool(true, "Price Impact Analysis", group="ğŸ“Š Order Flow Analysis", tooltip='âš ï¸ SIMPLIFIED Kyle Lambda approximation\n\nMeasures price impact efficiency.\n\nLow = institutional absorption\nHigh = retail-dominated')
i_use_entropy = input.bool(true, "Market Randomness", group="ğŸ“Š Order Flow Analysis", tooltip='Detects algorithmic trading patterns.\n\n>0.6 = human-driven (chaotic)\n<0.25 = algo-dominated (predictable)')
i_use_hawkes = input.bool(true, "Order Clustering", group="ğŸ“Š Order Flow Analysis", tooltip='âš ï¸ SIMPLIFIED Hawkes-inspired clustering\n\nDetects coordinated order activity.\n\n>0.7 = clustering active (spoofing/accumulation)')
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  DUAL MEMORY ARCHITECTURE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
memory_enabled = input.bool(true, "ğŸ§  Enable Memory System", group="ğŸ§  Memory", tooltip='Dual-layer memory: short-term (recent results) + long-term (historical patterns).\n\nğŸ’¡ Keep enabled for adaptive learning.')
short_memory_size = input.int(20, "Short-Term Size", minval=10, maxval=50, group="ğŸ§  Memory", tooltip='Recent results stored per agent.\n\n20 = balanced (10-20 trades/episode)')
long_memory_size = input.int(100, "Long-Term Size", minval=50, maxval=200, group="ğŸ§  Memory", tooltip='Episode averages preserved.\n\n100 = captures multiple regime cycles')
memory_transfer_threshold = input.int(10, "Transfer Threshold", minval=5, maxval=20, group="ğŸ§  Memory", tooltip='Results before averaging to long-term.\n\n10 = statistical significance')
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¾ MEMORY RESTORE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
restore_memory = input.bool(false, "ğŸ“¥ Restore From Memory", group="ğŸ’¾ Memory Restore", tooltip='Loads previously learned parameters.\n\nOptional: System learns fine from scratch.')
a1_saved_alpha = input.float(1.0, "A1: Î±", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a1")
a1_saved_beta = input.float(1.0, "Î²", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a1")
a1_saved_weight = input.float(0.25, "w", minval=-2, maxval=2, group="ğŸ’¾ Memory Restore", inline="a1")
a2_saved_alpha = input.float(1.0, "A2: Î±", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a2")
a2_saved_beta = input.float(1.0, "Î²", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a2")
a2_saved_weight = input.float(0.25, "w", minval=-2, maxval=2, group="ğŸ’¾ Memory Restore", inline="a2")
a3_saved_alpha = input.float(1.0, "A3: Î±", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a3")
a3_saved_beta = input.float(1.0, "Î²", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a3")
a3_saved_weight = input.float(0.25, "w", minval=-2, maxval=2, group="ğŸ’¾ Memory Restore", inline="a3")
a4_saved_alpha = input.float(1.0, "A4: Î±", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a4")
a4_saved_beta = input.float(1.0, "Î²", minval=0.1, maxval=10, group="ğŸ’¾ Memory Restore", inline="a4")
a4_saved_weight = input.float(0.25, "w", minval=-2, maxval=2, group="ğŸ’¾ Memory Restore", inline="a4")
microstructure_saved_vpin = input.float(1.5, "VPIN Sens", minval=0.5, maxval=3.0, group="ğŸ’¾ Memory Restore")
microstructure_saved_kyle = input.float(0.5, "Kyle Thresh", minval=0.1, maxval=1.0, group="ğŸ’¾ Memory Restore")
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ VISUAL CONTROLS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
i_show_zones = input.bool(true, "Kill Zones", group="ğŸ¨ Visuals", inline="v1")
i_show_spectral = input.bool(true, "Spectral", group="ğŸ¨ Visuals", inline="v1")
i_show_energy = input.bool(true, "Energy", group="ğŸ¨ Visuals", inline="v1")
i_show_nodes = input.bool(true, "Nodes", group="ğŸ¨ Visuals", inline="v2")
i_show_cones = input.bool(true, "Cones", group="ğŸ¨ Visuals", inline="v2")
i_show_connections = input.bool(true, "Connections", group="ğŸ¨ Visuals", inline="v2")
i_show_dashboard = input.bool(true, "Dashboard", group="ğŸ¨ Visuals", inline="v3")
i_show_memory = input.bool(true, "Memory Panel", group="ğŸ¨ Visuals", inline="v3")
i_glow_intensity = input.int(3, "Glow", minval=1, maxval=5, group="ğŸ¨ Visuals", inline="v4")
i_opacity = input.int(85, "Opacity", minval=40, maxval=95, group="ğŸ¨ Visuals", inline="v4")
dash_position = input.string("top_right", "Dashboard Position",  options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group="ğŸ“Š Dashboard Layout")
dash_size = input.string("normal", "Dashboard Size", options=["tiny", "small", "normal", "large"], group="ğŸ“Š Dashboard Layout")
memory_position = input.string("bottom_right", "Memory Position",  options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group="ğŸ“Š Dashboard Layout")
memory_size = input.string("small", "Memory Size", options=["tiny", "small", "normal", "large"], group="ğŸ“Š Dashboard Layout")
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ ADVANCED THEME ENGINE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
theme = input.string("Neon", "Visual Theme", options=["Dark", "Neon", "Light", "Cyber"], group="ğŸ¨ Theme", 
     tooltip='ğŸ¯ WHAT IT IS: Color scheme optimizing visual clarity for different trading environments.\n\nâš¡ THEME GUIDE:\nâ€¢ NEON: High-contrast cyan/magenta (best for crypto, high-volatility)\nâ€¢ CYBER: Matrix-style green/pink (algo-heavy markets)\nâ€¢ DARK: Professional gray/green/red (traditional stocks/forex)\nâ€¢ LIGHT: Clean pastels (lower-volatility instruments)\n\nğŸ’¡ PRO TIP: Match theme to instrument volatility. Neon for crypto, Dark for forex, Light for stocks.')
cBull = theme == "Neon" ? #00F5FF : theme == "Cyber" ? #00FF41 : theme == "Light" ? #00C853 : #00E676
cBear = theme == "Neon" ? #FF00FF : theme == "Cyber" ? #FF0080 : theme == "Light" ? #FF1744 : #FF4081
cNeut = theme == "Neon" ? #FFD700 : theme == "Cyber" ? #FFFF00 : theme == "Light" ? #FFC107 : #FFEB3B
cAccent = theme == "Neon" ? #FF0080 : theme == "Cyber" ? #00FFFF : theme == "Light" ? #9C27B0 : #E040FB
cInfo = theme == "Neon" ? #00BCD4 : theme == "Cyber" ? #39FF14 : theme == "Light" ? #00ACC1 : #26C6DA
cPanel = theme == "Light" ? color.new(#F5F7FB, 10) : theme == "Cyber" ? color.new(#000000, 15) : theme == "Neon" ? color.new(#05122B, 10) : color.new(#1A1A1A, 20)
cText = theme == "Light" ? color.black : color.white
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š CORE CALCULATIONS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
atr = ta.atr(14)
atr_avg = ta.sma(atr, 50)
vol_avg = ta.sma(volume, 20)
rsi = ta.rsi(close, 14)
[bb_upper, bb_mid, bb_lower] = ta.bb(close, 20, 2)
ema8 = ta.ema(close, 8)
ema21 = ta.ema(close, 21)
ema50 = ta.ema(close, 50)
ema200 = ta.ema(close, 200)
sma_20 = ta.sma(close, 20)
sma_50 = ta.sma(close, 50)
stdev_50 = ta.stdev(close, 50)
bar_range = high - low
volume_ratio = volume / math.max(vol_avg, 1)
volatility_ratio = atr / math.max(atr_avg, 1)
delta_sum = math.sum(close - open, 5)
vwap_val = ta.vwap(hlc3)
vwap_stdev = ta.stdev(hlc3, 20)
vwap_upper = vwap_val + vwap_stdev * 2
vwap_lower = vwap_val - vwap_stdev * 2
hour_val = hour(time)
minute_val = minute(time)
institutional_window = (hour_val == 9 and minute_val >= 30) or (hour_val == 10 and minute_val < 30) or 
                       (hour_val >= 3 and hour_val < 5)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š MARKET MICROSTRUCTURE METRICS (LITE APPROXIMATIONS)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var float adaptive_vpin_sensitivity = restore_memory ? microstructure_saved_vpin : 1.5
var float adaptive_kyle_threshold = restore_memory ? microstructure_saved_kyle : 0.5
f_calculate_vpin() =>
    buy_vol = 0.0
    sell_vol = 0.0
    for i = 0 to 19
        if close[i] > open[i]
            buy_vol += volume[i]
        else
            sell_vol += volume[i]
    math.abs(buy_vol - sell_vol) / (buy_vol + sell_vol + 1e-10)
vpin_score = microstructure_enabled and i_use_vpin ? f_calculate_vpin() : 0
vpin_ma = ta.sma(vpin_score, 20)
toxic_flow = vpin_score > vpin_ma * adaptive_vpin_sensitivity
kyle_lambda = microstructure_enabled and i_use_kyle ? 
              math.abs(close - close[10]) / math.sqrt(math.sum(volume, 10)) : 0
kyle_ma = ta.sma(kyle_lambda, 50)
institutional_impact = kyle_lambda < kyle_ma * adaptive_kyle_threshold
f_price_entropy() =>
    changes = 0.0
    for i = 1 to 20
        if close[i] != close[i-1]
            changes += 1
    changes / 20
price_entropy = microstructure_enabled and i_use_entropy ? f_price_entropy() : 3.0
algo_trading = price_entropy < 0.25
var float hawkes_intensity = 0.0
if microstructure_enabled and i_use_hawkes
    is_event = volume > vol_avg * 1.5
    if is_event
        hawkes_intensity := hawkes_intensity * 0.9 + 1.0
    else
        hawkes_intensity := hawkes_intensity * 0.9
order_clustering = hawkes_intensity > 0.7
trend_score = 0
trend_score += close > ema8 ? 1 : -1
trend_score += ema8 > ema21 ? 1 : -1
trend_score += ema21 > ema50 ? 1 : -1
trend_score += close > ema200 ? 1 : -1
regime = trend_score >= 3 ? "ğŸŸ¢ STRONG BULL" : 
         trend_score <= -3 ? "ğŸ”´ STRONG BEAR" : 
         trend_score > 0 ? "ğŸŸ¡ WEAK BULL" : "ğŸŸ  WEAK BEAR"
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  MEMORY STRUCTURES
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var float[] agent_alpha = restore_memory ? array.from(a1_saved_alpha, a2_saved_alpha, a3_saved_alpha, a4_saved_alpha) : array.new_float(4, 1.0)
var float[] agent_beta = restore_memory ? array.from(a1_saved_beta, a2_saved_beta, a3_saved_beta, a4_saved_beta) : array.new_float(4, 1.0)
var float[] agent_weights = restore_memory ? array.from(a1_saved_weight, a2_saved_weight, a3_saved_weight, a4_saved_weight) : array.new_float(4, 0.25)
var float[] agent_rewards = array.new_float(4, 0.5)
var int[] agent_pulls = array.new_int(4, 1)
var int[] agent_win_count = array.new_int(4, 0)
var int[] agent_loss_count = array.new_int(4, 0)
var array<float> short_bin_0 = array.new_float(0)
var array<float> short_bin_1 = array.new_float(0)
var array<float> short_bin_2 = array.new_float(0)
var array<float> short_bin_3 = array.new_float(0)
var array<float> long_bin_0 = array.new_float(0)
var array<float> long_bin_1 = array.new_float(0)
var array<float> long_bin_2 = array.new_float(0)
var array<float> long_bin_3 = array.new_float(0)
var int[] memory_episode_length = array.new_int(4, 0)
var int last_active_agent = -1
var int current_active_agent = -1
var int total_signals = 0
var float pending_entry_price = na
var int pending_signal_direction = 0
var int pending_signal_bar = -999
var int pending_agent = -1
var int performance_horizon = 8
var string[] agent_names = array.from("ğŸ­ Spoofing", "âš¡ Exhaustion", "ğŸ’§ Liquidity", "ğŸ“Š MeanRev")
var int[] agent_triggers = array.new_int(4, 0)
var float[] agent_last_conf = array.new_float(4, 0.0)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ MEMORY FUNCTIONS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_get_short_bin(agent_idx) =>
    agent_idx == 0 ? short_bin_0 : agent_idx == 1 ? short_bin_1 : agent_idx == 2 ? short_bin_2 : short_bin_3
f_get_long_bin(agent_idx) =>
    agent_idx == 0 ? long_bin_0 : agent_idx == 1 ? long_bin_1 : agent_idx == 2 ? long_bin_2 : long_bin_3
f_store_short_memory(agent_idx, value) =>
    if memory_enabled and agent_idx >= 0 and agent_idx < 4
        bin = f_get_short_bin(agent_idx)
        if array.size(bin) >= short_memory_size
            array.shift(bin)
        array.push(bin, value)
        array.set(memory_episode_length, agent_idx, 
                  array.get(memory_episode_length, agent_idx) + 1)
f_transfer_memory(agent_idx) =>
    if memory_enabled and agent_idx >= 0 and agent_idx < 4
        short_bin = f_get_short_bin(agent_idx)
        long_bin = f_get_long_bin(agent_idx)      
        if array.size(short_bin) > 0
            episode_avg = array.avg(short_bin)
            if array.size(long_bin) >= long_memory_size
                array.shift(long_bin)
            array.push(long_bin, episode_avg)
            array.clear(short_bin)
            array.set(memory_episode_length, agent_idx, 0)
f_retrieve_memory(agent_idx) =>
    memory_boost = 1.0
    if memory_enabled and agent_idx >= 0 and agent_idx < 4
        short_bin = f_get_short_bin(agent_idx)
        long_bin = f_get_long_bin(agent_idx)       
        short_avg = array.size(short_bin) > 0 ? array.avg(short_bin) : 0
        long_avg = array.size(long_bin) > 0 ? array.avg(long_bin) : 0        
        memory_signal = short_avg * 0.7 + long_avg * 0.3
        memory_boost := 1.0 + memory_signal * 0.2
    memory_boost
f_get_short_bin_size(agent_idx) =>
    bin = f_get_short_bin(agent_idx)
    array.size(bin)
f_get_long_bin_size(agent_idx) =>
    bin = f_get_long_bin(agent_idx)
    array.size(bin)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ² BANDIT ALGORITHMS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_select_ucb(pulls, rewards, n) =>
    best_idx = 0
    best_score = -1e10
    total_pulls = array.sum(pulls)   
    for i = 0 to n - 1
        pull_count = array.get(pulls, i)
        if pull_count == 0
            best_idx := i
            break        
        avg_reward = array.get(rewards, i) / pull_count
        exploration = math.sqrt(2 * math.log(total_pulls) / pull_count)
        ucb_score = avg_reward + exploration        
        if ucb_score > best_score
            best_score := ucb_score
            best_idx := i
    best_idx
f_select_thompson(alpha, beta, n) =>
    best_idx = 0
    best_sample = -1.0    
    for i = 0 to n - 1
        a = array.get(alpha, i)
        b = array.get(beta, i)
        noise = (close * 100 - math.floor(close * 100)) + (volume - math.floor(volume / 100) * 100) / 100
        sample = a / (a + b) + noise * 0.1 * math.sqrt(1 / (a + b))        
        if sample > best_sample
            best_sample := sample
            best_idx := i
    best_idx
f_select_epsilon(rewards, pulls, n, epsilon) =>
    explore = (close * 1000 - math.floor(close * 1000)) < epsilon    
    if explore
        int(bar_index % n)
    else
        best_idx = 0
        best_avg = -1.0
        for i = 0 to n - 1
            pull_count = array.get(pulls, i)
            if pull_count > 0
                avg_reward = array.get(rewards, i) / pull_count
                if avg_reward > best_avg
                    best_avg := avg_reward
                    best_idx := i
        best_idx
f_select_gradient(weights, n) =>
    sum_exp = 0.0
    probs = array.new_float(n, 0.0)    
    for i = 0 to n - 1
        exp_w = math.exp(array.get(weights, i))
        array.set(probs, i, exp_w)
        sum_exp += exp_w   
    for i = 0 to n - 1
        array.set(probs, i, array.get(probs, i) / sum_exp)    
    rand = (close * 1000 - math.floor(close * 1000))
    cum_prob = 0.0
    selected = 0   
    for i = 0 to n - 1
        cum_prob += array.get(probs, i)
        if rand <= cum_prob
            selected := i
            break
    selected
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– AGENT 1: SPOOFING DETECTOR
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_agent_spoof() =>
    var float score = 0.0
    score := 0.0   
    if microstructure_enabled and institutional_impact
        persistent_vol = 0.0
        for i = 0 to 4
            if volume[i] > vol_avg * 0.8 and math.abs(close[i] - close) < atr * 0.2
                persistent_vol += volume[i]        
        if persistent_vol > vol_avg * 4
            score += 2.5 * (close > open ? 1 : -1)    
    for i = 1 to 3
        upper_wick = high[i] - math.max(open[i], close[i])
        lower_wick = math.min(open[i], close[i]) - low[i]
        range_i = high[i] - low[i]        
        if upper_wick > range_i * 0.6 and volume[i] > vol_avg * 1.8
            if close > high[i] - upper_wick * 0.5
                score += 2.0        
        if lower_wick > range_i * 0.6 and volume[i] > vol_avg * 1.8
            if close < low[i] + lower_wick * 0.5
                score -= 2.0    
    if microstructure_enabled and order_clustering
        if high > high[1] and close < (high + low) / 2
            score += 3.0
        if low < low[1] and close > (high + low) / 2
            score -= 3.0   
    memory_boost = f_retrieve_memory(0)
    score *= memory_boost   
    threshold = 2.5 * i_spoof
    confidence = math.min(math.abs(score) / 5.0, 1.0)
    signal = math.abs(score) >= threshold ? (score > 0 ? 1 : -1) : 0   
    [signal, confidence]
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– AGENT 2: EXHAUSTION DETECTOR
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_agent_momentum() =>
    var float score = 0.0
    score := 0.0    
    price_chg = ta.change(close, 5)
    rsi_chg = ta.change(rsi, 5)  
    if rsi > 70 and rsi_chg < -3 and price_chg > 0
        score += 2.0
    if rsi < 30 and rsi_chg > 3 and price_chg < 0
        score -= 2.0   
    if microstructure_enabled and close > vwap_upper and volume > vol_avg * 2
        if volume < volume[1] * 0.7 and close < (high + low) / 2
            score += 3.0    
    if microstructure_enabled and close < vwap_lower and volume > vol_avg * 2
        if volume < volume[1] * 0.7 and close > (high + low) / 2
            score -= 3.0   
    if microstructure_enabled and toxic_flow
        if vpin_score > vpin_ma and close < close[1]
            score -= 3.0
        if vpin_score > vpin_ma and close > close[1]
            score += 3.0   
    memory_boost = f_retrieve_memory(1)
    score *= memory_boost  
    threshold = 2.5 * i_momentum
    confidence = math.min(math.abs(score) / 4.5, 1.0)
    signal = math.abs(score) >= threshold ? (score > 0 ? -1 : 1) : 0
    [signal, confidence]
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– AGENT 3: LIQUIDITY VOID DETECTOR
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_agent_liquidity() =>
    var float score = 0.0
    score := 0.0
    bb_width = (bb_upper - bb_lower) / bb_mid
    bb_width_avg = ta.sma(bb_width, 50)
    is_squeeze = bb_width < bb_width_avg * 0.6
    vol_dry = volume < vol_avg * 0.7
    if is_squeeze and vol_dry
        if delta_sum > atr * 0.3
            score -= 1.5
        else if delta_sum < -atr * 0.3
            score += 1.5
    prev_high = ta.highest(high, 20)[1]
    prev_low = ta.lowest(low, 20)[1]
    stop_hunt_up = high > prev_high and close < prev_high and volume > vol_avg * 2
    stop_hunt_down = low < prev_low and close > prev_low and volume > vol_avg * 2
    if stop_hunt_up
        score += 3.5
    if stop_hunt_down
        score -= 3.5
    if microstructure_enabled and institutional_impact
        absorption = volume > vol_avg * 2 and bar_range < atr * 0.3
        if absorption
            score += close > open ? -4.0 : 4.0
    memory_boost = f_retrieve_memory(2)
    score *= memory_boost
    threshold = 1.5 * i_liquidity
    confidence = math.min(math.abs(score) / 4.5, 1.0)
    signal = math.abs(score) >= threshold ? (score > 0 ? -1 : 1) : 0
    [signal, confidence]
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– AGENT 4: MEAN REVERSION
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_agent_statarb() =>
    var float score = 0.0
    score := 0.0
    zscore = (close - sma_50) / math.max(stdev_50, 1e-10)
    if zscore > 2.0
        score -= 2.0
    else if zscore < -2.0
        score += 2.0
    if microstructure_enabled and institutional_impact
        ou_score = -math.log(math.abs(close - sma_20) / atr + 0.01)
        score += ou_score * 2
    if microstructure_enabled and algo_trading
        entropy_edge = (3.0 - price_entropy) * 2
        score += close > sma_20 ? -entropy_edge : entropy_edge
    memory_boost = f_retrieve_memory(3)
    score *= memory_boost
    threshold = 2.0 * i_statarb
    confidence = math.min(math.abs(score) / 4.0, 1.0)
    signal = math.abs(score) >= threshold ? (score > 0 ? -1 : 1) : 0
    [signal, confidence]
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  PERFORMANCE UPDATE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_update_performance(agent_idx, signal_direction, entry_price, current_price) =>
    if agent_idx >= 0 and agent_idx < 4
        pulls = array.get(agent_pulls, agent_idx)
        array.set(agent_pulls, agent_idx, pulls + 1)
        price_move = current_price - entry_price
        signal_correct = (signal_direction == 1 and price_move > 0) or (signal_direction == -1 and price_move < 0)
        reward = signal_correct ? 1.0 : 0.0
        old_reward = array.get(agent_rewards, agent_idx)
        array.set(agent_rewards, agent_idx, old_reward * auto_decay + reward)
        if reward > 0.5
            array.set(agent_alpha, agent_idx, array.get(agent_alpha, agent_idx) + 1)
            array.set(agent_win_count, agent_idx, array.get(agent_win_count, agent_idx) + 1)
        else
            array.set(agent_beta, agent_idx, array.get(agent_beta, agent_idx) + 1)
            array.set(agent_loss_count, agent_idx, array.get(agent_loss_count, agent_idx) + 1)
        avg_reward = array.sum(agent_rewards) / 4
        gradient = reward - avg_reward
        old_weight = array.get(agent_weights, agent_idx)
        array.set(agent_weights, agent_idx, old_weight + 0.1 * gradient)
        f_store_short_memory(agent_idx, reward)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  ADAPTIVE META-COORDINATOR
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_adaptive_coordinator() =>
    selected_agent = -1
    final_signal = 0
    final_conf = 0.0
    consensus_pct = 0.0
    new_vpin_sens = adaptive_vpin_sensitivity
    new_kyle_thresh = adaptive_kyle_threshold
    [s1, c1] = f_agent_spoof()
    [s2, c2] = f_agent_momentum()
    [s3, c3] = f_agent_liquidity()
    [s4, c4] = f_agent_statarb()
    array.set(agent_last_conf, 0, c1)
    array.set(agent_last_conf, 1, c2)
    array.set(agent_last_conf, 2, c3)
    array.set(agent_last_conf, 3, c4)
    if s1 != 0
        array.set(agent_triggers, 0, array.get(agent_triggers, 0) + 1)
    if s2 != 0
        array.set(agent_triggers, 1, array.get(agent_triggers, 1) + 1)
    if s3 != 0
        array.set(agent_triggers, 2, array.get(agent_triggers, 2) + 1)
    if s4 != 0
        array.set(agent_triggers, 3, array.get(agent_triggers, 3) + 1)
    if auto_enable
        if auto_mode == "Switch"
            if lock_agent
                selected_agent := locked_agent_choice == "Spoofing Detector" ? 0 : 
                                 locked_agent_choice == "Exhaustion Detector" ? 1 :
                                 locked_agent_choice == "Liquidity Void" ? 2 : 3
            else
                if auto_algorithm == "UCB1"
                    selected_agent := f_select_ucb(agent_pulls, agent_rewards, 4)
                else if auto_algorithm == "Thompson Sampling"
                    selected_agent := f_select_thompson(agent_alpha, agent_beta, 4)
                else if auto_algorithm == "Epsilon-Greedy"
                    selected_agent := f_select_epsilon(agent_rewards, agent_pulls, 4, auto_epsilon)
                else
                    selected_agent := f_select_gradient(agent_weights, 4)
            signals = array.from(s1, s2, s3, s4)
            confs = array.from(c1, c2, c3, c4)
            final_signal := array.get(signals, selected_agent)
            final_conf := array.get(confs, selected_agent)
            consensus_pct := 100
        else
            weights = agent_weights
            signals = array.from(s1, s2, s3, s4)
            confs = array.from(c1, c2, c3, c4)
            float[] probs = array.new_float(4, 0.0)
            sum_exp = 0.0
            for i = 0 to 3
                w = array.get(weights, i)
                exp_w = math.exp(w / auto_temperature)
                array.set(probs, i, exp_w)
                sum_exp += exp_w
            for i = 0 to 3
                array.set(probs, i, array.get(probs, i) / sum_exp)
            long_weight = 0.0
            short_weight = 0.0
            for i = 0 to 3
                prob = array.get(probs, i)
                s = array.get(signals, i)
                c = array.get(confs, i)
                weighted_conf = prob * c
                if s == 1
                    long_weight += weighted_conf
                else if s == -1
                    short_weight += weighted_conf
            total_weight = long_weight + short_weight
            consensus_pct := total_weight > 0 ? math.max(long_weight, short_weight) / total_weight * 100 : 0
            threshold_factor = 1 + auto_temperature * 0.2
            if long_weight > short_weight * threshold_factor
                final_signal := 1
                final_conf := long_weight / math.max(long_weight + short_weight, 0.001)
                best_idx = 0
                best_contrib = 0.0
                for i = 0 to 3
                    if array.get(signals, i) == 1
                        contrib = array.get(probs, i) * array.get(confs, i)
                        if contrib > best_contrib
                            best_contrib := contrib
                            best_idx := i
                selected_agent := best_idx
            else if short_weight > long_weight * threshold_factor
                final_signal := -1
                final_conf := short_weight / math.max(long_weight + short_weight, 0.001)
                best_idx = 0
                best_contrib = 0.0
                for i = 0 to 3
                    if array.get(signals, i) == -1
                        contrib = array.get(probs, i) * array.get(confs, i)
                        if contrib > best_contrib
                            best_contrib := contrib
                            best_idx := i
                selected_agent := best_idx
    else
        signals = array.from(s1, s2, s3, s4)
        confs = array.from(c1, c2, c3, c4)
        long_weight = 0.0
        short_weight = 0.0
        total_weight = 0.0
        for i = 0 to 3
            sig = array.get(signals, i)
            conf = array.get(confs, i)
            weight = conf * conf
            if sig == 1
                long_weight += weight
            else if sig == -1
                short_weight += weight
            total_weight += weight
        consensus_pct := total_weight > 0 ? math.max(long_weight, short_weight) / total_weight * 100 : 0
        if consensus_pct >= i_consensus
            if long_weight > short_weight
                final_signal := 1
                final_conf := long_weight / total_weight
            else
                final_signal := -1
                final_conf := short_weight / total_weight
    if microstructure_enabled
        if toxic_flow and final_signal == 0
            new_vpin_sens := math.min(adaptive_vpin_sensitivity * 1.01, 3.0)
        if institutional_impact and volume > vol_avg * 2
            new_kyle_thresh := math.max(adaptive_kyle_threshold * 0.99, 0.1)
    [final_signal, final_conf, consensus_pct, s1, s2, s3, s4, c1, c2, c3, c4, selected_agent, new_vpin_sens, new_kyle_thresh]
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SIGNAL VALIDATION WITH CONFIDENCE FILTER
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var int confirm_count = 0
var int confirm_direction = 0
var float confirm_confidence = 0.0
var int last_signal_bar = -999
var float last_bar_price = na
var int last_signal_type = 0

// Minimum confidence threshold
min_confidence_threshold = 0.25  // Require at least 25% confidence

[raw_signal, raw_conf, consensus, s1, s2, s3, s4, c1, c2, c3, c4, selected_agent, new_vpin, new_kyle] = f_adaptive_coordinator()

adaptive_vpin_sensitivity := new_vpin
adaptive_kyle_threshold := new_kyle

if not na(pending_entry_price) and pending_agent >= 0
    bars_elapsed = bar_index - pending_signal_bar
    if bars_elapsed >= performance_horizon
        f_update_performance(pending_agent, pending_signal_direction, pending_entry_price, close)
        
        ep_length = array.get(memory_episode_length, pending_agent)
        if ep_length >= memory_transfer_threshold
            f_transfer_memory(pending_agent)
        
        pending_entry_price := na
        pending_signal_direction := 0
        pending_agent := -1

if auto_enable and selected_agent >= 0
    if selected_agent != last_active_agent
        last_active_agent := selected_agent
    current_active_agent := selected_agent

if raw_signal != 0
    if raw_signal == confirm_direction
        confirm_count += 1
        confirm_confidence := math.max(confirm_confidence, raw_conf)
    else
        confirm_count := 1
        confirm_direction := raw_signal
        confirm_confidence := raw_conf
else
    if confirm_count > 0
        confirm_count -= 1

bars_since_signal = bar_index - last_signal_bar
can_signal = bars_since_signal >= i_cooldown

validated_long = false
validated_short = false
validated_conf = 0.0

if confirm_count >= i_confirmation and can_signal
    if confirm_direction == 1 and trend_score >= -2 and confirm_confidence >= min_confidence_threshold
        validated_long := true
        validated_conf := confirm_confidence
        last_signal_bar := bar_index
        last_bar_price := close
        last_signal_type := 1
        confirm_count := 0
        total_signals += 1
        
        pending_entry_price := close
        pending_signal_direction := 1
        pending_signal_bar := bar_index
        pending_agent := current_active_agent
        
    else if confirm_direction == -1 and trend_score <= 2 and confirm_confidence >= min_confidence_threshold
        validated_short := true
        validated_conf := confirm_confidence
        last_signal_bar := bar_index
        last_bar_price := close
        last_signal_type := -1
        confirm_count := 0
        total_signals += 1
        
        pending_entry_price := close
        pending_signal_direction := -1
        pending_signal_bar := bar_index
        pending_agent := current_active_agent

singularity_strength = math.min((c1 + c2 + c3 + c4) / 4.0, 1.0)
is_singularity = validated_long or validated_short
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ VISUALIZATIONS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
calcOpacity(base, slider) => int(base * slider / 100)
spectral_color = trend_score > 0 ? cBull : cBear
layer1Upper = ema8 + atr * 0.5
layer1Lower = ema8 - atr * 0.5
p1u = plot(i_show_spectral ? layer1Upper : na, color=na, display=display.none)
p1l = plot(i_show_spectral ? layer1Lower : na, color=na, display=display.none)
fill(p1u, p1l, color=i_show_spectral ? color.new(spectral_color, calcOpacity(85, i_opacity)) : na)
var box[] energyBoxes = array.new_box()
if i_show_energy and is_singularity
    while array.size(energyBoxes) > 20
        box.delete(array.shift(energyBoxes))
    for layer = 1 to i_glow_intensity
        energyBox = box.new(
             bar_index - layer, 
             close + atr * layer * 0.3,
             bar_index + layer, 
             close - atr * layer * 0.3,
             border_color=color.new(validated_long ? cBull : cBear, calcOpacity(70 + layer * 5, i_opacity)),
             bgcolor=color.new(validated_long ? cBull : cBear, calcOpacity(85 + layer * 3, i_opacity)))
        array.push(energyBoxes, energyBox)
var line[] coneLines = array.new_line()
if i_show_cones and is_singularity
    while array.size(coneLines) > 15
        line.delete(array.shift(coneLines))
    projectionBars = 15
    uncertaintyWidth = atr * singularity_strength * projectionBars / 4
    futureX = bar_index + projectionBars
    projectionMult = validated_long ? 1 : -1
    futureY = close + (projectionMult * atr * projectionBars * 0.4)
    baseColor = validated_long ? cBull : cBear
    upperLine = line.new(bar_index, close, futureX, futureY + uncertaintyWidth, 
                         color=color.new(baseColor, calcOpacity(70, i_opacity)), width=1, style=line.style_dashed)
    array.push(coneLines, upperLine)
    lowerLine = line.new(bar_index, close, futureX, futureY - uncertaintyWidth, 
                         color=color.new(baseColor, calcOpacity(70, i_opacity)), width=1, style=line.style_dashed)
    array.push(coneLines, lowerLine)
var line[] connectionLines = array.new_line()
if i_show_connections and (validated_long or validated_short) and not na(last_bar_price) and last_signal_bar > 0
    while array.size(connectionLines) > 10
        line.delete(array.shift(connectionLines))
    bars_between = bar_index - last_signal_bar
    if bars_between > 1 and bars_between < 100
        same_direction = (validated_long and last_signal_type == 1) or (validated_short and last_signal_type == -1)
        line connection = line.new(last_signal_bar, last_bar_price, bar_index, close, 
                              color=color.new(cAccent, 40), width=same_direction ? 2 : 1, 
                              style=same_direction ? line.style_solid : line.style_dotted)
        array.push(connectionLines, connection)
if i_show_zones and is_singularity
    entry = close
    sl = entry + (validated_long ? -atr * 1.5 : atr * 1.5)
    tp1 = entry + (validated_long ? atr * 2.0 : -atr * 2.0)
    tp2 = entry + (validated_long ? atr * 3.5 : -atr * 3.5)
    zone_color = validated_long ? cBull : cBear
    box.new(bar_index, validated_long ? tp2 : sl, bar_index + 20, validated_long ? sl : tp2, bgcolor=color.new(zone_color, 92), border_color=color.new(zone_color, 50), border_width=2)
    label.new(bar_index + 20, tp2, 
              (validated_long ? "ğŸ¯ LONG " : "ğŸ¯ SHORT ") + str.tostring(int(validated_conf * 100)) + "%",
              style=label.style_label_left, color=color.new(zone_color, 80), 
              textcolor=zone_color, size=size.small)
plotshape(i_show_nodes and validated_long, "LONG", shape.triangleup, location.belowbar, cBull, size=size.tiny)
plotshape(i_show_nodes and validated_short, "SHORT", shape.triangledown, location.abovebar, cBear, size=size.tiny)
bgcolor(institutional_window ? color.new(cInfo, 95) : na)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š DASHBOARD
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_get_position(pos_string) =>
    pos_string == "top_left" ? position.top_left : pos_string == "top_center" ? position.top_center : pos_string == "top_right" ? position.top_right : pos_string == "middle_left" ? position.middle_left : pos_string == "middle_center" ? position.middle_center : pos_string == "middle_right" ? position.middle_right : pos_string == "bottom_left" ? position.bottom_left : pos_string == "bottom_center" ? position.bottom_center : position.bottom_right
f_get_size(size_string) =>
    size_string == "tiny" ? size.tiny : size_string == "small" ? size.small : size_string == "normal" ? size.normal : size.large
var table panel = table.new(f_get_position(dash_position), 4, 20, bgcolor=cPanel, border_color=cAccent, border_width=2)
if barstate.islast and i_show_dashboard
    row = 0
    txt_size = f_get_size(dash_size)
    table.merge_cells(panel, 0, row, 3, row)
    table.cell(panel, 0, row, "ğŸ¯ ADAPTIVE MULTI-AGENT ML", text_color=cAccent, text_size=size.large, 
               text_halign=text.align_center, bgcolor=color.new(cAccent, 90))
    row += 1
    table.merge_cells(panel, 0, row, 3, row)
    table.cell(panel, 0, row, regime, text_color=trend_score > 0 ? cBull : cBear, 
               text_size=txt_size, text_halign=text.align_center)
    row += 1
    table.merge_cells(panel, 0, row, 3, row)
    mode_status = auto_enable ? 
                 (lock_agent ? "ğŸ”’ LOCKED: " + locked_agent_choice : "ğŸ¤– " + auto_mode + " (" + auto_algorithm + ")") : 
                 "ğŸ“Š CONSENSUS (" + str.tostring(int(i_consensus)) + "%)"
    table.cell(panel, 0, row, mode_status, text_color=auto_enable ? (lock_agent ? color.orange : color.lime) : color.gray, text_size=txt_size)
    row += 1
    table.merge_cells(panel, 0, row, 3, row)
    table.cell(panel, 0, row, "â”â”â” AGENTS â”â”â”", text_color=color.gray, text_size=size.tiny)
    row += 1
    table.cell(panel, 0, row, "AGENT", text_color=color.gray, text_size=size.tiny)
    table.cell(panel, 1, row, "WIN%", text_color=color.gray, text_size=size.tiny)
    table.cell(panel, 2, row, "CONF", text_color=color.gray, text_size=size.tiny)
    table.cell(panel, 3, row, "MEM", text_color=color.gray, text_size=size.tiny)
    for i = 0 to 3
        row += 1
        wins = array.get(agent_win_count, i)
        losses = array.get(agent_loss_count, i)
        total = wins + losses
        win_rate = total > 0 ? wins * 100 / total : 50
        conf = array.get(agent_last_conf, i)
        mem_size = f_get_short_bin_size(i)
        is_selected = auto_enable and i == selected_agent
        bg_color = is_selected ? color.new(cAccent, 85) : na
        name_prefix = is_selected ? "â–º " : "  "
        table.cell(panel, 0, row, name_prefix + array.get(agent_names, i), text_color=cText, 
                   text_size=size.tiny, bgcolor=bg_color)
        table.cell(panel, 1, row, str.tostring(win_rate, "0") + "%", 
                   text_color=win_rate > 60 ? cBull : win_rate < 40 ? cBear : cNeut, 
                   text_size=size.tiny, bgcolor=bg_color)
        conf_bars = ""
        for j = 0 to 4
            conf_bars += j < int(conf * 5) ? "â–ˆ" : "â–‘"
        table.cell(panel, 2, row, conf_bars, text_color=cInfo, text_size=size.tiny, bgcolor=bg_color)
        table.cell(panel, 3, row, str.tostring(mem_size), text_color=cAccent, 
                   text_size=size.tiny, bgcolor=bg_color)
    if microstructure_enabled
        row += 1
        table.merge_cells(panel, 0, row, 3, row)
        table.cell(panel, 0, row, "â”â”â” ORDER FLOW â”â”â”", text_color=color.gray, text_size=size.tiny)
        row += 1
        table.cell(panel, 0, row, "Toxicity", text_color=cText, text_size=size.tiny)
        table.cell(panel, 1, row, toxic_flow ? "âš ï¸" : "âœ“", text_color=toxic_flow ? cBear : cBull)
        table.cell(panel, 2, row, "Impact", text_color=cText, text_size=size.tiny)
        table.cell(panel, 3, row, institutional_impact ? "ğŸ›ï¸" : "ğŸª", text_color=cInfo)
    row += 1
    table.merge_cells(panel, 0, row, 3, row)
    signal_text = validated_long ? "ğŸŸ¢ LONG" : validated_short ? "ğŸ”´ SHORT" : 
                  confirm_count > 0 ? "ğŸŸ¡ CONFIRMING (" + str.tostring(confirm_count) + "/" + str.tostring(i_confirmation) + ")" : 
                  "âšª WAITING"
    signal_bg = validated_long ? color.new(cBull, 85) : validated_short ? color.new(cBear, 85) : confirm_count > 0 ? color.new(cNeut, 90) : na
    table.cell(panel, 0, row, signal_text, text_color=cText, text_size=size.large, bgcolor=signal_bg)
    row += 1
    table.merge_cells(panel, 0, row, 3, row)
    table.cell(panel, 0, row, "Signals: " + str.tostring(total_signals), 
               text_color=color.gray, text_size=size.tiny)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¾ MEMORY EXPORT PANEL
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table memory_panel = table.new(f_get_position(memory_position), 2, 12, 
                                   bgcolor=color.new(color.black, 80), 
                                   border_color=color.yellow)
if barstate.islast and i_show_memory
    m_row = 0
    mem_txt_size = f_get_size(memory_size)
    table.merge_cells(memory_panel, 0, m_row, 1, m_row)
    table.cell(memory_panel, 0, m_row, "ğŸ’¾ MEMORY EXPORT", text_color=color.yellow, 
               text_size=mem_txt_size, text_halign=text.align_center)
    m_row += 1
    table.merge_cells(memory_panel, 0, m_row, 1, m_row)
    table.cell(memory_panel, 0, m_row, "â•â•â•â•â•â•â•â•â•â•â•", text_color=color.gray, text_size=size.tiny)
    for i = 0 to 3
        m_row += 1
        alpha_val = array.get(agent_alpha, i)
        beta_val = array.get(agent_beta, i)
        weight_val = array.get(agent_weights, i)
        table.cell(memory_panel, 0, m_row, "A" + str.tostring(i+1) + ":", text_color=color.gray, text_size=size.tiny)
        table.cell(memory_panel, 1, m_row, 
                   str.tostring(alpha_val, "#.#") + "/" + 
                   str.tostring(beta_val, "#.#") + " w:" + 
                   str.tostring(weight_val, "#.##"),
                   text_color=color.white, text_size=size.tiny)
    m_row += 1
    table.cell(memory_panel, 0, m_row, "VPIN:", text_color=color.gray, text_size=size.tiny)
    table.cell(memory_panel, 1, m_row, str.tostring(adaptive_vpin_sensitivity, "#.##"), 
               text_color=color.aqua, text_size=size.tiny)
    m_row += 1
    table.cell(memory_panel, 0, m_row, "Kyle:", text_color=color.gray, text_size=size.tiny)
    table.cell(memory_panel, 1, m_row, str.tostring(adaptive_kyle_threshold, "#.##"), 
               text_color=color.aqua, text_size=size.tiny)
    m_row += 1
    table.merge_cells(memory_panel, 0, m_row, 1, m_row)
    table.cell(memory_panel, 0, m_row, restore_memory ? "âœ… RESTORED" : "ğŸ“ SAVE THESE", 
               text_color=restore_memory ? color.lime : color.yellow, 
               bgcolor=restore_memory ? color.new(color.green, 90) : color.new(color.red, 90))
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”” ALERTS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(validated_long, "ğŸ¯ LONG", "Adaptive ML: LONG Signal")
alertcondition(validated_short, "ğŸ¯ SHORT", "Adaptive ML: SHORT Signal")
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“š THEORETICAL FOUNDATION & USER GUIDE
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“š IMPORTANT: LITE VERSION DISCLAIMER
//
// This is a SIMPLIFIED/EDUCATIONAL implementation of multi-armed bandits and
// market microstructure analysis. The "Pro" version includes:
//
// â€¢ Proper Thompson Sampling with Beta distribution sampling
// â€¢ Legitimate VPIN calculation with volume buckets and bulk classification
// â€¢ Full Kyle's Lambda with proper order flow regression
// â€¢ True Hawkes Process with self-exciting point process mathematics
// â€¢ Additional institutional metrics (Amihud illiquidity, Roll spread, etc.)
//
// This LITE version uses APPROXIMATIONS:
// â€¢ Simplified Thompson Sampling (pseudo-random via price/volume noise)
// â€¢ Basic VPIN (directional volume ratio vs true bulk classification)
// â€¢ Kyle approximation (price change / sqrt(volume))
// â€¢ Simplified entropy and clustering detection
//
// For educational and general trading use. Professional/institutional traders
// should use the full mathematical implementations in the Pro version.
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ§¬ ALGORITHM PREDATOR: ADAPTIVE MULTI-ARMED BANDIT SYSTEM
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// ğŸŒŒ CORE PHILOSOPHY: QUANTUM MARKET INTELLIGENCE
//
// Traditional indicators assume markets behave consistently. Algorithm Predator
// (AP-ML) recognizes that markets are multi-regime, non-stationary systems where
// no single strategy dominates universally. Instead, AP-ML deploys FOUR specialized
// quantum agents, each optimized for different market microstructure patterns.
//
// The system uses CONTEXTUAL MULTI-ARMED BANDITSâ€”a reinforcement learning framework
// that automatically discovers which agent performs best in each market regime, then
// adapts its strategy selection in real-time without human intervention.
//
// This is not curve-fitting. This is online learning from live market feedback.
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ¤– THE FOUR QUANTUM AGENTS: SPECIALIST PREDATORS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// Each agent hunts specific market inefficiencies using advanced microstructure
// analysis. They operate independently, competing for system resources based on
// proven performance.
//
// ğŸ­ AGENT 1: SPOOF HUNTER (Iceberg & Layering Detection)
//
// TARGET: Institutional order manipulation and hidden liquidity
//
// QUANTUM METRICS:
// â€¢ Kyle's Lambda: Measures price impact per unit volume
// â€¢ Hawkes Intensity: Detects order clustering (spoofing signatures)
// â€¢ VPIN (Volume-Synchronized Probability of Informed Trading): Toxicity detector
//
// DETECTION PATTERNS:
// 1. ICEBERG ORDERS: Persistent volume at same price level with minimal price movement
//    - Detects: volume[i] > vol_avg * 0.8 for 5+ consecutive bars
//    - Within: price range < ATR * 0.2
//    - Signal: Institutional accumulation/distribution
//
// 2. SPOOF PATTERNS: Extreme wicks with high volume, then price reversal
//    - Upper wick > 60% of bar range + volume > 1.8Ã— average
//    - Indicates: Sell pressure absorbed, reversal imminent
//
// 3. ORDER CLUSTERING: Hawkes process intensity spikes
//    - Detects: Burst of large orders in short time
//    - Indicates: Algorithmic coordination or stop hunts
//
// TRADING LOGIC:
// â€¢ If institutional buying detected (low Kyle's Lambda + high persistent volume):
//   â†’ CONTRARIAN LONG signal
// â€¢ If spoofing detected (fake sell walls absorbed):
//   â†’ LONG signal (smart money accumulating)
//
// OPTIMAL REGIMES: Consolidation, institutional windows (9:30-10:30, 3-4pm EST)
//
// âš¡ AGENT 2: MOMENTUM EXHAUST (Divergence & Exhaustion Detection)
//
// TARGET: Momentum failure points where trend loses internal energy
//
// QUANTUM METRICS:
// â€¢ RSI Divergence: Price vs momentum misalignment
// â€¢ VWAP Exhaustion: Volume drying up at extremes
// â€¢ VPIN Toxicity: Informed traders exiting
//
// DETECTION PATTERNS:
// 1. RSI DIVERGENCE: Price makes new high but RSI declining
//    - RSI > 70 AND rsi_change < -3 AND price_change > 0
//    - Indicates: Buyers exhausted, sellers taking control
//
// 2. VWAP EXHAUSTION: Price extended beyond 2Ïƒ VWAP bands
//    - Close > VWAP_upper + volume spike
//    - BUT: Volume drops 30%+ on next bar
//    - Indicates: No follow-through, reversal likely
//
// 3. TOXIC FLOW REVERSAL: VPIN spikes but price can't sustain direction
//    - VPIN > moving average (informed traders active)
//    - Price closes against the informed flow
//    - Indicates: Smart money fading retail
//
// TRADING LOGIC:
// â€¢ Momentum exhaust at tops â†’ SHORT signal
// â€¢ Momentum exhaust at bottoms â†’ LONG signal
// â€¢ CONTRARIAN by design: Fades overextended moves
//
// OPTIMAL REGIMES: Strong trends reaching exhaustion, post-news overreactions
//
// ğŸ’§ AGENT 3: LIQUIDITY VOID (Gap & Squeeze Detection)
//
// TARGET: Thin liquidity zones where price moves explosively
//
// QUANTUM METRICS:
// â€¢ Bollinger Band Width: Volatility compression
// â€¢ Volume Profile: Liquidity concentration
// â€¢ Order Absorption: Kyle's Lambda impact
//
// DETECTION PATTERNS:
// 1. LIQUIDITY SQUEEZE: Bollinger Bands contract + volume dries up
//    - BB_width < 60% of 50-bar average
//    - Volume < 70% of average
//    - Indicates: Coiling spring, explosive move pending
//
// 2. STOP HUNTS: Price spikes beyond recent high/low then retraces
//    - High > 20-bar highest high + volume > 2Ã— average
//    - Close below previous high (absorption)
//    - Indicates: Stops triggered, smart money entering opposite direction
//
// 3. HIDDEN LIQUIDITY: Institutional absorption patterns
//    - Large volume but minimal price movement (range < 30% ATR)
//    - Kyle's Lambda confirms institutional activity
//    - Indicates: Big player building position, prepare for breakout
//
// TRADING LOGIC:
// â€¢ Stop hunt up + absorption â†’ SHORT signal
// â€¢ Stop hunt down + absorption â†’ LONG signal
// â€¢ Squeeze + directional bias â†’ Breakout direction
//
// OPTIMAL REGIMES: Range-bound markets, pre-breakout consolidations
//
// ğŸ“Š AGENT 4: STATISTICAL ARBITRAGE (Mean Reversion)
//
// TARGET: Statistical extremes and Ornstein-Uhlenbeck mean-reversion
//
// QUANTUM METRICS:
// â€¢ Z-Score: Standard deviation from mean
// â€¢ Entropy: Market microstructure randomness
// â€¢ Institutional Footprint: Kyle's Lambda
//
// DETECTION PATTERNS:
// 1. Z-SCORE EXTREMES: Price > 2Ïƒ from 50-period mean
//    - Z-score > 2.0 â†’ Overextended up (fade)
//    - Z-score < -2.0 â†’ Overextended down (fade)
//    - Statistical edge: 95% of prices revert within 2Ïƒ
//
// 2. ORNSTEIN-UHLENBECK PROCESS: Mean-reversion strength
//    - OU_score = -log(|price - SMA| / ATR)
//    - Higher OU score = stronger reversion force
//    - Combined with institutional footprint for confirmation
//
// 3. ENTROPY ARBITRAGE: Algorithmic trading signatures
//    - Low entropy (< 0.25) indicates algo-dominated market
//    - Algos mean-revert predictably
//    - Exploit their behavior with counter-positioning
//
// TRADING LOGIC:
// â€¢ Price > 2Ïƒ + algo activity â†’ SHORT (fade extension)
// â€¢ Price < -2Ïƒ + algo activity â†’ LONG (fade extension)
// â€¢ Works best when institutions are NOT active (Kyle's Lambda neutral)
//
// OPTIMAL REGIMES: Range-bound, low-volatility, algo-heavy periods
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ° MULTI-ARMED BANDIT FRAMEWORK: THE META-COORDINATOR
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// ğŸ§  THE EXPLORATION-EXPLOITATION DILEMMA
//
// Markets cycle through regimes. A strategy that works in trending markets fails
// in ranges. A mean-reversion system that crushes consolidations bleeds in trends.
//
// The MULTI-ARMED BANDIT (MAB) framework solves this by treating each agent as a
// "slot machine arm." The system must balance:
//
// â€¢ EXPLOITATION: Use the agent currently performing best
// â€¢ EXPLORATION: Try other agents to discover if regimes changed
//
// This is the same problem Google faces serving ads, Amazon recommending products,
// and hedge funds allocating capital. AP-ML applies it to strategy selection.
//
// ğŸ² FOUR BANDIT ALGORITHMS (User-Selectable)
//
// 1. UCB1 (Upper Confidence Bound)
//
// FORMULA: UCB_score[i] = avg_reward[i] + sqrt(2 Ã— log(total_pulls) / pulls[i])
//
// â€¢ First term: Exploitation (known performance)
// â€¢ Second term: Exploration bonus (uncertainty premium)
// â€¢ Agents pulled less frequently get higher exploration bonus
// â€¢ Deterministic: Always picks provably optimal agent under uncertainty
//
// BEST FOR: Stable regimes where you want maximum efficiency
// DRAWBACK: Slower to adapt when markets shift rapidly
//
// 2. THOMPSON SAMPLING (Beta Distribution)
//
// FORMULA: Sample Î¸[i] ~ Beta(Î±[i], Î²[i]), pick argmax Î¸[i]
//
// â€¢ Î± (alpha): Count of wins + 1
// â€¢ Î² (beta): Count of losses + 1
// â€¢ Randomly samples from each agent's belief distribution
// â€¢ Probability of selecting agent âˆ probability agent is best
//
// BEST FOR: Non-stationary markets, crypto, forex (fast regime changes)
// ADVANTAGE: Naturally balances exploration/exploitation via Bayesian inference
//
// 3. EPSILON-GREEDY
//
// LOGIC:
// â€¢ With probability Îµ: Pick random agent (explore)
// â€¢ With probability (1-Îµ): Pick best-performing agent (exploit)
//
// TUNING:
// â€¢ Îµ = 0.1: Conservative (10% exploration)
// â€¢ Îµ = 0.3: Aggressive (30% exploration)
//
// BEST FOR: Simple, interpretable, works well with high Îµ in volatile markets
// DRAWBACK: Explores blindly (doesn't use uncertainty information)
//
// 4. GRADIENT BANDIT
//
// FORMULA: P[i] = exp(H[i]) / Î£ exp(H[j])
//
// â€¢ H[i] = preference weight for agent i
// â€¢ Updated via: H[i] += Î± Ã— (reward - baseline) Ã— gradient
// â€¢ Softmax converts preferences to probabilities
//
// BEST FOR: When you want smooth probability mixing rather than hard switching
// ADVANTAGE: Learns optimal mixture weights over time
//
// ğŸ”„ TWO OPERATING MODES
//
// SWITCH MODE:
// â€¢ Bandit selects ONE agent per bar
// â€¢ That agent's signal is used exclusively
// â€¢ Fast, decisive, but can whipsaw between agents
// â€¢ Best for: Clear regime states, lower-frequency trading
//
// BLEND MODE:
// â€¢ ALL agents vote, weighted by bandit-learned probabilities
// â€¢ Signals combined via softmax: weight[i] = exp(H[i] / temp)
// â€¢ Temperature controls blending smoothness
// â€¢ Best for: Ambiguous regimes, higher-frequency trading
//
// ğŸ“ˆ PERFORMANCE TRACKING & REWARD SYSTEM
//
// After each signal:
// 1. Entry price recorded
// 2. After N bars (default: prediction horizon), outcome measured:
//    â€¢ Reward = +1.0 if price moved in signal direction
//    â€¢ Reward = 0.0 if price moved against signal
// 3. Bandit parameters updated:
//    â€¢ Î±[i] += 1 (if win)
//    â€¢ Î²[i] += 1 (if loss)
//    â€¢ weights[i] adjusted via gradient
// 4. Memory system stores result for long-term learning
//
// ADAPTIVE DECAY:
// â€¢ Recent results weighted more heavily: reward *= decay^age
// â€¢ Default decay = 0.95
// â€¢ Allows system to "forget" old regimes and adapt
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ§  DUAL MEMORY ARCHITECTURE: SHORT-TERM & LONG-TERM
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// Inspired by human memory: working memory (short-term) and consolidated memory
// (long-term). Each agent maintains both.
//
// ğŸ“¦ SHORT-TERM MEMORY (STM)
//
// â€¢ Size: 10-50 recent results (default: 20)
// â€¢ Purpose: Track current episode performance
// â€¢ Updates: Every signal result stored immediately
// â€¢ Retrieval: Used for immediate performance boost calculations
//
// STM Boost Formula:
//    boost = 1.0 + (avg(STM) Ã— 0.2)
//
// â€¢ If agent's recent results good: boost = 1.1-1.2 (amplify signals)
// â€¢ If agent's recent results bad: boost = 0.8-0.9 (dampen signals)
//
// ğŸ“š LONG-TERM MEMORY (LTM)
//
// â€¢ Size: 50-200 episode averages (default: 100)
// â€¢ Purpose: Preserve regime knowledge across market cycles
// â€¢ Updates: When STM reaches transfer threshold (default: 10 results)
// â€¢ Transfer: STM averaged and pushed to LTM, STM cleared
//
// LTM provides stabilityâ€”prevents over-reacting to short-term noise while
// maintaining learned patterns from past regime encounters.
//
// ğŸ’¾ MEMORY CONSOLIDATION PROCESS
//
// 1. Agent generates signal
// 2. Result stored in STM[agent_id]
// 3. When STM size >= transfer_threshold:
//    a. Calculate episode average
//    b. Push to LTM[agent_id]
//    c. Clear STM
//    d. "Episode" complete
//
// 4. Memory retrieval combines:
//    memory_signal = STM_avg Ã— 0.7 + LTM_avg Ã— 0.3
//
// This 70/30 weighting emphasizes recent performance while incorporating
// historical regime knowledge.
//
// ğŸ’¡ HUMAN MEMORY RESTORE SYSTEM
//
// After extensive use, you can export learned parameters and restore them later:
//
// 1. Enable "Show Memory Panel" in visuals
// 2. Note displayed alpha/beta values for each agent
// 3. Copy to "Memory Restore" input section
// 4. Enable "Restore From Memory" on next chart load
// 5. System initializes with your learned parameters
//
// This allows transfer learning across timeframes, instruments, or accounts.
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ“Š SIGNAL VALIDATION & CONSENSUS SYSTEM
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// Raw agent signals are noisy. Validation system filters noise via:
//
// ğŸ”„ CONFIRMATION COUNTER
//
// Signal must persist for N consecutive bars (default: 2-4 based on mode):
//
// â€¢ Conservative mode: 4 confirmations (ultra-selective)
// â€¢ Balanced mode: 3 confirmations (standard)
// â€¢ Aggressive mode: 2 confirmations (fast reaction)
//
// LOGIC:
// if agent_signal == previous_signal:
//     confirm_count += 1
// else:
//     confirm_count = 1
//
// Only triggers when confirm_count >= threshold
//
// â±ï¸ COOLDOWN PERIOD
//
// Prevents over-trading by enforcing minimum bars between signals:
//
// â€¢ Conservative: 15 bars
// â€¢ Balanced: 10 bars
// â€¢ Aggressive: 5 bars
//
// This acts as position holding periodâ€”signals ignored during cooldown.
//
// ğŸ“Š CONSENSUS WEIGHTING (Manual Mode Only)
//
// If adaptive bandits disabled, system uses weighted voting:
//
// For each agent[i]:
//    vote_weight[i] = confidence[i]Â²
//
// Total votes:
//    long_weight = Î£(weight Ã— signal_long)
//    short_weight = Î£(weight Ã— signal_short)
//
// Consensus %:
//    consensus = max(long_weight, short_weight) / total_weight Ã— 100
//
// Signal triggers when consensus >= threshold (default: 70%)
//
// This ensures multiple agents agree before committing capital.
//
// ğŸ¯ TREND FILTER
//
// Final safety: Signal must align with trend context:
//
// â€¢ LONG signals require: trend_score >= -2 (not strong downtrend)
// â€¢ SHORT signals require: trend_score <= 2 (not strong uptrend)
//
// Prevents fighting extreme momentumâ€”even best setups fail against tsunami.
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ¨ VISUALIZATION SYSTEM: MULTI-LAYER QUANTUM DISPLAY
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// ğŸŒŠ SPECTRAL LAYERS: Regime-Adaptive Dynamic Zones
//
// Renders transparent bands around EMA8 showing trend strength:
//
// â€¢ Cyan spectral: Bullish regime (trend_score > 0)
// â€¢ Magenta spectral: Bearish regime (trend_score < 0)
// â€¢ Width: Â± 0.5 ATR from EMA8
// â€¢ Opacity: Scales with trend strength
//
// Acts as visual "energy field" showing market state at a glance.
//
// âš¡ ENERGY RADIANCE: Signal Intensity Visualization
//
// On signal trigger, renders concentric boxes around entry:
//
// â€¢ Layers: 1-5 boxes (based on glow_intensity setting)
// â€¢ Width: Expands outward by 0.3 ATR per layer
// â€¢ Color: Bull (cyan) or bear (magenta) based on direction
// â€¢ Opacity: Increases per layer (creates glow effect)
//
// Visually emphasizes high-conviction signalsâ€”bigger glow = stronger signal.
//
// ğŸ¯ PROBABILITY CONES: Trajectory Projections
//
// Projects expected price path for 15 bars:
//
// â€¢ Center line: Expected trajectory (direction Ã— ATR Ã— bars Ã— 0.4)
// â€¢ Cone width: Uncertainty band (ATR Ã— singularity_strength)
// â€¢ Narrows with higher confidence
// â€¢ Widens with lower confidence
//
// Think: "navigation cone" showing probable destination zone.
//
// ğŸ”— CONNECTION LINES: Signal Correlation Tracker
//
// Links consecutive signals showing:
//
// â€¢ SOLID line: Same direction (trend continuation)
// â€¢ DOTTED line: Opposite direction (reversal)
// â€¢ Color: Accent color (defaults to neon pink)
// â€¢ Connects: Last signal price to current signal price
//
// Reveals whether system is trend-following or mean-reverting in current regime.
//
// ğŸ¯ KILL ZONES: Trade Management Boxes
//
// On signal, renders target box showing:
//
// â€¢ Entry: Current close
// â€¢ Stop loss: Â± 1.5 ATR
// â€¢ Target 1: Â± 2.0 ATR
// â€¢ Target 2: Â± 3.5 ATR
//
// Box extends 20 bars forward, fades after signal closes.
// Label shows signal direction + confidence %.
//
// ğŸ“Š DASHBOARD: Real-Time Intelligence Panel
//
// Top display (customizable position) showing:
//
// 1. REGIME: Current trend state (Strong Bull/Bear, Weak Bull/Bear)
// 2. MODE: Auto (algorithm + mode) or Manual (Consensus)
// 3. AGENT TABLE:
//    â€¢ Name (4 agents)
//    â€¢ Win Rate %
//    â€¢ Current confidence (bar graph)
//    â€¢ Memory size
//    â€¢ HIGHLIGHTED row = currently selected agent (in Switch mode)
// 4. QUANTUM METRICS: VPIN toxicity, Kyle's Lambda institutional footprint
// 5. SIGNAL STATUS: Current state (LONG/SHORT/CONFIRMING/WAITING)
//
// This is your cockpitâ€”monitor agent performance and system state at a glance.
//
// ğŸ’¾ MEMORY EXPORT PANEL: Parameter Persistence
//
// Bottom-right panel (optional) displaying:
//
// â€¢ Agent alpha/beta values (Bayesian parameters)
// â€¢ Adapted quantum sensitivities (VPIN, Kyle)
// â€¢ Status: "RESTORED" (if loaded from saved) or "SAVE THESE" (current state)
//
// Copy these values to inputs for future sessionsâ€”transfer learned intelligence.
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ¯ TRADING STRATEGIES & WORKFLOWS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// ğŸš€ QUICK START (First Week)
//
// Day 1-3: Observation Mode
// 1. Add indicator to your main trading instrument
// 2. Use "Balanced" mode, enable all visuals
// 3. Watch signals but DON'T TRADE yet
// 4. Observe:
//    â€¢ Which agents trigger most often
//    â€¢ Win rates developing in dashboard
//    â€¢ How signals align with price action
//
// Day 4-7: Paper Trading
// 1. Take signals on paper/simulator
// 2. Monitor agent performance
// 3. Note which agents work best on your instrument/timeframe
// 4. Consider adjusting agent sensitivity sliders
//
// Week 2+: Live Trading (Small Size)
// 1. Enable auto mode if agent performance differentiated (>15% win rate spread)
// 2. Start with 25% of normal size
// 3. Gradually increase as confidence builds
// 4. Export memory parameters after 50+ signals
//
// ğŸšï¸ MODE SELECTION GUIDE
//
// CONSERVATIVE:
// â€¢ Best for: Swing trading, volatile instruments, new users
// â€¢ Characteristics: 4-bar confirmation, 15-bar cooldown, 85% consensus
// â€¢ Trade frequency: 2-8 signals per week
// â€¢ Win rate expectation: 65-75% (high quality, low quantity)
//
// BALANCED: â­ RECOMMENDED
// â€¢ Best for: Day trading, most timeframes, experienced traders
// â€¢ Characteristics: 3-bar confirmation, 10-bar cooldown, 70% consensus
// â€¢ Trade frequency: 5-15 signals per week
// â€¢ Win rate expectation: 55-65% (balanced)
//
// AGGRESSIVE:
// â€¢ Best for: Scalping, highly liquid instruments, active traders
// â€¢ Characteristics: 2-bar confirmation, 5-bar cooldown, 60% consensus
// â€¢ Trade frequency: 10-30 signals per week
// â€¢ Win rate expectation: 50-60% (lower win rate, more opportunities)
//
// ELITE:
// â€¢ Custom tuned between Balanced and Conservative
// â€¢ Use after understanding system deeply
//
// QUANTUM:
// â€¢ Experimentalâ€”very sensitive quantum metrics
// â€¢ Use only on highly liquid instruments (SPY, ES, EURUSD, BTC)
//
// ğŸ¤– AUTO MODE VS MANUAL MODE
//
// MANUAL MODE (Auto disabled):
// â€¢ All 4 agents vote simultaneously
// â€¢ Weighted consensus determines signal
// â€¢ Best for: Beginners, stable regimes, diversification
// â€¢ Pros: Smoother, less whipsaw, multiple perspectives
// â€¢ Cons: Slower to adapt, can miss regime-specific edges
//
// AUTO MODE (Recommended after week 1):
// â€¢ Bandit algorithm selects best agent(s)
// â€¢ System learns optimal strategy per regime
// â€¢ Best for: Experienced users, regime-shifting markets
// â€¢ Pros: Adapts automatically, exploits discovered edges
// â€¢ Cons: Can overfit if insufficient data, requires monitoring
//
// SWITCH MODE (within Auto):
// â€¢ Use only the currently best agent
// â€¢ Decisive, clean, easy to interpret
// â€¢ Best for: Lower-frequency trading (4H+), clear regimes
//
// BLEND MODE (within Auto):
// â€¢ Weight all agents by learned probabilities
// â€¢ Smooth transitions, robust to uncertainty
// â€¢ Best for: Higher-frequency (5m-1H), ambiguous regimes
//
// ğŸ“Š BANDIT ALGORITHM SELECTION
//
// THOMPSON SAMPLING: â­ DEFAULT RECOMMENDED
// â€¢ Best all-around performer
// â€¢ Adapts quickly to regime changes
// â€¢ Naturally balances exploration/exploitation
// â€¢ Use for: Crypto, forex, volatile stocks
//
// UCB1:
// â€¢ More conservative than Thompson
// â€¢ Deterministic (repeatable)
// â€¢ Use for: Trending markets, stable regimes, backtesting
//
// EPSILON-GREEDY:
// â€¢ Simple, intuitive
// â€¢ Increase epsilon (to 0.2-0.3) for fast-changing markets
// â€¢ Use for: Learning how bandits work, high-volatility periods
//
// GRADIENT BANDIT:
// â€¢ Best for blend mode
// â€¢ Learns smooth mixture weights
// â€¢ Use for: Multi-strategy portfolios, unclear regime states
//
// ğŸ¯ AGENT SENSITIVITY TUNING
//
// After observing performance for 50+ signals, adjust agent sensitivities:
//
// INCREASE sensitivity (1.2-2.0) if:
// â€¢ Agent has high win rate (>65%) but low trigger frequency
// â€¢ Agent missing obvious setups you can see
// â€¢ You want more signals from this agent
//
// DECREASE sensitivity (0.5-0.9) if:
// â€¢ Agent has low win rate (<45%)
// â€¢ Agent triggering too often on noise
// â€¢ You want to filter this agent more strictly
//
// DISABLE agent entirely (sensitivity = 0) if:
// â€¢ Consistently underperforming (<40% after 30+ signals)
// â€¢ Not suited to your instrument (e.g., StatArb fails on trending crypto)
//
// ğŸ§¬ QUANTUM FEATURE USAGE
//
// Enable ALL quantum features (VPIN, Kyle, Entropy, Hawkes) by default.
//
// Disable individually only if:
// â€¢ VPIN: Low volume instrument (<100k shares/day) - calculations unreliable
// â€¢ Kyle's Lambda: No institutional activity (penny stocks, obscure pairs)
// â€¢ Entropy: Ultra-low volatility (bonds, pegged currencies)
// â€¢ Hawkes: Instrument without clustering behavior (random walk assets)
//
// Generally: If liquid and volatile, keep all enabled.
//
// ğŸ“ˆ MULTI-TIMEFRAME STRATEGY
//
// For maximum edge, use AP-ML across 2 timeframes:
//
// HIGHER TF (Directional Bias):
// â€¢ 4H or Daily chart
// â€¢ Determines: Bull/Bear regime
// â€¢ Rule: Only trade in direction of higher TF trend
//
// LOWER TF (Execution):
// â€¢ 15m or 1H chart
// â€¢ Determines: Entry timing
// â€¢ Rule: Take signals only when aligned with higher TF
//
// Example:
// â€¢ Daily: Dashboard shows "ğŸŸ¢ STRONG BULL"
// â€¢ 1H: Wait for LONG signal from system
// â€¢ Ignore: Any SHORT signals on 1H
// â€¢ Exit: When Daily flips to weak/bear, or 1H gives opposite signal
//
// ğŸ’° RISK MANAGEMENT
//
// POSITION SIZING:
// â€¢ Use 1-2% risk per signal
// â€¢ Stop loss: 1.5 ATR from entry (shown in kill zone box)
// â€¢ Tighter stops: 1.0 ATR in Conservative mode
// â€¢ Wider stops: 2.0 ATR in Aggressive mode
//
// PROFIT TARGETS:
// â€¢ Target 1: 2.0 ATR (2:1 R:R) - Take partial (50%)
// â€¢ Target 2: 3.5 ATR (3.5:1 R:R) - Take remainder
// â€¢ Trailing stop: After T1 hit, trail stop at breakeven or T1 level
//
// CORRELATION LIMITS:
// â€¢ Max 3 simultaneous AP-ML signals across portfolio
// â€¢ No more than 2 signals on correlated pairs (e.g., EURUSD + GBPUSD)
// â€¢ Respect aggregate risk across all positions
//
// ğŸš« WHEN NOT TO TRADE
//
// Pause trading if:
// â€¢ All agents showing <45% win rate (regime unknown, let system re-learn)
// â€¢ Major news event in next 2 hours (fundamental override)
// â€¢ Dashboard shows "CONFIRMING" for >5 bars (indecision)
// â€¢ Kill zones from last 3 signals all hit stops (clearly wrong regime)
// â€¢ Institutional window closed + low volume (illiquid conditions)
//
// ğŸ“Š PERFORMANCE EXPECTATIONS
//
// Realistic targets (after 100+ signals on appropriate timeframe):
//
// CONSERVATIVE MODE:
// â€¢ Win rate: 60-70%
// â€¢ Avg R:R: 2:1
// â€¢ Signals/week: 3-8
// â€¢ Expectancy: 0.4-0.6R per trade
//
// BALANCED MODE:
// â€¢ Win rate: 55-65%
// â€¢ Avg R:R: 1.8:1
// â€¢ Signals/week: 8-15
// â€¢ Expectancy: 0.3-0.5R per trade
//
// AGGRESSIVE MODE:
// â€¢ Win rate: 50-58%
// â€¢ Avg R:R: 1.5:1
// â€¢ Signals/week: 15-30
// â€¢ Expectancy: 0.2-0.3R per trade
//
// âš ï¸ If underperforming targets after 50+ signals, consider:
// 1. Wrong mode for your timeframe (try one level more conservative)
// 2. Wrong timeframe for instrument (try 4H/1D instead of 15m/1H)
// 3. Instrument not suitable (try more liquid alternatives)
// 4. Tune agent sensitivities based on dashboard performance
//
// ğŸ’¡ ADVANCED TECHNIQUES
//
// ğŸ”¬ MEMORY TRANSFER LEARNING:
// â€¢ Train system on high-liquidity instrument (SPY, ES, BTCUSD)
// â€¢ Export memory parameters
// â€¢ Apply to correlated lower-liquidity instrument
// â€¢ Speeds up learning on new instruments
//
// ğŸ¨ THEME-BASED REGIME DETECTION:
// â€¢ Neon theme: Crypto/high-volatility
// â€¢ Cyber theme: Algo-heavy markets
// â€¢ Dark theme: Traditional markets
// â€¢ Light theme: Lower-volatility instruments
// â€¢ Not just aestheticâ€”visual cues help pattern recognition
//
// ğŸ§® AGENT SPECIALIZATION TRACKING:
// â€¢ After 100 signals, note which agent dominates each regime
// â€¢ Spoof Hunter: Consolidations
// â€¢ Momentum Exhaust: Trend exhaustion
// â€¢ Liquidity Void: Breakouts
// â€¢ StatArb: Ranges
// â€¢ Use this knowledge to anticipate regime shifts
//
// ğŸ“ˆ ADAPTIVE PARAMETER ADJUSTMENT:
// â€¢ Quantum metrics auto-adapt (VPIN sensitivity, Kyle threshold)
// â€¢ Monitor in Memory Export panel
// â€¢ If adapted values drift >50% from defaults, market regime changed
// â€¢ Consider resetting memory and re-training
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ† CONCLUSION: INTELLIGENCE AMPLIFICATION
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// Algorithm Predator is not a holy grailâ€”it's an intelligence amplification tool.
//
// The system doesn't predict the future. It recognizes microstructure patterns
// that statistical edge has historically exploited, and dynamically allocates
// capital to whichever pattern-recognition strategy is currently working.
//
// Your role:
// â€¢ Select appropriate timeframe and mode
// â€¢ Monitor agent performance
// â€¢ Tune sensitivities based on results
// â€¢ Apply proper risk management
// â€¢ Respect the signals, but think independently
//
// The machine learns from markets. You learn from the machine. Together, you
// build an adaptive trading intelligence that evolves with market regime.
//
// This is the future of systematic tradingâ€”not curve-fit black boxes, but
// transparent, interpretable, adaptive learning systems that show their work.
//
// ğŸŒŠ Dskyz (DAFE) Trading Systems
//
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
