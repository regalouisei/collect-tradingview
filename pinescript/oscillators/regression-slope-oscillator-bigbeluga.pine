// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// © BigBeluga

//@version=6
indicator("Regression Slope Oscillator [BigBeluga]", overlay = false)



// ＩＮＰＵＴＳ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
maxRange = input.int(100, "Max Range")
minRange = input.int(10, "Min Range")
step     = input.int(5, "Step")
sigLine  = input.int(7, "Signal Line")
colorRange = input.int(100, "Color Range", inline = "color")
obColor = input.color(color.aqua, "", inline = "color")
oscolor = input.color(color.orange, "", inline = "color")

slopAvg     = array.new<float>()
var min_max = array.new<float>()
var dash = table.new(position.top_right, 100, 100, force_overlay = true)

// }


// ＣＡＬＣＵＬＡＴＩＯＮＳ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
f_log_regression(src, length) =>
    float sumX      = 0.0
    float sumY      = 0.0
    float sumXSqr   = 0.0
    float sumXY     = 0.0

    for i = 0 to length - 1
        val = math.log(src[i])
        per = i + 1.0
        sumX += per
        sumY += val
        sumXSqr += per * per
        sumXY += val * per

    slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - sumX * sumX)

    slope*-1


multiSlope(length)=>
    // Get regression slope
    slope = f_log_regression(close, length)
    slopAvg.push(slope)

for i = minRange to maxRange by step
    multiSlope(i)


slopeOscillator = slopAvg.avg()
min_max.push(slopeOscillator)

trendColor = color.from_gradient(slopeOscillator, min_max.min(), min_max.max(), oscolor, obColor)

if min_max.size() > colorRange
    min_max.shift()

sigL = ta.sma(slopeOscillator, sigLine)
// }


// ＰＬＯＴ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
if barstate.islast
    samples = math.floor((maxRange-minRange)/step)
    table.cell(dash, 0, 0, "Samples Amount", text_color = chart.fg_color)
    table.cell(dash, 1, 0, str.tostring(samples), text_color = chart.fg_color)

    table.cell(dash, 0, 1, "Slopes Avg", text_color = chart.fg_color)
    table.cell(dash, 1, 1, str.tostring(slopeOscillator), text_color = trendColor)



barcolor(trendColor)
plotcandle(open, high, low, close, title='Candle Color', color = trendColor, wickcolor=trendColor, bordercolor = trendColor, force_overlay = true )

pslope = plot(slopeOscillator, "Oscillator", color = color.new(trendColor, 0), linewidth = 2)
p0 = plot(0, "Zero Line", color = chart.fg_color, display = display.none, editable = false)
plot(sigL, "Signal Line", color = chart.fg_color)
hline(0)
fill(pslope, p0, slopeOscillator, 0, color.new(trendColor, 50), color(na))



plotshape(ta.crossunder(slopeOscillator, sigL) and barstate.isconfirmed and slopeOscillator > 0 ? slopeOscillator : float(na)
        , "Reversal Down"
        , shape.circle
        , location.absolute
        , chart.fg_color
        , 0
        , size = size.tiny)

plotshape(ta.crossunder(slopeOscillator, sigL) and barstate.isconfirmed and slopeOscillator > 0 ? high : float(na)
        , "Reversal Down"
        , shape.circle
        , location.abovebar
        , chart.fg_color
        , 0
        , size = size.tiny, force_overlay = true)

plotshape(ta.crossover(slopeOscillator, sigL) and barstate.isconfirmed and slopeOscillator < 0 ? slopeOscillator : float(na)
        , "Reversal Up"
        , shape.circle
        , location.absolute
        , chart.fg_color
        , 0
        , size = size.tiny)

plotshape(ta.crossover(slopeOscillator, sigL) and barstate.isconfirmed and slopeOscillator < 0 ? low : float(na)
        , "Reversal Up"
        , shape.circle
        , location.belowbar
        , chart.fg_color
        , 0
        , size = size.tiny, force_overlay = true)
// }
