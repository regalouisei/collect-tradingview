// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© BackQuant

//@version=6
indicator("Ehlers Super Smoother Trend Score [BackQuant]", shorttitle = "Ehlers SS Trend Score [BackQuant]", overlay=false)

// Constants
const string calc   = "Core Calculation Settings"
const string thres  = "Signal Settings"
const string ui     = "Plotting and Coloring"
const color  GREEN  = #00ff00
const color  RED    = #ff0000

// Inputs
float  src          = input.source(close, "Source", group=calc)
int    ssPeriod     = input.int(2, "Super Smoother Period", minval=2, group=calc, tooltip="Cutoff period for the Ehlers Super Smoother. Lower = faster but noisier, higher = smoother but more lag. The filter eliminates Nyquist aliasing unlike standard MAs.")
int    poles        = input.int(3, "Poles", options=[2, 3], group=calc, tooltip="Filter order. 2-pole is the classic. 3-pole gives heavier smoothing at the cost of slightly more lag.")
int    scoreStart   = input.int(1, "Score Lookback Start", inline="SL", group=calc)
int    scoreEnd     = input.int(45, "End", maxval=50, inline="SL", group=calc, tooltip="Range of bars for the directional persistence score.")

bool   showRefs     = input.bool(true, "Show Reference Lines", group=thres)
bool   showSignals  = input.bool(true, "Show Signals on Chart?", group=thres)
int    longThres    = input.int(40, "Long Threshold", group=thres, inline="TH")
int    shortThres   = input.int(-10, "Short Threshold", group=thres, inline="TH")

color  longCol      = input.color(GREEN, "Long Color", group=ui, inline="col")
color  shortCol     = input.color(RED, "Short Color", group=ui, inline="col")
int    lineW        = input.int(5, "Line Width", group=ui)
bool   showSmooth   = input.bool(true, "Show Super Smoother on Chart?", group=ui)
bool   paintCandles = input.bool(false, "Paint Candles to Trend?", group=ui)
bool   bgCol        = input.bool(false, "Background Color?", group=ui)

// Helpers
method transp(color x, int t) =>
    color.new(x, t)

/////////////////////////////////////////////////////////////// ¬© BackQuant ///////////////////////////////////////////////////////////////
// Types
type SuperSmootherTS
    float c1 = 0.0
    float c2 = 0.0
    float c3 = 0.0
    float c4 = 0.0
    int   numPoles = 2
    float filt = na
    float prevFilt1 = na
    float prevFilt2 = na
    float prevFilt3 = na
    float score = 0.0
    float prevScore = 0.0
    int   signal = 0

/////////////////////////////////////////////////////////////// ¬© BackQuant ///////////////////////////////////////////////////////////////
// Methods

// Initialize Butterworth coefficients from Ehlers' derivation
method init(SuperSmootherTS this, float initSrc, int period, int nPoles) =>
    this.numPoles := nPoles
    if nPoles == 2
        float a = math.exp(-math.sqrt(2) * math.pi / period)
        float b = 2.0 * a * math.cos(math.sqrt(2) * math.pi / period)
        this.c2 := b
        this.c3 := -a * a
        this.c1 := 1.0 - this.c2 - this.c3
    else
        float a = math.exp(-math.pi / period)
        float b = 2.0 * a * math.cos(1.738 * math.pi / period)
        float c = a * a
        this.c2 := b + c
        this.c3 := -(c + b * c)
        this.c4 := c * c
        this.c1 := 1.0 - this.c2 - this.c3 - this.c4
    this.filt      := initSrc
    this.prevFilt1 := initSrc
    this.prevFilt2 := initSrc
    this.prevFilt3 := initSrc
    this

// Recursive Super Smoother with anti-aliasing pre-filter
method smooth(SuperSmootherTS this, float src) =>
    float avg = (src + nz(src[1], src)) / 2.0
    this.prevFilt3 := this.prevFilt2
    this.prevFilt2 := this.prevFilt1
    this.prevFilt1 := this.filt
    if this.numPoles == 2
        this.filt := this.c1 * avg + this.c2 * this.prevFilt1 + this.c3 * this.prevFilt2
    else
        this.filt := this.c1 * avg + this.c2 * this.prevFilt1 + this.c3 * this.prevFilt2 + this.c4 * this.prevFilt3
    this

// Threshold + crossunder signal logic
method updateSignal(SuperSmootherTS this, int longT, int shortT) =>
    bool longCond  = this.score > longT
    bool shortCond = this.prevScore >= shortT and this.score < shortT
    if longCond and not shortCond
        this.signal := 1
    else if shortCond
        this.signal := -1
    this

method getColor(SuperSmootherTS this) =>
    this.signal == 1 ? longCol : shortCol

/////////////////////////////////////////////////////////////// ¬© BackQuant ///////////////////////////////////////////////////////////////
// Instantiation
var SuperSmootherTS ss = SuperSmootherTS.new()

if barstate.isfirst
    ss.init(src, ssPeriod, poles)

ss.smooth(src)

// Score the Super Smoother's directional persistence directly
float filtSeries = ss.filt
float scoreS = 0.0
for i = scoreStart to scoreEnd
    scoreS += (filtSeries > filtSeries[i] ? 1.0 : -1.0)

ss.prevScore := ss.score
ss.score     := scoreS
ss.updateSignal(longThres, shortThres)

// Color state
color col = ss.getColor()

/////////////////////////////////////////////////////////////// ¬© BackQuant ///////////////////////////////////////////////////////////////
// Plotting

// Score line in pane
plot(ss.score, "Trend Score", col, lineW)

// Reference lines
if barstate.islast and showRefs
    line.new(last_bar_index, longThres, bar_index - 1, longThres, color=chart.fg_color.transp(50), style=line.style_dashed, extend=extend.right)
    line.new(last_bar_index, shortThres, bar_index - 1, shortThres, color=chart.fg_color.transp(50), style=line.style_dashed, extend=extend.right)

// Super Smoother on chart
plot(ss.filt, "Super Smoother", col, 2, plot.style_line, force_overlay=true,
     display=showSmooth ? display.all : display.none)

// Candle painting
plotcandle(open, high, low, close, "Trend Candles",
     col, col, true,
     bordercolor=col,
     display=paintCandles ? display.all : display.none, force_overlay=true)

// Background
bgcolor(bgCol ? col.transp(80) : na, force_overlay=true)

// Signals
int sigS = ss.signal
plotshape(sigS == 1 and sigS[1] == -1, "Long Signal", shape.triangleup, location.belowbar, longCol, 0, "ùïÉ", longCol, true, size.small,
     display=showSignals ? display.all : display.none, force_overlay=true)
plotshape(sigS == -1 and sigS[1] == 1, "Short Signal", shape.triangledown, location.abovebar, shortCol, 0, "ùïä", shortCol, true, size.small,
     display=showSignals ? display.all : display.none, force_overlay=true)

/////////////////////////////////////////////////////////////// ¬© BackQuant ///////////////////////////////////////////////////////////////
// Alerts
alertcondition(sigS == 1 and sigS[1] == -1, title="SS Trend Score Long", message="Ehlers SS Trend Score Long {{exchange}}:{{ticker}}")
alertcondition(sigS == -1 and sigS[1] == 1, title="SS Trend Score Short", message="Ehlers SS Trend Score Short {{exchange}}:{{ticker}}")
