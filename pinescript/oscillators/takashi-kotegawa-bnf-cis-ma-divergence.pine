// This Pine Script® code is subject to the Mozilla Public License 2.0
// © BNF Kotegawa — MA Divergence Strategy (Fixed)
//
// Core BNF method: price fallen far BELOW 25MA = buy, exit when it returns to MA
// Fixes vs prior version:
//   - Removed conflicting strategy.close + strategy.exit on same position
//   - MA-return exit now only fires when price crossed MA (not just touched)
//   - entryRef race condition fixed with separate tracking var
//   - Shorts disabled by default (Gold is in uptrend — shorts were killing P&L)
//   - ATR-based SL/TP replaces fixed % (adapts to Gold's actual volatility)
//   - Volume filter removed as optional (Gold spot volume unreliable on some feeds)
//
// Additional fixes for negative P&L:
//   - Reduced commission to a more realistic 0.001% (IC Markets raw spread for gold is ~0.0014% equivalent per round turn)
//   - Changed default exit mode to "ATR TP/SL" for adaptive risk management
//   - Increased long divergence threshold to 0.15% to ensure larger potential profits exceeding costs
//   - Lowered RSI max for longs to 40 for stronger oversold filter
//   - Enabled reversal candle filter by default to reduce false entries

//@version=6
strategy(
     title                   = "BNF MA Divergence [Fixed]",
     shorttitle              = "BNF MAD",
     overlay                 = true,
     pyramiding              = 0,
     default_qty_type        = strategy.percent_of_equity,
     default_qty_value       = 10,
     commission_type         = strategy.commission.percent,
     commission_value        = 0.001,
     slippage                = 2,
     process_orders_on_close = false,
     use_bar_magnifier       = true
)

// ═══════════════════════════════════════════════
//  INPUTS
// ═══════════════════════════════════════════════

// ① MA Settings
i_ma25Len  = input.int(25,  "Core MA (BNF = 25)",          group = "① MAs")
i_ma75Len  = input.int(75,  "Slow MA",                     group = "① MAs")
i_ma200Len = input.int(200, "Trend MA (0 = disable)",      group = "① MAs")

// ② MA Divergence — core signal
// Gold 1m typically moves 0.05–0.20% from its 25MA on pullbacks
// Use the "vs MA25" row in the table to observe real values, then set threshold
i_longDiv  = input.float(0.15, "Long:  min % BELOW MA25",  group = "② Divergence", minval = 0.01, step = 0.01,
     tooltip = "Watch the table's 'vs MA25' value during pullbacks and set this just below that level.")
i_shortDiv = input.float(0.10, "Short: min % ABOVE MA25",  group = "② Divergence", minval = 0.01, step = 0.01)

// ③ Exit
i_exitMode = input.string("ATR TP/SL", "Exit Mode",
     options = ["MA Cross", "Fixed TP/SL", "ATR TP/SL"],  group = "③ Exit",
     tooltip = "MA Cross = exit when price crosses back through MA25 (BNF's method). ATR = adaptive.")
i_tp       = input.float(0.5,  "Fixed TP %",               group = "③ Exit", minval = 0.05, step = 0.05)
i_sl       = input.float(0.25, "Fixed SL %",               group = "③ Exit", minval = 0.05, step = 0.05)
i_atrLen   = input.int(14,     "ATR Length",               group = "③ Exit")
i_atrTP    = input.float(2.0,  "ATR TP Multiplier",        group = "③ Exit", step = 0.1)
i_atrSL    = input.float(1.0,  "ATR SL Multiplier",        group = "③ Exit", step = 0.1)

// ④ Filters
i_rsiLen   = input.int(14,    "RSI Length",                group = "④ Filters")
i_rsiOS    = input.float(40,  "RSI Max for Long",          group = "④ Filters", minval = 10, maxval = 70,
     tooltip = "50 = price pulling back but not necessarily extreme. Tighten to 40 for stronger filter.")
i_rsiOB    = input.float(50,  "RSI Min for Short",         group = "④ Filters", minval = 30, maxval = 90)
i_useVol   = input.bool(false, "Require Volume Spike",     group = "④ Filters",
     tooltip = "Disable for Gold spot — volume data is unreliable on many Gold feeds.")
i_volLen   = input.int(20,    "Volume MA Length",          group = "④ Filters")
i_volMult  = input.float(1.5, "Volume Multiplier",         group = "④ Filters", step = 0.1)
i_useCandle= input.bool(true, "Require Reversal Candle",  group = "④ Filters",
     tooltip = "Strict candle filter. Disable if too few signals appear.")

// ⑤ Session
i_useSess  = input.bool(true,         "Session Filter",   group = "⑤ Session")
i_sess     = input.session("0200-2200","Session",         group = "⑤ Session")

// ⑥ Direction — shorts OFF by default (Gold in uptrend)
i_long     = input.bool(true,  "Enable Long",             group = "⑥ Direction")
i_short    = input.bool(false, "Enable Short",            group = "⑥ Direction",
     tooltip = "Keep OFF for instruments in a strong uptrend like Gold. Enable only in downtrends.")

// ═══════════════════════════════════════════════
//  CALCULATIONS
// ═══════════════════════════════════════════════
ma25   = ta.sma(close, i_ma25Len)
ma75   = ta.sma(close, i_ma75Len)
ma200  = ta.sma(close, i_ma200Len)
rsi    = ta.rsi(close, i_rsiLen)
atr    = ta.atr(i_atrLen)
volAvg = ta.sma(volume, i_volLen)

// Core divergence measurement
pctVsMA  = (close - ma25) / ma25 * 100
belowPct = -pctVsMA   // positive when below
abovePct =  pctVsMA   // positive when above

// Trend
trendUp   = i_ma200Len == 0 or close > ma200
trendDown = i_ma200Len == 0 or close < ma200

// Volume
volOk = not i_useVol or volume > volAvg * i_volMult

// Candle
body     = math.abs(close - open)
loShad   = math.min(close, open) - low
hiShad   = high - math.max(close, open)
hammer   = body > 0 and loShad >= 1.5 * body and hiShad <= body * 0.5
bullEng  = close > open and close > high[1] and open <= close[1]
shootStar= body > 0 and hiShad >= 1.5 * body and loShad <= body * 0.5
bearEng  = close < open and close < low[1]  and open >= close[1]
bullCdl  = not i_useCandle or (hammer or bullEng)
bearCdl  = not i_useCandle or (shootStar or bearEng)

// Session
inSess = i_useSess ? not na(time("", i_sess)) : true

// MA25 cross (for exit)
crossAboveMA25 = ta.crossover(close,  ma25)
crossBelowMA25 = ta.crossunder(close, ma25)

// ═══════════════════════════════════════════════
//  ENTRY CONDITIONS
// ═══════════════════════════════════════════════
noPos  = strategy.position_size == 0
isLong = strategy.position_size > 0
isSht  = strategy.position_size < 0

lDiv = belowPct >= i_longDiv
lRsi = rsi     <= i_rsiOS
sDiv = abovePct >= i_shortDiv
sRsi = rsi     >= i_rsiOB

goLong  = i_long  and lDiv and lRsi and bullCdl and volOk and trendUp   and inSess and noPos
goShort = i_short and sDiv and sRsi and bearCdl and volOk and trendDown and inSess and noPos

// ═══════════════════════════════════════════════
//  ENTRY PRICE TRACKING (clean — no race condition)
// ═══════════════════════════════════════════════
var float ep      = na   // entry price
var bool  longOn  = false
var bool  shortOn = false

if goLong
    strategy.entry("Long",  strategy.long)
    longOn  := true
    shortOn := false

if goShort
    strategy.entry("Short", strategy.short)
    shortOn := true
    longOn  := false

// Capture entry price one bar after entry fires
if longOn and isLong and na(ep)
    ep := strategy.position_avg_price

if shortOn and isSht and na(ep)
    ep := strategy.position_avg_price

if noPos
    ep      := na
    longOn  := false
    shortOn := false

// ═══════════════════════════════════════════════
//  EXITS — unified, no conflicts
// ═══════════════════════════════════════════════
if isLong and not na(ep)
    tp = i_exitMode == "Fixed TP/SL" ? ep * (1 + i_tp / 100)  :
         i_exitMode == "ATR TP/SL"   ? ep + atr * i_atrTP     : na
    sl = i_exitMode == "Fixed TP/SL" ? ep * (1 - i_sl / 100)  :
         i_exitMode == "ATR TP/SL"   ? ep - atr * i_atrSL     : ep * (1 - i_sl / 100)

    if i_exitMode == "MA Cross"
        // Exit when price crosses back up through MA25 (mean reversion complete)
        if crossAboveMA25
            strategy.close("Long", comment = "MA Cross")
        else
            strategy.exit("Long SL", "Long", stop = sl)
    else
        strategy.exit("Long Exit", "Long", limit = tp, stop = sl)

if isSht and not na(ep)
    tp = i_exitMode == "Fixed TP/SL" ? ep * (1 - i_tp / 100)  :
         i_exitMode == "ATR TP/SL"   ? ep - atr * i_atrTP     : na
    sl = i_exitMode == "Fixed TP/SL" ? ep * (1 + i_sl / 100)  :
         i_exitMode == "ATR TP/SL"   ? ep + atr * i_atrSL     : ep * (1 + i_sl / 100)

    if i_exitMode == "MA Cross"
        if crossBelowMA25
            strategy.close("Short", comment = "MA Cross")
        else
            strategy.exit("Short SL", "Short", stop = sl)
    else
        strategy.exit("Short Exit", "Short", limit = tp, stop = sl)

// Session end close
if i_useSess and (isLong or isSht)
    if not inSess
        strategy.close_all(comment = "Session End")

// ═══════════════════════════════════════════════
//  VISUALS
// ═══════════════════════════════════════════════
plot(ma25,  "MA 25",  color.new(color.orange, 0),  linewidth = 2)
plot(ma75,  "MA 75",  color.new(color.red,    20), linewidth = 1)
plot(i_ma200Len > 0 ? ma200 : na, "MA 200", color.new(color.blue, 30), linewidth = 2)

// Shade when price is in the divergence zone (stretched from MA)
bgcolor(lDiv and inSess and not isLong ? color.new(color.green, 90) : na, title = "Long Zone")
bgcolor(sDiv and inSess and not isSht  ? color.new(color.red,   90) : na, title = "Short Zone")
bgcolor(goLong  ? color.new(color.green, 65) : na, title = "Long Entry")
bgcolor(goShort ? color.new(color.red,   65) : na, title = "Short Entry")

plotshape(goLong,  style = shape.labelup,   location = location.belowbar,
     color = color.new(color.green, 5), textcolor = color.white, text = "BNF\nBUY",  size = size.small)
plotshape(goShort, style = shape.labeldown, location = location.abovebar,
     color = color.new(color.red,   5), textcolor = color.white, text = "BNF\nSELL", size = size.small)

// Active TP/SL lines
var line tpLine = na
var line slLine = na

if (isLong or isSht) and not na(ep)
    tpVal = i_exitMode == "ATR TP/SL" ? (isLong ? ep + atr * i_atrTP : ep - atr * i_atrTP)
          : i_exitMode == "Fixed TP/SL"? (isLong ? ep * (1 + i_tp/100): ep * (1 - i_tp/100))
          : na
    slVal = isLong ? (i_exitMode == "ATR TP/SL" ? ep - atr * i_atrSL : ep * (1 - i_sl/100))
                   : (i_exitMode == "ATR TP/SL" ? ep + atr * i_atrSL : ep * (1 + i_sl/100))

    if not na(tpVal)
        if na(tpLine)
            tpLine := line.new(bar_index, tpVal, bar_index+1, tpVal, color=color.green, style=line.style_dashed, extend=extend.right)
        else
            line.set_y1(tpLine, tpVal), line.set_y2(tpLine, tpVal)
    if na(slLine)
        slLine := line.new(bar_index, slVal, bar_index+1, slVal, color=color.red, style=line.style_dashed, extend=extend.right)
    else
        line.set_y1(slLine, slVal), line.set_y2(slLine, slVal)
else
    line.delete(tpLine), tpLine := na
    line.delete(slLine), slLine := na

// ═══════════════════════════════════════════════
//  INFO TABLE
// ═══════════════════════════════════════════════
var table tbl = table.new(
     position.top_right, 3, 10,
     bgcolor=color.new(color.black,60), border_color=color.new(color.gray,50),
     border_width=1, frame_color=color.new(color.gray,50), frame_width=1
)
cOk = color.lime
cNo = color.new(color.silver, 30)
cHd = color.new(color.navy,   20)

if barstate.islast
    divStr  = str.tostring(math.round(math.abs(pctVsMA), 3)) + "%"
    dirStr  = pctVsMA < 0 ? "BELOW" : "ABOVE"
    divCol  = pctVsMA < 0 ? (lDiv ? cOk : cNo) : (sDiv ? cOk : cNo)

    table.cell(tbl,0,0,"BNF MAD",        text_color=color.white,bgcolor=cHd,text_size=size.small)
    table.cell(tbl,1,0,"LONG",           text_color=color.lime, bgcolor=cHd,text_size=size.small)
    table.cell(tbl,2,0,"SHORT",          text_color=color.red,  bgcolor=cHd,text_size=size.small)

    table.cell(tbl,0,1,"vs MA25",        text_color=cNo,text_size=size.small)
    table.cell(tbl,1,1,dirStr+" "+divStr,text_color=divCol,text_size=size.small)
    table.cell(tbl,2,1,dirStr+" "+divStr,text_color=divCol,text_size=size.small)

    table.cell(tbl,0,2,"Need",           text_color=cNo,text_size=size.small)
    table.cell(tbl,1,2,str.tostring(i_longDiv) +"%↓",text_color=cNo,text_size=size.small)
    table.cell(tbl,2,2,str.tostring(i_shortDiv)+"%↑",text_color=cNo,text_size=size.small)

    table.cell(tbl,0,3,"RSI",            text_color=cNo,text_size=size.small)
    table.cell(tbl,1,3,str.tostring(math.round(rsi,1)),text_color=lRsi?cOk:cNo,text_size=size.small)
    table.cell(tbl,2,3,str.tostring(math.round(rsi,1)),text_color=sRsi?cOk:cNo,text_size=size.small)

    table.cell(tbl,0,4,"Candle",         text_color=cNo,text_size=size.small)
    table.cell(tbl,1,4,bullCdl?"OK":"NO",text_color=bullCdl?cOk:cNo,text_size=size.small)
    table.cell(tbl,2,4,bearCdl?"OK":"NO",text_color=bearCdl?cOk:cNo,text_size=size.small)

    table.cell(tbl,0,5,"Volume",         text_color=cNo,text_size=size.small)
    table.cell(tbl,1,5,volOk?"OK":"NO",  text_color=volOk?cOk:cNo,text_size=size.small)
    table.cell(tbl,2,5,volOk?"OK":"NO",  text_color=volOk?cOk:cNo,text_size=size.small)

    table.cell(tbl,0,6,"Trend",          text_color=cNo,text_size=size.small)
    table.cell(tbl,1,6,trendUp  ?"WITH":"AGAINST",text_color=trendUp  ?cOk:color.red,text_size=size.small)
    table.cell(tbl,2,6,trendDown?"WITH":"AGAINST",text_color=trendDown?cOk:color.red,text_size=size.small)

    table.cell(tbl,0,7,"Session",        text_color=cNo,text_size=size.small)
    table.cell(tbl,1,7,inSess?"OPEN":"CLOSED",text_color=inSess?cOk:cNo,text_size=size.small)
    table.cell(tbl,2,7,inSess?"OPEN":"CLOSED",text_color=inSess?cOk:cNo,text_size=size.small)

    table.cell(tbl,0,8,"Exit Mode",      text_color=cNo,text_size=size.small)
    table.cell(tbl,1,8,i_exitMode,       text_color=color.yellow,text_size=size.tiny)
    table.cell(tbl,2,8,i_exitMode,       text_color=color.yellow,text_size=size.tiny)

    table.cell(tbl,0,9,"Signal",         text_color=cNo,text_size=size.small)
    table.cell(tbl,1,9,goLong ?"BUY":"-",text_color=goLong ?cOk      :color.gray,text_size=size.small)
    table.cell(tbl,2,9,goShort?"SELL":"-",text_color=goShort?color.red:color.gray,text_size=size.small)
