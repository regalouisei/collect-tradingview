//@version=6
//
// Copyright (C) 2017 CC BY, whentotrade / Lars von Thienen
// Source:
// Book: Decoding The Hidden Market Rhythm - Part 1: Dynamic Cycles (2017)
// Chapter 4: "Fine-tuning technical indicators for more details on the cRSI Indicator
//
// Modified for Multi-Timeframe (MTF) capability
// Updated to Pine Script v6 by Gemini
//

indicator(title="CAP - cRSI cyclic smoothed [MTF]", overlay=false)

// === Inputs ===
tf = input.timeframe(defval="", title="Timeframe", group="Timeframe Settings")
domcycle = input.int(20, minval=10, title="Dominant Cycle Length", group="Calculation Settings")
thresholdLow = input.int(50, title="Low Band Threshold", group="Calculation Settings")
thresholdHigh = input.int(50, title="High Band Threshold", group="Calculation Settings")

// === Calculation Function ===
f_calc_crsi(_src, _domcycle) =>
    _cyclelen = _domcycle / 2
    _vibration = 10
    _leveling = 10.0
    _cyclicmemory = _domcycle * 2
    
    // RSI & cyclic smoothing
    _torque = 2.0 / (_vibration + 1)
    _phasingLag = (_vibration - 1) / 2.0
    
    // Using ta.rma and math functions for v6 compliance
    _up = ta.rma(math.max(ta.change(_src), 0), _cyclelen)
    _down = ta.rma(-math.min(ta.change(_src), 0), _cyclelen)
    _rsi = _down == 0 ? 100 : _up == 0 ? 0 : 100 - 100 / (1 + _up / _down)
    
    // Calculate cRSI with self-referencing history
    var float _crsi = 0.0
    _crsi := _torque * (2 * _rsi - _rsi[_phasingLag]) + (1 - _torque) * nz(_crsi[1])
    
    // Range scan
    _lmax = -999999.0
    _lmin = 999999.0
    
    // In v6, loops and array logic are handled similarly
    for i = 0 to _cyclicmemory - 1 by 1
        val = nz(_crsi[i], -999999.0)
        if val > _lmax
            _lmax := val
        valMin = nz(_crsi[i], 999999.0)
        if valMin < _lmin
            _lmin := valMin

    // Distribution logic
    _mstep = (_lmax - _lmin) / 100
    _aperc = _leveling / 100

    _db = 0.0
    for steps = 0 to 100 by 1
        _testvalue = _lmin + _mstep * steps
        _below = 0
        for m = 0 to _cyclicmemory - 1 by 1
            _below += (_crsi[m] < _testvalue ? 1 : 0) // Replaced iff with ternary
        
        _ratio = _below / _cyclicmemory
        if _ratio >= _aperc
            _db := _testvalue
            break
            
    _ub = 0.0
    for steps = 0 to 100 by 1
        _testvalue = _lmax - _mstep * steps
        _above = 0
        for m = 0 to _cyclicmemory - 1 by 1
            _above += (_crsi[m] >= _testvalue ? 1 : 0) // Replaced iff with ternary
        
        _ratio = _above / _cyclicmemory
        if _ratio >= _aperc
            _ub := _testvalue
            break

    [_db, _ub, _crsi]

// === MTF Security Call ===
// Use the current chart timeframe if input is empty, otherwise use input
res_tf = tf == "" ? timeframe.period : tf

// Fetch the calculated values from the Higher Timeframe using request.security (v6 standard)
[db, ub, crsi] = request.security(syminfo.tickerid, res_tf, f_calc_crsi(close, domcycle))

// === Dynamic Band Color Conditions ===
lowBandColor = db > thresholdLow ? color.orange : color.aqua
highBandColor = ub < thresholdHigh ? color.red : color.aqua

// === Plotting ===
h1 = hline(30, color=color.silver, linestyle=hline.style_dashed)
h2 = hline(70, color=color.silver, linestyle=hline.style_dashed)

// Plot bands with solid colors
lowband = plot(db, "LowBand", color=lowBandColor)
highband = plot(ub, "HighBand", color=highBandColor)
plot(crsi, "CRSI", color=color.rgb(249, 249, 249), linewidth=1)

// === Fill Between Static Levels and Bands ===
// In v6, 'transp' is deprecated. We use color.new(color, transparency_value)
fill(h1, h2, color=color.new(color.silver, 90))
fill(lowband, highband, color=color.new(color.gray, 90))
