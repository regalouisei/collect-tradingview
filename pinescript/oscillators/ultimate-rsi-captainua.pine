// ===========================================================================
// Â© captainua - MAINTAINER Vitalii Natarov
// ===========================================================================
//@version=6
indicator(title="Ultimate RSI [captainua]", shorttitle="RSI", overlay=false)

//======================================================================================
//                              SCRIPT DESCRIPTION
//======================================================================================
// Ultimate RSI [captainua] - Advanced RSI Indicator with Multiple Features
//
// This comprehensive RSI indicator provides:
//   - Multiple RSI periods (6, 14, 24) with customizable smoothing (EMA, SMA, RMA, WMA, Zero-Lag)
//   - Dynamic overbought/oversold levels based on ATR volatility (adapts to market conditions)
//   - Adaptive RSI calculation that adjusts to market volatility
//   - Advanced divergence detection (regular, hidden, pivot-based with robust NA handling)
//     â†’ Divergence labels (ðŸ‚ ðŸ» H Bull H Bear) are preserved across all historical data
//     â†’ Supports up to 500 labels per chart (Pine Script maximum) via max_labels_count parameter
//   - Multi-RSI synergy signals when enabled RSIs align (ALL or 2-of-3 modes)
//   - Volume confirmation (climax âš¡ and dry-up ðŸ’§ detection with statistical thresholds)
//   - Trend filtering with EMA and slope confirmation
//   - ADX filter for trend strength confirmation
//   - RSI pivot trendlines with break detection and angle filtering
//   - Regression forecasting with confidence bands (Linear, Polynomial, Exponential Smoothing, Moving Average)
//   - Stochastic RSI overlay with customizable source selection
//   - Multiple noise reduction filters for signal accuracy (strength, extreme zones, consecutive bars)
//   - Alert cooldown system to prevent signal spam
//   - Signal strength indicator (weighted scoring 0-100%) with improved calculation showing full range
//     â†’ RSI depth contributes 50% of score (0-50 points), ensuring extreme RSI values can reach 70-100%
//     â†’ Filter weights optimized to show meaningful strength variations across all preset modes
//   - Comprehensive performance statistics and filter rejection diagnostics
//   - Robust error handling with NA checks and safe array operations
//
// Key Features:
//   - Smart Signal Generation: Tracks raw crossovers separately from filtered signals
//     â†’ Signals can fire even if filters initially block them (when conditions improve)
//     â†’ Prevents missed opportunities while maintaining filter quality
//   - Configurable noise reduction to filter false signals (disabled for Scalping preset)
//   - Momentum confirmation for stronger signal accuracy (configurable per preset)
//   - Multi-timeframe confirmation support (higher timeframe RSI alignment)
//   - Pivot-based divergence for more accurate detection (optional, more reliable than traditional)
//     â†’ Labels created when divergence lines are visible (matching line plotting conditions exactly)
//     â†’ Historical labels preserved with intelligent cleanup (only removes labels 15+ years old)
//   - Zone persistence and RSI slope filters (optional additional confirmation)
//   - Volume climax/dry-up markers with statistical standard deviation thresholds
//   - Engulfing pattern confirmation (optional candlestick pattern filter)
//   - Customizable alert conditions (main signals, divergences, extremes, synergy, trend breaks)
//   - Preset configurations optimized for different trading styles:
//     â€¢ Scalping: Fast RSI(4), minimal smoothing, noise reduction disabled
//     â€¢ Day Trading: Balanced RSI(9), moderate smoothing, momentum enabled
//     â€¢ Swing Trading: Standard RSI(14), balanced smoothing, full filters
//     â€¢ Position Trading: Slow RSI(21-28), heavy smoothing, conservative filters
//   - Comprehensive statistics table showing filter pass rates and rejection diagnostics
//
// Usage:
//   - Choose a preset mode or use Custom for full manual control
//   - Adjust noise reduction settings to balance signal frequency vs accuracy
//   - Enable/disable features based on your trading style
//   - Use pivot trendlines for visual trend analysis (with optional confirmation)
//   - Monitor signal strength labels (shows 0-100% range, with 70-100% for extreme RSI values)
//   - View performance statistics table for filter diagnostics
//   - Set up alerts for your preferred signal types (with cooldown to prevent spam)
//   - Customize divergence detection (regular/hidden, pivot-based vs traditional)
//   - Configure regression forecasting for future RSI predictions
//   - Adjust maxDivergenceLabels setting if viewing very long historical charts (default: 50,000)
//
// Technical Notes:
//   - All calculations include robust NA handling to prevent errors
//   - Array operations are safely guarded with initialization checks
//   - Signal generation uses raw crossover tracking for maximum reliability
//   - Statistics tracking separates raw and filtered signals for accurate metrics
//   - Preset modes automatically optimize RSI periods, smoothing, and filter settings
//   - Divergence labels use max_labels_count=500 (Pine Script maximum) for full historical coverage
//   - Signal strength calculation optimized: RSI depth (50 points) + filters (15-5 points each)
//   - Label cleanup runs only on last bar to preserve historical labels during processing
//======================================================================================

//======================================================================================
//                               INPUT SETTINGS
//======================================================================================
// --------------------- Configuration Presets ---------------------
presetMode = input.string(defval="Custom", title="Configuration Preset", options=["Custom", "Scalping", "Day Trading", "Swing Trading", "Position Trading"], tooltip="Choose a preset configuration optimized for your trading style. Custom allows full manual control.", group="Configuration Presets")

// --------------------- Volatility (ATR) ---------------------
volatilityMultiplier      = input.float(defval=1.2, title="Volatility Multiplier", minval=0.1, tooltip="Multiplier for volatility-based thresholds, scaled by ATR.", group="Volatility Settings")
atrLength                 = input.int(defval=14,    title="ATR Length", tooltip="Period length for ATR calculations.", group="Volatility Settings")

// --------------------- Background Settings ---------------------
disableBgColor            = input.bool(true, title="Disable Dynamic Background Color", tooltip="Use a monotonic background color instead of dynamic coloring.", group="Background Settings")
monotoneBgColor           = input.color(color.gray, title="Monotonic Background Color", tooltip="Color used for monotone background.", group="Background Settings")

// --------------------- Overbought/Oversold ---------------------
thresholdAdjustmentFactor = input.float(defval=50, title="Base Overbought/Oversold (%)", minval=0.1, tooltip="Base percentage used for dynamic OB/OS calculations.", group="Overbought/Oversold Settings")
overboughtThreshold       = input.int(defval=70,  title="Overbought Threshold", tooltip="RSI above this is considered overbought.",   group="Overbought/Oversold Settings")
oversoldThreshold         = input.int(defval=30,  title="Oversold Threshold",  tooltip="RSI below this is considered oversold.",      group="Overbought/Oversold Settings")

showObOsFill              = input.bool(defval=true, title="Fill OB/OS Zones?", tooltip="Fills the area between RSI line and threshold when RSI is in overbought/oversold zones.", group="Overbought/Oversold Settings")
obFillColor               = input.color(defval=color.new(color.red, 0), title="Overbought Fill Color", tooltip="Color for the overbought zone fill (between RSI and overbought threshold).", group="Overbought/Oversold Settings")
osFillColor               = input.color(defval=color.new(color.green, 0), title="Oversold Fill Color", tooltip="Color for the oversold zone fill (between RSI and oversold threshold).", group="Overbought/Oversold Settings")

// --------------------- RSI Settings ---------------------
showRsiHigherTimeframe    = input.bool(defval=false, title="Enable Higher Timeframe RSI", tooltip="Displays RSI from the selected higher timeframe.", group="RSI Settings")
higherTimeframe           = input.timeframe(defval="D", title="Higher Timeframe", tooltip="Set timeframe for the higher-timeframe RSI.", group="RSI Settings")

showRsi6                  = input.bool(defval=true, title="Enable RSI(6) Smoothed", tooltip="Shows a high-sensitivity RSI(6). âš ï¸ Only applies in Custom mode - presets automatically select the RSI to display.", group="RSI Settings")
rsiLength6                = input.int(defval=6,    title="RSI (6) Length", minval=1, maxval=100, tooltip="Period for RSI(6) calculations. âš ï¸ Only applies in Custom mode - presets override with optimized values (Scalping: 4, Day Trading: 6, Swing Trading: 14, Position Trading: 24).", group="RSI Settings")

showRsi14                 = input.bool(defval=true, title="Enable RSI(14) Smoothed", tooltip="Shows the standard RSI(14). âš ï¸ Only applies in Custom mode - presets automatically select the RSI to display.", group="RSI Settings")
rsiLength14               = input.int(defval=14,   title="RSI (14) Length", minval=1, maxval=100, tooltip="Period for RSI(14). âš ï¸ Only applies in Custom mode - presets override with optimized values (Scalping: 7, Day Trading: 9, Swing Trading: 14, Position Trading: 21).", group="RSI Settings")

showRsi24                 = input.bool(defval=true, title="Enable RSI(24) Smoothed", tooltip="Shows a longer RSI(24) for smoother signals. âš ï¸ Only applies in Custom mode - presets automatically select the RSI to display.", group="RSI Settings")
rsiLength24               = input.int(defval=24,   title="RSI (24) Length", minval=1, maxval=100, tooltip="Period for RSI(24). âš ï¸ Only applies in Custom mode - presets override with optimized values (Scalping: 9, Day Trading: 14, Swing Trading: 21, Position Trading: 28).", group="RSI Settings")

applyGlobalSmoothing      = input.bool(defval=false, title="Apply Global Smoothing", tooltip="Uses a single smoothing length for all RSIs (6,14,24). âš ï¸ In preset modes, smoothing is automatically optimized per RSI.", group="RSI Settings")
globalSmoothingLength     = input.int(defval=6,    title="Global Smoothing Len", minval=1, maxval=100, tooltip="Common smoothing length for RSI(6,14,24) if enabled. âš ï¸ Only applies in Custom mode - presets use individual optimized smoothing values.", group="RSI Settings")

customSmoothingLength_6   = input.int(defval=2,    title="RSI(6) Smoothing",  minval=1, maxval=100, tooltip="EMA smoothing length for RSI(6). âš ï¸ Only applies in Custom mode - presets override with optimized values (Scalping: 1, Day Trading: 2, Swing Trading: 3, Position Trading: 5).",  group="RSI Settings")
customSmoothingLength_14  = input.int(defval=3,    title="RSI(14) Smoothing", minval=1, maxval=100, tooltip="EMA smoothing length for RSI(14). âš ï¸ Only applies in Custom mode - presets override with optimized values (Scalping: 2, Day Trading: 3, Swing Trading: 3, Position Trading: 5).", group="RSI Settings")
customSmoothingLength_24  = input.int(defval=5,    title="RSI(24) Smoothing", minval=1, maxval=100, tooltip="EMA smoothing length for RSI(24). âš ï¸ Only applies in Custom mode - presets override with optimized values (Scalping: 3, Day Trading: 4, Swing Trading: 5, Position Trading: 7).", group="RSI Settings")

rsiBottomPeriod           = input.int(defval=10,   title="RSI Bottom Period", minval=1, maxval=100, tooltip="Lookback period for detecting RSI bottoms.", group="RSI Settings")
rsiBottomThreshold        = input.int(defval=5,    title="Threshold for Strong Buy", minval=1, maxval=100, tooltip="Min difference from RSI's lowest to confirm a strong buy.", group="RSI Settings")
rsiTopPeriod              = input.int(defval=7,    title="RSI Top Period",    minval=1, maxval=100, tooltip="Lookback period for detecting RSI tops.",   group="RSI Settings")
rsiTopThreshold           = input.int(defval=7,    title="Threshold for Strong Sell", minval=1, maxval=100, tooltip="Min difference from RSI's highest to confirm a strong sell. RSI must decline by at least this many points from its highest in the period. Example: If RSI was at 80 and threshold is 7, RSI must drop to 73 or lower. Higher values = more conservative (fewer but stronger signals).", group="RSI Settings")
resetPeriod               = input.int(defval=5,    title="Reset Period", minval=1, maxval=100, tooltip="Bars to wait before another signal triggers. Higher = fewer signals.", group="RSI Settings")

// --------------------- Accuracy & Confirmation Settings ---------------------
requireMomentumConfirmation = input.bool(defval=true, title="Require RSI Momentum Confirmation?", tooltip="Requires RSI to be accelerating in the signal direction for stronger accuracy. âš ï¸ Presets override: Disabled for Scalping, Enabled for Day Trading, Uses this setting for Swing/Position Trading.", group="Accuracy Settings")
momentumLookback           = input.int(defval=3, title="Momentum Lookback", minval=2, maxval=10, tooltip="Bars to check for RSI momentum/acceleration.", group="Accuracy Settings")
requirePivotDivergence     = input.bool(defval=true, title="Use Pivot-Based Divergence?", tooltip="Uses actual pivot points instead of simple lowest/highest for more accurate divergence detection.", group="Accuracy Settings")
pivotDivergencePeriod      = input.int(defval=5, title="Pivot Divergence Period", minval=3, maxval=20, tooltip="Period for detecting pivot points in divergence analysis.", group="Accuracy Settings")
requireMultiTimeframeConf  = input.bool(defval=false, title="Require Higher TF Confirmation?", tooltip="Requires higher timeframe RSI to align with signal direction.", group="Accuracy Settings")
mtfConfirmationThreshold   = input.float(defval=5.0, title="MTF Confirmation Threshold", minval=1.0, maxval=20.0, tooltip="RSI difference threshold for multi-timeframe confirmation.", group="Accuracy Settings")
requireEngulfingPattern    = input.bool(defval=false, title="Require Engulfing Pattern Confirmation?", tooltip="Requires bullish/bearish engulfing candlestick pattern for signal confirmation. Adds price action confirmation to RSI signals.", group="Accuracy Settings")

// --------------------- Divergence Settings ---------------------
enableDivergence = input.bool(defval=true, title="Enable Divergence Detection", tooltip="Detect bullish and bearish divergences between price and RSI. Divergences often precede reversals and are powerful reversal signals.", group="Divergence Settings")
dontTouchCenterline = input.bool(defval=false, title="Don't Touch Centerline (50)", tooltip="For bullish divergence: RSI must stay below 50. For bearish divergence: RSI must stay above 50. This ensures divergences occur in proper context.", group="Divergence Settings")
pivotLookbackRight = input.int(defval=5, minval=1, maxval=20, title="Pivot Lookback Right", tooltip="Number of bars to the right of pivot point for confirmation. Higher values = more conservative pivot detection.", group="Divergence Settings")
pivotLookbackLeft = input.int(defval=5, minval=1, maxval=20, title="Pivot Lookback Left", tooltip="Number of bars to the left of pivot point for confirmation. Higher values = more conservative pivot detection.", group="Divergence Settings")
rangeUpper = input.int(defval=60, minval=10, maxval=200, title="Max Lookback Range", tooltip="Maximum bars between pivots to consider for divergence. Higher values = longer-term divergences.", group="Divergence Settings")
rangeLower = input.int(defval=15, minval=1, maxval=50, title="Min Lookback Range", tooltip="Minimum bars between pivots to consider for divergence. Higher values = fewer but more significant divergences. Lower values = more frequent but potentially weaker signals.", group="Divergence Settings")
plotBullishDiv = input.bool(defval=true, title="Plot Bullish Divergence", tooltip="Display regular bullish divergence markers and labels.", group="Divergence Settings")
plotHiddenBullishDiv = input.bool(defval=false, title="Plot Hidden Bullish Divergence", tooltip="Display hidden bullish divergence markers and labels.", group="Divergence Settings")
plotBearishDiv = input.bool(defval=true, title="Plot Bearish Divergence", tooltip="Display regular bearish divergence markers and labels.", group="Divergence Settings")
plotHiddenBearishDiv = input.bool(defval=false, title="Plot Hidden Bearish Divergence", tooltip="Display hidden bearish divergence markers and labels.", group="Divergence Settings")
bullishDivColor = input.color(color.new(#00ff88, 0), title="Bullish Divergence Color", tooltip="Color for bullish divergence markers and lines.", group="Divergence Settings")
bearishDivColor = input.color(color.new(#c64b44, 0), title="Bearish Divergence Color", tooltip="Color for bearish divergence markers and lines.", group="Divergence Settings")
hiddenBullishDivColor = input.color(color.new(#00ff88, 70), title="Hidden Bullish Divergence Color", tooltip="Color for hidden bullish divergence markers and lines.", group="Divergence Settings")
hiddenBearishDivColor = input.color(color.new(#c64b44, 70), title="Hidden Bearish Divergence Color", tooltip="Color for hidden bearish divergence markers and lines.", group="Divergence Settings")
bullishDivTextColor = input.color(color.white, title="Bullish Divergence Text Color", tooltip="Text color for bullish divergence labels.", group="Divergence Settings")
bearishDivTextColor = input.color(color.white, title="Bearish Divergence Text Color", tooltip="Text color for bearish divergence labels.", group="Divergence Settings")
hiddenBullishDivTextColor = input.color(color.white, title="Hidden Bullish Divergence Text Color", tooltip="Text color for hidden bullish divergence labels.", group="Divergence Settings")
hiddenBearishDivTextColor = input.color(color.white, title="Hidden Bearish Divergence Text Color", tooltip="Text color for hidden bearish divergence labels.", group="Divergence Settings")
divergenceLabelSize = input.string("Normal", title="Divergence Label Size", options=["Tiny", "Small", "Normal", "Large"], tooltip="Size of divergence labels.", group="Divergence Settings")
maxDivergenceLabels = input.int(defval=50000, minval=1, maxval=50000, title="Max Divergence Labels", tooltip="Maximum number of divergence labels to keep on chart. Default 50000 ensures full historical coverage (10+ years). Lower values (3000-5000) = cleaner chart showing only most recent divergences. Older labels are automatically deleted when limit is exceeded by 500+ labels (only extremely old labels >10 years deleted first, cleanup runs only on the last bar to preserve historical labels). âš ï¸ If you see missing labels on older parts of the chart, increase this value. Note: Pine Script has a hard limit of 500 labels per indicator (configured via max_labels_count).", group="Divergence Settings")

// --------------------- Volume Settings ---------------------
volumeLookback            = input.int(defval=10, title="Volume Lookback", tooltip="Period for Volume SMA calculations.", group="Volume Settings")
volumeThreshold           = input.float(defval=1.2, title="Volume Threshold", minval=0.1, maxval=3.0, tooltip="Volume must be above SMA * this factor to confirm signals. Set to 0.1 to disable volume filtering.", group="Volume Settings")
showVolumeClimax          = input.bool(defval=true, title="Enable Volume Climax Check - âš¡?", tooltip="Marks bars where Volume is X stdev above SMA (capitulation).", group="Volume Settings")
volClimaxMult             = input.float(defval=3.0, title="Volume Climax StdDev Mult - âš¡", minval=0.5, maxval=5.0, tooltip="Number of stdev above average = volume climax. Higher values (3.0-3.5) = fewer but stronger climax signals, lower (2.0-2.5) = more frequent.", group="Volume Settings")
enableVolumeDryUp         = input.bool(defval=true, title="Enable Volume Dry-Up - ðŸ’§?", tooltip="Flags bars with extremely low volume vs. average (opposite of climax).", group="Volume Settings")
volDryUpMult              = input.float(defval=2.0, title="Volume Dry-Up StdDev Mult - ðŸ’§", minval=0.5, maxval=5.0, tooltip="Number of stdev below average = volume dry-up. Higher values (2.5-3.0) = fewer but more significant dry-up signals, lower (1.5-2.0) = more frequent.", group="Volume Settings")

// --------------------- Multi-RSI Synergy ---------------------
enableMultiRsiSynergy     = input.bool(defval=true, title="Enable Multi-RSI Synergy?", tooltip="Generates signals when enabled RSIs align as overbought or oversold. Only checks RSIs that are enabled in Custom mode. âš ï¸ Only works in Custom mode and requires at least 2 RSIs enabled.", group="Additional Synergy")
multiRsiResetPeriod       = input.int(defval=5,      title="Multi-RSI Synergy Reset",   minval=1, maxval=100, tooltip="Bars to wait before synergy signal can fire again. âš ï¸ Only applies in Custom mode.", group="Additional Synergy")

synergyMode = input.string(defval="ALL", title="Synergy Mode", options=["ALL","2-of-3"], tooltip="ALL => all enabled RSIs must be OB/OS; '2-of-3' => at least 2 enabled RSIs must be OB/OS. âš ï¸ Only applies in Custom mode and requires at least 2 RSIs enabled.", group="Additional Synergy")
synergyBuyColor  = input.color(defval=color.lime, title="Synergy Buy Color",  group="Additional Synergy")
synergySellColor = input.color(defval=color.red,  title="Synergy Sell Color", group="Additional Synergy")

// --------------------- StochRSI Settings ---------------------
showStochRsi        = input.bool(false, title="Show StochRSI?", tooltip="Displays Stochastic RSI indicator.", group="StochRSI")
stochRsiSource      = input.string(defval="RSI(14)", options=["RSI(6)", "RSI(14)", "RSI(24)"], title="StochRSI Source", tooltip="Which RSI to use for StochRSI calculation. âš ï¸ In preset modes, consider using the displayed RSI for consistency.", group="StochRSI")
stochRsiLength      = input.int(defval=14, title="StochRSI Length", minval=1, maxval=100, tooltip="Period for StochRSI calculation.", group="StochRSI")
stochRsiSmoothK     = input.int(defval=3, title="StochRSI %K Smoothing", minval=1, maxval=20, tooltip="Smoothing period for %K line.", group="StochRSI")
stochRsiSmoothD     = input.int(defval=3, title="StochRSI %D Smoothing", minval=1, maxval=20, tooltip="Smoothing period for %D line.", group="StochRSI")
stochRsiOverbought  = input.int(defval=80, title="StochRSI Overbought", minval=50, maxval=100, tooltip="StochRSI overbought threshold.", group="StochRSI")
stochRsiOversold    = input.int(defval=20, title="StochRSI Oversold", minval=0, maxval=50, tooltip="StochRSI oversold threshold.", group="StochRSI")

// --------------------- Regression Forecasting Inputs ---------------------
regressionEnabled = input.bool(true, title="Enable Regression Forecasting", group="Regression Forecasting")
forecastHorizon   = input.int(5, minval=1, maxval=50, title="Forecast Horizon (Bars)", tooltip="Number of bars to forecast ahead.", group="Regression Forecasting")
regressionType    = input.string("Linear", options=["Linear", "Polynomial", "Exponential Smoothing", "Moving Average"], title="Regression Type", tooltip="Choose the type of regression for forecasting.", group="Regression Forecasting")

forecastRsiSource = input.string(defval="RSI(14)", options=["RSI(6)", "RSI(14)", "RSI(24)", "Adaptive RSI"], title="Forecast RSI Source", tooltip="Which RSI to use for forecasting. âš ï¸ 'Adaptive RSI' automatically uses the displayed RSI for each preset mode.", group="Regression Forecasting")
showConfidenceBands = input.bool(defval=true, title="Show Confidence Bands?", tooltip="Display upper/lower confidence bands around forecast.", group="Regression Forecasting")
confidenceLevel = input.float(defval=1.5, title="Confidence Band Multiplier", minval=0.5, maxval=3.0, tooltip="Standard deviation multiplier for confidence bands.", group="Regression Forecasting")
forecastLineColor = input.color(defval=color.new(color.blue, 0), title="Forecast Line Color", group="Regression Forecasting")
forecastLineWidth = input.int(defval=2, title="Forecast Line Width", minval=1, maxval=5, group="Regression Forecasting")

// --------------------- RSI Pivot Trendlines ---------------------
enablePivotTrendlines = input.bool(false, title="Enable RSI Pivot Trendlines?", tooltip="Draws trendlines connecting pivot highs/lows on the displayed RSI (adapts to preset mode).", group="RSI Pivot Trendlines")
pivotDetectionPeriod = input.int(defval=5, minval=2, maxval=50, title="Pivot Detection Period", tooltip="Lookback period for detecting pivot points on the displayed RSI. Higher = fewer pivots, less noise.", group="RSI Pivot Trendlines")
enablePivotConfirmation = input.bool(true, title="Enable Pivot Confirmation?", tooltip="Waits N bars to confirm pivot remains the extreme (reduces repainting).", group="RSI Pivot Trendlines")
pivotConfirmationBars = input.int(defval=2, minval=1, maxval=10, title="Pivot Confirmation Bars", tooltip="Number of bars to wait before confirming a pivot point. Higher = less repainting.", group="RSI Pivot Trendlines")
minPivotStrength = input.float(defval=1.0, title="Min Pivot Strength (RSI Points)", minval=0.0, maxval=10.0, tooltip="Minimum RSI difference from surrounding bars to qualify as pivot. Higher = stronger pivots only. Lower = more trendlines.", group="RSI Pivot Trendlines")
keepHistoricalTrendlines = input.bool(false, title="Keep Historical Trendlines?", tooltip="If enabled, keeps all trendlines. If disabled, only shows the most recent trendline (less clutter).", group="RSI Pivot Trendlines")
maxTrendlines = input.int(defval=5, minval=1, maxval=20, title="Max Trendlines to Keep", tooltip="Maximum number of historical trendlines to keep. Only used if 'Keep Historical Trendlines' is enabled.", group="RSI Pivot Trendlines")
uptrendLineColor = input.color(defval=color.new(color.green, 0), title="Uptrend Line Color", tooltip="Color for trendlines connecting pivot lows (uptrend).", group="RSI Pivot Trendlines")
downtrendLineColor = input.color(defval=color.new(color.red, 0), title="Downtrend Line Color", tooltip="Color for trendlines connecting pivot highs (downtrend).", group="RSI Pivot Trendlines")
trendlineWidth = input.int(defval=2, minval=1, maxval=5, title="Trendline Width", group="RSI Pivot Trendlines")
showTrendBreaks = input.bool(true, title="Show Trend Break Signals?", tooltip="Displays signals when RSI breaks above/below trendlines.", group="RSI Pivot Trendlines")
requireTrendBreakConfirmation = input.bool(false, title="Require Trend Break Confirmation?", tooltip="Requires trend break to persist for N bars and have volume confirmation. Reduces false signals.", group="RSI Pivot Trendlines")
trendBreakConfirmationBars = input.int(defval=1, minval=1, maxval=5, title="Trend Break Confirmation Bars", tooltip="Bars trend break must persist before signal. Higher = fewer false signals.", group="RSI Pivot Trendlines")
minTrendlineAngle = input.float(defval=0.0, title="Min Trendline Angle", minval=0.0, maxval=5.0, tooltip="Minimum trendline slope to generate signals. Filters flat/weak trendlines. 0 = disabled.", group="RSI Pivot Trendlines")
trendBreakBuyColor = input.color(defval=color.lime, title="Trend Break Buy Color", group="RSI Pivot Trendlines")
trendBreakSellColor = input.color(defval=color.red, title="Trend Break Sell Color", group="RSI Pivot Trendlines")

// --------------------- RSI Bollinger Bands---------------------
plotRsiBB       = input.bool(false, title="Plot RSI Bollinger Bands?", tooltip="Plots upper/lower Bollinger on the displayed RSI (adapts to preset mode) for extreme zones.", group="RSI Bollinger Bands")
bbLength        = input.int(defval=20, title="RSI BB Period", tooltip="Number of bars in Bollinger Band calculations for the displayed RSI.", group="RSI Bollinger Bands")
bbDev           = input.float(defval=2.0, title="RSI BB Deviation", tooltip="StdDev multiplier for Bollinger Bands on the displayed RSI.", group="RSI Bollinger Bands")

// --------------------- Statistics ---------------------
showPerformanceStats = input.bool(false, title="Show Performance Statistics?", tooltip="Displays performance statistics: signal counts, filter pass rates, etc.", group="Statistics")
statsTablePosition = input.string("Top Right", title="Table Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], tooltip="Screen position for the statistics table. Choose based on your chart layout preferences. Top Right is standard.", group="Statistics")

// --------------------- EMA Filter ---------------------
smoothingMethod = input.string(defval="EMA", title="Smoothing Method", options=["EMA","SMA","RMA","WMA","ZL"], tooltip="Pick RSI smoothing method: EMA, SMA, RMA (Wilder), WMA, or ZL (Zero-Lag).", group="EMA Filter")

useTrendFilter      = input.bool(false, title="Use Trend Filter (EMA)?", tooltip="Only Buys if price above this EMA, only Sells if price below it.", group="EMA Filter")
trendFilterEmaLength = input.int(defval=200, title="Trend Filter EMA Length", tooltip="Long-term EMA length used for the trend filter.", group="EMA Filter")
useTrendSlope        = input.bool(false, title="Require EMA Slope?", tooltip="Also require EMA to be rising (bullish) or falling (bearish) for stronger trend confirmation.", group="EMA Filter")

// --------------------- ADX Filter ---------------------
useAdxFilter        = input.bool(false, title="Use ADX Filter?", tooltip="Require ADX to be above a threshold for final signals.", group="ADX Filter")
adxLength           = input.int(defval=14, title="ADX Length", tooltip="Lookback for ADX calculation.", group="ADX Filter")
adxSmoothing        = input.int(defval=14, title="ADX Smoothing", tooltip="Smoothing period for ADX calculation.", group="ADX Filter")
adxThreshold        = input.float(defval=20.0, title="ADX Threshold", tooltip="Minimum ADX level to confirm signals if ADX filter is on.", group="ADX Filter")

// --------------------- Show Buy/Sell Strength signals ---------------------
showBuyStrengthLabel = input.bool(true, title="Show Buy Strength Label?", tooltip="Displays 'Buy Strength %' label on the chart when buy signals occur. Shows weighted score (0-100%) based on RSI depth (50% weight) and filters passed (Trend, ADX, Momentum, Volume, etc.). Strong signals with extreme RSI values typically show 70-100% strength. Works for all trading modes.", group="Signals Settings")
showSellStrengthLabel = input.bool(true, title="Show Sell Strength Label?", tooltip="Displays 'Sell Strength %' label on the chart when sell signals occur. Shows weighted score (0-100%) based on RSI depth (50% weight) and filters passed (Trend, ADX, Momentum, Volume, etc.). Strong signals with extreme RSI values typically show 70-100% strength. Works for all trading modes.", group="Signals Settings")
minLabelDistanceBars = input.int(defval=5, title="Minimum Bars Between Labels", minval=1, maxval=50, tooltip="Minimum number of bars required between consecutive labels to prevent duplicate labels from appearing too close together.", group="Signals Settings")
labelHistoricalLookback = input.int(defval=20, title="Historical Lookback for Label Placement", minval=5, maxval=100, tooltip="Number of bars to look back when placing labels to find the true lowest/highest RSI value. Higher values analyze more history but may be slower.", group="Signals Settings")

// --------------------- Show Strong Top/Bottom signals ---------------------
showStrongTopBottomSignals = input.bool(true, title="Show Strong Top/Bottom Signals?", tooltip="Displays 'sBottom' and 'sTop' labels when RSI shows strong recovery from extreme levels. Works for all trading modes.", group="Signals Settings")
strongSignalConfirmationBars = input.int(defval=2, title="Strong Signal Confirmation Bars", minval=1, maxval=5, tooltip="Require recovery/decline to persist for N consecutive bars before signaling. Higher = later but more reliable signals. Helps avoid early signals.", group="Signals Settings")

// --------------------- Alert Frequency Control ---------------------
enableAlertCooldown = input.bool(true, title="Enable Alert Cooldown?", tooltip="Prevents alert spam by limiting alerts to once per X bars. RECOMMENDED: Enable for noise reduction.", group="Alert Settings")
alertCooldownBars   = input.int(defval=10, title="Alert Cooldown (Bars)", minval=1, maxval=100, tooltip="Minimum bars between alerts of the same type. Higher = fewer signals.", group="Alert Settings")

// --------------------- Alert Options ---------------------
// Main Buy/Sell Alerts (works for all trading modes: Custom, Scalping, Day Trading, Swing Trading, Position Trading)
enableMainBuySellAlerts = input.bool(true, title="Enable Main Buy/Sell Alerts", tooltip="Alerts when final buy/sell signals trigger (after all filters and noise reduction). Works for all trading modes.", group="Alert Settings")

// Additional Alert Types (grouped for simplicity)
enableDivergenceAlerts = input.bool(false, title="Enable Divergence Alerts (All Types)", tooltip="Alerts for all divergence types: Regular/Hidden Bullish/Bearish. Works for all trading modes.", group="Alert Settings")
enableRsiExtremeAlerts = input.bool(false, title="Enable RSI Extreme Alerts (Top/Bottom)", tooltip="Alerts when RSI reaches strong top/bottom with volume confirmation. Works for all trading modes.", group="Alert Settings")
enableSynergyAlerts = input.bool(false, title="Enable Multi-RSI Synergy Alerts", tooltip="Alerts when multiple RSIs align (buy/sell). âš ï¸ Only works in Custom mode with at least 2 RSIs enabled.", group="Alert Settings")
enableTrendBreakAlerts = input.bool(false, title="Enable Trend Break Alerts", tooltip="Alerts when RSI breaks trendlines (buy/sell). âš ï¸ Requires 'Enable RSI Pivot Trendlines' to be enabled. Works for all trading modes.", group="Alert Settings")

// --------------------- Noise Reduction Settings ---------------------
enableNoiseReduction = input.bool(true, title="Enable Noise Reduction?", tooltip="Reduces false signals by requiring stronger confirmation. âš ï¸ Disabled automatically for Scalping preset (requires more signals), uses this setting for other presets.", group="Noise Reduction")
minSignalStrength = input.float(defval=3.0, title="Min Signal Strength (RSI Points)", minval=0.0, maxval=20.0, tooltip="Minimum RSI distance from centerline (50) to generate signal. Higher = fewer signals.", group="Noise Reduction")
requireConsecutiveBars = input.int(defval=1, title="Consecutive Bars Confirmation", minval=1, maxval=5, tooltip="Require signal to persist for N consecutive bars before triggering. Higher = fewer false signals.", group="Noise Reduction")
minRsiExtreme = input.float(defval=0.0, title="Min RSI Extreme Distance", minval=0.0, maxval=15.0, tooltip="For buy: RSI must be at least this far below oversold. For sell: RSI must be at least this far above overbought.", group="Noise Reduction")
requireZonePersistence = input.bool(false, title="Require Zone Persistence?", tooltip="Requires RSI to stay in OB/OS zone for N bars. More strict filter.", group="Noise Reduction")
requireRsiSlope = input.bool(false, title="Require RSI Slope Confirmation?", tooltip="Requires RSI to be moving in signal direction. More strict filter.", group="Noise Reduction")

//======================================================================================
//                         CONSTANTS & VALIDATION HELPERS
//======================================================================================
pivotTolerance = 1.0
minDivergenceThreshold = 1.0
minFillGap = 0.1  // Minimum gap for fill rendering (TradingView requirement)
rsiTopBottomBuffer = 2.0
priceTolerancePercent = 0.01
POLYNOMIAL_MAX_HORIZON = 20  // Performance safeguard - polynomial regression is CPU-intensive

f_validateInput(_value, _min, _max, _default) =>
    _value >= _min and _value <= _max ? _value : _default

f_validateSmoothingLength(_smoothing, _rsiLength) =>
    _smoothing >= _rsiLength ? math.max(1, _rsiLength - 1) : _smoothing

f_validateRangeOrder(_lower, _upper, _lowerDefault, _upperDefault) =>
    validatedLower = _lower < _upper ? _lower : _lowerDefault
    validatedUpper = _upper > _lower ? _upper : _upperDefault
    [validatedLower, validatedUpper]

f_validateStringOption(_value, _options, _default) =>
    isValid = false
    for i = 0 to array.size(_options) - 1
        if array.get(_options, i) == _value
            isValid := true
    isValid ? _value : _default

f_safeDivide(_numerator, _denominator, _default) =>
    _denominator != 0 ? _numerator / _denominator : _default

//======================================================================================
//                         PRESET MODE HELPER FUNCTIONS
//======================================================================================
f_getPresetRsiLength6(_mode, _customValue) =>
    _mode == "Scalping" ? 4 : _mode == "Day Trading" ? 6 : _mode == "Swing Trading" ? 14 : _mode == "Position Trading" ? 24 : _customValue

f_getPresetRsiLength14(_mode, _customValue) =>
    _mode == "Scalping" ? 7 : _mode == "Day Trading" ? 9 : _mode == "Swing Trading" ? 14 : _mode == "Position Trading" ? 21 : _customValue

f_getPresetRsiLength24(_mode, _customValue) =>
    _mode == "Scalping" ? 9 : _mode == "Day Trading" ? 14 : _mode == "Swing Trading" ? 21 : _mode == "Position Trading" ? 28 : _customValue

f_getPresetSmoothingLength6(_mode, _customValue) =>
    _mode == "Scalping" ? 1 : _mode == "Day Trading" ? 2 : _mode == "Swing Trading" ? 3 : _mode == "Position Trading" ? 5 : _customValue

f_getPresetSmoothingLength14(_mode, _customValue) =>
    _mode == "Scalping" ? 2 : _mode == "Day Trading" ? 3 : _mode == "Swing Trading" ? 3 : _mode == "Position Trading" ? 5 : _customValue

f_getPresetSmoothingLength24(_mode, _customValue) =>
    _mode == "Scalping" ? 3 : _mode == "Day Trading" ? 4 : _mode == "Swing Trading" ? 5 : _mode == "Position Trading" ? 7 : _customValue

f_getPresetRsiSource(_mode) =>
    _mode == "Scalping" ? "RSI(6)" : (_mode == "Day Trading" or _mode == "Swing Trading") ? "RSI(14)" : _mode == "Position Trading" ? "RSI(24)" : "RSI(14)"

f_getPresetAdaptiveRsiLength(_mode, _customLength6, _customLength14, _customLength24, _defaultLength) =>
    _mode == "Custom" ? _defaultLength : _mode == "Scalping" ? f_getPresetRsiLength6(_mode, _customLength6) : (_mode == "Day Trading" or _mode == "Swing Trading") ? f_getPresetRsiLength14(_mode, _customLength14) : _mode == "Position Trading" ? f_getPresetRsiLength24(_mode, _customLength24) : _defaultLength

f_isCustomMode(_mode) =>
    _mode == "Custom"

f_isScalpingMode(_mode) =>
    _mode == "Scalping"

f_isDayTradingOrSwingMode(_mode) =>
    _mode == "Day Trading" or _mode == "Swing Trading"

f_isPositionTradingMode(_mode) =>
    _mode == "Position Trading"

f_isDayTradingMode(_mode) =>
    _mode == "Day Trading"

f_getPresetForecastHorizon(_mode, _customHorizon) =>
    _mode == "Scalping" ? math.min(5, _customHorizon) : _mode == "Day Trading" ? math.min(10, _customHorizon) : _mode == "Swing Trading" ? math.min(20, _customHorizon) : _mode == "Position Trading" ? math.min(30, _customHorizon) : _customHorizon

adjustedSmoothingLength_6 = f_validateSmoothingLength(customSmoothingLength_6, rsiLength6)
adjustedSmoothingLength_14 = f_validateSmoothingLength(customSmoothingLength_14, rsiLength14)
adjustedSmoothingLength_24 = f_validateSmoothingLength(customSmoothingLength_24, rsiLength24)
adjustedGlobalSmoothingLength = f_validateSmoothingLength(globalSmoothingLength, math.min(math.min(rsiLength6, rsiLength14), rsiLength24))

[validRangeLower, validRangeUpper] = f_validateRangeOrder(rangeLower, rangeUpper, 15, 60)

finalRsiLength6 = f_getPresetRsiLength6(presetMode, rsiLength6)
finalRsiLength14 = f_getPresetRsiLength14(presetMode, rsiLength14)
finalRsiLength24 = f_getPresetRsiLength24(presetMode, rsiLength24)

finalSmoothingLength_6 = f_getPresetSmoothingLength6(presetMode, adjustedSmoothingLength_6)
finalSmoothingLength_14 = f_getPresetSmoothingLength14(presetMode, adjustedSmoothingLength_14)
finalSmoothingLength_24 = f_getPresetSmoothingLength24(presetMode, adjustedSmoothingLength_24)

finalAdaptiveRsiLength = f_getPresetAdaptiveRsiLength(presetMode, finalRsiLength6, finalRsiLength14, finalRsiLength24, rsiLength14)

finalGlobalSmoothingLength = not f_isCustomMode(presetMode) ? adjustedGlobalSmoothingLength : globalSmoothingLength
finalNoiseReductionEnabled = f_isScalpingMode(presetMode) ? false : enableNoiseReduction
finalMomentumConfirmation = f_isScalpingMode(presetMode) ? false : (f_isDayTradingMode(presetMode) ? true : requireMomentumConfirmation)

finalShowRsi6 = f_isCustomMode(presetMode) ? showRsi6 : f_isScalpingMode(presetMode) ? true : false
finalShowRsi14 = f_isCustomMode(presetMode) ? showRsi14 : f_isDayTradingOrSwingMode(presetMode) ? true : false
finalShowRsi24 = f_isCustomMode(presetMode) ? showRsi24 : f_isPositionTradingMode(presetMode) ? true : false

finalEnableMultiRsiSynergy = f_isCustomMode(presetMode) ? enableMultiRsiSynergy : false

finalObOsFillRsiSource = f_isCustomMode(presetMode) ? "RSI(14)" : f_getPresetRsiSource(presetMode)

finalAdaptiveRsiSource = f_isCustomMode(presetMode) ? "RSI(14)" : f_getPresetRsiSource(presetMode)

presetForecastHorizon = f_getPresetForecastHorizon(presetMode, forecastHorizon)

finalForecastHorizon = (regressionType == "Polynomial" and presetForecastHorizon > POLYNOMIAL_MAX_HORIZON) ? POLYNOMIAL_MAX_HORIZON : presetForecastHorizon

//======================================================================================
//                               UTILITY FUNCTIONS
//======================================================================================
f_zeroLagRsi(rsiVal) =>
    if na(rsiVal) or na(rsiVal[1])
        nz(rsiVal, 50.0)
    else
        zl = rsiVal + (rsiVal - rsiVal[1])
        math.max(0, math.min(100, zl))

f_smooth(src, length, method) =>
    method == "EMA" ? ta.ema(src, length) : 
     method == "SMA" ? ta.sma(src, length) : 
     method == "RMA" ? ta.rma(src, length) : 
     method == "WMA" ? ta.wma(src, length) : 
     method == "ZL"  ? f_zeroLagRsi(src)    : src

isBullishEngulfing() =>
    (close[1] < open[1]) and (close > open) and (close > open[1]) and (open < close[1])

isBearishEngulfing() =>
    (close[1] > open[1]) and (close < open) and (close < open[1]) and (open > close[1])

f_rsiMomentum(_rsiVal, _lookback, _isBullish) =>
    if bar_index < _lookback
        false
    else if _isBullish
        sumChanges = 0.0
        positiveCount = 0
        for i = 1 to _lookback
            change = _rsiVal[i-1] - _rsiVal[i]
            sumChanges := sumChanges + change
            if change > 0
                positiveCount := positiveCount + 1
        minRequiredBars = math.max(1, math.floor(_lookback * 0.5))
        (positiveCount >= minRequiredBars) and (sumChanges > 0)
    else
        sumChanges = 0.0
        negativeCount = 0
        for i = 1 to _lookback
            change = _rsiVal[i-1] - _rsiVal[i]
            sumChanges := sumChanges + change
            if change < 0
                negativeCount := negativeCount + 1
        minRequiredBars = math.max(1, math.floor(_lookback * 0.5))
        (negativeCount >= minRequiredBars) and (sumChanges < 0)

// Signal Strength Calculation: Weighted scoring system (0-100%) combining RSI depth and filter confirmations
// RSI depth contributes 50% of total score (allows extreme signals to reach 70-100%)
// Filter weights are optimized to show meaningful variations while prioritizing RSI extremeness
f_calculateSignalStrength(_isBuy, _rsi14Smooth, _trendIsBullish, _trendIsBearish, _adxIsStrong, _isVolumeDryUp, _rsiHigherTf, _zonePersistenceOk, _rsiSlopeOk, _osThreshold, _obThreshold, _osDyn, _obDyn) =>
    totalWeight = 0.0
    weightedScore = 0.0
    
    // RSI Depth Score: 0-50 points based on how extreme RSI is relative to thresholds
    // Uses static thresholds for predictable scoring (not dynamic levels)
    rsiDepthScore = 0.0
    if _isBuy
        if _rsi14Smooth <= _osThreshold
            depthBelowOs = _osThreshold - _rsi14Smooth
            maxDepth = _osThreshold
            depthRatio = math.min(1.0, depthBelowOs / maxDepth)
            rsiDepthScore := 25.0 + (depthRatio * 25.0)
        else if _rsi14Smooth <= _osThreshold + 10.0
            distanceAboveOs = _rsi14Smooth - _osThreshold
            rsiDepthScore := math.max(0, 25.0 * (1.0 - (distanceAboveOs / 10.0)))
        else
            rsiDepthScore := 0.0
    else
        if _rsi14Smooth >= _obThreshold
            depthAboveOb = _rsi14Smooth - _obThreshold
            maxDepth = 100.0 - _obThreshold
            depthRatio = math.min(1.0, depthAboveOb / maxDepth)
            rsiDepthScore := 25.0 + (depthRatio * 25.0)
        else if _rsi14Smooth >= _obThreshold - 10.0
            distanceBelowOb = _obThreshold - _rsi14Smooth
            rsiDepthScore := math.max(0, 25.0 * (1.0 - (distanceBelowOb / 10.0)))
        else
            rsiDepthScore := 0.0
    weightedScore := weightedScore + rsiDepthScore
    totalWeight := totalWeight + 50.0
    
    if useTrendFilter
        totalWeight := totalWeight + 15.0
        if (_isBuy ? _trendIsBullish : _trendIsBearish)
            weightedScore := weightedScore + 15.0
    
    if useAdxFilter
        totalWeight := totalWeight + 12.0
        if _adxIsStrong
            weightedScore := weightedScore + 12.0
    
    if finalMomentumConfirmation
        totalWeight := totalWeight + 10.0
        momentumResult = f_rsiMomentum(_rsi14Smooth, momentumLookback, _isBuy)
        if momentumResult
            weightedScore := weightedScore + 10.0
    
    if requireMultiTimeframeConf
        totalWeight := totalWeight + 8.0
        if not na(_rsiHigherTf) and (_isBuy ? _rsi14Smooth < _rsiHigherTf - mtfConfirmationThreshold : _rsi14Smooth > _rsiHigherTf + mtfConfirmationThreshold)
            weightedScore := weightedScore + 8.0
    
    if enableVolumeDryUp
        totalWeight := totalWeight + 5.0
        if not _isVolumeDryUp
            weightedScore := weightedScore + 5.0
    
    if requireZonePersistence
        totalWeight := totalWeight + 5.0
        if _zonePersistenceOk
            weightedScore := weightedScore + 5.0
    
    if requireRsiSlope
        totalWeight := totalWeight + 5.0
        if _rsiSlopeOk
            weightedScore := weightedScore + 5.0
    
    finalScore = totalWeight > 0 ? (weightedScore / totalWeight) * 100 : 100.0
    math.round(math.max(0, math.min(100, finalScore)))

// Pivot-Based Bullish Divergence Detection: More accurate than simple lowest/highest comparison
// This method uses actual pivot points detected by ta.pivotlow() instead of simple lowest values
// Divergence pattern: Price makes lower low while RSI makes higher low (bullish signal)
f_pivot_bullish_divergence(_lowSrc, _rsiVal, _osThreshold, _pivotPeriod) =>
    // Need enough history to detect pivots
    lookback = _pivotPeriod * 3
    
    if bar_index >= lookback
        // Detect pivot lows for both price and RSI
        pricePivotLow = ta.pivotlow(_lowSrc, _pivotPeriod, _pivotPeriod)
        rsiPivotLow = ta.pivotlow(_rsiVal, _pivotPeriod, _pivotPeriod)
        
        // Check if we have a pivot low detected (not na)
        hasPricePivot = not na(pricePivotLow)
        hasRsiPivot = not na(rsiPivotLow)
        
        if hasPricePivot and hasRsiPivot
            // Get current and previous pivot values using valuewhen
            currentPricePivot = ta.valuewhen(hasPricePivot, pricePivotLow, 0)
            prevPricePivot = ta.valuewhen(hasPricePivot, pricePivotLow, 1)
            currentRsiPivot = ta.valuewhen(hasRsiPivot, rsiPivotLow, 0)
            prevRsiPivot = ta.valuewhen(hasRsiPivot, rsiPivotLow, 1)
            
            // Validate all values are not na
            if not na(currentPricePivot) and not na(prevPricePivot) and not na(currentRsiPivot) and not na(prevRsiPivot)
                // Verify divergence pattern: Price lower low, RSI higher low
                priceLowerLow = currentPricePivot < prevPricePivot
                rsiHigherLow = currentRsiPivot > prevRsiPivot + minDivergenceThreshold  // RSI at least threshold points higher
                rsiOversold = currentRsiPivot < _osThreshold  // RSI must be in oversold zone
                // Divergence confirmed: price declining but RSI recovering
                priceLowerLow and rsiHigherLow and rsiOversold
            else
                false
        else
            false
    else
        false  // Not enough bars for pivot analysis

// Pivot-Based Bearish Divergence Detection: More accurate than simple highest comparison
// This method uses actual pivot points detected by ta.pivothigh() instead of simple highest values
// Divergence pattern: Price makes higher high while RSI makes lower high (bearish signal)
f_pivot_bearish_divergence(_highSrc, _rsiVal, _obThreshold, _pivotPeriod) =>
    // Need enough history to detect pivots
    lookback = _pivotPeriod * 3
    
    if bar_index >= lookback
        // Detect pivot highs for both price and RSI
        pricePivotHigh = ta.pivothigh(_highSrc, _pivotPeriod, _pivotPeriod)
        rsiPivotHigh = ta.pivothigh(_rsiVal, _pivotPeriod, _pivotPeriod)
        
        // Check if we have a pivot high detected (not na)
        hasPricePivot = not na(pricePivotHigh)
        hasRsiPivot = not na(rsiPivotHigh)
        
        if hasPricePivot and hasRsiPivot
            // Get current and previous pivot values using valuewhen
            currentPricePivot = ta.valuewhen(hasPricePivot, pricePivotHigh, 0)
            prevPricePivot = ta.valuewhen(hasPricePivot, pricePivotHigh, 1)
            currentRsiPivot = ta.valuewhen(hasRsiPivot, rsiPivotHigh, 0)
            prevRsiPivot = ta.valuewhen(hasRsiPivot, rsiPivotHigh, 1)
            
            // Validate all values are not na
            if not na(currentPricePivot) and not na(prevPricePivot) and not na(currentRsiPivot) and not na(prevRsiPivot)
                // Verify divergence pattern: Price higher high, RSI lower high
                priceHigherHigh = currentPricePivot > prevPricePivot
                rsiLowerHigh = currentRsiPivot < prevRsiPivot - minDivergenceThreshold  // RSI at least threshold points lower
                rsiOverbought = currentRsiPivot > _obThreshold  // RSI must be in overbought zone
                // Divergence confirmed: price rising but RSI weakening
                priceHigherHigh and rsiLowerHigh and rsiOverbought
            else
                false
        else
            false
    else
        false  // Not enough bars for pivot analysis

// Divergence Detection Helper: Check if condition occurred within specified range
// Reference: _inRange(cond) => bars = barssince(cond == true); validRangeLower <= bars and bars <= validRangeUpper
// In Pine Script, if barssince returns na, the comparison returns na (falsy), so we don't need explicit na check
_inRange(cond) =>
    bars = ta.barssince(cond == true)
    not na(bars) and validRangeLower <= bars and bars <= validRangeUpper

// Get label size
getLabelSize(sizeStr) =>
    switch sizeStr
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        => size.large

// RSI Calculation with Optional Smoothing: Calculates raw RSI and smoothed version
// Returns both raw RSI and smoothed RSI for flexibility in signal generation
// Supports global smoothing (same length for all RSIs) or individual smoothing per RSI period
f_calculate_rsi(_rsiLen, _customSmooth, _globalSmoothEnabled, _globalSmoothLen) =>
    rsiRaw    = ta.rsi(close, _rsiLen)  // Calculate raw RSI using standard formula
    smoothLen = _globalSmoothEnabled ? _globalSmoothLen : _customSmooth  // Select smoothing length
    [rsiRaw, f_smooth(rsiRaw, smoothLen, smoothingMethod)]  // Return [raw, smoothed]

// ATR Cache: Optimizes ATR calculation by caching values
// Reduces redundant calculations while maintaining accuracy
// Always calls ta.atr on every bar for consistency as recommended by TradingView
f_atrCache(_atrLen) =>
    var float atrCached = na  // Persistent variable to cache ATR value
    currentAtr = ta.atr(_atrLen)  // Always call on every bar for consistency
    if barstate.islastconfirmedhistory or barstate.isrealtime
        atrCached := currentAtr  // Update cache on confirmed or realtime bars
    nz(atrCached, currentAtr)  // Return cached value or current value if cache not available

// Dynamic Overbought/Oversold: Adjusts OB/OS levels based on market volatility (ATR)
// Higher volatility = wider OB/OS bands, lower volatility = tighter bands
// This adapts to changing market conditions for more accurate signal generation
// NOTE: ATR is normalized as percentage of price to work with RSI scale (0-100)
f_dynamicOverboughtOversold(_atr, _obBase, _osBase, _volMult, _basePct) =>
    // Normalize ATR to percentage of price (ATR/close * 100) to scale properly with RSI
    atrPercent = f_safeDivide(_atr * 100, close, 0.0)  // ATR as percentage of price
    // Calculate dynamic thresholds: base level Â± (normalized ATR * multiplier * percentage)
    // The adjustment is now in RSI-scale units (0-100 range) rather than price units
    dynamicOB  = _obBase + (atrPercent * _volMult * (_basePct / 100))  // Expand OB level with volatility
    dynamicOS  = _osBase - (atrPercent * _volMult * (_basePct / 100))  // Expand OS level with volatility
    obClamped  = math.max(0,  math.min(100, dynamicOB))  // Clamp to valid RSI range
    osClamped  = math.max(0,  math.min(100, dynamicOS))  // Clamp to valid RSI range
    [obClamped, osClamped]

// Adaptive RSI: Adjusts RSI calculation based on current volatility vs average volatility
// When volatility is high, RSI is amplified; when low, RSI is reduced
// This creates an adaptive indicator that responds to market conditions
f_adaptiveRsiCalculation(_atrVal, _volMult) =>
    baseRsi      = ta.rsi(close, 14)  // Standard RSI(14) as base
    smaOfAtr     = ta.sma(_atrVal, 20)  // Average ATR for comparison
    adaptFactor  = f_safeDivide(_atrVal * _volMult, smaOfAtr, 0.0)  // Volatility ratio
    adaptRsiTemp = baseRsi * (1 + adaptFactor)  // Adjust RSI by volatility factor
    math.max(0, math.min(100, adaptRsiTemp))  // Clamp to valid RSI range (0-100)


// RSI Heatmap Color: Generates background color based on RSI position
// Green for oversold, red for overbought, gray for neutral zone
// Used for visual indication of RSI state
f_rsiHeatmapColor(_rsi6, _osThreshold, _obThreshold) =>
    _rsi6 < _osThreshold ? color.new(color.green, 80) :  // Oversold = green
     _rsi6 > _obThreshold ? color.new(color.red, 80)   :  // Overbought = red
     color.new(color.gray, 50)  // Neutral = gray

// Dynamic Background Color: Generates background color based on adaptive RSI and divergence signals
// Priority: Strong divergence > Adaptive RSI position > Neutral
// Provides visual feedback for current market state
f_dynamic_bg_color(_adaptRsi, _obLevel, _osLevel, _bullStr, _bearStr) =>
    _bullStr ? color.new(color.green, 80) :  // Strong bullish divergence = green
     _bearStr ? color.new(color.red,   80) :  // Strong bearish divergence = red
     _adaptRsi > _obLevel ? color.new(color.red,   90) :  // Adaptive RSI overbought = light red
     _adaptRsi < _osLevel ? color.new(color.green, 90) :  // Adaptive RSI oversold = light green
     na  // Neutral = no background color

// Volume SMA Cache: Optimizes volume SMA calculation by caching values
// Reduces redundant calculations while maintaining accuracy
f_getVolumeSMA(_volume, _lookback) =>
    var float volumeSmaCached = na  // Persistent variable to cache volume SMA
    smaVal = ta.sma(_volume, _lookback)  // Calculate current SMA
    if barstate.islastconfirmedhistory or barstate.isrealtime
        volumeSmaCached := smaVal  // Update cache on confirmed or realtime bars
    nz(volumeSmaCached, smaVal)  // Return cached value or calculate if not available

// RSI Bottom Detection: Checks if RSI is at or near its lowest point in lookback period
// Also verifies RSI is below oversold threshold minus buffer
// Used to identify potential reversal points from oversold conditions
f_isRsiAtBottom(_rsiVal, _lookback, _osThreshold, _buffer) =>
    (_rsiVal <= ta.lowest(_rsiVal, _lookback)) and (_rsiVal < (_osThreshold - _buffer))

// RSI Top Detection: Checks if RSI is at or near its highest point in lookback period
// Also verifies RSI is above overbought threshold plus buffer
// Used to identify potential reversal points from overbought conditions
f_isRsiAtTop(_rsiVal, _lookback, _obThreshold, _buffer) =>
    (_rsiVal >= ta.highest(_rsiVal, _lookback)) and (_rsiVal > (_obThreshold + _buffer))

// Strong Buy Signal: Detects when RSI has recovered significantly from its lowest point
// Requires RSI to be at least _botThreshold points above the lowest point in period
// AND RSI must be in or near oversold zone (below threshold or just above it)
// Indicates strong reversal potential from oversold conditions
// Allow RSI to be slightly above oversold (up to 5 points) to catch early recovery signals
f_isStrongBuySignal(_rsiVal, _botPeriod, _botThreshold, _osThreshold) =>
    (math.abs(_rsiVal - ta.lowest(_rsiVal, _botPeriod)) > _botThreshold) and (_rsiVal < (_osThreshold + 5.0))

// Strong Sell Signal: Detects when RSI has declined significantly from its highest point
// Requires RSI to be at least _topThreshold points below the highest point in period
// AND RSI must be in or near overbought zone (above threshold or just below it)
// Indicates strong reversal potential from overbought conditions
// Allow RSI to be slightly below overbought (up to 5 points) to catch early decline signals
f_isStrongSellSignal(_rsiVal, _topPeriod, _topThreshold, _obThreshold) =>
    (math.abs(_rsiVal - ta.highest(_rsiVal, _topPeriod)) > _topThreshold) and (_rsiVal > (_obThreshold - 5.0))

// Volume Confirmation: Checks if current volume exceeds SMA * threshold multiplier
// Used to confirm signals with volume participation
// If threshold <= 0.1, volume confirmation is disabled (always returns true)
f_isVolumeConfirmed(_volume, _volSmaVal, _volMult) =>
    _volMult <= 0.1 ? true : (_volume > _volSmaVal * _volMult)  // Disabled if threshold too low

// Reset Condition: Prevents signal clustering by requiring minimum bars between signals
// Returns true if enough bars have passed since last trigger condition
// Used to space out signals and reduce noise
f_resetCondition(_triggerCond, _barsToReset) =>
    barsSince = ta.barssince(_triggerCond)  // Bars since last trigger
    na(barsSince) ? true : barsSince > _barsToReset  // True if never triggered or enough bars passed

// Stochastic RSI Calculation: Applies stochastic oscillator to RSI values
// StochRSI = (RSI - Lowest RSI) / (Highest RSI - Lowest RSI) * 100
// Provides additional momentum information by showing RSI position within its recent range
// Returns [raw %K, smoothed %K, %D line]
f_stochRsi(_rsi, _length, _smoothK, _smoothD) =>
    // Find the lowest and highest RSI values in the lookback period
    lowestRsi = ta.lowest(_rsi, _length)
    highestRsi = ta.highest(_rsi, _length)
    rsiRange = highestRsi - lowestRsi  // Calculate the range
    
    // Calculate raw %K: Position of current RSI within the range (0-100)
    stochK = f_safeDivide((_rsi - lowestRsi) * 100, rsiRange, 50.0)  // Default to 50 if no range
    stochK := math.max(0, math.min(100, stochK))  // Clamp to valid range (0-100)
    
    // Smooth %K line using SMA
    k = ta.sma(stochK, _smoothK)
    k := math.max(0, math.min(100, k))  // Clamp to valid range (0-100)
    
    // Calculate %D line: Smooth the smoothed %K
    d = ta.sma(k, _smoothD)
    d := math.max(0, math.min(100, d))  // Clamp to valid range (0-100)
    
    [stochK, k, d]  // Return [raw %K, smoothed %K, %D]

// Alert cooldown check: Returns true if alert is allowed (enough bars since last alert)
f_canAlert(_lastAlertBar, _cooldownBars) =>
    na(_lastAlertBar) ? true : (bar_index - _lastAlertBar >= _cooldownBars)

// Alert Cooldown Helper: Encapsulates the alert cooldown pattern
// Returns true if the signal should trigger (respecting cooldown settings)
// This function centralizes the cooldown logic to reduce code duplication
// Usage:
//   var int lastAlertBar = na
//   alertSignal = f_applyAlertCooldown(signalCondition, lastAlertBar, enableAlertCooldown, alertCooldownBars)
//   if alertSignal
//       lastAlertBar := bar_index
f_applyAlertCooldown(_signal, _lastAlertBar, _enableCooldown, _cooldownBars) =>
    _signal and (not _enableCooldown or f_canAlert(_lastAlertBar, _cooldownBars))

// Signal Strength Check: Validates RSI distance from centerline (50)
// Ensures signals only trigger when RSI is significantly away from neutral
// Buy signals: RSI must be at least _minStrength points below 50
// Sell signals: RSI must be at least _minStrength points above 50
// This filter reduces weak signals near the centerline
f_hasMinSignalStrength(_rsiVal, _isBuy, _minStrength) =>
    if _isBuy
        // For buy: RSI should be significantly below 50 (oversold territory)
        (50 - _rsiVal) >= _minStrength
    else
        // For sell: RSI should be significantly above 50 (overbought territory)
        (_rsiVal - 50) >= _minStrength

// Extreme Zone Check: Validates RSI is deep in OB/OS zone
// Requires RSI to be at least _minExtreme points beyond the threshold
// Buy signals: RSI must be at least _minExtreme points below oversold threshold
// Sell signals: RSI must be at least _minExtreme points above overbought threshold
// This filter ensures signals only trigger in extreme conditions
f_isInExtremeZone(_rsiVal, _isBuy, _osThreshold, _obThreshold, _minExtreme) =>
    if _isBuy
        // For buy: RSI must be at least minExtreme points below oversold threshold
        _rsiVal <= (_osThreshold - _minExtreme)
    else
        // For sell: RSI must be at least minExtreme points above overbought threshold
        _rsiVal >= (_obThreshold + _minExtreme)

// Consecutive Bar Confirmation: Requires signal to persist for N consecutive bars
// Reduces false signals by ensuring condition remains true over multiple bars
// If _requiredBars <= 1, returns signal as-is (no confirmation needed)
// Otherwise, checks that signal was true for all bars in the lookback period
f_consecutiveBarConfirmation(_signalCondition, _requiredBars) =>
    if _requiredBars <= 1
        _signalCondition  // No confirmation needed, return signal as-is
    else
        // Verify signal has been true for all required consecutive bars
        allTrue = true
        for i = 0 to _requiredBars - 1
            allTrue := allTrue and _signalCondition[i]  // Check each bar in lookback
        allTrue  // Return true only if all bars confirm the signal

// RSI Zone Persistence: Validates RSI has remained in OB/OS zone for N consecutive bars
// Reduces false signals by ensuring RSI stays in extreme zone, not just touching it
// Buy signals: RSI must be in oversold zone for _requiredBars consecutive bars
// Sell signals: RSI must be in overbought zone for _requiredBars consecutive bars
f_rsiZonePersistence(_rsiVal, _isBuy, _osThreshold, _obThreshold, _requiredBars) =>
    if _requiredBars <= 1
        // No persistence required, just check current bar
        _isBuy ? (_rsiVal <= _osThreshold) : (_rsiVal >= _obThreshold)
    else
        // Verify RSI has been in zone for all required consecutive bars
        allInZone = true
        for i = 0 to _requiredBars - 1
            if _isBuy
                allInZone := allInZone and (_rsiVal[i] <= _osThreshold)  // All bars in oversold
            else
                allInZone := allInZone and (_rsiVal[i] >= _obThreshold)  // All bars in overbought
        allInZone  // Return true only if all bars were in zone

// RSI Slope Confirmation: Validates RSI is moving in the expected signal direction
// Buy signals: RSI should be rising (recovering from oversold)
// Sell signals: RSI should be falling (declining from overbought)
// This ensures momentum is aligned with the signal direction
f_rsiSlopeConfirmation(_rsiVal, _isBuy, _lookback) =>
    if bar_index < _lookback
        false  // Not enough bars for slope calculation
    else
        currentVal = _rsiVal[0]  // Current RSI value
        pastVal = _rsiVal[_lookback]  // RSI value _lookback bars ago
        if _isBuy
            // For buy: RSI should be rising (current > past) = recovery momentum
            currentVal > pastVal
        else
            // For sell: RSI should be falling (current < past) = decline momentum
            currentVal < pastVal

// Trendline Angle Calculation: Computes the slope/angle of a trendline
// Used to filter out flat/weak trendlines that may generate false break signals
// Returns absolute angle value (higher = steeper trendline)
f_trendlineAngle(_lineObj) =>
    if na(_lineObj)
        na  // No trendline = no angle
    else
        // Get trendline coordinates
        x1 = line.get_x1(_lineObj)  // Start X (bar index)
        x2 = line.get_x2(_lineObj)  // End X (bar index)
        y1 = line.get_y1(_lineObj)  // Start Y (RSI value)
        y2 = line.get_y2(_lineObj)  // End Y (RSI value)
        if x2 != x1
            math.abs((y2 - y1) / (x2 - x1))  // Calculate absolute slope (angle)
        else
            na  // Vertical line (shouldn't happen)

// Pivot Low Detection: Identifies pivot lows with minimum strength requirement
// A pivot low must be significantly lower than surrounding bars to qualify
// This filters out weak pivots and reduces noise in trendline drawing
// Edge case handling: Requires sufficient historical bars before calculating averages
f_isPivotLowStrong(_rsiSeries, _detectionPeriod, _minStrength) =>
    // Always call ta.lowestbars on every bar for consistency, then use result conditionally
    lowestBarsAgo = ta.lowestbars(_rsiSeries, _detectionPeriod)
    // Require minimum bars for reliable pivot detection (need at least 2 * detectionPeriod for left/right averages)
    minBarsRequired = _detectionPeriod * 2
    if bar_index < minBarsRequired
        false  // Not enough historical bars for reliable pivot detection
    else if lowestBarsAgo == 0  // Current bar is the lowest
        pivotValue = _rsiSeries[0]  // Current bar's RSI value
        // Calculate average RSI of surrounding bars (left and right of pivot)
        // Left average: bars before the pivot period (now guaranteed to have enough bars)
        leftSum = 0.0
        leftCount = 0
        for i = _detectionPeriod to _detectionPeriod * 2 - 1
            if i < bar_index
                leftSum := leftSum + _rsiSeries[i]
                leftCount := leftCount + 1
        leftAvg = leftCount > 0 ? leftSum / float(leftCount) : pivotValue
        // Right average: bars after the pivot (if any)
        rightSum = 0.0
        rightCount = 0
        for i = 1 to math.min(_detectionPeriod, bar_index)
            rightSum := rightSum + _rsiSeries[i]
            rightCount := rightCount + 1
        rightAvg = rightCount > 0 ? rightSum / float(rightCount) : pivotValue
        avgSurrounding = (leftAvg + rightAvg) / 2.0  // Overall surrounding average
        // Pivot must be at least _minStrength points lower than surrounding average
        (avgSurrounding - pivotValue) >= _minStrength
    else
        false  // Current bar is not a pivot low

// Enhanced Pivot High Detection: Identifies pivot highs with minimum strength requirement
// A pivot high must be significantly higher than surrounding bars to qualify
// This filters out weak pivots and reduces noise in trendline drawing
// Edge case handling: Requires sufficient historical bars before calculating averages
f_isPivotHighStrong(_rsiSeries, _detectionPeriod, _minStrength) =>
    // Always call ta.highestbars on every bar for consistency, then use result conditionally
    highestBarsAgo = ta.highestbars(_rsiSeries, _detectionPeriod)
    // Require minimum bars for reliable pivot detection (need at least 2 * detectionPeriod for left/right averages)
    minBarsRequired = _detectionPeriod * 2
    if bar_index < minBarsRequired
        false  // Not enough historical bars for reliable pivot detection
    else if highestBarsAgo == 0  // Current bar is the highest
        pivotValue = _rsiSeries[0]  // Current bar's RSI value
        // Calculate average RSI of surrounding bars (left and right of pivot)
        // Left average: bars before the pivot period (now guaranteed to have enough bars)
        leftSum = 0.0
        leftCount = 0
        for i = _detectionPeriod to _detectionPeriod * 2 - 1
            if i < bar_index
                leftSum := leftSum + _rsiSeries[i]
                leftCount := leftCount + 1
        leftAvg = leftCount > 0 ? leftSum / float(leftCount) : pivotValue
        // Right average: bars after the pivot (if any)
        rightSum = 0.0
        rightCount = 0
        for i = 1 to math.min(_detectionPeriod, bar_index)
            rightSum := rightSum + _rsiSeries[i]
            rightCount := rightCount + 1
        rightAvg = rightCount > 0 ? rightSum / float(rightCount) : pivotValue
        avgSurrounding = (leftAvg + rightAvg) / 2.0  // Overall surrounding average
        // Pivot must be at least _minStrength points higher than surrounding average
        (pivotValue - avgSurrounding) >= _minStrength
    else
        false  // Current bar is not a pivot high

// RSI Source Selection Helper: Centralizes RSI source selection logic
// Reduces code duplication by providing single function for RSI source selection
// Note: RSI values must be passed as parameters since they're calculated later in the script
// Returns the selected RSI value (raw or smoothed) based on source name and smoothing preference
f_getRsiSource(_sourceName, _useSmooth, _rsi6, _rsi6Smooth, _rsi14, _rsi14Smooth, _rsi24, _rsi24Smooth) =>
    switch _sourceName
        "RSI(6)" => _useSmooth ? _rsi6Smooth : _rsi6  // Return RSI(6) raw or smoothed
        "RSI(14)" => _useSmooth ? _rsi14Smooth : _rsi14  // Return RSI(14) raw or smoothed
        "RSI(24)" => _useSmooth ? _rsi24Smooth : _rsi24  // Return RSI(24) raw or smoothed
        => na  // Unknown source name

// Table Position Helper: Converts string position input to position enum
// Used for statistics table positioning based on user preference
f_getTablePosition(_positionStr) =>
    switch _positionStr
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Bottom Left" => position.bottom_left
        "Bottom Right" => position.bottom_right
        => position.top_right  // Default to top right if invalid

//======================================================================================
//                         Regression HELPER FUNCTIONS
//======================================================================================
// Regression Function: Calculates regression coefficients for forecasting
// Supports multiple regression types: Linear, Polynomial, Exponential Smoothing, Moving Average
// Returns array of coefficients that can be used to forecast future RSI values
// Note: seriesArray parameter must be an array, not a series (for historical data access)
f_regression(seriesArray, horizon, type) =>
    var float[] coeffs = na  // Persistent array to store coefficients
    // Validate input: ensure array is not empty, horizon is valid, and horizon doesn't exceed array size
    if array.size(seriesArray) == 0 or horizon <= 0 or horizon > array.size(seriesArray)
        coeffs := array.new_float(2, na)  // Return empty array if invalid input
    else if type == "Linear"
        // Linear Regression: y = mx + b (simple trend line)
        coeffs := array.new_float(2, na)
        x = array.new_float(horizon, na)
        y = array.new_float(horizon, na)
        for i = 0 to horizon - 1
            array.set(x, i, i)
            array.set(y, i, array.get(seriesArray, i))
        
        // Linear regression: y = mx + b
        sumX = 0.0
        sumY = 0.0
        sumXY = 0.0
        sumX2 = 0.0
        for i = 0 to horizon - 1
            xi = array.get(x, i)
            yi = array.get(y, i)
            sumX := sumX + xi
            sumY := sumY + yi
            sumXY := sumXY + xi * yi
            sumX2 := sumX2 + xi * xi
        
        meanX = sumX / float(horizon)  // horizon is validated > 0 at function start
        meanY = sumY / float(horizon)  // horizon is validated > 0 at function start
        denominator = sumX2 - horizon * meanX * meanX
        m = f_safeDivide(sumXY - horizon * meanX * meanY, denominator, 0.0)
        b = meanY - m * meanX
        
        array.set(coeffs, 0, b)
        array.set(coeffs, 1, m)
    
    else if type == "Polynomial"
        // Polynomial Regression: y = axÂ² + bx + c (quadratic curve)
        // Captures non-linear trends and curvature in RSI movement
        coeffs := array.new_float(3, na)
        x = array.new_float(horizon, na)
        y = array.new_float(horizon, na)
        for i = 0 to horizon - 1
            array.set(x, i, i)
            array.set(y, i, array.get(seriesArray, i))
        
        // Calculate sums for polynomial regression
        sumX = 0.0
        sumY = 0.0
        sumXY = 0.0
        sumX2 = 0.0
        sumX3 = 0.0
        sumX4 = 0.0
        sumX2Y = 0.0
        
        for i = 0 to horizon - 1
            xi = array.get(x, i)
            yi = array.get(y, i)
            xi2 = xi * xi
            sumX := sumX + xi
            sumY := sumY + yi
            sumXY := sumXY + xi * yi
            sumX2 := sumX2 + xi2
            sumX3 := sumX3 + xi2 * xi
            sumX4 := sumX4 + xi2 * xi2
            sumX2Y := sumX2Y + xi2 * yi
        
        // Solve system: n*c + sumX*b + sumX2*a = sumY
        //              sumX*c + sumX2*b + sumX3*a = sumXY
        //              sumX2*c + sumX3*b + sumX4*a = sumX2Y
        n = float(horizon)
        det = n * (sumX2 * sumX4 - sumX3 * sumX3) - sumX * (sumX * sumX4 - sumX3 * sumX2) + sumX2 * (sumX * sumX3 - sumX2 * sumX2)
        
        if math.abs(det) > 0.0001
            c = (sumY * (sumX2 * sumX4 - sumX3 * sumX3) - sumXY * (sumX * sumX4 - sumX3 * sumX2) + sumX2Y * (sumX * sumX3 - sumX2 * sumX2)) / det
            b = (n * (sumXY * sumX4 - sumX2Y * sumX3) - sumY * (sumX * sumX4 - sumX3 * sumX2) + sumX2Y * (sumX * sumX2 - sumX2 * sumX)) / det
            a = (n * (sumX2 * sumX2Y - sumX3 * sumXY) - sumX * (sumX * sumX2Y - sumX2 * sumXY) + sumY * (sumX * sumX3 - sumX2 * sumX2)) / det
            
            array.set(coeffs, 0, c)  // constant
            array.set(coeffs, 1, b)   // linear
            array.set(coeffs, 2, a)   // quadratic
        else
            // Fallback to linear if determinant is too small
            array.set(coeffs, 0, sumY / n)
            array.set(coeffs, 1, 0.0)
            array.set(coeffs, 2, 0.0)
    
    else if type == "Exponential Smoothing"
        // Exponential Smoothing: Weighted average with more weight on recent values
        // Includes trend component for directional forecasting
        coeffs := array.new_float(2, na)
        if horizon >= 2
            alpha = 2.0 / float(horizon + 1)  // Adaptive smoothing factor (horizon >= 2, so horizon + 1 > 0)
            // Smooth from oldest to newest
            smoothed = array.get(seriesArray, horizon - 1)
            if horizon > 2
                for i = horizon - 2 to 0
                    smoothed := alpha * array.get(seriesArray, i) + (1 - alpha) * smoothed
            
            // Calculate trend using linear regression on smoothed values
            // Use a simple approach: compare current smoothed to value from earlier in horizon
            earlierIdx = math.max(1, math.round(horizon * 0.6))
            earlierSmoothed = array.get(seriesArray, horizon - 1)
            if horizon > 2 and horizon - 2 >= earlierIdx
                for i = horizon - 2 to earlierIdx
                    earlierSmoothed := alpha * array.get(seriesArray, i) + (1 - alpha) * earlierSmoothed
            // Calculate trend, with safety check for division by zero
            trendDivisor = float(horizon - earlierIdx)
            trend = f_safeDivide(smoothed - earlierSmoothed, trendDivisor, 0.0)
            array.set(coeffs, 0, smoothed)  // current smoothed value
            array.set(coeffs, 1, trend)      // trend component
        else
            // Horizon is 1 - use single value with zero trend
            array.set(coeffs, 0, array.get(seriesArray, 0))
            array.set(coeffs, 1, 0.0)
    
    else if type == "Moving Average"
        // Moving Average Regression: Uses difference between short and long MA to estimate trend
        // Simpler than other methods but effective for trend-based forecasting
        // Note: For arrays, we need to calculate MA manually (no built-in array MA function)
        coeffs := array.new_float(2, na)
        shortLen = math.max(1, math.round(horizon / 2))
        // Ensure longLen doesn't exceed available array elements (bound by horizon)
        longLen = math.max(shortLen + 1, math.min(horizon, array.size(seriesArray)))
        
        // Calculate short MA (ensure we don't access beyond array bounds)
        sumShort = 0.0
        for i = 0 to math.min(shortLen - 1, horizon - 1)
            sumShort := sumShort + array.get(seriesArray, horizon - 1 - i)
        validShortLen = math.min(shortLen, horizon)
        maShort = validShortLen > 0 ? sumShort / float(validShortLen) : array.get(seriesArray, horizon - 1)
        
        // Calculate long MA (ensure we don't access beyond array bounds)
        sumLong = 0.0
        for i = 0 to math.min(longLen - 1, horizon - 1)
            sumLong := sumLong + array.get(seriesArray, horizon - 1 - i)
        validLongLen = math.min(longLen, horizon)
        maLong = validLongLen > 0 ? sumLong / float(validLongLen) : array.get(seriesArray, horizon - 1)
        
        // Trend is the difference normalized by horizon (with safety check for division by zero)
        trendDivisor = float(longLen - shortLen)
        trend = f_safeDivide(maShort - maLong, trendDivisor, 0.0)
        array.set(coeffs, 0, maShort)   // current MA value (shorter)
        array.set(coeffs, 1, trend)      // trend component
    
    else
        // Unknown regression type or fallback - use first array value with zero trend
        coeffs := array.new_float(2, na)
        if array.size(seriesArray) > 0
            array.set(coeffs, 0, array.get(seriesArray, 0))
        else
            array.set(coeffs, 0, 0.0)
        array.set(coeffs, 1, 0.0)
    
    coeffs

// Enhanced Forecast Function: Generates future RSI values using regression coefficients
// Creates forecast array with horizon+1 values (current + future predictions)
// Supports confidence intervals for uncertainty estimation
f_forecast(series, coeffs, horizon, type) =>
    forecast = array.new_float(horizon + 1, na)  // Array to store forecast values
    array.set(forecast, 0, series[0])  // First value is current RSI (no forecast needed)
    
    if type == "Linear" and array.size(coeffs) >= 2
        b = array.get(coeffs, 0)
        m = array.get(coeffs, 1)
        for i = 1 to horizon
            array.set(forecast, i, b + m * i)
    
    else if type == "Polynomial" and array.size(coeffs) >= 3
        c = array.get(coeffs, 0)  // constant
        b = array.get(coeffs, 1)  // linear
        a = array.get(coeffs, 2)  // quadratic
        for i = 1 to horizon
            x = float(i)
            array.set(forecast, i, a * x * x + b * x + c)
    
    else if type == "Exponential Smoothing" and array.size(coeffs) >= 2
        base = array.get(coeffs, 0)
        trend = array.get(coeffs, 1)
        for i = 1 to horizon
            array.set(forecast, i, base + trend * i)
    
    else if type == "Moving Average" and array.size(coeffs) >= 2
        base = array.get(coeffs, 0)
        trend = array.get(coeffs, 1)
        for i = 1 to horizon
            array.set(forecast, i, base + trend * i)
    
    else
        // Fallback: constant value
        for i = 1 to horizon
            array.set(forecast, i, series[0])
    
    forecast

// Forecast Error Calculation: Computes prediction accuracy for confidence bands
// Compares historical values with forecast to estimate prediction uncertainty
// Returns RMSE (Root Mean Square Error) or fallback to historical volatility estimate
f_forecast_error(histSeries, forecastArray, horizon) =>
    // Safety check: Return 0.0 if arrays are empty (handles bar 0 and other edge cases)
    if array.size(histSeries) == 0 or array.size(forecastArray) == 0 or horizon <= 0
        0.0  // Return 0 error when no data is available
    else
        sumSqError = 0.0  // Sum of squared errors
        count = 0  // Number of valid comparisons
        // Compare historical values with forecast (backward validation)
        for i = 0 to math.min(horizon - 1, array.size(forecastArray) - 1)
            histVal = array.get(histSeries, i)
            forecastVal = array.get(forecastArray, i)
            if not na(histVal) and not na(forecastVal)
                error = histVal - forecastVal
                sumSqError := sumSqError + error * error
                count := count + 1
        
        // Calculate RMSE or fallback to historical volatility
        if count >= 2
            rmse = math.sqrt(sumSqError / float(count))
            rmse
        else
            // Fallback: use average of recent RSI values to estimate volatility
            sumVal = 0.0
            validCount = 0
            for i = 0 to math.min(horizon - 1, array.size(histSeries) - 1)
                val = array.get(histSeries, i)
                if not na(val)
                    sumVal := sumVal + val
                    validCount := validCount + 1
            
            if validCount > 0
                meanVal = sumVal / float(validCount)
                sumSqDiff = 0.0
                for i = 0 to math.min(horizon - 1, array.size(histSeries) - 1)
                    val = array.get(histSeries, i)
                    if not na(val)
                        diff = val - meanVal
                        sumSqDiff := sumSqDiff + diff * diff
                stdev = validCount > 1 ? math.sqrt(sumSqDiff / float(validCount - 1)) : 5.0
                stdev
            else
                5.0  // Default error estimate

//======================================================================================
//                         PIVOT DETECTION FUNCTIONS
//======================================================================================
// Basic Pivot Detection: Identifies local extremes in RSI series
// Pivot Low: Current bar is the lowest within detection period
// Used for trendline drawing and divergence analysis
f_isPivotLow(_rsiSeries, _detectionPeriod) =>
    ta.lowestbars(_rsiSeries, _detectionPeriod) == 0  // Current bar is the lowest

// Pivot High: Current bar is the highest within detection period
// Used for trendline drawing and divergence analysis
f_isPivotHigh(_rsiSeries, _detectionPeriod) =>
    ta.highestbars(_rsiSeries, _detectionPeriod) == 0  // Current bar is the highest

// Pivot Confirmation: Validates pivot remains extreme after N bars (reduces repainting)
// For Pivot Low: Checks if pivot value is still the lowest after waiting period
// This confirmation prevents false pivots and improves trendline accuracy
f_confirmPivotLow(_rsiSeries, _pivotBarIndex, _pivotValue, _detectionPeriod, _barsWait) =>
    // Always call ta.lowest on every bar for consistency, then use result conditionally
    lowestSeries = ta.lowest(_rsiSeries, _detectionPeriod)
    // Wait for confirmation period, then verify pivot is still valid
    if bar_index >= _pivotBarIndex + _barsWait
        barsBack = bar_index - _pivotBarIndex  // Bars since pivot occurred
        // Get the lowest value in the detection period ending at the pivot bar
        lowestAtPivotBar = lowestSeries[barsBack]
        // Compare with small epsilon for float precision (pivot still valid if equal)
        math.abs(_pivotValue - lowestAtPivotBar) < 0.0001
    else
        false  // Not enough bars for confirmation yet

// Pivot High Confirmation: Validates pivot remains extreme after N bars
// For Pivot High: Checks if pivot value is still the highest after waiting period
f_confirmPivotHigh(_rsiSeries, _pivotBarIndex, _pivotValue, _detectionPeriod, _barsWait) =>
    // Always call ta.highest on every bar for consistency, then use result conditionally
    highestSeries = ta.highest(_rsiSeries, _detectionPeriod)
    // Wait for confirmation period, then verify pivot is still valid
    if bar_index >= _pivotBarIndex + _barsWait
        barsBack = bar_index - _pivotBarIndex  // Bars since pivot occurred
        // Get the highest value in the detection period ending at the pivot bar
        highestAtPivotBar = highestSeries[barsBack]
        // Compare with small epsilon for float precision (pivot still valid if equal)
        math.abs(_pivotValue - highestAtPivotBar) < 0.0001
    else
        false  // Not enough bars for confirmation yet

//======================================================================================
//                         HELPER FUNCTIONS FOR FILTERS
//======================================================================================
// Consolidated Filter Function: Single source of truth for all signal filters
// Applies all enabled filters (Trend, ADX, Volume, Momentum, MTF, Engulfing Pattern) to signals
// Returns true only if all enabled filters pass
// Note: All required values must be passed as parameters since they're calculated later
// _rsi14Smooth parameter receives the displayed RSI (adaptive based on preset mode)
f_applyAllFilters(_isBuy, _rsi14Smooth, _trendIsBullish, _trendIsBearish, _adxIsStrong, _isVolumeDryUp, _rsiHigherTf) =>
    // Trend Filter: Buy signals require bullish trend, Sell signals require bearish trend
    trendOk = not useTrendFilter or (_isBuy ? _trendIsBullish : _trendIsBearish)
    
    // ADX Filter: Requires ADX above threshold (trend strength confirmation)
    adxOk = not useAdxFilter or _adxIsStrong
    
    // Volume Filter: Avoids signals during volume dry-up periods
    volumeOk = not enableVolumeDryUp or not _isVolumeDryUp
    
    // Momentum Filter: Requires RSI momentum in signal direction (respects presets)
    // Always call momentum function on every bar for consistency, then use result conditionally
    momentumResult = f_rsiMomentum(_rsi14Smooth, momentumLookback, _isBuy)
    momentumOk = not finalMomentumConfirmation or momentumResult
    
    // Multi-Timeframe Filter: Requires higher timeframe RSI alignment
    // Buy: Current RSI must be below HTF RSI by threshold
    // Sell: Current RSI must be above HTF RSI by threshold
    mtfOk = not requireMultiTimeframeConf or (not na(_rsiHigherTf) and (_isBuy ? _rsi14Smooth < _rsiHigherTf - mtfConfirmationThreshold : _rsi14Smooth > _rsiHigherTf + mtfConfirmationThreshold))
    
    // Engulfing Pattern Filter: Requires candlestick pattern confirmation
    // Buy signals require bullish engulfing, Sell signals require bearish engulfing
    engulfingOk = not requireEngulfingPattern or (_isBuy ? isBullishEngulfing() : isBearishEngulfing())
    
    // All filters must pass (if enabled)
    trendOk and adxOk and volumeOk and momentumOk and mtfOk and engulfingOk

//======================================================================================
//                         MAIN CALCULATIONS (RSI, ATR, Volume, ADX, etc.)
//======================================================================================
// Calculate RSI values for all three periods (6, 14, 24)
// Each returns [raw RSI, smoothed RSI] for maximum flexibility
// Using validated/final values that respect presets and cross-input validation
[rsi6,  rsi6Smooth]  = f_calculate_rsi(finalRsiLength6,  finalSmoothingLength_6,  applyGlobalSmoothing, finalGlobalSmoothingLength)
[rsi14, rsi14Smooth] = f_calculate_rsi(finalRsiLength14, finalSmoothingLength_14, applyGlobalSmoothing, finalGlobalSmoothingLength)
[rsi24, rsi24Smooth] = f_calculate_rsi(finalRsiLength24, finalSmoothingLength_24, applyGlobalSmoothing, finalGlobalSmoothingLength)

// Higher Timeframe RSI: Fetches RSI from selected higher timeframe for MTF confirmation
// Used for multi-timeframe analysis to confirm signals with higher timeframe trend
// Only calculate when needed (MTF confirmation enabled OR higher TF RSI display enabled)
// Use adaptive RSI length based on preset mode
rsiHigherTf = (requireMultiTimeframeConf or showRsiHigherTimeframe) ? request.security(syminfo.tickerid, higherTimeframe, ta.rsi(close, finalAdaptiveRsiLength)) : na

// Adaptive RSI Source: Select the correct RSI (raw and smoothed) based on preset mode
// This ensures all features use the displayed RSI for the selected preset
adaptiveRsiRaw = f_getRsiSource(finalAdaptiveRsiSource, false, rsi6, rsi6Smooth, rsi14, rsi14Smooth, rsi24, rsi24Smooth)
adaptiveRsiSmooth = f_getRsiSource(finalAdaptiveRsiSource, applyGlobalSmoothing, rsi6, rsi6Smooth, rsi14, rsi14Smooth, rsi24, rsi24Smooth)

// Dynamic Overbought/Oversold: Calculate volatility-adjusted OB/OS levels
// These levels adapt to market volatility using ATR, providing more accurate signals
atrValue      = f_atrCache(atrLength)  // Get cached ATR value
[obDyn, osDyn]= f_dynamicOverboughtOversold(atrValue, overboughtThreshold, oversoldThreshold, volatilityMultiplier, thresholdAdjustmentFactor)

// Adaptive RSI: Volatility-adjusted RSI used for signal generation (not plotted)
// This RSI adapts to market conditions, amplifying during high volatility periods
normalizedAdaptiveRsi = f_adaptiveRsiCalculation(atrValue, volatilityMultiplier)

// RSI Bollinger Bands: Applies Bollinger Bands to the displayed RSI for extreme zone identification
// Upper/Lower bands help identify when RSI is in extreme territory
// Use adaptive RSI source based on preset mode
rsiBBBasis = ta.sma(adaptiveRsiSmooth, bbLength)  // RSI moving average (middle band)
rsiBBStdev = ta.stdev(adaptiveRsiSmooth, bbLength)  // RSI standard deviation
rsiBBUpper = rsiBBBasis + bbDev * rsiBBStdev  // Upper band (basis + deviation)
rsiBBLower = rsiBBBasis - bbDev * rsiBBStdev  // Lower band (basis - deviation)

// Trend Filter: Long-term EMA for trend direction confirmation
// Only calculated if trend filter is enabled (performance optimization)
longTermEma = useTrendFilter ? ta.ema(close, trendFilterEmaLength) : na  // Long-term EMA
emaSlope = useTrendFilter ? (longTermEma - longTermEma[1]) : 0.0  // EMA direction/slope
emaRising = useTrendFilter ? (emaSlope > 0) : false  // EMA is rising (bullish)
emaFalling = useTrendFilter ? (emaSlope < 0) : false  // EMA is falling (bearish)

// Basic Trend: Price position relative to EMA
// Bullish = price above EMA, Bearish = price below EMA
trendIsBullishBasic = useTrendFilter ? (close > longTermEma) : false
trendIsBearishBasic = useTrendFilter ? (close < longTermEma) : false

// Enhanced Trend: Combines price position with EMA slope direction
// Requires both price position AND EMA direction for stronger trend confirmation
trendIsBullish = useTrendFilter ? (useTrendSlope ? (trendIsBullishBasic and emaRising) : trendIsBullishBasic) : false
trendIsBearish = useTrendFilter ? (useTrendSlope ? (trendIsBearishBasic and emaFalling) : trendIsBearishBasic) : false

// ADX Filter: Measures trend strength using Directional Movement Index
// ADX > threshold indicates strong trend (good for trend-following signals)
// Calculate always but only use when filter is enabled (performance optimization)
[plusDI, minusDI, adxVal] = ta.dmi(adxLength, adxSmoothing=adxSmoothing)  // Get DMI components
adxIsStrong = useAdxFilter and (adxVal > adxThreshold)  // Strong trend if ADX above threshold

// Volume Analysis: Detects volume extremes (climax and dry-up)
// Volume Climax: Extremely high volume (capitulation) - marked with âš¡
// Volume Dry-Up: Extremely low volume (consolidation) - marked with ðŸ’§
// Use direct SMA calculation (not cached) for real-time accuracy in climax/dry-up detection
avgVolume       = ta.sma(volume, volumeLookback)  // Average volume (direct calculation for real-time accuracy)
volStd          = ta.stdev(volume, volumeLookback)  // Volume standard deviation
// Calculate threshold using standard statistical approach
climaxThreshold = avgVolume + volClimaxMult * volStd  // Upper threshold (climax): avg + (multiplier Ã— stddev)
dryUpThreshold  = math.max(0.0, avgVolume - volDryUpMult * volStd)  // Lower threshold (dry-up) - clamped to prevent negative values
// Volume climax detection: volume must exceed threshold
isVolumeClimax  = volume > climaxThreshold  // Current volume is climax
isVolumeDryUp   = volume < dryUpThreshold  // Current volume is dry-up

//======================================================================================
//                       STOCHRSI CALCULATION
//======================================================================================
// Stochastic RSI: Applies stochastic oscillator to RSI values for additional momentum insight
// Shows RSI position within its recent range (0-100 scale)
// Only calculated if enabled (performance optimization - reduces unnecessary calculations)
var float stochRsiK = na  // Raw %K line
var float stochRsiKSmoothed = na  // Smoothed %K line
var float stochRsiD = na  // %D line (signal line)

if showStochRsi
    // Select RSI source for StochRSI calculation (only calculate when feature is enabled)
    rsiForStoch = stochRsiSource == "RSI(6)" ? (applyGlobalSmoothing ? rsi6Smooth : rsi6) :
                  stochRsiSource == "RSI(14)" ? (applyGlobalSmoothing ? rsi14Smooth : rsi14) :
                  (applyGlobalSmoothing ? rsi24Smooth : rsi24)
    // Calculate StochRSI: Returns [raw %K, smoothed %K, %D]
    [k, kSmooth, d] = f_stochRsi(rsiForStoch, stochRsiLength, stochRsiSmoothK, stochRsiSmoothD)
    stochRsiK := k
    stochRsiKSmoothed := kSmooth
    stochRsiD := d

//======================================================================================
//                       PLOTTING MAIN RSI & BACKGROUND
//======================================================================================
plot(finalShowRsi6  ? (applyGlobalSmoothing ? rsi6Smooth  : rsi6)  : na, title="RSI (6)",  color=color.yellow, linewidth=2)
plot(finalShowRsi14 ? (applyGlobalSmoothing ? rsi14Smooth : rsi14) : na, title="RSI (14)", color=color.purple, linewidth=2)
plot(finalShowRsi24 ? (applyGlobalSmoothing ? rsi24Smooth : rsi24) : na, title="RSI (24)", color=color.orange, linewidth=2)

// Higher TF RSI
plot(showRsiHigherTimeframe ? rsiHigherTf : na, title="Higher TF RSI", color=color.blue, linewidth=2)

// Static Overbought / Oversold lines (dotted for display, plots for fill support)
hline(overboughtThreshold, title="Overbought", color=color.red, linestyle=hline.style_dotted, linewidth=2)
hline(oversoldThreshold, title="Oversold", color=color.green, linestyle=hline.style_dotted, linewidth=2)
hline(50, title="RSI Centerline (50)", color=color.gray, linestyle=hline.style_dashed, linewidth=1)

// Select RSI source for OB/OS fills (using helper function)
rsiForFill = f_getRsiSource(finalObOsFillRsiSource, applyGlobalSmoothing, rsi6, rsi6Smooth, rsi14, rsi14Smooth, rsi24, rsi24Smooth)

// Determine if RSI is in OB/OS zones - use inclusive conditions to ensure complete area coverage
// Check if RSI is in zone OR was in zone on previous bar (to cover exit boundaries)
isOverbought = rsiForFill >= overboughtThreshold
isOversold = rsiForFill <= oversoldThreshold
wasOverbought = rsiForFill[1] >= overboughtThreshold
wasOversold = rsiForFill[1] <= oversoldThreshold

// Extended conditions to ensure fill covers entry/exit boundaries completely
// Include current bar if in zone OR previous bar was in zone (catches exit points)
shouldFillOb = showObOsFill and (isOverbought or wasOverbought)
shouldFillOs = showObOsFill and (isOversold or wasOversold)

// Minimum gap to ensure TradingView renders fills reliably (prevents missed polygons)
// Using constant defined at top of file

// Create plots for fills - use actual RSI value to follow line accurately
// For overbought: when should fill, use RSI value but ensure minimum gap from threshold
// When not filling, use threshold value (not na) to prevent gaps in fill rendering
rsiObFill = showObOsFill ? (shouldFillOb ? (rsiForFill >= overboughtThreshold ? math.max(rsiForFill, overboughtThreshold + minFillGap) : overboughtThreshold + minFillGap) : overboughtThreshold) : na

// For oversold: when should fill, use RSI value but ensure minimum gap from threshold
// When not filling, use threshold value (not na) to prevent gaps in fill rendering
rsiOsFill = showObOsFill ? (shouldFillOs ? (rsiForFill <= oversoldThreshold ? math.min(rsiForFill, oversoldThreshold - minFillGap) : oversoldThreshold - minFillGap) : oversoldThreshold) : na

// Invisible plots at threshold levels for fill support (must use plot() for fill())
plotObLine = plot(overboughtThreshold, title="Overbought Fill Line", color=na)
plotOsLine = plot(oversoldThreshold, title="Oversold Fill Line", color=na)

// RSI plots for fills (invisible, only used for fill calculation)
plotRsiObFill = plot(rsiObFill, title="RSI OB Fill", color=na)
plotRsiOsFill = plot(rsiOsFill, title="RSI OS Fill", color=na)

// Fill zones (must be at global scope)
fill(plotRsiObFill, plotObLine, color=shouldFillOb ? obFillColor : na, title="Overbought Zone")

// Oversold zone fill
fill(plotRsiOsFill, plotOsLine, color=shouldFillOs ? osFillColor : na, title="Oversold Zone")

// StochRSI plots
plot(showStochRsi ? stochRsiKSmoothed : na, title="StochRSI %K", color=color.blue, linewidth=1)
plot(showStochRsi ? stochRsiD : na, title="StochRSI %D", color=color.red, linewidth=1)
hline(showStochRsi ? stochRsiOverbought : na, title="StochRSI Overbought", color=color.new(color.red, 50), linestyle=hline.style_dotted, linewidth=1)
hline(showStochRsi ? stochRsiOversold : na, title="StochRSI Oversold", color=color.new(color.green, 50), linestyle=hline.style_dotted, linewidth=1)

// Dynamic OB/OS bands
dynamicOB = plot(obDyn, title="Dynamic Overbought", color=color.new(color.red,   90), linewidth=2, style=plot.style_stepline)
dynamicOS = plot(osDyn, title="Dynamic Oversold",   color=color.new(color.green, 90), linewidth=2, style=plot.style_stepline)
fill(dynamicOB, dynamicOS, color=color.new(color.yellow, 90), title="OB/OS Fill")

// Bollinger on RSI
plotRsiBBUpper = plot(plotRsiBB ? rsiBBUpper : na, color=color.new(color.gray, 50), linewidth=1, title="RSI BB Upper")
plotRsiBBLower = plot(plotRsiBB ? rsiBBLower : na, color=color.new(color.gray, 50), linewidth=1, title="RSI BB Lower")
fill(plotRsiBBUpper, plotRsiBBLower, color=color.new(color.blue, 85), title="RSI BB Fill")

//======================================================================================
//                              ALERT CONDITIONS
//======================================================================================
// Core Signal Detection: Adaptive RSI crossing dynamic OB/OS levels
// Buy Signal: Adaptive RSI crosses below dynamic oversold level
// Sell Signal: Adaptive RSI crosses above dynamic overbought level
// Use adaptiveRsiSmooth (displayed RSI) for consistency with what user sees on chart
buySignal  = ta.crossunder(adaptiveRsiSmooth, osDyn)
sellSignal = ta.crossover(adaptiveRsiSmooth,  obDyn)

// Apply Accuracy Filters: Trend, ADX, Volume, Momentum, MTF confirmation
// These filters improve signal quality by requiring multiple confirmations
// Always call filter functions on every bar for consistency, then use results conditionally
// Use adaptive RSI source based on preset mode
buyFiltersPassed = f_applyAllFilters(true, adaptiveRsiSmooth, trendIsBullish, trendIsBearish, adxIsStrong, isVolumeDryUp, rsiHigherTf)
sellFiltersPassed = f_applyAllFilters(false, adaptiveRsiSmooth, trendIsBullish, trendIsBearish, adxIsStrong, isVolumeDryUp, rsiHigherTf)
buySignalFiltered  = buySignal  and buyFiltersPassed
sellSignalFiltered = sellSignal and sellFiltersPassed

// Apply Noise Reduction Filters: Optional additional filters for signal quality
// Zone Persistence: Requires RSI to stay in OB/OS zone for N bars (optional)
// RSI Slope: Requires RSI to be moving in signal direction (optional)
// Always call zone persistence and slope confirmation on every bar for consistency, then use results conditionally
// Use adaptive RSI source based on preset mode
zonePersistenceBuyRaw = f_rsiZonePersistence(adaptiveRsiSmooth, true, oversoldThreshold, overboughtThreshold, requireConsecutiveBars)
zonePersistenceSellRaw = f_rsiZonePersistence(adaptiveRsiSmooth, false, oversoldThreshold, overboughtThreshold, requireConsecutiveBars)
rsiSlopeBuyRaw = f_rsiSlopeConfirmation(adaptiveRsiSmooth, true, math.max(2, requireConsecutiveBars))
rsiSlopeSellRaw = f_rsiSlopeConfirmation(adaptiveRsiSmooth, false, math.max(2, requireConsecutiveBars))

zonePersistenceBuy = not requireZonePersistence or zonePersistenceBuyRaw
zonePersistenceSell = not requireZonePersistence or zonePersistenceSellRaw
rsiSlopeBuy = not requireRsiSlope or rsiSlopeBuyRaw
rsiSlopeSell = not requireRsiSlope or rsiSlopeSellRaw

// Create persistent conditions for consecutive bar confirmation
// buySignalFiltered/sellSignalFiltered are momentary (only true on crossover bar)
// We need persistent conditions that remain true while RSI is in zone AND filters pass
// This allows consecutiveBarConfirmation to work correctly
buyConditionPersistent = (adaptiveRsiSmooth <= osDyn) and buyFiltersPassed
sellConditionPersistent = (adaptiveRsiSmooth >= obDyn) and sellFiltersPassed

// Noise Reduction: Combines multiple filters to reduce false signals
// - Signal Strength: RSI must be X points from centerline
// - Extreme Zone: RSI must be deep in OB/OS zone
// - Consecutive Bars: Signal must persist for N bars (using persistent condition, not momentary crossover)
// - Zone Persistence: RSI must stay in zone (if enabled)
// - RSI Slope: RSI must move in signal direction (if enabled)
// Using final noise reduction setting (respects presets)
// Always call consecutive bar confirmation on every bar for consistency
buySignalConsecutiveConfirm = f_consecutiveBarConfirmation(buyConditionPersistent, requireConsecutiveBars)
sellSignalConsecutiveConfirm = f_consecutiveBarConfirmation(sellConditionPersistent, requireConsecutiveBars)

// Use adaptive RSI source based on preset mode
noiseReductionBuy = not finalNoiseReductionEnabled or (f_hasMinSignalStrength(adaptiveRsiSmooth, true, minSignalStrength) and f_isInExtremeZone(adaptiveRsiSmooth, true, oversoldThreshold, overboughtThreshold, minRsiExtreme) and buySignalConsecutiveConfirm and zonePersistenceBuy and rsiSlopeBuy)
noiseReductionSell = not finalNoiseReductionEnabled or (f_hasMinSignalStrength(adaptiveRsiSmooth, false, minSignalStrength) and f_isInExtremeZone(adaptiveRsiSmooth, false, oversoldThreshold, overboughtThreshold, minRsiExtreme) and sellSignalConsecutiveConfirm and zonePersistenceSell and rsiSlopeSell)

// Final Signals: Combine filtered signals with noise reduction
// IMPORTANT: For consecutive bar confirmation, we need to trigger when confirmation is met,
// not just on the crossover bar. Track raw crossovers separately from filtered ones.
// This ensures signals fire when consecutive confirmation completes, even if crossover happened earlier.
// Rationale: A crossover at bar N might not meet consecutive confirmation until bar N+M.
// By tracking the raw crossover separately, we can trigger the signal when confirmation completes.
var int lastBuyCrossoverBar = na      // Track raw buy crossover (before filters)
var int lastSellCrossoverBar = na      // Track raw sell crossover (before filters)
var int lastBuyFilteredCrossoverBar = na  // Track filtered buy crossover (for statistics)
var int lastSellFilteredCrossoverBar = na // Track filtered sell crossover (for statistics)

// Track raw crossovers (for signal generation) - these occur when RSI crosses OB/OS levels
// This ensures we can detect signals even if filters initially block them
if buySignal
    lastBuyCrossoverBar := bar_index
if sellSignal
    lastSellCrossoverBar := bar_index

// Track filtered crossovers (for statistics only)
if buySignalFiltered
    lastBuyFilteredCrossoverBar := bar_index
if sellSignalFiltered
    lastSellFilteredCrossoverBar := bar_index

// Final signal triggers when: (1) we had a recent raw crossover AND (2) consecutive confirmation is now met
// This allows signals to fire when confirmation completes, not just on the crossover bar
// Use a window that allows confirmation to complete after the crossover
maxConfirmationWindow = math.max(requireConsecutiveBars + 2, 5)  // Allow enough bars for confirmation to complete
barsSinceBuyCrossover = not na(lastBuyCrossoverBar) ? (bar_index - lastBuyCrossoverBar) : 999
barsSinceSellCrossover = not na(lastSellCrossoverBar) ? (bar_index - lastSellCrossoverBar) : 999
recentBuyCrossover = barsSinceBuyCrossover <= maxConfirmationWindow  // Allow crossover within confirmation window
recentSellCrossover = barsSinceSellCrossover <= maxConfirmationWindow

// Final signals: trigger when we had a recent raw crossover AND noise reduction passes AND filters pass
// This ensures signals fire when consecutive confirmation completes, not just on crossover bar
// Note: We check filters here (buyConditionPersistent includes buyFiltersPassed) to ensure quality
finalBuySignalRaw  = recentBuyCrossover and noiseReductionBuy and buyConditionPersistent
finalSellSignalRaw = recentSellCrossover and noiseReductionSell and sellConditionPersistent

// Calculate Signal Strength: Enhanced weighted calculation with RSI depth scoring (always calculated for display)
// Pass dynamic OB/OS levels for more accurate depth scoring relative to current market conditions
buySignalStrength = f_calculateSignalStrength(true, adaptiveRsiSmooth, trendIsBullish, trendIsBearish, adxIsStrong, isVolumeDryUp, rsiHigherTf, zonePersistenceBuy, rsiSlopeBuy, oversoldThreshold, overboughtThreshold, osDyn, obDyn)
sellSignalStrength = f_calculateSignalStrength(false, adaptiveRsiSmooth, trendIsBullish, trendIsBearish, adxIsStrong, isVolumeDryUp, rsiHigherTf, zonePersistenceSell, rsiSlopeSell, oversoldThreshold, overboughtThreshold, osDyn, obDyn)

// Performance Statistics Tracking
var int totalBuySignals = 0
var int totalSellSignals = 0
var int totalBuySignalsAfterAccuracy = 0
var int totalSellSignalsAfterAccuracy = 0
var int totalBuySignalsFiltered = 0
var int totalSellSignalsFiltered = 0

// Filter-by-filter diagnostic tracking (counts rejections per filter type)
var int buyRejectedByTrend = 0
var int sellRejectedByTrend = 0
var int buyRejectedByAdx = 0
var int sellRejectedByAdx = 0
var int buyRejectedByVolume = 0
var int sellRejectedByVolume = 0
var int buyRejectedByMomentum = 0
var int sellRejectedByMomentum = 0
var int buyRejectedByMtf = 0
var int sellRejectedByMtf = 0
var int buyRejectedByEngulfing = 0
var int sellRejectedByEngulfing = 0

// Statistics tracking variables (must be at global scope, not inside if block)
var int lastCountedBuyCrossoverBar = na
var int lastCountedSellCrossoverBar = na

if showPerformanceStats
    // Count only when signal transitions from false to true (unique signals only, not persistent signals)
    // This prevents counting the same signal multiple times when it persists across consecutive bars
    if buySignal and not buySignal[1]
        totalBuySignals := totalBuySignals + 1
        // Track which filters failed (for diagnostics)
        // Check each filter individually to see which one(s) blocked the signal
        trendOk = not useTrendFilter or trendIsBullish
        adxOk = not useAdxFilter or adxIsStrong
        volumeOk = not enableVolumeDryUp or not isVolumeDryUp
        momentumResult = f_rsiMomentum(adaptiveRsiSmooth, momentumLookback, true)
        momentumOk = not finalMomentumConfirmation or momentumResult
        mtfOk = not requireMultiTimeframeConf or (not na(rsiHigherTf) and adaptiveRsiSmooth < rsiHigherTf - mtfConfirmationThreshold)
        engulfingOk = not requireEngulfingPattern or isBullishEngulfing()
        
        // Count rejections per filter (only count if filter is enabled and failed)
        if useTrendFilter and not trendIsBullish
            buyRejectedByTrend := buyRejectedByTrend + 1
        if useAdxFilter and not adxIsStrong
            buyRejectedByAdx := buyRejectedByAdx + 1
        if enableVolumeDryUp and isVolumeDryUp
            buyRejectedByVolume := buyRejectedByVolume + 1
        if finalMomentumConfirmation and not momentumResult
            buyRejectedByMomentum := buyRejectedByMomentum + 1
        if requireMultiTimeframeConf and (na(rsiHigherTf) or not (adaptiveRsiSmooth < rsiHigherTf - mtfConfirmationThreshold))
            buyRejectedByMtf := buyRejectedByMtf + 1
        if requireEngulfingPattern and not isBullishEngulfing()
            buyRejectedByEngulfing := buyRejectedByEngulfing + 1
    
    if sellSignal and not sellSignal[1]
        totalSellSignals := totalSellSignals + 1
        // Track which filters failed (for diagnostics)
        trendOk = not useTrendFilter or trendIsBearish
        adxOk = not useAdxFilter or adxIsStrong
        volumeOk = not enableVolumeDryUp or not isVolumeDryUp
        momentumResult = f_rsiMomentum(adaptiveRsiSmooth, momentumLookback, false)
        momentumOk = not finalMomentumConfirmation or momentumResult
        mtfOk = not requireMultiTimeframeConf or (not na(rsiHigherTf) and adaptiveRsiSmooth > rsiHigherTf + mtfConfirmationThreshold)
        engulfingOk = not requireEngulfingPattern or isBearishEngulfing()
        
        // Count rejections per filter (only count if filter is enabled and failed)
        if useTrendFilter and not trendIsBearish
            sellRejectedByTrend := sellRejectedByTrend + 1
        if useAdxFilter and not adxIsStrong
            sellRejectedByAdx := sellRejectedByAdx + 1
        if enableVolumeDryUp and isVolumeDryUp
            sellRejectedByVolume := sellRejectedByVolume + 1
        if finalMomentumConfirmation and not momentumResult
            sellRejectedByMomentum := sellRejectedByMomentum + 1
        if requireMultiTimeframeConf and (na(rsiHigherTf) or not (adaptiveRsiSmooth > rsiHigherTf + mtfConfirmationThreshold))
            sellRejectedByMtf := sellRejectedByMtf + 1
        if requireEngulfingPattern and not isBearishEngulfing()
            sellRejectedByEngulfing := sellRejectedByEngulfing + 1
    
    // Track intermediate stage: signals after accuracy filters (before noise reduction)
    if buySignalFiltered and not buySignalFiltered[1]
        totalBuySignalsAfterAccuracy := totalBuySignalsAfterAccuracy + 1
    if sellSignalFiltered and not sellSignalFiltered[1]
        totalSellSignalsAfterAccuracy := totalSellSignalsAfterAccuracy + 1
    
    // Only count finalBuySignalRaw if it's a new signal (transition from false to true)
    // AND we haven't already counted this crossover event
    // Use lastBuyFilteredCrossoverBar for statistics (tracks filtered crossovers, not raw ones)
    if finalBuySignalRaw and not finalBuySignalRaw[1]
        // Check if this signal corresponds to a recent filtered crossover that hasn't been counted yet
        if not na(lastBuyFilteredCrossoverBar) and (na(lastCountedBuyCrossoverBar) or lastBuyFilteredCrossoverBar != lastCountedBuyCrossoverBar)
            totalBuySignalsFiltered := totalBuySignalsFiltered + 1
            lastCountedBuyCrossoverBar := lastBuyFilteredCrossoverBar
    
    if finalSellSignalRaw and not finalSellSignalRaw[1]
        // Check if this signal corresponds to a recent filtered crossover that hasn't been counted yet
        if not na(lastSellFilteredCrossoverBar) and (na(lastCountedSellCrossoverBar) or lastSellFilteredCrossoverBar != lastCountedSellCrossoverBar)
            totalSellSignalsFiltered := totalSellSignalsFiltered + 1
            lastCountedSellCrossoverBar := lastSellFilteredCrossoverBar

// Alert cooldown for main signals using reusable helper
var int lastBuyAlert = na
var int lastSellAlert = na

// Track last bar index where strength labels were created (to prevent duplicates)
var int lastBuyStrengthLabelBar = na
var int lastSellStrengthLabelBar = na

// Track pending buy/sell signals to find the best (lowest/highest) point within the distance window
var int pendingBuySignalBar = na
var float pendingBuySignalRsi = na
var int pendingBuySignalStrength = na
var int pendingSellSignalBar = na
var float pendingSellSignalRsi = na
var int pendingSellSignalStrength = na

finalBuySignal  = f_applyAlertCooldown(finalBuySignalRaw, lastBuyAlert, enableAlertCooldown, alertCooldownBars)
finalSellSignal = f_applyAlertCooldown(finalSellSignalRaw, lastSellAlert, enableAlertCooldown, alertCooldownBars)

// Update cooldown tracking when alerts fire
if finalBuySignal
    lastBuyAlert := bar_index
if finalSellSignal
    lastSellAlert := bar_index

// Main Buy/Sell Alerts (works for all trading modes)
alertcondition(enableMainBuySellAlerts and finalBuySignal,  title="Buy Alert",  message="Adaptive RSI < Dynamic Oversold => Potential BUY. Filters passed.")
alertcondition(enableMainBuySellAlerts and finalSellSignal, title="Sell Alert", message="Adaptive RSI > Dynamic Overbought => Potential SELL. Filters passed.")

// Adaptive RSI Cross Alerts removed - use Main Buy/Sell Alerts instead (more filtered and accurate)

//======================================================================================
//                         DIVERGENCE DETECTION
//======================================================================================
var array<label> divergenceLabels = array.new<label>()
var array<int> divergenceLabelBars = array.new<int>()  // Track bar indices for each label

// Use adaptive RSI source based on preset mode (divergence uses smoothed RSI)
// Keep raw RSI for detection logic, but use adaptive RSI for visual positioning
osc = adaptiveRsiSmooth
oscDisplay = adaptiveRsiSmooth  // Use adaptive RSI for labels and lines

// Detect pivot points - exactly like MACD script
// Add bounds checking to prevent errors on early bars
hasEnoughHistory = bar_index >= (pivotLookbackLeft + pivotLookbackRight)
plFound = hasEnoughHistory ? (not na(ta.pivotlow(osc, pivotLookbackLeft, pivotLookbackRight))) : false
phFound = hasEnoughHistory ? (not na(ta.pivothigh(osc, pivotLookbackLeft, pivotLookbackRight))) : false

// Cache pivot calculations to avoid redundant valuewhen() calls
// Cache osc[pivotLookbackRight] to avoid multiple array accesses
oscAtPivot = bar_index >= pivotLookbackRight ? osc[pivotLookbackRight] : na
lowAtPivot = bar_index >= pivotLookbackRight ? low[pivotLookbackRight] : na
highAtPivot = bar_index >= pivotLookbackRight ? high[pivotLookbackRight] : na

// Regular Bullish Divergence - cache pivot low calculations
prevOscBull = ta.valuewhen(plFound, oscAtPivot, 1)
prevLowBull = ta.valuewhen(plFound, lowAtPivot, 1)
inRangeBull = _inRange(plFound[1])
rsiHHCenterline = ta.highest(osc, pivotLookbackLeft + pivotLookbackRight + 5)
bullBelowCenterline = dontTouchCenterline ? (rsiHHCenterline < 50) : true

// Regular Bearish Divergence - cache pivot high calculations
prevOscBear = ta.valuewhen(phFound, oscAtPivot, 1)
prevHighBear = ta.valuewhen(phFound, highAtPivot, 1)
inRangeBear = _inRange(phFound[1])
rsiLLCenterline = ta.lowest(osc, pivotLookbackLeft + pivotLookbackRight + 5)
bearAboveCenterline = dontTouchCenterline ? (rsiLLCenterline > 50) : true

// Regular Bullish Divergence Conditions
// Use pivot-based divergence if enabled (more accurate), otherwise use traditional method
// Always call pivot-based divergence function on every bar for consistency, then use result conditionally
pivotBullDivRaw = f_pivot_bullish_divergence(low, osc, oversoldThreshold, pivotDivergencePeriod)
// Traditional method: Price makes lower low while RSI makes higher low (reversal signal)
oscHL = not na(prevOscBull) and not na(oscAtPivot) and oscAtPivot > prevOscBull and inRangeBull and oscAtPivot < 50
priceLL = not na(prevLowBull) and not na(lowAtPivot) and lowAtPivot < prevLowBull
traditionalBullCond = enableDivergence and plotBullishDiv and priceLL and oscHL and plFound and bullBelowCenterline
// When pivot-based divergence is enabled, use it OR traditional method (both require plFound for visualization)
// This allows pivot-based detection to work even if traditional method doesn't catch it, and vice versa
bullCond = requirePivotDivergence ? (enableDivergence and plotBullishDiv and plFound and bullBelowCenterline and (pivotBullDivRaw or (priceLL and oscHL))) : traditionalBullCond

// Regular Bearish Divergence Conditions
// Use pivot-based divergence if enabled (more accurate), otherwise use traditional method
// Always call pivot-based divergence function on every bar for consistency, then use result conditionally
pivotBearDivRaw = f_pivot_bearish_divergence(high, osc, overboughtThreshold, pivotDivergencePeriod)
// Traditional method: Price makes higher high while RSI makes lower high (reversal signal)
oscLH = not na(prevOscBear) and not na(oscAtPivot) and oscAtPivot < prevOscBear and inRangeBear and oscAtPivot > 50
priceHH = not na(prevHighBear) and not na(highAtPivot) and highAtPivot > prevHighBear
traditionalBearCond = enableDivergence and plotBearishDiv and priceHH and oscLH and phFound and bearAboveCenterline
// When pivot-based divergence is enabled, use it OR traditional method (both require phFound for visualization)
// This allows pivot-based detection to work even if traditional method doesn't catch it, and vice versa
bearCond = requirePivotDivergence ? (enableDivergence and plotBearishDiv and phFound and bearAboveCenterline and (pivotBearDivRaw or (priceHH and oscLH))) : traditionalBearCond

// Hidden Bullish Divergence - reuse cached pivot low calculations
// Price makes higher low while RSI makes lower low = bullish continuation signal
oscLL = not na(prevOscBull) and not na(oscAtPivot) and oscAtPivot < prevOscBull and inRangeBull
priceHL = not na(prevLowBull) and not na(lowAtPivot) and lowAtPivot > prevLowBull
hiddenBullCond = enableDivergence and plotHiddenBullishDiv and priceHL and oscLL and plFound

// Hidden Bearish Divergence - reuse cached pivot high calculations
// Price makes lower high while RSI makes higher high = bearish continuation signal
oscHH = not na(prevOscBear) and not na(oscAtPivot) and oscAtPivot > prevOscBear and inRangeBear
priceLH = not na(prevHighBear) and not na(highAtPivot) and highAtPivot < prevHighBear
hiddenBearCond = enableDivergence and plotHiddenBearishDiv and priceLH and oscHH and phFound

oscDisplayAtPivot = enableDivergence and bar_index >= pivotLookbackRight ? oscDisplay[pivotLookbackRight] : na
labelBarIndex = enableDivergence and bar_index >= pivotLookbackRight ? (bar_index - pivotLookbackRight) : bar_index

var int lastLabeledBullPivotBar = na
var int lastLabeledBearPivotBar = na
var int lastLabeledHiddenBullPivotBar = na
var int lastLabeledHiddenBearPivotBar = na

f_labelExistsForBar(targetBar) =>
    labelExists = false
    arraySize = array.size(divergenceLabelBars)
    if arraySize > 0
        for i = 0 to arraySize - 1
            labelBar = array.get(divergenceLabelBars, i)
            if not na(labelBar) and labelBar == targetBar
                labelExists := true
                break
    labelExists

f_cleanupOldLabels() =>
    currentSize = array.size(divergenceLabels)
    cleanupThreshold = maxDivergenceLabels + 500
    if currentSize > cleanupThreshold
        extremeMaxLabelAge = 15000
        
        removedAny = false
        oldestBeyondAge = bar_index
        oldestBeyondAgeIndex = -1
        
        for i = 0 to array.size(divergenceLabelBars) - 1
            labelBar = array.get(divergenceLabelBars, i)
            if not na(labelBar) and (bar_index - labelBar > extremeMaxLabelAge)
                if labelBar < oldestBeyondAge
                    oldestBeyondAge := labelBar
                    oldestBeyondAgeIndex := i
                    removedAny := true
        
        if removedAny and oldestBeyondAgeIndex >= 0
            oldLabel = array.get(divergenceLabels, oldestBeyondAgeIndex)
            if not na(oldLabel)
                label.delete(oldLabel)
            array.remove(divergenceLabels, oldestBeyondAgeIndex)
            array.remove(divergenceLabelBars, oldestBeyondAgeIndex)
        else if array.size(divergenceLabels) > cleanupThreshold
            minAgeToRemove = 8000
            
            oldestBarIndex = bar_index
            oldestIndex = -1
            
            for i = 0 to array.size(divergenceLabelBars) - 1
                labelBar = array.get(divergenceLabelBars, i)
                if not na(labelBar) and labelBar < oldestBarIndex and (bar_index - labelBar > minAgeToRemove)
                    oldestBarIndex := labelBar
                    oldestIndex := i
            
            if oldestIndex >= 0 and oldestIndex < array.size(divergenceLabels)
                oldLabel = array.get(divergenceLabels, oldestIndex)
                if not na(oldLabel)
                    label.delete(oldLabel)
                array.remove(divergenceLabels, oldestIndex)
                array.remove(divergenceLabelBars, oldestIndex)

if enableDivergence
    bullishLineHasValue = enableDivergence and plFound and bar_index >= pivotLookbackRight
    bullishLineIsVisible = bullCond
    
    if bullishLineHasValue and bullishLineIsVisible
        pivotValue = oscDisplay[pivotLookbackRight]
        pivotBar = bar_index - pivotLookbackRight
        if not na(pivotValue)
            labelAlreadyExists = f_labelExistsForBar(pivotBar)
            if not labelAlreadyExists
                newLabel = label.new(pivotBar, pivotValue, " ðŸ‚ ", color=bullishDivColor, textcolor=bullishDivTextColor, style=label.style_label_up, size=getLabelSize(divergenceLabelSize))
                array.push(divergenceLabels, newLabel)
                array.push(divergenceLabelBars, pivotBar)
    
    bearishLineHasValue = enableDivergence and phFound and bar_index >= pivotLookbackRight
    bearishLineIsVisible = bearCond
    
    if bearishLineHasValue and bearishLineIsVisible
        pivotValue = oscDisplay[pivotLookbackRight]
        pivotBar = bar_index - pivotLookbackRight
        if not na(pivotValue)
            labelAlreadyExists = f_labelExistsForBar(pivotBar)
            if not labelAlreadyExists
                newLabel = label.new(pivotBar, pivotValue, " ðŸ» ", color=bearishDivColor, textcolor=bearishDivTextColor, style=label.style_label_down, size=getLabelSize(divergenceLabelSize))
                array.push(divergenceLabels, newLabel)
                array.push(divergenceLabelBars, pivotBar)
    
    hiddenBullishLineHasValue = enableDivergence and plFound and bar_index >= pivotLookbackRight
    hiddenBullishLineIsVisible = hiddenBullCond
    
    if hiddenBullishLineHasValue and hiddenBullishLineIsVisible
        pivotValue = oscDisplay[pivotLookbackRight]
        pivotBar = bar_index - pivotLookbackRight
        if not na(pivotValue)
            labelAlreadyExists = f_labelExistsForBar(pivotBar)
            if not labelAlreadyExists
                newLabel = label.new(pivotBar, pivotValue, " H Bull ", color=hiddenBullishDivColor, textcolor=hiddenBullishDivTextColor, style=label.style_label_up, size=getLabelSize(divergenceLabelSize))
                array.push(divergenceLabels, newLabel)
                array.push(divergenceLabelBars, pivotBar)
    
    hiddenBearishLineHasValue = enableDivergence and phFound and bar_index >= pivotLookbackRight
    hiddenBearishLineIsVisible = hiddenBearCond
    
    if hiddenBearishLineHasValue and hiddenBearishLineIsVisible
        pivotValue = oscDisplay[pivotLookbackRight]
        pivotBar = bar_index - pivotLookbackRight
        if not na(pivotValue)
            labelAlreadyExists = f_labelExistsForBar(pivotBar)
            if not labelAlreadyExists
                newLabel = label.new(pivotBar, pivotValue, " H Bear ", color=hiddenBearishDivColor, textcolor=hiddenBearishDivTextColor, style=label.style_label_down, size=getLabelSize(divergenceLabelSize))
                array.push(divergenceLabels, newLabel)
                array.push(divergenceLabelBars, pivotBar)

if barstate.islast and array.size(divergenceLabels) > maxDivergenceLabels
    f_cleanupOldLabels()
var int lastBullishDivAlert = na
var int lastBearishDivAlert = na
var int lastHiddenBullishDivAlert = na
var int lastHiddenBearishDivAlert = na

bullishDivAlertSignal = f_applyAlertCooldown(bullCond, lastBullishDivAlert, enableAlertCooldown, alertCooldownBars)
bearishDivAlertSignal = f_applyAlertCooldown(bearCond, lastBearishDivAlert, enableAlertCooldown, alertCooldownBars)
hiddenBullishDivAlertSignal = f_applyAlertCooldown(hiddenBullCond, lastHiddenBullishDivAlert, enableAlertCooldown, alertCooldownBars)
hiddenBearishDivAlertSignal = f_applyAlertCooldown(hiddenBearCond, lastHiddenBearishDivAlert, enableAlertCooldown, alertCooldownBars)

// Update cooldown tracking when alerts fire (only if alerts are enabled)
if enableDivergenceAlerts and bullishDivAlertSignal
    lastBullishDivAlert := bar_index
if enableDivergenceAlerts and bearishDivAlertSignal
    lastBearishDivAlert := bar_index
if enableDivergenceAlerts and hiddenBullishDivAlertSignal
    lastHiddenBullishDivAlert := bar_index
if enableDivergenceAlerts and hiddenBearishDivAlertSignal
    lastHiddenBearishDivAlert := bar_index

alertcondition(enableDivergenceAlerts and bullishDivAlertSignal, title="Bullish Div Alert", message="Bullish Divergence Detected")
alertcondition(enableDivergenceAlerts and bearishDivAlertSignal, title="Bearish Div Alert", message="Bearish Divergence Detected")
alertcondition(enableDivergenceAlerts and hiddenBullishDivAlertSignal, title="Hidden Bullish Div", message="Hidden Bullish Divergence Detected")
alertcondition(enableDivergenceAlerts and hiddenBearishDivAlertSignal, title="Hidden Bearish Div", message="Hidden Bearish Divergence Detected")

noneColor = color.new(color.white, 100)

bullishDivLineValue = enableDivergence and plFound ? oscDisplay[pivotLookbackRight] : na
bullishDivLineColor = bullCond ? bullishDivColor : noneColor
plot(bullishDivLineValue, title="Regular Bullish Divergence Line", color=bullishDivLineColor, linewidth=3, offset=-pivotLookbackRight, style=plot.style_line)

bearishDivLineValue = enableDivergence and phFound ? oscDisplay[pivotLookbackRight] : na
bearishDivLineColor = bearCond ? bearishDivColor : noneColor
plot(bearishDivLineValue, title="Regular Bearish Divergence Line", color=bearishDivLineColor, linewidth=3, offset=-pivotLookbackRight, style=plot.style_line)

hiddenBullishDivLineValue = enableDivergence and plFound ? oscDisplay[pivotLookbackRight] : na
hiddenBullishDivLineColor = hiddenBullCond ? hiddenBullishDivColor : noneColor
plot(hiddenBullishDivLineValue, title="Hidden Bullish Divergence Line", color=hiddenBullishDivLineColor, linewidth=2, offset=-pivotLookbackRight, style=plot.style_line)

hiddenBearishDivLineValue = enableDivergence and phFound ? oscDisplay[pivotLookbackRight] : na
hiddenBearishDivLineColor = hiddenBearCond ? hiddenBearishDivColor : noneColor
plot(hiddenBearishDivLineValue, title="Hidden Bearish Divergence Line", color=hiddenBearishDivLineColor, linewidth=2, offset=-pivotLookbackRight, style=plot.style_line)

//======================================================================================
//           REFINED RSI TOP & BOTTOM DETECTION WITH SIGNALS
//======================================================================================
volumeSmaVal     = f_getVolumeSMA(volume, volumeLookback)
// Use adaptive RSI source based on preset mode
isRSIAtTop       = f_isRsiAtTop(adaptiveRsiSmooth, rsiTopPeriod,    overboughtThreshold, rsiTopBottomBuffer)
isRSIAtBottom    = f_isRsiAtBottom(adaptiveRsiSmooth, rsiBottomPeriod, oversoldThreshold, rsiTopBottomBuffer)
strongSellSignal = f_isStrongSellSignal(adaptiveRsiSmooth, rsiTopPeriod,    rsiTopThreshold,    overboughtThreshold)
strongBuySignal  = f_isStrongBuySignal(adaptiveRsiSmooth, rsiBottomPeriod, rsiBottomThreshold, oversoldThreshold)
volumeConfirmed  = f_isVolumeConfirmed(volume, volumeSmaVal, volumeThreshold)
resetCondBuy     = f_resetCondition(isRSIAtBottom, resetPeriod)
resetCondSell    = f_resetCondition(isRSIAtTop, resetPeriod)

// Additional filters with momentum and MTF confirmation (using consolidated filter function)
// Use adaptive RSI source based on preset mode
confirmBuy  = f_applyAllFilters(true, adaptiveRsiSmooth, trendIsBullish, trendIsBearish, adxIsStrong, isVolumeDryUp, rsiHigherTf)
confirmSell = f_applyAllFilters(false, adaptiveRsiSmooth, trendIsBullish, trendIsBearish, adxIsStrong, isVolumeDryUp, rsiHigherTf)

// RSI Strong Top/Bottom signals with cooldown
// Logic: RSI shows strong recovery/decline from recent extreme levels
// strongBuySignal/strongSellSignal already check if RSI has recovered from lowest/highest in period
// So we just need to ensure RSI was at extreme recently (within the period) and now shows recovery
var int lastRsiStrongBottomAlert = na
var int lastRsiStrongTopAlert = na
var int lastRsiStrongBottomSignal = na
var int lastRsiStrongTopSignal = na

// Store actual bottom/top RSI values when they occur (for accurate recovery comparison)
// IMPORTANT: Find the bar that had the actual lowest/highest value, not just capture when condition becomes true
// This ensures we compare against the true extreme bar, even if detection happens later
var float actualBottomRsi = na
var float actualTopRsi = na

// Capture bottom/top RSI values when they occur
// Find the actual bar that had the lowest/highest value using ta.lowestbars/ta.highestbars
// Then get the RSI value at that specific bar to ensure we capture the true extreme
// IMPORTANT: ta.* functions must be called on every bar for consistency in Pine Script
// Extract calls from conditionals and use results conditionally

// Call ta.* functions unconditionally on every bar (required for Pine Script consistency)
lowestBarsAgo = ta.lowestbars(adaptiveRsiSmooth, rsiBottomPeriod)
lowestRsiValue = ta.lowest(adaptiveRsiSmooth, rsiBottomPeriod)
highestBarsAgo = ta.highestbars(adaptiveRsiSmooth, rsiTopPeriod)
highestRsiValue = ta.highest(adaptiveRsiSmooth, rsiTopPeriod)

// Reset actualBottomRsi/actualTopRsi when a new extreme is detected (transition from false to true)
if isRSIAtBottom
    // Reset when new bottom is detected (transition from false to true)
    if not isRSIAtBottom[1]
        actualBottomRsi := na  // Reset to allow new bottom to be captured
    
    // Only attempt to find the specific bar if we have enough history
    // On early bars, just use ta.lowest() which is always safe
    if bar_index >= rsiBottomPeriod
        // Additional safety: ensure lowestBarsAgo is within valid range before accessing
        if lowestBarsAgo >= 0 and lowestBarsAgo <= bar_index
            // Get the RSI value at the bar that had the actual lowest value
            actualBottomRsi := adaptiveRsiSmooth[lowestBarsAgo]
        else
            // Fallback: Use ta.lowest() if index is out of bounds
            actualBottomRsi := lowestRsiValue
    else
        // On early bars, use ta.lowest() directly (safe fallback)
        actualBottomRsi := lowestRsiValue

if isRSIAtTop
    // Reset when new top is detected (transition from false to true)
    if not isRSIAtTop[1]
        actualTopRsi := na  // Reset to allow new top to be captured
    
    // Only attempt to find the specific bar if we have enough history
    // On early bars, just use ta.highest() which is always safe
    if bar_index >= rsiTopPeriod
        // Additional safety: ensure highestBarsAgo is within valid range before accessing
        if highestBarsAgo >= 0 and highestBarsAgo <= bar_index
            // Get the RSI value at the bar that had the actual highest value
            actualTopRsi := adaptiveRsiSmooth[highestBarsAgo]
        else
            // Fallback: Use ta.highest() if index is out of bounds
            actualTopRsi := highestRsiValue
    else
        // On early bars, use ta.highest() directly (safe fallback)
        actualTopRsi := highestRsiValue

// Check if RSI was at bottom/top within the lookback period (must be at least 1 bar ago to allow recovery)
// Use ta.barssince to find when RSI was last at extreme, then check if it's within period
barsSinceBottom = ta.barssince(isRSIAtBottom)
barsSinceTop = ta.barssince(isRSIAtTop)
wasRSIAtBottom = not na(barsSinceBottom) and barsSinceBottom > 0 and barsSinceBottom <= rsiBottomPeriod
wasRSIAtTop = not na(barsSinceTop) and barsSinceTop > 0 and barsSinceTop <= rsiTopPeriod

// Reset condition: Check bars since last signal (not since RSI was at bottom)
resetCondBuySignal = na(lastRsiStrongBottomSignal) ? true : (bar_index - lastRsiStrongBottomSignal > resetPeriod)
resetCondSellSignal = na(lastRsiStrongTopSignal) ? true : (bar_index - lastRsiStrongTopSignal > resetPeriod)

// Confirmation: Require recovery/decline to persist for N consecutive bars (prevents early signals)
// This ensures the signal fires when recovery is confirmed, not just when it starts
// Compare against the actual bottom/top RSI value that was captured when extreme occurred
// Note: Cannot use for loops in ternary expressions, so we use a regular if-else block structure
var bool strongBuySignalConfirmed = false
if strongSignalConfirmationBars <= 1
    strongBuySignalConfirmed := strongBuySignal  // No confirmation needed
else
    // Check if recovery condition has been true for all required bars
    // For each bar in the confirmation period, verify RSI has recovered from the actual bottom value
    allConfirmed = true
    if not na(actualBottomRsi)
        for i = 0 to strongSignalConfirmationBars - 1
            rsiValAtBar = adaptiveRsiSmooth[i]
            // Compare against the actual bottom value, verify recovery by at least threshold points
            recoveredAtBar = (rsiValAtBar - actualBottomRsi) > rsiBottomThreshold
            allConfirmed := allConfirmed and recoveredAtBar
    else
        allConfirmed := false  // No bottom value captured yet
    strongBuySignalConfirmed := allConfirmed and strongBuySignal  // Current bar must also pass

// Note: Cannot use for loops in ternary expressions, so we use a regular if-else block structure
var bool strongSellSignalConfirmed = false
if strongSignalConfirmationBars <= 1
    strongSellSignalConfirmed := strongSellSignal  // No confirmation needed
else
    // Check if decline condition has been true for all required bars
    // For each bar in the confirmation period, verify RSI has declined from the actual top value
    allConfirmed = true
    if not na(actualTopRsi)
        for i = 0 to strongSignalConfirmationBars - 1
            rsiValAtBar = adaptiveRsiSmooth[i]
            // Compare against the actual top value, verify decline by at least threshold points
            declinedAtBar = (actualTopRsi - rsiValAtBar) > rsiTopThreshold
            allConfirmed := allConfirmed and declinedAtBar
    else
        allConfirmed := false  // No top value captured yet
    strongSellSignalConfirmed := allConfirmed and strongSellSignal  // Current bar must also pass

// Additional requirement: RSI must have actually recovered from extreme zone (similar to Buy Strength timing)
// For bottom: RSI should be at or above oversold threshold (recovered from extreme)
// For top: RSI should be at or below overbought threshold (declined from extreme)
// This ensures signal fires when recovery is confirmed, not when it just starts
rsiRecoveredFromBottom = adaptiveRsiSmooth >= oversoldThreshold  // RSI has moved out of oversold zone
rsiDeclinedFromTop = adaptiveRsiSmooth <= overboughtThreshold  // RSI has moved out of overbought zone

rsiStrongBottomSignalRaw = wasRSIAtBottom and strongBuySignalConfirmed and rsiRecoveredFromBottom and volumeConfirmed and resetCondBuySignal and confirmBuy
rsiStrongTopSignalRaw = wasRSIAtTop and strongSellSignalConfirmed and rsiDeclinedFromTop and volumeConfirmed and resetCondSellSignal and confirmSell

// Track last signal for reset condition
if rsiStrongBottomSignalRaw
    lastRsiStrongBottomSignal := bar_index
if rsiStrongTopSignalRaw
    lastRsiStrongTopSignal := bar_index

rsiStrongBottomAlertSignal = f_applyAlertCooldown(rsiStrongBottomSignalRaw, lastRsiStrongBottomAlert, enableAlertCooldown, alertCooldownBars)
rsiStrongTopAlertSignal = f_applyAlertCooldown(rsiStrongTopSignalRaw, lastRsiStrongTopAlert, enableAlertCooldown, alertCooldownBars)

// Update cooldown tracking when alerts fire (only if alerts are enabled)
if enableRsiExtremeAlerts and rsiStrongBottomAlertSignal
    lastRsiStrongBottomAlert := bar_index
if enableRsiExtremeAlerts and rsiStrongTopAlertSignal
    lastRsiStrongTopAlert := bar_index

// Strong Bottom (RSI at bottom + strong buy conditions)
// Position at the actual lowest RSI value (bottom of the bottom) using actualBottomRsi and lowestBarsAgo
var int lastSBottomBar = na
if showStrongTopBottomSignals and rsiStrongBottomSignalRaw and not na(actualBottomRsi) and lowestBarsAgo >= 0 and lowestBarsAgo <= bar_index
    bottomBarIndex = bar_index - lowestBarsAgo
    bottomRsiValue = actualBottomRsi
    // Only create label if we haven't already labeled this bar (prevent duplicates)
    if na(lastSBottomBar) or lastSBottomBar != bottomBarIndex
        label.new(bottomBarIndex, bottomRsiValue, "sBottom", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
        lastSBottomBar := bottomBarIndex
alertcondition(enableRsiExtremeAlerts and rsiStrongBottomAlertSignal, title="RSI Strong Bottom Detected", message="RSI Bottom w/ Strong Signal, Volume Confirmation, & Filters pass")

// Strong Top (RSI at top + strong sell conditions)
// Position at the actual highest RSI value (top of the top) using actualTopRsi and highestBarsAgo
var int lastSTopBar = na
if showStrongTopBottomSignals and rsiStrongTopSignalRaw and not na(actualTopRsi) and highestBarsAgo >= 0 and highestBarsAgo <= bar_index
    topBarIndex = bar_index - highestBarsAgo
    topRsiValue = actualTopRsi
    // Only create label if we haven't already labeled this bar (prevent duplicates)
    if na(lastSTopBar) or lastSTopBar != topBarIndex
        label.new(topBarIndex, topRsiValue, "sTop", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
        lastSTopBar := topBarIndex
alertcondition(enableRsiExtremeAlerts and rsiStrongTopAlertSignal, title="RSI Strong Top Detected", message="RSI Top w/ Strong Signal, Volume Confirmation, & Filters pass")

// Mark Volume Climax or Dry-Up (positioned at top of pane)
plotchar(showVolumeClimax and isVolumeClimax, title="Volume Climax", char='âš¡', location=location.top, color=color.yellow, size=size.tiny)
plotchar(enableVolumeDryUp and isVolumeDryUp, title="Volume DryUp",  char='ðŸ’§', location=location.top, color=color.aqua, size=size.tiny)

//======================================================================================
//                 MULTI-RSI SYNERGY SIGNALS (All or 2-of-3 RSI Overbought/Oversold)
//======================================================================================
// Multi-RSI Synergy: Generates signals when multiple RSI periods align in OB/OS zones
// This creates stronger signals when enabled RSIs agree on market condition
// Two modes: 
//   - "ALL": requires all enabled RSIs to be in the same zone
//   - "2-of-3": requires at least 2 enabled RSIs in zone (or all if fewer than 2 enabled)
//     Note: If only 1 RSI is enabled, "2-of-3" requires that one; if 2 enabled, requires both
// Only checks RSIs that are enabled in Custom mode (respects finalShowRsi6/14/24 settings)

// Check if each enabled RSI is in overbought zone (only count if RSI is enabled)
rsi6OB  = finalShowRsi6  and (rsi6Smooth  > overboughtThreshold)
rsi14OB = finalShowRsi14 and (rsi14Smooth > overboughtThreshold)
rsi24OB = finalShowRsi24 and (rsi24Smooth > overboughtThreshold)

// Check if each enabled RSI is in oversold zone (only count if RSI is enabled)
rsi6OS  = finalShowRsi6  and (rsi6Smooth  < oversoldThreshold)
rsi14OS = finalShowRsi14 and (rsi14Smooth < oversoldThreshold)
rsi24OS = finalShowRsi24 and (rsi24Smooth < oversoldThreshold)

// Count how many RSIs are enabled (for dynamic "ALL" mode calculation)
enabledRsiCount = (finalShowRsi6 ? 1 : 0) + (finalShowRsi14 ? 1 : 0) + (finalShowRsi24 ? 1 : 0)

// Count how many enabled RSIs are in OB/OS zones
obCount = (rsi6OB ? 1 : 0) + (rsi14OB ? 1 : 0) + (rsi24OB ? 1 : 0)
osCount = (rsi6OS ? 1 : 0) + (rsi14OS ? 1 : 0) + (rsi24OS ? 1 : 0)

// "ALL" mode: All enabled RSIs must be in the same zone
// If only 1 RSI enabled, "ALL" requires that one; if 2 enabled, requires both; if 3, requires all 3
allEnabledOversold = enabledRsiCount > 0 and osCount == enabledRsiCount
allEnabledOverbought = enabledRsiCount > 0 and obCount == enabledRsiCount

// "2-of-3" mode: At least two enabled RSIs must be in the same zone (or all if fewer than 2 enabled)
// Logic: If 1 RSI enabled, requires that one; if 2 enabled, requires both; if 3 enabled, requires at least 2
// This ensures the mode works correctly regardless of how many RSIs are enabled
twoOfEnabledOB = obCount >= 2 or (enabledRsiCount == 1 and obCount == 1) or (enabledRsiCount == 2 and obCount == 2)
twoOfEnabledOS = osCount >= 2 or (enabledRsiCount == 1 and osCount == 1) or (enabledRsiCount == 2 and osCount == 2)

// Select synergy mode: "ALL" requires all enabled RSIs, otherwise use "2-of-3" logic
synergyOB = synergyMode == "ALL" ? allEnabledOverbought : twoOfEnabledOB
synergyOS = synergyMode == "ALL" ? allEnabledOversold   : twoOfEnabledOS

multiRsiReset = f_resetCondition(synergyOB or synergyOS, multiRsiResetPeriod)

// Synergy buy/sell signals (only if enabled and at least 2 RSIs are enabled in Custom mode)
// Requires volume confirmation and reset condition
// Note: We don't use main filters here because synergy already requires multiple RSIs to align,
// which is a very strong condition on its own
synergyBuySignalRaw  = finalEnableMultiRsiSynergy and enabledRsiCount >= 2 and synergyOS and volumeConfirmed and multiRsiReset
synergySellSignalRaw = finalEnableMultiRsiSynergy and enabledRsiCount >= 2 and synergyOB and volumeConfirmed and multiRsiReset

// Alert cooldown for synergy signals using reusable helper
var int lastSynergyBuyAlert = na
var int lastSynergySellAlert = na

synergyBuySignal  = f_applyAlertCooldown(synergyBuySignalRaw, lastSynergyBuyAlert, enableAlertCooldown, alertCooldownBars)
synergySellSignal = f_applyAlertCooldown(synergySellSignalRaw, lastSynergySellAlert, enableAlertCooldown, alertCooldownBars)

// Update cooldown tracking when alerts fire
if synergyBuySignal
    lastSynergyBuyAlert := bar_index
if synergySellSignal
    lastSynergySellAlert := bar_index

// Use adaptive RSI source for positioning (though synergy only works in Custom mode)
plotshape(synergyBuySignal ? adaptiveRsiSmooth : na, style=shape.labeldown, location=location.absolute, color=synergyBuyColor, size=size.small, title="Multi-RSI Synergy Buy", text="SyBuy", textcolor=color.white)
plotshape(synergySellSignal ? adaptiveRsiSmooth : na, style=shape.labeldown, location=location.absolute, color=synergySellColor, size=size.small, title="Multi-RSI Synergy Sell", text="SySell", textcolor=color.white)
// Multi-RSI Synergy Alerts (only works in Custom mode when multiple RSIs are enabled)
alertcondition(enableSynergyAlerts and synergyBuySignal, title="Synergy Buy Alert", message="RSIs below Oversold => Multi-RSI Synergy Buy")
alertcondition(enableSynergyAlerts and synergySellSignal, title="Synergy Sell Alert", message="RSIs above Overbought => Multi-RSI Synergy Sell")

//======================================================================================
//                      REGRESSION & FORECASTING
//======================================================================================
// Regression Forecasting: Predicts future RSI values using mathematical regression
// Supports multiple methods: Linear, Polynomial, Exponential Smoothing, Moving Average
// Includes confidence bands to show forecast uncertainty
// RSI source selection for forecasting:
//   - Preset modes: Always use the displayed RSI (adaptiveRsiSmooth) to match what's shown on chart
//   - Custom mode: Use user's forecastRsiSource selection ("Adaptive RSI" uses displayed RSI, otherwise uses selected RSI)
rsiForForecast = f_isCustomMode(presetMode) ? (forecastRsiSource == "Adaptive RSI" ? adaptiveRsiSmooth : f_getRsiSource(forecastRsiSource, applyGlobalSmoothing, rsi6, rsi6Smooth, rsi14, rsi14Smooth, rsi24, rsi24Smooth)) : adaptiveRsiSmooth

// Arrays for storing forecast lines (only initialize if regression is enabled)
var line[] forecastDottedLines = na
var line[] forecastUpperBand = na
var line[] forecastLowerBand = na

// Initialize arrays only once and only if regression is enabled
if bar_index == 0 and regressionEnabled
    forecastDottedLines := array.new_line()
    forecastUpperBand := array.new_line()
    forecastLowerBand := array.new_line()

// Prepare historical series array (always build if conditions met, for consistent function calls)
canCalculateForecast = regressionEnabled and bar_index >= finalForecastHorizon
histSeries = canCalculateForecast ? array.new_float(finalForecastHorizon, na) : array.new<float>()
if canCalculateForecast
    for i = 0 to finalForecastHorizon - 1
        array.set(histSeries, i, rsiForForecast[i])

// Always call regression and forecast functions on every bar for consistency (TradingView best practice)
// Functions handle invalid inputs gracefully, so we can always call them
// â”€â”€ Calculate regression coefficients (always call on every bar)
rsiCoeffs = f_regression(histSeries, finalForecastHorizon, regressionType)

// â”€â”€ Generate forecast array (always call on every bar for consistency)
hasValidCoeffs = not na(rsiCoeffs) and array.size(rsiCoeffs) > 0
rsiForecastArray = f_forecast(rsiForForecast, rsiCoeffs, finalForecastHorizon, regressionType)

// â”€â”€ Calculate confidence bands (always call on every bar for consistency, use result conditionally)
forecastErrorRaw = f_forecast_error(histSeries, rsiForecastArray, finalForecastHorizon)
forecastError = showConfidenceBands ? forecastErrorRaw : 0.0

// Use forecast results to draw lines (only if valid)
// Ensure arrays are initialized before accessing them
// Add defensive checks: verify arrays are initialized and not na
arraysInitialized = not na(forecastDottedLines) and not na(forecastUpperBand) and not na(forecastLowerBand)
if canCalculateForecast and array.size(histSeries) > 0 and hasValidCoeffs and array.size(rsiForecastArray) > 0 and arraysInitialized
    // â”€â”€ Draw forecast line segments â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for i = 0 to array.size(rsiForecastArray) - 2
        startVal = math.max(0, math.min(100, array.get(rsiForecastArray, i)))
        endVal   = math.max(0, math.min(100, array.get(rsiForecastArray, i + 1)))
        startIdx = bar_index + i
        endIdx   = bar_index + i + 1
        
        // Main forecast line
        if i < array.size(forecastDottedLines)
            line.set_xy1(array.get(forecastDottedLines, i), startIdx, startVal)
            line.set_xy2(array.get(forecastDottedLines, i), endIdx, endVal)
            line.set_color(array.get(forecastDottedLines, i), forecastLineColor)
            line.set_width(array.get(forecastDottedLines, i), forecastLineWidth)
        else
            newLine = line.new(startIdx, startVal, endIdx, endVal, color=forecastLineColor, width=forecastLineWidth, style=line.style_dotted)
            array.push(forecastDottedLines, newLine)
        
        // Confidence bands (upper and lower)
        if showConfidenceBands and forecastError > 0
            startUpper = math.max(0, math.min(100, startVal + forecastError * confidenceLevel))
            startLower = math.max(0, math.min(100, startVal - forecastError * confidenceLevel))
            endUpper = math.max(0, math.min(100, endVal + forecastError * confidenceLevel))
            endLower = math.max(0, math.min(100, endVal - forecastError * confidenceLevel))
            
            // Upper band
            if i < array.size(forecastUpperBand)
                line.set_xy1(array.get(forecastUpperBand, i), startIdx, startUpper)
                line.set_xy2(array.get(forecastUpperBand, i), endIdx, endUpper)
            else
                upperLine = line.new(startIdx, startUpper, endIdx, endUpper, color=color.new(forecastLineColor, 80), width=1, style=line.style_dotted)
                array.push(forecastUpperBand, upperLine)
            
            // Lower band
            if i < array.size(forecastLowerBand)
                line.set_xy1(array.get(forecastLowerBand, i), startIdx, startLower)
                line.set_xy2(array.get(forecastLowerBand, i), endIdx, endLower)
            else
                lowerLine = line.new(startIdx, startLower, endIdx, endLower, color=color.new(forecastLineColor, 80), width=1, style=line.style_dotted)
                array.push(forecastLowerBand, lowerLine)
    
    // â”€â”€ Trim unused lines when horizon shrinks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    targetSize = array.size(rsiForecastArray) - 1
    while array.size(forecastDottedLines) > targetSize
        line.delete(array.pop(forecastDottedLines))
    if showConfidenceBands
        while array.size(forecastUpperBand) > targetSize
            line.delete(array.pop(forecastUpperBand))
        while array.size(forecastLowerBand) > targetSize
            line.delete(array.pop(forecastLowerBand))
// â”€â”€ Clean up old lines if forecast is disabled or array is empty â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
else
    // Defensive cleanup: only delete if arrays are initialized (not na)
    if not na(forecastDottedLines) and array.size(forecastDottedLines) > 0
        while array.size(forecastDottedLines) > 0
            line.delete(array.pop(forecastDottedLines))
    if not na(forecastUpperBand) and array.size(forecastUpperBand) > 0
        while array.size(forecastUpperBand) > 0
            line.delete(array.pop(forecastUpperBand))
    if not na(forecastLowerBand) and array.size(forecastLowerBand) > 0
        while array.size(forecastLowerBand) > 0
            line.delete(array.pop(forecastLowerBand))

//======================================================================================
//                      RSI PIVOT TRENDLINES
//======================================================================================
// RSI Pivot Trendlines: Draws trendlines connecting pivot highs/lows on the displayed RSI
// Helps visualize RSI trends and identify trend breaks
// Trend breaks can signal potential reversals or continuations
// Use adaptive RSI source based on preset mode for pivot detection
rsiForPivots = adaptiveRsiSmooth

// Variables to store pivot points and trendlines
var int lastPivotLowBar = na
var float lastPivotLowValue = na
var int lastPivotHighBar = na
var float lastPivotHighValue = na
var line currentUptrendLine = na
var line currentDowntrendLine = na

// Arrays to store historical trendlines (if keepHistoricalTrendlines is enabled)
var line[] historicalUptrendLines = na
var line[] historicalDowntrendLines = na

// Variables to track previous confirmed pivots (must be at global scope)
var int prevConfirmedPivotLowBar = na
var float prevConfirmedPivotLowValue = na
var int prevConfirmedPivotHighBar = na
var float prevConfirmedPivotHighValue = na

// Variables for no-confirmation mode (must be at global scope)
var int prevPivotLowBar = na
var float prevPivotLowValue = na
var int prevPivotHighBar = na
var float prevPivotHighValue = na

// Initialize trendline arrays if keeping historical trendlines
if bar_index == 0 and enablePivotTrendlines and keepHistoricalTrendlines
    historicalUptrendLines := array.new_line()
    historicalDowntrendLines := array.new_line()

// Detect pivot candidates with strength requirement
isPivotLowCandidate = enablePivotTrendlines ? f_isPivotLowStrong(rsiForPivots, pivotDetectionPeriod, minPivotStrength) : false
isPivotHighCandidate = enablePivotTrendlines ? f_isPivotHighStrong(rsiForPivots, pivotDetectionPeriod, minPivotStrength) : false

// Initialize trend break signals at global scope
trendBreakBuy = false
trendBreakSell = false

// Calculate trendline values at global scope (always execute for consistency)
uptrendLineY = enablePivotTrendlines and not na(currentUptrendLine) ? line.get_price(currentUptrendLine, bar_index) : na
downtrendLineY = enablePivotTrendlines and not na(currentDowntrendLine) ? line.get_price(currentDowntrendLine, bar_index) : na

// Always call crossover functions on every bar as recommended by TradingView
// Use safe default values outside RSI range if trendline Y is na to ensure crossover always executes
// Default to 100 for uptrend (above RSI range) and 0 for downtrend (below RSI range) so crossover always returns false when trendline doesn't exist
safeUptrendY = na(uptrendLineY) ? 100.0 : uptrendLineY
safeDowntrendY = na(downtrendLineY) ? 0.0 : downtrendLineY
uptrendBreakRaw = ta.crossunder(rsiForPivots, safeUptrendY)
downtrendBreakRaw = ta.crossover(rsiForPivots, safeDowntrendY)

// Pivot confirmation logic
if enablePivotTrendlines
    
    // Always call pivot confirmation functions on every bar for consistency
    // Use safe default values when pivot bars are na (functions will return false)
    safePivotLowBar = na(lastPivotLowBar) ? bar_index : lastPivotLowBar
    safePivotLowValue = na(lastPivotLowValue) ? rsiForPivots : lastPivotLowValue
    safePivotHighBar = na(lastPivotHighBar) ? bar_index : lastPivotHighBar
    safePivotHighValue = na(lastPivotHighValue) ? rsiForPivots : lastPivotHighValue
    
    // Always call confirmation functions on every bar for consistency, then use results conditionally
    pivotLowConfirmedRaw = f_confirmPivotLow(rsiForPivots, safePivotLowBar, safePivotLowValue, pivotDetectionPeriod, pivotConfirmationBars)
    pivotHighConfirmedRaw = f_confirmPivotHigh(rsiForPivots, safePivotHighBar, safePivotHighValue, pivotDetectionPeriod, pivotConfirmationBars)
    
    // Use results only when we have valid pivot bars and confirmation is enabled
    pivotLowConfirmed = (not na(lastPivotLowBar) and enablePivotConfirmation) ? pivotLowConfirmedRaw : false
    pivotHighConfirmed = (not na(lastPivotHighBar) and enablePivotConfirmation) ? pivotHighConfirmedRaw : false
    
    // Check if previous pivot low is confirmed
    if not na(lastPivotLowBar) and enablePivotConfirmation
        if pivotLowConfirmed
            // Pivot confirmed - create or update uptrend line
            if na(prevConfirmedPivotLowBar)
                // First confirmed pivot low - create line extending to current bar
                prevConfirmedPivotLowBar := lastPivotLowBar
                prevConfirmedPivotLowValue := lastPivotLowValue
                if na(currentUptrendLine)
                    currentUptrendLine := line.new(lastPivotLowBar, lastPivotLowValue, bar_index, rsiForPivots, color=uptrendLineColor, width=trendlineWidth, style=line.style_solid)
            else
                // New confirmed pivot - create line from previous to current pivot
                if not na(currentUptrendLine)
                    // Save to historical if enabled, otherwise delete
                    if keepHistoricalTrendlines
                        array.push(historicalUptrendLines, currentUptrendLine)
                        // Limit historical lines to maxTrendlines
                        while array.size(historicalUptrendLines) > maxTrendlines
                            line.delete(array.shift(historicalUptrendLines))
                    else
                        line.delete(currentUptrendLine)
                currentUptrendLine := line.new(prevConfirmedPivotLowBar, prevConfirmedPivotLowValue, lastPivotLowBar, lastPivotLowValue, color=uptrendLineColor, width=trendlineWidth, style=line.style_solid)
                prevConfirmedPivotLowBar := lastPivotLowBar
                prevConfirmedPivotLowValue := lastPivotLowValue
    
    // Check if previous pivot high is confirmed
    if not na(lastPivotHighBar) and enablePivotConfirmation
        if pivotHighConfirmed
            // Pivot confirmed - create or update downtrend line
            if na(prevConfirmedPivotHighBar)
                // First confirmed pivot high - create line extending to current bar
                prevConfirmedPivotHighBar := lastPivotHighBar
                prevConfirmedPivotHighValue := lastPivotHighValue
                if na(currentDowntrendLine)
                    currentDowntrendLine := line.new(lastPivotHighBar, lastPivotHighValue, bar_index, rsiForPivots, color=downtrendLineColor, width=trendlineWidth, style=line.style_solid)
            else
                // New confirmed pivot - create line from previous to current pivot
                if not na(currentDowntrendLine)
                    // Save to historical if enabled, otherwise delete
                    if keepHistoricalTrendlines
                        array.push(historicalDowntrendLines, currentDowntrendLine)
                        // Limit historical lines to maxTrendlines
                        while array.size(historicalDowntrendLines) > maxTrendlines
                            line.delete(array.shift(historicalDowntrendLines))
                    else
                        line.delete(currentDowntrendLine)
                currentDowntrendLine := line.new(prevConfirmedPivotHighBar, prevConfirmedPivotHighValue, lastPivotHighBar, lastPivotHighValue, color=downtrendLineColor, width=trendlineWidth, style=line.style_solid)
                prevConfirmedPivotHighBar := lastPivotHighBar
                prevConfirmedPivotHighValue := lastPivotHighValue
    
    // Handle new pivot candidates (no confirmation mode)
    if isPivotLowCandidate and not enablePivotConfirmation
        if na(prevPivotLowBar)
            // First pivot low - create line extending to current bar
            prevPivotLowBar := bar_index
            prevPivotLowValue := rsiForPivots
            if na(currentUptrendLine)
                currentUptrendLine := line.new(bar_index, rsiForPivots, bar_index, rsiForPivots, color=uptrendLineColor, width=trendlineWidth, style=line.style_solid)
        else
            // New pivot - create line from previous pivot to current
            if not na(currentUptrendLine)
                // Save to historical if enabled, otherwise delete
                if keepHistoricalTrendlines
                    array.push(historicalUptrendLines, currentUptrendLine)
                    // Limit historical lines to maxTrendlines
                    while array.size(historicalUptrendLines) > maxTrendlines
                        line.delete(array.shift(historicalUptrendLines))
                else
                    line.delete(currentUptrendLine)
            currentUptrendLine := line.new(prevPivotLowBar, prevPivotLowValue, bar_index, rsiForPivots, color=uptrendLineColor, width=trendlineWidth, style=line.style_solid)
            prevPivotLowBar := bar_index
            prevPivotLowValue := rsiForPivots
    
    if isPivotHighCandidate and not enablePivotConfirmation
        if na(prevPivotHighBar)
            // First pivot high - create line extending to current bar
            prevPivotHighBar := bar_index
            prevPivotHighValue := rsiForPivots
            if na(currentDowntrendLine)
                currentDowntrendLine := line.new(bar_index, rsiForPivots, bar_index, rsiForPivots, color=downtrendLineColor, width=trendlineWidth, style=line.style_solid)
        else
            // New pivot - create line from previous pivot to current
            if not na(currentDowntrendLine)
                // Save to historical if enabled, otherwise delete
                if keepHistoricalTrendlines
                    array.push(historicalDowntrendLines, currentDowntrendLine)
                    // Limit historical lines to maxTrendlines
                    while array.size(historicalDowntrendLines) > maxTrendlines
                        line.delete(array.shift(historicalDowntrendLines))
                else
                    line.delete(currentDowntrendLine)
            currentDowntrendLine := line.new(prevPivotHighBar, prevPivotHighValue, bar_index, rsiForPivots, color=downtrendLineColor, width=trendlineWidth, style=line.style_solid)
            prevPivotHighBar := bar_index
            prevPivotHighValue := rsiForPivots
    
    // Store pivot candidates for confirmation
    if isPivotLowCandidate
        lastPivotLowBar := bar_index
        lastPivotLowValue := rsiForPivots
    
    if isPivotHighCandidate
        lastPivotHighBar := bar_index
        lastPivotHighValue := rsiForPivots
    
    // Update existing lines to current bar (for extending lines with only one pivot)
    // Extend uptrend line if it ends at the last pivot (meaning we only have one pivot so far)
    if not na(currentUptrendLine)
        x2 = line.get_x2(currentUptrendLine)
        lastPivotBar = enablePivotConfirmation ? prevConfirmedPivotLowBar : prevPivotLowBar
        // If line ends at the last pivot bar, extend it to current bar
        if not na(lastPivotBar) and x2 == lastPivotBar
            line.set_xy2(currentUptrendLine, bar_index, rsiForPivots)
    
    // Extend downtrend line if it ends at the last pivot
    if not na(currentDowntrendLine)
        x2 = line.get_x2(currentDowntrendLine)
        lastPivotBar = enablePivotConfirmation ? prevConfirmedPivotHighBar : prevPivotHighBar
        // If line ends at the last pivot bar, extend it to current bar
        if not na(lastPivotBar) and x2 == lastPivotBar
            line.set_xy2(currentDowntrendLine, bar_index, rsiForPivots)
    
    // Always call consecutive bar confirmation on every bar for consistency (before conditional use)
    uptrendBreakConsecutiveConfirm = f_consecutiveBarConfirmation(uptrendBreakRaw, trendBreakConfirmationBars)
    downtrendBreakConsecutiveConfirm = f_consecutiveBarConfirmation(downtrendBreakRaw, trendBreakConfirmationBars)
    
    // Detect trend breaks with confirmation and angle checks (using pre-calculated crossovers)
    if not na(currentUptrendLine) and showTrendBreaks and not na(uptrendLineY)
        // Check trendline angle
        trendlineAngle = f_trendlineAngle(currentUptrendLine)
        angleOk = na(trendlineAngle) or (trendlineAngle >= minTrendlineAngle)
        
        // Apply confirmation if required (using pre-calculated consecutive confirmation)
        if requireTrendBreakConfirmation and angleOk
            // Require break to persist for N bars and optionally volume confirmation
            volumeOk = f_isVolumeConfirmed(volume, volumeSmaVal, volumeThreshold)
            trendBreakBuy := uptrendBreakConsecutiveConfirm and volumeOk
        else if angleOk
            trendBreakBuy := uptrendBreakRaw
        else
            trendBreakBuy := false
    
    if not na(currentDowntrendLine) and showTrendBreaks and not na(downtrendLineY)
        // Check trendline angle
        trendlineAngle = f_trendlineAngle(currentDowntrendLine)
        angleOk = na(trendlineAngle) or (trendlineAngle >= minTrendlineAngle)
        
        // Apply confirmation if required (using pre-calculated consecutive confirmation)
        if requireTrendBreakConfirmation and angleOk
            // Require break to persist for N bars and optionally volume confirmation
            volumeOk = f_isVolumeConfirmed(volume, volumeSmaVal, volumeThreshold)
            trendBreakSell := downtrendBreakConsecutiveConfirm and volumeOk
        else if angleOk
            trendBreakSell := downtrendBreakRaw
        else
            trendBreakSell := false
else
    // Clean up lines if feature is disabled
    if not na(currentUptrendLine)
        line.delete(currentUptrendLine)
        currentUptrendLine := na
    if not na(currentDowntrendLine)
        line.delete(currentDowntrendLine)
        currentDowntrendLine := na
    // Clean up historical trendlines if feature is disabled
    if keepHistoricalTrendlines and not na(historicalUptrendLines)
        while array.size(historicalUptrendLines) > 0
            line.delete(array.pop(historicalUptrendLines))
    if keepHistoricalTrendlines and not na(historicalDowntrendLines)
        while array.size(historicalDowntrendLines) > 0
            line.delete(array.pop(historicalDowntrendLines))

// Plot trend break signals (must be at global scope)
plotshape(enablePivotTrendlines and showTrendBreaks and trendBreakBuy ? rsiForPivots : na, style=shape.triangleup, location=location.absolute, color=trendBreakBuyColor, size=size.small, title="Uptrend Break (Buy)", text="â†‘")
plotshape(enablePivotTrendlines and showTrendBreaks and trendBreakSell ? rsiForPivots : na, style=shape.triangledown, location=location.absolute, color=trendBreakSellColor, size=size.small, title="Downtrend Break (Sell)", text="â†“")

// Alert conditions for trend breaks with cooldown (must be at global scope)
// Only create alerts if feature and alert are enabled (works for all trading modes)
var int lastTrendBreakBuyAlert = na
var int lastTrendBreakSellAlert = na

trendBreakBuySignalRaw = enablePivotTrendlines and showTrendBreaks and trendBreakBuy
trendBreakSellSignalRaw = enablePivotTrendlines and showTrendBreaks and trendBreakSell

trendBreakBuyAlertSignal = f_applyAlertCooldown(trendBreakBuySignalRaw, lastTrendBreakBuyAlert, enableAlertCooldown, alertCooldownBars)
trendBreakSellAlertSignal = f_applyAlertCooldown(trendBreakSellSignalRaw, lastTrendBreakSellAlert, enableAlertCooldown, alertCooldownBars)

// Update cooldown tracking when alerts fire (only if alerts are enabled)
if enableTrendBreakAlerts and trendBreakBuyAlertSignal
    lastTrendBreakBuyAlert := bar_index
if enableTrendBreakAlerts and trendBreakSellAlertSignal
    lastTrendBreakSellAlert := bar_index

uptrendBreakAlert = enableTrendBreakAlerts and trendBreakBuyAlertSignal
downtrendBreakAlert = enableTrendBreakAlerts and trendBreakSellAlertSignal
alertcondition(uptrendBreakAlert, title="Uptrend Break Alert", message="RSI broke below uptrend line => Potential BUY signal")
alertcondition(downtrendBreakAlert, title="Downtrend Break Alert", message="RSI broke above downtrend line => Potential SELL signal")

//======================================================================================
//                   BACKGROUND COLOR (Single Call)
//======================================================================================
bgColorDynamic = disableBgColor ? monotoneBgColor : f_dynamic_bg_color(normalizedAdaptiveRsi, obDyn, osDyn, bullCond, bearCond)
bgColorRsi6    = disableBgColor ? na : f_rsiHeatmapColor(adaptiveRsiSmooth, oversoldThreshold, overboughtThreshold)

mergedBgColor  = na(bgColorDynamic) ? bgColorRsi6 : bgColorDynamic
bgcolor(mergedBgColor, title="Adaptive RSI Background")

//======================================================================================
//                   SIGNAL STRENGTH & PERFORMANCE STATISTICS DISPLAY
//======================================================================================
// Signal Strength Label Placement: Tracks RSI extremes and places labels at optimal locations
// Algorithm: When RSI enters OB/OS zone, track the lowest/highest RSI within the zone
// Place label at the actual extreme point (not entry point) for better visual accuracy
// Uses pending signal tracking to find true extreme before finalizing label placement
isInOversoldZone = adaptiveRsiSmooth < oversoldThreshold
enteredOversoldZone = isInOversoldZone and not isInOversoldZone[1]

if showBuyStrengthLabel
    // Start tracking when RSI enters oversold zone OR when buy signal fires
    if enteredOversoldZone or (buySignal and not buySignal[1])
        isFarEnough = na(lastBuyStrengthLabelBar) or (bar_index - lastBuyStrengthLabelBar >= minLabelDistanceBars)
        
        if isFarEnough
            // Finalize pending signal if current RSI is higher (worse) than pending extreme
            // This ensures we label the true lowest point before RSI starts recovering
            if not na(pendingBuySignalBar) and adaptiveRsiSmooth > pendingBuySignalRsi
                label.new(pendingBuySignalBar, pendingBuySignalRsi, "Buy Strength: " + str.tostring(pendingBuySignalStrength) + "%", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_up, size=size.small)
                lastBuyStrengthLabelBar := pendingBuySignalBar
                pendingBuySignalBar := na
                pendingBuySignalRsi := na
                pendingBuySignalStrength := na
            
            if na(pendingBuySignalBar)
                if bar_index >= rsiBottomPeriod
                    if lowestBarsAgo >= 0 and lowestBarsAgo <= bar_index
                        pendingBuySignalBar := bar_index - lowestBarsAgo
                        pendingBuySignalRsi := adaptiveRsiSmooth[lowestBarsAgo]
                    else
                        pendingBuySignalBar := bar_index
                        pendingBuySignalRsi := lowestRsiValue
                else
                    pendingBuySignalBar := bar_index
                    pendingBuySignalRsi := adaptiveRsiSmooth
                pendingBuySignalStrength := buySignalStrength

    // Update pending signal tracking while RSI is still in zone or too close to last label
    if not na(pendingBuySignalBar)
        // Continue tracking while in oversold zone OR within minimum distance from last label
        shouldKeepTracking = isInOversoldZone or (bar_index - pendingBuySignalBar < minLabelDistanceBars)
        
        // Finalize label if RSI exited zone AND enough bars passed since entry
        if not shouldKeepTracking and (bar_index - pendingBuySignalBar >= minLabelDistanceBars)
            canCreateLabel = na(lastBuyStrengthLabelBar) or (math.abs(pendingBuySignalBar - lastBuyStrengthLabelBar) >= minLabelDistanceBars)
            if canCreateLabel
                label.new(pendingBuySignalBar, pendingBuySignalRsi, "Buy Strength: " + str.tostring(pendingBuySignalStrength) + "%", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_up, size=size.small)
                lastBuyStrengthLabelBar := pendingBuySignalBar
                pendingBuySignalBar := na
                pendingBuySignalRsi := na
                pendingBuySignalStrength := na
        
        if shouldKeepTracking
            // Update pending signal if current RSI is lower (better extreme found)
            if adaptiveRsiSmooth < pendingBuySignalRsi
                pendingBuySignalBar := bar_index
                pendingBuySignalRsi := adaptiveRsiSmooth
                if buySignal
                    pendingBuySignalStrength := buySignalStrength
            
            // Also check historical lowest within lookback period (finds true bottom)
            if bar_index >= rsiBottomPeriod
                if lowestBarsAgo >= 0 and lowestBarsAgo <= bar_index
                    bottomBar = bar_index - lowestBarsAgo
                    bottomRsiValue = adaptiveRsiSmooth[lowestBarsAgo]
                    if bottomRsiValue < pendingBuySignalRsi and (bar_index - bottomBar < minLabelDistanceBars)
                        pendingBuySignalBar := bottomBar
                        pendingBuySignalRsi := bottomRsiValue

// Finalize pending buy label when RSI exits oversold zone (early exit) or after sufficient distance
exitedOversoldZone = not isInOversoldZone and isInOversoldZone[1]
shouldFinalizeBuy = not na(pendingBuySignalBar) and ((bar_index - pendingBuySignalBar >= minLabelDistanceBars) or (exitedOversoldZone and (bar_index - pendingBuySignalBar >= 1)))

if shouldFinalizeBuy
    canCreateLabel = na(lastBuyStrengthLabelBar) or (math.abs(pendingBuySignalBar - lastBuyStrengthLabelBar) >= minLabelDistanceBars)
    
    if canCreateLabel
        label.new(pendingBuySignalBar, pendingBuySignalRsi, "Buy Strength: " + str.tostring(pendingBuySignalStrength) + "%", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_up, size=size.small)
        lastBuyStrengthLabelBar := pendingBuySignalBar
        pendingBuySignalBar := na
        pendingBuySignalRsi := na
        pendingBuySignalStrength := na

// Safety: Force finalization of very old pending signals to prevent memory buildup
if showBuyStrengthLabel and not na(pendingBuySignalBar)
    isVeryOld = (bar_index - pendingBuySignalBar) >= (minLabelDistanceBars * 2)
    if isVeryOld
        canCreateLabel = na(lastBuyStrengthLabelBar) or (math.abs(pendingBuySignalBar - lastBuyStrengthLabelBar) >= minLabelDistanceBars)
        if canCreateLabel
            label.new(pendingBuySignalBar, pendingBuySignalRsi, "Buy Strength: " + str.tostring(pendingBuySignalStrength) + "%", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_up, size=size.small)
            lastBuyStrengthLabelBar := pendingBuySignalBar
            pendingBuySignalBar := na
            pendingBuySignalRsi := na
            pendingBuySignalStrength := na

isInOverboughtZone = adaptiveRsiSmooth > overboughtThreshold
enteredOverboughtZone = isInOverboughtZone and not isInOverboughtZone[1]

historicalHighestBarsAgo = ta.highestbars(adaptiveRsiSmooth, labelHistoricalLookback)
historicalHighestRsi = ta.highest(adaptiveRsiSmooth, labelHistoricalLookback)

if showSellStrengthLabel
    // Start tracking when RSI enters overbought zone OR when sell signal fires
    if enteredOverboughtZone or (sellSignal and not sellSignal[1])
        isFarEnough = na(lastSellStrengthLabelBar) or (bar_index - lastSellStrengthLabelBar >= minLabelDistanceBars)
        
        if isFarEnough
            // Finalize pending signal if current RSI is lower (worse) than pending extreme
            // This ensures we label the true highest point before RSI starts declining
            if not na(pendingSellSignalBar) and adaptiveRsiSmooth < pendingSellSignalRsi
                label.new(pendingSellSignalBar, pendingSellSignalRsi, "Sell Strength: " + str.tostring(pendingSellSignalStrength) + "%", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
                lastSellStrengthLabelBar := pendingSellSignalBar
                pendingSellSignalBar := na
                pendingSellSignalRsi := na
                pendingSellSignalStrength := na
            
            if na(pendingSellSignalBar)
                if bar_index >= rsiTopPeriod
                    if highestBarsAgo >= 0 and highestBarsAgo <= bar_index
                        pendingSellSignalBar := bar_index - highestBarsAgo
                        pendingSellSignalRsi := adaptiveRsiSmooth[highestBarsAgo]
                    else
                        pendingSellSignalBar := bar_index
                        pendingSellSignalRsi := highestRsiValue
                else
                    pendingSellSignalBar := bar_index
                    pendingSellSignalRsi := adaptiveRsiSmooth
                pendingSellSignalStrength := sellSignalStrength

    // Update pending signal tracking while RSI is still in zone or too close to last label
    if not na(pendingSellSignalBar)
        // Continue tracking while in overbought zone OR within minimum distance from last label
        shouldKeepTracking = isInOverboughtZone or (bar_index - pendingSellSignalBar < minLabelDistanceBars)
        
        // Finalize label if RSI exited zone AND enough bars passed since entry
        if not shouldKeepTracking and (bar_index - pendingSellSignalBar >= minLabelDistanceBars)
            canCreateLabel = na(lastSellStrengthLabelBar) or (math.abs(pendingSellSignalBar - lastSellStrengthLabelBar) >= minLabelDistanceBars)
            if canCreateLabel
                label.new(pendingSellSignalBar, pendingSellSignalRsi, "Sell Strength: " + str.tostring(pendingSellSignalStrength) + "%", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
                lastSellStrengthLabelBar := pendingSellSignalBar
                pendingSellSignalBar := na
                pendingSellSignalRsi := na
                pendingSellSignalStrength := na
        
        if shouldKeepTracking
            // Update pending signal if current RSI is higher (better extreme found)
            if adaptiveRsiSmooth > pendingSellSignalRsi
                pendingSellSignalBar := bar_index
                pendingSellSignalRsi := adaptiveRsiSmooth
                if sellSignal
                    pendingSellSignalStrength := sellSignalStrength
            
            // Also check historical highest within lookback period (finds true top)
            if bar_index >= rsiTopPeriod
                if highestBarsAgo >= 0 and highestBarsAgo <= bar_index
                    topBar = bar_index - highestBarsAgo
                    topRsiValue = adaptiveRsiSmooth[highestBarsAgo]
                    if topRsiValue > pendingSellSignalRsi and (bar_index - topBar < minLabelDistanceBars)
                        pendingSellSignalBar := topBar
                        pendingSellSignalRsi := topRsiValue

// Finalize pending sell label when RSI exits overbought zone (early exit) or after sufficient distance
exitedOverboughtZone = not isInOverboughtZone and isInOverboughtZone[1]
shouldFinalizeSell = not na(pendingSellSignalBar) and ((bar_index - pendingSellSignalBar >= minLabelDistanceBars) or (exitedOverboughtZone and (bar_index - pendingSellSignalBar >= 1)))

if shouldFinalizeSell
    canCreateLabel = na(lastSellStrengthLabelBar) or (math.abs(pendingSellSignalBar - lastSellStrengthLabelBar) >= minLabelDistanceBars)
    
    if canCreateLabel
        label.new(pendingSellSignalBar, pendingSellSignalRsi, "Sell Strength: " + str.tostring(pendingSellSignalStrength) + "%", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
        lastSellStrengthLabelBar := pendingSellSignalBar
        pendingSellSignalBar := na
        pendingSellSignalRsi := na
        pendingSellSignalStrength := na

// Safety: Force finalization of very old pending signals to prevent memory buildup
if showSellStrengthLabel and not na(pendingSellSignalBar)
    isVeryOld = (bar_index - pendingSellSignalBar) >= (minLabelDistanceBars * 2)
    if isVeryOld
        canCreateLabel = na(lastSellStrengthLabelBar) or (math.abs(pendingSellSignalBar - lastSellStrengthLabelBar) >= minLabelDistanceBars)
        if canCreateLabel
            label.new(pendingSellSignalBar, pendingSellSignalRsi, "Sell Strength: " + str.tostring(pendingSellSignalStrength) + "%", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)
            lastSellStrengthLabelBar := pendingSellSignalBar
            pendingSellSignalBar := na
            pendingSellSignalRsi := na
            pendingSellSignalStrength := na

// Performance Statistics Display (shown in Data Window via table)
if showPerformanceStats and barstate.islast
    // Calculate pass rates for each filtering stage
    buyAccuracyPassRate = totalBuySignals > 0 ? math.round((float(totalBuySignalsAfterAccuracy) / float(totalBuySignals)) * 100) : 0
    sellAccuracyPassRate = totalSellSignals > 0 ? math.round((float(totalSellSignalsAfterAccuracy) / float(totalSellSignals)) * 100) : 0
    buyFilterPassRate = totalBuySignals > 0 ? math.round((float(totalBuySignalsFiltered) / float(totalBuySignals)) * 100) : 0
    sellFilterPassRate = totalSellSignals > 0 ? math.round((float(totalSellSignalsFiltered) / float(totalSellSignals)) * 100) : 0
    buyNoiseReductionPassRate = totalBuySignalsAfterAccuracy > 0 ? math.round((float(totalBuySignalsFiltered) / float(totalBuySignalsAfterAccuracy)) * 100) : 0
    sellNoiseReductionPassRate = totalSellSignalsAfterAccuracy > 0 ? math.round((float(totalSellSignalsFiltered) / float(totalSellSignalsAfterAccuracy)) * 100) : 0
    
    // Calculate filter rejection counts for diagnostics
    buyRejectedByAccuracy = totalBuySignals - totalBuySignalsAfterAccuracy
    sellRejectedByAccuracy = totalSellSignals - totalSellSignalsAfterAccuracy
    buyRejectedByNoise = totalBuySignalsAfterAccuracy - totalBuySignalsFiltered
    sellRejectedByNoise = totalSellSignalsAfterAccuracy - totalSellSignalsFiltered
    
    // Format rejection text: show "N/A" when no signals reached that stage
    noiseRejectionText = (totalBuySignalsAfterAccuracy > 0 or totalSellSignalsAfterAccuracy > 0) ? (str.tostring(buyRejectedByNoise) + " B / " + str.tostring(sellRejectedByNoise) + " S") : "N/A"
    noiseReductionPassText = (totalBuySignalsAfterAccuracy > 0 or totalSellSignalsAfterAccuracy > 0) ? (str.tostring(buyNoiseReductionPassRate) + "% B / " + str.tostring(sellNoiseReductionPassRate) + "% S") : "N/A"
    
    // Create table for statistics (only on last bar)
    // Use user-selected position from input settings
    // Expanded table to show filter-by-filter diagnostics (19 rows: 12 original + 1 separator + 6 filter diagnostics)
    var table statsTable = na
    if na(statsTable)
        tablePosition = f_getTablePosition(statsTablePosition)
        statsTable := table.new(tablePosition, 2, 19, bgcolor=color.new(color.white, 80), border_width=1)
    
    // Update all cells on every last bar to ensure values are current
    table.cell(statsTable, 0, 0, "Performance Statistics", text_color=color.black, bgcolor=color.new(color.gray, 70), text_size=size.normal)
    table.cell(statsTable, 1, 0, "", bgcolor=color.new(color.gray, 70))
    
    table.cell(statsTable, 0, 1, "Total Buy Signals:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 1, str.tostring(totalBuySignals), text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 2, "Total Sell Signals:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 2, str.tostring(totalSellSignals), text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 3, "After Accuracy Filters:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 3, str.tostring(totalBuySignalsAfterAccuracy) + " B / " + str.tostring(totalSellSignalsAfterAccuracy) + " S", text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 4, "Accuracy Pass Rate:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 4, str.tostring(buyAccuracyPassRate) + "% B / " + str.tostring(sellAccuracyPassRate) + "% S", text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 5, "Rejected by Accuracy:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 5, str.tostring(buyRejectedByAccuracy) + " B / " + str.tostring(sellRejectedByAccuracy) + " S", text_color=color.new(color.red, 0), text_size=size.small)
    
    table.cell(statsTable, 0, 6, "Filtered Buy Signals:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 6, str.tostring(totalBuySignalsFiltered), text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 7, "Filtered Sell Signals:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 7, str.tostring(totalSellSignalsFiltered), text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 8, "Rejected by Noise Red:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 8, noiseRejectionText, text_color=color.new(color.orange, 0), text_size=size.small)
    
    table.cell(statsTable, 0, 9, "Noise Reduction Pass:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 9, noiseReductionPassText, text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 10, "Overall Buy Pass Rate:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 10, str.tostring(buyFilterPassRate) + "%", text_color=color.black, text_size=size.small)
    
    table.cell(statsTable, 0, 11, "Overall Sell Pass Rate:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 11, str.tostring(sellFilterPassRate) + "%", text_color=color.black, text_size=size.small)
    
    // Filter-by-filter diagnostics (only show if filters are enabled and have rejections)
    // Row 12: Separator
    table.cell(statsTable, 0, 12, "â”€ Filter Diagnostics â”€", text_color=color.new(color.gray, 30), bgcolor=color.new(color.gray, 85), text_size=size.small)
    table.cell(statsTable, 1, 12, "", bgcolor=color.new(color.gray, 85))
    
    // Row 13: Trend Filter rejections
    trendRejectionText = (useTrendFilter and (buyRejectedByTrend > 0 or sellRejectedByTrend > 0)) ? (str.tostring(buyRejectedByTrend) + " B / " + str.tostring(sellRejectedByTrend) + " S") : (useTrendFilter ? "0 B / 0 S" : "Disabled")
    table.cell(statsTable, 0, 13, "Rejected by Trend:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 13, trendRejectionText, text_color=useTrendFilter ? color.new(color.orange, 0) : color.new(color.gray, 50), text_size=size.small)
    
    // Row 14: ADX Filter rejections
    adxRejectionText = (useAdxFilter and (buyRejectedByAdx > 0 or sellRejectedByAdx > 0)) ? (str.tostring(buyRejectedByAdx) + " B / " + str.tostring(sellRejectedByAdx) + " S") : (useAdxFilter ? "0 B / 0 S" : "Disabled")
    table.cell(statsTable, 0, 14, "Rejected by ADX:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 14, adxRejectionText, text_color=useAdxFilter ? color.new(color.orange, 0) : color.new(color.gray, 50), text_size=size.small)
    
    // Row 15: Volume Filter rejections
    volumeRejectionText = (enableVolumeDryUp and (buyRejectedByVolume > 0 or sellRejectedByVolume > 0)) ? (str.tostring(buyRejectedByVolume) + " B / " + str.tostring(sellRejectedByVolume) + " S") : (enableVolumeDryUp ? "0 B / 0 S" : "Disabled")
    table.cell(statsTable, 0, 15, "Rejected by Volume:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 15, volumeRejectionText, text_color=enableVolumeDryUp ? color.new(color.orange, 0) : color.new(color.gray, 50), text_size=size.small)
    
    // Row 16: Momentum Filter rejections
    momentumRejectionText = (finalMomentumConfirmation and (buyRejectedByMomentum > 0 or sellRejectedByMomentum > 0)) ? (str.tostring(buyRejectedByMomentum) + " B / " + str.tostring(sellRejectedByMomentum) + " S") : (finalMomentumConfirmation ? "0 B / 0 S" : "Disabled")
    table.cell(statsTable, 0, 16, "Rejected by Momentum:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 16, momentumRejectionText, text_color=finalMomentumConfirmation ? color.new(color.orange, 0) : color.new(color.gray, 50), text_size=size.small)
    
    // Row 17: MTF Filter rejections
    mtfRejectionText = (requireMultiTimeframeConf and (buyRejectedByMtf > 0 or sellRejectedByMtf > 0)) ? (str.tostring(buyRejectedByMtf) + " B / " + str.tostring(sellRejectedByMtf) + " S") : (requireMultiTimeframeConf ? "0 B / 0 S" : "Disabled")
    table.cell(statsTable, 0, 17, "Rejected by MTF:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 17, mtfRejectionText, text_color=requireMultiTimeframeConf ? color.new(color.orange, 0) : color.new(color.gray, 50), text_size=size.small)
    
    // Row 18: Engulfing Filter rejections
    engulfingRejectionText = (requireEngulfingPattern and (buyRejectedByEngulfing > 0 or sellRejectedByEngulfing > 0)) ? (str.tostring(buyRejectedByEngulfing) + " B / " + str.tostring(sellRejectedByEngulfing) + " S") : (requireEngulfingPattern ? "0 B / 0 S" : "Disabled")
    table.cell(statsTable, 0, 18, "Rejected by Engulfing:", text_color=color.black, text_size=size.small)
    table.cell(statsTable, 1, 18, engulfingRejectionText, text_color=requireEngulfingPattern ? color.new(color.orange, 0) : color.new(color.gray, 50), text_size=size.small)
