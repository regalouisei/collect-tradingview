//@version=6
indicator('Intuitive Predictive MACD Targets', overlay = true, max_lines_count = 10, max_labels_count = 10)

// --- MAIN SETTINGS ---
fastLength = input.int(12, 'Fast Length', group = 'MACD Settings')
slowLength = input.int(26, 'Slow Length', group = 'MACD Settings')
signalLength = input.int(9, 'Signal Length', group = 'MACD Settings')

// --- VISUAL SETTINGS ---
line_mode = input.string('Infinite', 'Line Length', options = ['Infinite', 'Short'], group = 'Visual Settings')
text_mode = input.string('Match Line', 'Text Color', options = ['Match Line', 'White', 'Black'], group = 'Visual Settings')

// GROUP: CROSSOVER
grp_cross = 'Crossover Line (PCO/NCO)'
c_bull = input.color(color.green, 'Bullish Color', group = grp_cross)
c_bear = input.color(color.red, 'Bearish Color', group = grp_cross)
w_cross = input.int(2, 'Line Width', minval = 1, group = grp_cross)
st_cross = input.string('Solid', 'Line Style', options = ['Solid', 'Dashed', 'Dotted'], group = grp_cross)

// GROUP: SETTLEMENT
grp_settle = 'Settlement Line (Angle Hook)'
c_settle = input.color(color.orange, 'Settle Color', group = grp_settle)
w_settle = input.int(1, 'Line Width', minval = 1, group = grp_settle)
st_settle = input.string('Dashed', 'Line Style', options = ['Solid', 'Dashed', 'Dotted'], group = grp_settle)

// GROUP: ZERO
grp_zero = 'Zero Cross Line'
showZero = input.bool(false, 'Show Zero Target', group = grp_zero)
c_zero = input.color(color.gray, 'Zero Color', group = grp_zero)
w_zero = input.int(2, 'Line Width', minval = 1, group = grp_zero)
st_zero = input.string('Dotted', 'Line Style', options = ['Solid', 'Dashed', 'Dotted'], group = grp_zero)

// --- HELPERS ---
f_get_style(style_str) =>
    style_str == 'Solid' ? line.style_solid : style_str == 'Dashed' ? line.style_dashed : line.style_dotted

// Helper to determine text color
f_txt_col(line_col) =>
    text_mode == 'White' ? color.white : text_mode == 'Black' ? color.black : line_col

// --- CALCULATIONS ---
k1 = 2 / (fastLength + 1)
k2 = 2 / (slowLength + 1)

var float fastEMA = na
var float slowEMA = na
var float signalEMA = na

if bar_index == 0
    fastEMA := close
    slowEMA := close
    signalEMA := 0.0
    signalEMA
else
    fastEMA := close * k1 + fastEMA[1] * (1 - k1)
    slowEMA := close * k2 + slowEMA[1] * (1 - k2)
    macdLine = fastEMA - slowEMA
    signalEMA := macdLine * 2 / (signalLength + 1) + signalEMA[1] * (1 - 2 / (signalLength + 1))
    signalEMA

f_get_req_price(target_val) =>
    term1 = fastEMA[1] * (1 - k1)
    term2 = slowEMA[1] * (1 - k2)
    (target_val - term1 + term2) / (k1 - k2)

// --- TARGETS ---
p_cross = f_get_req_price(signalEMA[1])
p_settle = f_get_req_price(fastEMA[1] - slowEMA[1])
p_zero = f_get_req_price(0)

// --- DRAWING ---
var line l_cross = na
var label lb_cross = na
var line l_settle = na
var label lb_settle = na
var line l_zero = na
var label lb_zero = na

// Logic for Length
is_inf = line_mode == 'Infinite'
ext_style = is_inf ? extend.right : extend.none
// End points for Short Mode
x_cross = is_inf ? bar_index + 1 : bar_index + 8
x_settle = is_inf ? bar_index + 1 : bar_index + 20
x_zero = is_inf ? bar_index + 1 : bar_index + 30

if barstate.islast
    // Clear old
    line.delete(l_cross)
    label.delete(lb_cross)
    line.delete(l_settle)
    label.delete(lb_settle)
    line.delete(l_zero)
    label.delete(lb_zero)

    // ------------------------------------
    // 1. CROSSOVER (Closest)
    // ------------------------------------
    final_cross_col = close < p_cross ? c_bull : c_bear
    final_cross_style = f_get_style(st_cross)

    l_cross := line.new(bar_index - 1, p_cross, x_cross, p_cross, color = final_cross_col, width = w_cross, style = final_cross_style, extend = ext_style)

    // Logic: Keep text OFF the line. 
    // If price is BELOW target, put text BELOW (style_label_up) so the path UP is clear.
    // If price is ABOVE target, put text ABOVE (style_label_down).
    cross_lbl_style = close < p_cross ? label.style_label_up : label.style_label_down
    dist_cross = math.round((p_cross - close) / close * 100, 2)

    // Add spaces for padding
    txt_cross = '  CROSS: ' + str.tostring(p_cross, format.mintick) + ' (' + str.tostring(dist_cross) + '%)  '

    lb_cross := label.new(bar_index + 3, p_cross, txt_cross, color = color.new(final_cross_col, 85), style = cross_lbl_style, textcolor = f_txt_col(final_cross_col), size = size.small)


    // ------------------------------------
    // 2. SETTLEMENT (Middle)
    // ------------------------------------
    final_settle_style = f_get_style(st_settle)

    l_settle := line.new(bar_index - 1, p_settle, x_settle, p_settle, color = c_settle, width = w_settle, style = final_settle_style, extend = ext_style)

    dist_settle = math.round((p_settle - close) / close * 100, 2)
    txt_settle = '  SETTLE: ' + str.tostring(p_settle, format.mintick) + ' (' + str.tostring(dist_settle) + '%)  '

    lb_settle := label.new(bar_index + 15, p_settle, txt_settle, color = color.new(c_settle, 85), style = label.style_label_down, textcolor = f_txt_col(c_settle), size = size.small)


    // ------------------------------------
    // 3. ZERO (Furthest)
    // ------------------------------------
    if showZero and math.abs(p_zero - close) < close * 0.10
        final_zero_style = f_get_style(st_zero)
        l_zero := line.new(bar_index - 1, p_zero, x_zero, p_zero, color = c_zero, width = w_zero, style = final_zero_style, extend = ext_style)
        lb_zero := label.new(bar_index + 25, p_zero, '  ZERO: ' + str.tostring(p_zero, format.mintick) + '  ', color = color.new(c_zero, 85), style = label.style_label_down, textcolor = f_txt_col(c_zero), size = size.small)
        lb_zero
