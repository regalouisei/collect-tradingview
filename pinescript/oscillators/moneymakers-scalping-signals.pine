//@version=5
strategy("1m BB + RSI Mean Reversion + DCA (Memcoin) v1b",
     overlay=true,
     initial_capital=1000,
     commission_type=strategy.commission.percent,
     commission_value=0.05,
     pyramiding=4,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=5)

//–––– INPUTS ––––
bbLen       = input.int(20,  "Bollinger length", minval=1)
bbDev       = input.float(1.8, "Bollinger deviation", minval=0.5, step=0.1)   // buvo 2.0
rsiLen      = input.int(14,  "RSI length", minval=2)

rsiLongMax  = input.float(40, "RSI max for LONG (<=)", minval=0, maxval=100)  // buvo 30
rsiShortMin = input.float(60, "RSI min for SHORT (>=)", minval=0, maxval=100) // buvo 70

atrLen      = input.int(7,  "ATR length", minval=1)
dcaAtrStep  = input.float(0.5, "DCA distance (x ATR from avg price)", minval=0.1, step=0.1)
maxDcaSteps = input.int(3,  "Max DCA adds", minval=1, maxval=3)

useShorts   = input.bool(true, "Allow shorts?")
useFilter   = input.bool(false, "Use simple trend filter?")   // pagal nutylėjimą OFF

//–––– CALCS ––––
basis = ta.sma(close, bbLen)
dev   = bbDev * ta.stdev(close, bbLen)
upper = basis + dev
lower = basis - dev

rsi   = ta.rsi(close, rsiLen)
atr   = ta.atr(atrLen)

// Paprastas trend filteris (dabar optional)
emaTrend = ta.ema(close, 50)
trendUp  = close > emaTrend
trendDn  = close < emaTrend

// Mean‑reversion sąlygos
longZone  = close < lower and rsi <= rsiLongMax
shortZone = close > upper and rsi >= rsiShortMin and useShorts

filterOkLong  = not useFilter or not trendDn
filterOkShort = not useFilter or not trendUp

longEntryCond  = longZone  and filterOkLong
shortEntryCond = shortZone and filterOkShort

// Pozicijos info
posSize  = strategy.position_size
posAvg   = strategy.position_avg_price
inLong   = posSize > 0
inShort  = posSize < 0
dcaCount = math.max(math.abs(posSize) - 1, 0)

//–––– ENTRY LOGIKA ––––
if longEntryCond and not inLong and not inShort
    strategy.entry("L0", strategy.long)

if shortEntryCond and not inLong and not inShort
    strategy.entry("S0", strategy.short)

// DCA LONG
longDcaPrice = posAvg - atr * dcaAtrStep
longDcaCond  = inLong and dcaCount < maxDcaSteps and low <= longDcaPrice
if longDcaCond
    id = "L" + str.tostring(dcaCount + 1)
    strategy.entry(id, strategy.long)

// DCA SHORT
shortDcaPrice = posAvg + atr * dcaAtrStep
shortDcaCond  = inShort and dcaCount < maxDcaSteps and high >= shortDcaPrice
if shortDcaCond
    id = "S" + str.tostring(dcaCount + 1)
    strategy.entry(id, strategy.short)

//–––– EXIT / TP / SL ––––
tpMult = 1.5
slMult = 3.0

if inLong
    longTp = posAvg + atr * tpMult
    longSl = posAvg - atr * slMult
    strategy.exit("L-EXIT", from_entry="L0", limit=longTp, stop=longSl)

if inShort
    shortTp = posAvg - atr * tpMult
    shortSl = posAvg + atr * slMult
    strategy.exit("S-EXIT", from_entry="S0", limit=shortTp, stop=shortSl)

//–––– PLOTTING ––––
plot(basis, "BB Basis", color=color.new(color.orange, 0))
plot(upper, "BB Upper", color=color.new(color.red, 0))
plot(lower, "BB Lower", color=color.new(color.lime, 0))
