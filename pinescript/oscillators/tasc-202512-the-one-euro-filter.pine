//  TASC Issue: December 2025
//     Article: Low-Latency Smoothing
//              The One Euro Filter
//  Article By: John F. Ehlers
//    Language: TradingView's Pine ScriptÂ® v6
// Provided By: PineCoders, for tradingview.com

//@version=6
indicator("TASC 2025.12 The One Euro Filter", "OE")


//#region   --- Constants and inputs ---

// @enum    An enumeration of oscillator options.
enum Osc
    HP   = "High-pass filter"
    RSI  = "Relative Strength Index"
    BBW  = "Bollingers Band Width %"
    CCI  = "Commodity Channel Index"
    ST   = "Stochastic"
    CMO  = "Chande Momentum Oscillator"
    ATR  = "Average True Range"
    MFI  = "Money Flow Index"
    MOM  = "Momentum"
    NONE = "None"

// Tooltips
string TT_MP = "The minimum period in the adaptive calculation."
string TT_BT = "Controls the responsiveness of the filter. Larger values cause greater
                 increases in the cutoff period."
string TT_OM = "The type and period of the oscillator to use as the filter source for
                 the pane display. Select the 'None' option to use the 'Source' series
                 in the pane instead of displaying its filter on the main chart pane."

// Inputs
float sourceInput    = input.source(close, "Source:")
int   minPeriodInput = input.int(10, "Min Period:", 1, tooltip = TT_MP)
float betaInput      = input.float(0.2, "Beta:", 0, step = 0.1, tooltip = TT_BT)
Osc   oscMethodInput = input.enum(Osc.HP, "Osc type:", inline = "osc", tooltip = TT_OM)
bool  showOsc        = oscMethodInput != Osc.NONE
int   oscPeriodInput = input.int(20, "Period:", 1, inline = "osc", active = showOsc)
//#endregion


//#region   --- Functions ---

// @function    Applies a two-pole high-pass filter to a `source` series.
hp(float Source, int Period) =>
    float a0 = math.pi * math.sqrt(2.0) / Period
    float a1 = math.exp(-a0)
    float c2 = 2.0 * a1 * math.cos(a0)
    float c3 = -a1 * a1
    float c1 = (1.0 + c2 - c3) * 0.25
    float hp = 0.0
    if bar_index >= 4
        hp := c1 * (Source - 2.0 * Source[1] + Source[2]) + 
              c2 * nz(hp[1]) + c3 * nz(hp[2])
    hp

// @function    Calculates the One Euro filter of a `source` series.
oneEuro(float source, float minPeriod, float beta) =>
    float pi2 = 2.0 * math.pi
    float pi4 = 2.0 * pi2
    float a1  = pi2 / (pi4 + 10.0)
    float sdx = 0.0
    sdx := a1 * nz(source - source[1]) + (1.0 - a1) * nz(sdx[1])
    float cutoff = minPeriod + beta * math.abs(sdx)
    float a2 = pi2 / (pi4 + cutoff)
    float result = source
    result := a2 * source + (1.0 - a2) * nz(result[1], source)
    result
//#endregion


//#region   --- Calculations ---

// @variable The One Euro filter of `sourceInput`.
float oeFilter = oneEuro(sourceInput, minPeriodInput, betaInput)

// @variable The series to filter for the pane display.
float osc = switch oscMethodInput
    Osc.HP   => hp(sourceInput, oscPeriodInput)
    Osc.RSI  => ta.rsi(sourceInput, oscPeriodInput)
    Osc.BBW  => ta.bbw(sourceInput, oscPeriodInput, 2.0)
    Osc.CCI  => ta.cci(sourceInput, oscPeriodInput)
    Osc.ST   => ta.stoch(sourceInput, sourceInput, sourceInput, oscPeriodInput)
    Osc.CMO  => ta.cmo(sourceInput, oscPeriodInput)
    Osc.ATR  => ta.atr(oscPeriodInput)
    Osc.MFI  => ta.mfi(sourceInput, oscPeriodInput)
    Osc.MOM  => ta.mom(sourceInput, oscPeriodInput)
    =>          sourceInput

// @variable The One Euro filter of `osc`.
float oscFilter = oneEuro(osc, minPeriodInput, betaInput)
//#endregion


//#region   --- Display ---

onChart = showOsc ? display.all : display.none
plot(oeFilter, "Source - One Euro Filter", color.orange, display = onChart, force_overlay = true)
plot(osc, "Oscillator")
plot(oscFilter, "Oscillator - One Euro Filter", color.orange)
//#endregion
