// This work is licensed under Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
// Â© EDUVEST - IFA Ã— VP Context v3.0 (NEON Edition)
// Market Context Indicator - High Visual Impact Design for Global Market
// NOT a buy/sell signal - Shows market environment for your own decisions
//
// v3.0 Changes: Neon color palette, enlarged labels, enhanced visual impact
// Based on 2024-2025 TradingView SMC indicator market research
//
// Architecture: Core / Adapter / UI 3-Layer
// Performance: VP calculation on bar close only, pre-allocated objects with set() updates

//@version=6
indicator('IFA-VP Context v3.0 [NEON Edition]', 'IFA-VP', overlay=true,
     max_labels_count=500,
     max_lines_count=200,
     max_boxes_count=200)

//=============================================================================
// NEON COLOR PALETTE (v3.0)
//=============================================================================

color NEON_CYAN    = #00F5FF   // Bullish / GOLDEN CROSS / Buy signals
color NEON_PINK    = #FF007F   // Bearish / DEATH CROSS / Sell signals
color NEON_GOLD    = #FFD700   // Neutral / Levels / Important info
color NEON_PURPLE  = #BF00FF   // Warning / Wait / Caution
color NEON_GREEN   = #39FF14   // Strong Buy / High score
color NEON_ORANGE  = #FF6600   // Alert / Medium warning
color NEON_WHITE   = #FFFFFF   // Text on dark backgrounds
color NEON_DARK    = #1a1a2e   // Panel backgrounds

//=============================================================================
// CONSTANTS
//=============================================================================

int BULLISH = 1
int BEARISH = -1
int NEUTRAL = 0

string MODE_IMPACT = 'Impact'
string MODE_MINIMAL = 'Minimal'
string MODE_PRO = 'Pro'

//=============================================================================
// INPUTS - Display Mode
//=============================================================================

string GROUP_MODE = 'ðŸŽ¨ Display Mode'
string i_mode = input.string(MODE_IMPACT, 'Mode', options=[MODE_IMPACT, MODE_MINIMAL, MODE_PRO], group=GROUP_MODE,
     tooltip='Impact: Visual emphasis with badges and ribbons\nMinimal: Clean lines only\nPro: Full Volume Profile histogram')

//=============================================================================
// INPUTS - SMA Settings
//=============================================================================

string GROUP_SMA = 'ðŸŽ¯ SMA Settings'
bool i_showSma = input.bool(true, 'Show SMA Lines', group=GROUP_SMA)
bool i_showSma20 = input.bool(true, 'SMA 20', group=GROUP_SMA, inline='sma20')
color i_sma20Color = input.color(NEON_CYAN, '', group=GROUP_SMA, inline='sma20')
bool i_showSma50 = input.bool(true, 'SMA 50', group=GROUP_SMA, inline='sma50')
color i_sma50Color = input.color(NEON_ORANGE, '', group=GROUP_SMA, inline='sma50')
bool i_showSma200 = input.bool(true, 'SMA 200', group=GROUP_SMA, inline='sma200')
color i_sma200Color = input.color(NEON_PURPLE, '', group=GROUP_SMA, inline='sma200')
int i_smaWidth = input.int(2, 'Line Width', group=GROUP_SMA, minval=1, maxval=5)
bool i_showSmaCross = input.bool(true, 'Show Cross Signals', group=GROUP_SMA,
     tooltip='Show triangles when SMA crosses occur (trend change signals)')

//=============================================================================
// INPUTS - Volume Profile
//=============================================================================

string GROUP_VP = 'ðŸ“Š Volume Profile'
int i_vpLookback = input.int(100, 'Lookback (bars)', group=GROUP_VP, minval=20, maxval=500,
     tooltip='Number of bars to calculate Volume Profile')
int i_vpRows = input.int(24, 'Price Levels', group=GROUP_VP, minval=10, maxval=50,
     tooltip='Number of price levels to divide the range')
float i_vaPercent = input.float(70, 'Value Area (%)', group=GROUP_VP, minval=50, maxval=95, step=5,
     tooltip='Percentage of volume that defines the Value Area')

//=============================================================================
// INPUTS - POC/VA Display
//=============================================================================

string GROUP_POC = 'ðŸ“ POC / Value Area'
color i_pocColor = input.color(NEON_GOLD, 'POC Color', group=GROUP_POC)
int i_pocWidth = input.int(2, 'POC Width', group=GROUP_POC, minval=1, maxval=5)
color i_vahColor = input.color(NEON_CYAN, 'VAH Color', group=GROUP_POC)
color i_valColor = input.color(NEON_PINK, 'VAL Color', group=GROUP_POC)
bool i_showVaLabels = input.bool(true, 'Show Price Labels', group=GROUP_POC)

//=============================================================================
// INPUTS - Impact Mode Features
//=============================================================================

string GROUP_IMPACT = 'âœ¨ Impact Features'
int i_vaFillOpacity = input.int(92, 'VA Band Opacity', group=GROUP_IMPACT, minval=80, maxval=98,
     tooltip='Higher = more transparent')
int i_pocZoneOpacity = input.int(85, 'POC Zone Opacity', group=GROUP_IMPACT, minval=70, maxval=95)
bool i_showContextBadge = input.bool(true, 'Context Badge', group=GROUP_IMPACT,
     tooltip='Shows SUPER/POWER/STRONG/BUY/SELL badges based on score')
bool i_showPocReaction = input.bool(true, 'POC Reaction Marker', group=GROUP_IMPACT,
     tooltip='Shows when price enters POC zone')
bool i_showTrendRibbon = input.bool(true, 'Trend Ribbon', group=GROUP_IMPACT,
     tooltip='Fill between SMA20 and SMA50')
bool i_showContextHeat = input.bool(true, 'Context Heat Glow', group=GROUP_IMPACT,
     tooltip='Background glow when context score >= 70')
bool i_showTrendBg = input.bool(true, 'Trend Background', group=GROUP_IMPACT,
     tooltip='Subtle background color based on trend')

//=============================================================================
// INPUTS - Pro Mode (VP Full)
//=============================================================================

string GROUP_PRO = 'ðŸ“ˆ Pro Mode (VP Histogram)'
int i_vpWidth = input.int(10, 'Profile Width', group=GROUP_PRO, minval=5, maxval=30)
color i_bullVolColor = input.color(color.new(NEON_CYAN, 70), 'Bull Volume', group=GROUP_PRO)
color i_bearVolColor = input.color(color.new(NEON_PINK, 70), 'Bear Volume', group=GROUP_PRO)
color i_hvnColor = input.color(color.new(NEON_GOLD, 60), 'HVN (High Vol Node)', group=GROUP_PRO)
color i_lvnColor = input.color(color.new(#808080, 80), 'LVN (Low Vol Node)', group=GROUP_PRO)

//=============================================================================
// INPUTS - Alerts
//=============================================================================

string GROUP_ALERT = 'ðŸ”” Alerts'
bool i_alertsEnabled = input.bool(true, 'Enable Alerts', group=GROUP_ALERT)
bool i_alertPoc = input.bool(true, 'POC Reaction', group=GROUP_ALERT)
bool i_alertCross = input.bool(true, 'SMA Cross', group=GROUP_ALERT)
bool i_alertContext = input.bool(true, 'Context Change', group=GROUP_ALERT)

//=============================================================================
// HELPER FUNCTIONS (v3.0)
//=============================================================================

// Score color function
f_score_color(int score) =>
    color result = NEON_PINK
    if score >= 80
        result := NEON_GREEN
    else if score >= 60
        result := NEON_CYAN
    else if score >= 40
        result := NEON_GOLD
    else if score >= 20
        result := NEON_ORANGE
    result

// Score bar function
f_score_bar(int score) =>
    int filled = math.round(score / 10)
    string bar = ''
    for i = 0 to 9
        bar := bar + (i < filled ? 'â–ˆ' : 'â–‘')
    bar

//=============================================================================
// CORE LAYER: Trend Indicators (calculated every bar)
//=============================================================================

// ATR for dynamic thresholds (calculated once per bar, not in conditionals)
float atr14 = ta.atr(14)

// SMA calculations
float sma20 = ta.sma(close, 20)
float sma50 = ta.sma(close, 50)
float sma200 = ta.sma(close, 200)

// SMA cross detection (confirmed on bar close - no repaint)
bool goldenCross20x50 = ta.crossover(sma20, sma50)
bool deadCross20x50 = ta.crossunder(sma20, sma50)
bool goldenCross50x200 = ta.crossover(sma50, sma200)
bool deadCross50x200 = ta.crossunder(sma50, sma200)

// Cross pulse (for visual emphasis in Impact mode)
bool goldenPulse20x50 = ta.barssince(goldenCross20x50) <= 3
bool deadPulse20x50 = ta.barssince(deadCross20x50) <= 3
bool goldenPulse50x200 = ta.barssince(goldenCross50x200) <= 5
bool deadPulse50x200 = ta.barssince(deadCross50x200) <= 5

// SMA alignment (trend structure)
bool smaBullAligned = sma20 > sma50 and sma50 > sma200
bool smaBearAligned = sma20 < sma50 and sma50 < sma200

//=============================================================================
// CORE LAYER: Volume Profile Calculation (on bar close only)
//=============================================================================

// Cached VP values (persistent)
var float pocPrice = na
var float vahPrice = na
var float valPrice = na
var float vpHigh = na
var float vpLow = na
var int vpStartBar = 0
var float vpRowSize = na
var float vpMaxVolume = 0.0

// VP arrays (persistent, updated on bar close)
var float[] volumeByPrice = array.new_float(i_vpRows, 0)
var float[] bullVolume = array.new_float(i_vpRows, 0)
var float[] bearVolume = array.new_float(i_vpRows, 0)

// VP calculation function
calcVolumeProfile() =>
    float hPrice = ta.highest(high, i_vpLookback)
    float lPrice = ta.lowest(low, i_vpLookback)
    float pRange = hPrice - lPrice
    float rowSz = pRange > 0 ? pRange / i_vpRows : syminfo.mintick

    // Reset arrays
    array.fill(volumeByPrice, 0.0)
    array.fill(bullVolume, 0.0)
    array.fill(bearVolume, 0.0)

    // Accumulate volume by price level
    for i = 0 to i_vpLookback - 1
        float p = close[i]
        float v = volume[i]
        bool isBull = close[i] >= open[i]

        int row = rowSz > 0 ? int(math.floor((p - lPrice) / rowSz)) : 0
        row := math.max(0, math.min(i_vpRows - 1, row))

        array.set(volumeByPrice, row, array.get(volumeByPrice, row) + v)
        if isBull
            array.set(bullVolume, row, array.get(bullVolume, row) + v)
        else
            array.set(bearVolume, row, array.get(bearVolume, row) + v)

    // Find POC (max volume row)
    float maxVol = array.max(volumeByPrice)
    int pocRow = array.indexof(volumeByPrice, maxVol)
    float pocP = lPrice + (pocRow + 0.5) * rowSz

    // Calculate Value Area (expanding from POC until target % reached)
    float totalVol = array.sum(volumeByPrice)
    float targetVol = totalVol * i_vaPercent / 100

    int vahRow = pocRow
    int valRow = pocRow
    float accVol = array.get(volumeByPrice, pocRow)

    if totalVol > 0
        while accVol < targetVol and (vahRow < i_vpRows - 1 or valRow > 0)
            float upperV = vahRow < i_vpRows - 1 ? array.get(volumeByPrice, vahRow + 1) : 0.0
            float lowerV = valRow > 0 ? array.get(volumeByPrice, valRow - 1) : 0.0

            if upperV > lowerV and vahRow < i_vpRows - 1
                vahRow += 1
                accVol += upperV
            else if valRow > 0
                valRow -= 1
                accVol += lowerV
            else
                break

    float vahP = lPrice + (vahRow + 1) * rowSz
    float valP = lPrice + valRow * rowSz

    [pocP, vahP, valP, hPrice, lPrice, maxVol, rowSz]

// Execute VP calculation ONLY on confirmed bar close (no repaint)
if barstate.isconfirmed and bar_index >= i_vpLookback
    [p, vh, vl, h, l, mv, rs] = calcVolumeProfile()
    pocPrice := p
    vahPrice := vh
    valPrice := vl
    vpHigh := h
    vpLow := l
    vpMaxVolume := mv
    vpRowSize := rs
    vpStartBar := bar_index - i_vpLookback

//=============================================================================
// ADAPTER LAYER: Zone & Score Calculation (every bar)
//=============================================================================

// POC zone threshold (based on ATR)
float pocThreshold = not na(atr14) ? atr14 * 0.15 : syminfo.mintick * 10

// Price zone determination
string priceZone = 'unknown'
if not na(vahPrice) and not na(valPrice)
    if close > vahPrice
        priceZone := 'above_vah'
    else if close < valPrice
        priceZone := 'below_val'
    else if not na(pocPrice) and math.abs(close - pocPrice) < pocThreshold
        priceZone := 'at_poc'
    else
        priceZone := 'in_va'

// POC proximity state machine
bool inPocZone = not na(pocPrice) and math.abs(close - pocPrice) < pocThreshold

var bool prevInPocZone = false
bool pocEnter = inPocZone and not prevInPocZone
bool pocExit = not inPocZone and prevInPocZone
prevInPocZone := inPocZone

string pocState = pocEnter ? 'ENTER' : inPocZone ? 'IN' : pocExit ? 'EXIT' : 'OUT'

// Context Score calculation
int bullScore = 0
int bearScore = 0

// SMA alignment: +40
if smaBullAligned
    bullScore += 40
if smaBearAligned
    bearScore += 40

// Price zone: +30 or +20 or +10
if priceZone == 'above_vah'
    bullScore += 30
else if priceZone == 'below_val'
    bearScore += 30
else if priceZone == 'at_poc'
    bullScore += 20
    bearScore += 20
else if priceZone == 'in_va'
    bullScore += 10
    bearScore += 10

// Clamp scores
bullScore := math.min(100, bullScore)
bearScore := math.min(100, bearScore)

// Determine context bias
int contextBias = bullScore > bearScore ? BULLISH : bearScore > bullScore ? BEARISH : NEUTRAL
int contextScore = math.max(bullScore, bearScore)
bool strongContext = contextScore >= 70

// Context change detection (for alerts)
var int prevContextBias = NEUTRAL
bool contextChanged = contextBias != prevContextBias and contextBias != NEUTRAL
prevContextBias := contextBias

//=============================================================================
// ADAPTER LAYER: Beginner-Friendly Status (v3.0 NEON Enhanced)
//=============================================================================

// Favorable conditions
bool isLongFavorable = contextScore >= 70 and smaBullAligned and (priceZone == 'above_vah' or priceZone == 'at_poc')
bool isShortFavorable = contextScore >= 70 and smaBearAligned and (priceZone == 'below_val' or priceZone == 'at_poc')

// v3.0: NEON Enhanced badge text based on score levels
string badgeText = ''
color badgeColor = NEON_PURPLE
color badgeTextColor = NEON_WHITE

if contextBias == BULLISH
    if contextScore >= 80
        badgeText := 'âš¡ SUPER\nBUY\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_GREEN, 10)
        badgeTextColor := NEON_DARK
    else if contextScore >= 70
        badgeText := 'ðŸ”¥ POWER\nBUY\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_CYAN, 10)
        badgeTextColor := NEON_DARK
    else if contextScore >= 60
        badgeText := 'ðŸ’ª STRONG\nBUY\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_CYAN, 30)
        badgeTextColor := NEON_WHITE
    else if contextScore >= 50
        badgeText := 'ðŸ“ˆ BUY\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_CYAN, 50)
        badgeTextColor := NEON_WHITE
    else
        badgeText := 'â¸ WAIT\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_PURPLE, 30)
        badgeTextColor := NEON_WHITE
else if contextBias == BEARISH
    if contextScore >= 80
        badgeText := 'âš¡ SUPER\nSELL\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_GREEN, 10)
        badgeTextColor := NEON_DARK
    else if contextScore >= 70
        badgeText := 'ðŸ”¥ POWER\nSELL\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_PINK, 10)
        badgeTextColor := NEON_WHITE
    else if contextScore >= 60
        badgeText := 'ðŸ’ª STRONG\nSELL\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_PINK, 30)
        badgeTextColor := NEON_WHITE
    else if contextScore >= 50
        badgeText := 'ðŸ“‰ SELL\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_PINK, 50)
        badgeTextColor := NEON_WHITE
    else
        badgeText := 'â¸ WAIT\n' + str.tostring(contextScore)
        badgeColor := color.new(NEON_PURPLE, 30)
        badgeTextColor := NEON_WHITE
else
    badgeText := 'â¸ WAIT\n' + str.tostring(contextScore)
    badgeColor := color.new(NEON_PURPLE, 30)
    badgeTextColor := NEON_WHITE

// Main status for table
string mainStatus = isLongFavorable ? 'LONG FAVORABLE' : isShortFavorable ? 'SHORT FAVORABLE' : contextScore >= 50 ? 'NEUTRAL - WAIT' : 'LOW CONFIDENCE'
string mainIcon = isLongFavorable ? 'ðŸŸ¢' : isShortFavorable ? 'ðŸ”´' : contextScore >= 50 ? 'âšª' : 'âš ï¸'
color mainColor = isLongFavorable ? NEON_CYAN : isShortFavorable ? NEON_PINK : contextScore >= 50 ? NEON_PURPLE : NEON_ORANGE

// Action guidance
string actionGuide = isLongFavorable ? (priceZone == 'above_vah' ? 'Bullish breakout zone' : priceZone == 'at_poc' ? 'POC support test' : 'Uptrend active') : isShortFavorable ? (priceZone == 'below_val' ? 'Bearish breakdown zone' : priceZone == 'at_poc' ? 'POC resistance test' : 'Downtrend active') : contextScore >= 50 ? 'No clear edge - wait' : 'Trend unclear'

//=============================================================================
// UI LAYER: Trend Background (v3.0)
//=============================================================================

// v3.0: Dynamic trend background with neon colors
color trendBgColor = smaBullAligned ? color.new(NEON_CYAN, 95) : smaBearAligned ? color.new(NEON_PINK, 95) : na
bgcolor(i_showTrendBg and (i_mode == MODE_IMPACT or i_mode == MODE_PRO) ? trendBgColor : na, title='Trend Background')

//=============================================================================
// UI LAYER: Pre-allocated Drawing Objects
//=============================================================================

var line linePoc = na
var line lineVah = na
var line lineVal = na
var label labelPoc = na
var label labelVah = na
var label labelVal = na

var box boxVaFill = na
var box boxPocZone = na
var box boxContextHeat = na
var label labelContextBadge = na
var label labelPocReaction = na

var box[] boxesVpFull = array.new_box()
var bool boxesInitialized = false

// Initialize objects on first bar
if barstate.isfirst
    linePoc := line.new(bar_index, na, bar_index, na, xloc=xloc.bar_index, color=i_pocColor, width=i_pocWidth)
    lineVah := line.new(bar_index, na, bar_index, na, xloc=xloc.bar_index, color=i_vahColor, width=2, style=line.style_dashed)
    lineVal := line.new(bar_index, na, bar_index, na, xloc=xloc.bar_index, color=i_valColor, width=2, style=line.style_dashed)

    // v3.0: Enlarged labels (size.normal minimum)
    labelPoc := label.new(bar_index, na, '', xloc=xloc.bar_index, color=color.new(i_pocColor, 70), textcolor=NEON_WHITE, style=label.style_label_left, size=size.normal)
    labelVah := label.new(bar_index, na, '', xloc=xloc.bar_index, color=color.new(i_vahColor, 50), textcolor=NEON_WHITE, style=label.style_label_left, size=size.normal)
    labelVal := label.new(bar_index, na, '', xloc=xloc.bar_index, color=color.new(i_valColor, 50), textcolor=NEON_WHITE, style=label.style_label_left, size=size.normal)

    boxVaFill := box.new(bar_index, na, bar_index, na, xloc=xloc.bar_index, border_color=color.new(NEON_PURPLE, 100), bgcolor=color.new(NEON_PURPLE, 92))
    boxPocZone := box.new(bar_index, na, bar_index, na, xloc=xloc.bar_index, border_color=color.new(i_pocColor, 80), bgcolor=color.new(i_pocColor, 85))
    boxContextHeat := box.new(bar_index, na, bar_index, na, xloc=xloc.bar_index, border_color=color.new(NEON_DARK, 100), bgcolor=color.new(NEON_DARK, 90))

    // v3.0: Enlarged badge labels
    labelContextBadge := label.new(bar_index, na, '', xloc=xloc.bar_index, color=color.new(NEON_PURPLE, 30), textcolor=NEON_WHITE, style=label.style_label_up, size=size.huge)
    labelPocReaction := label.new(bar_index, na, '', xloc=xloc.bar_index, color=color.new(i_pocColor, 20), textcolor=NEON_WHITE, style=label.style_label_center, size=size.large)

// Initialize VP Full boxes (Pro mode only)
bool showVpFull = i_mode == MODE_PRO
bool needReinitBoxes = showVpFull and (not boxesInitialized or array.size(boxesVpFull) != i_vpRows)

if needReinitBoxes
    if array.size(boxesVpFull) > 0
        for j = 0 to array.size(boxesVpFull) - 1
            box.delete(array.get(boxesVpFull, j))
        array.clear(boxesVpFull)

    for i = 0 to i_vpRows - 1
        array.push(boxesVpFull, box.new(0, na, 0, na, xloc=xloc.bar_index, border_color=color.new(NEON_DARK, 50), bgcolor=color.new(NEON_DARK, 80)))

    boxesInitialized := true

//=============================================================================
// UI LAYER: Drawing Updates (on last bar only)
//=============================================================================

if barstate.islast
    int hideX = bar_index
    bool showImpact = i_mode == MODE_IMPACT or i_mode == MODE_PRO

    // ----- POC / VAH / VAL Lines -----
    if not na(pocPrice)
        int startX = vpStartBar > 0 ? vpStartBar : bar_index - i_vpLookback
        int endX = bar_index + 10

        line.set_xy1(linePoc, startX, pocPrice)
        line.set_xy2(linePoc, endX, pocPrice)
        line.set_color(linePoc, i_pocColor)
        line.set_width(linePoc, i_pocWidth)

        line.set_xy1(lineVah, startX, vahPrice)
        line.set_xy2(lineVah, endX, vahPrice)
        line.set_color(lineVah, i_vahColor)

        line.set_xy1(lineVal, startX, valPrice)
        line.set_xy2(lineVal, endX, valPrice)
        line.set_color(lineVal, i_valColor)

        if i_showVaLabels
            label.set_xy(labelPoc, endX, pocPrice)
            label.set_text(labelPoc, 'POC ' + str.tostring(pocPrice, format.mintick))
            label.set_color(labelPoc, color.new(i_pocColor, 70))

            label.set_xy(labelVah, endX, vahPrice)
            label.set_text(labelVah, 'VAH ' + str.tostring(vahPrice, format.mintick))
            label.set_color(labelVah, color.new(i_vahColor, 50))

            label.set_xy(labelVal, endX, valPrice)
            label.set_text(labelVal, 'VAL ' + str.tostring(valPrice, format.mintick))
            label.set_color(labelVal, color.new(i_valColor, 50))
        else
            label.set_xy(labelPoc, hideX, na)
            label.set_xy(labelVah, hideX, na)
            label.set_xy(labelVal, hideX, na)
    else
        line.set_xy1(linePoc, hideX, na)
        line.set_xy2(linePoc, hideX, na)
        line.set_xy1(lineVah, hideX, na)
        line.set_xy2(lineVah, hideX, na)
        line.set_xy1(lineVal, hideX, na)
        line.set_xy2(lineVal, hideX, na)
        label.set_xy(labelPoc, hideX, na)
        label.set_xy(labelVah, hideX, na)
        label.set_xy(labelVal, hideX, na)

    // ----- VA Fill & POC Zone (Impact/Pro) -----
    if showImpact and not na(vahPrice) and not na(valPrice)
        int startX = vpStartBar > 0 ? vpStartBar : bar_index - i_vpLookback
        int endX = bar_index + 5

        color vaFillCol = color.new(NEON_PURPLE, i_vaFillOpacity)
        box.set_lefttop(boxVaFill, startX, vahPrice)
        box.set_rightbottom(boxVaFill, endX, valPrice)
        box.set_bgcolor(boxVaFill, vaFillCol)
        box.set_border_color(boxVaFill, color.new(NEON_PURPLE, 95))

        if not na(pocPrice) and not na(atr14)
            float pocZoneTop = pocPrice + atr14 * 0.1
            float pocZoneBottom = pocPrice - atr14 * 0.1
            color pocZoneCol = color.new(i_pocColor, i_pocZoneOpacity)
            box.set_lefttop(boxPocZone, startX, pocZoneTop)
            box.set_rightbottom(boxPocZone, endX, pocZoneBottom)
            box.set_bgcolor(boxPocZone, pocZoneCol)
            box.set_border_color(boxPocZone, color.new(i_pocColor, 80))
        else
            box.set_lefttop(boxPocZone, hideX, na)
            box.set_rightbottom(boxPocZone, hideX, na)
    else
        box.set_lefttop(boxVaFill, hideX, na)
        box.set_rightbottom(boxVaFill, hideX, na)
        box.set_lefttop(boxPocZone, hideX, na)
        box.set_rightbottom(boxPocZone, hideX, na)

    // ----- Context Heat (v3.0: NEON colors) -----
    if showImpact and i_showContextHeat and strongContext and not na(vpHigh) and not na(vpLow)
        color heatCol = contextBias == BULLISH ? color.new(NEON_CYAN, 93) : color.new(NEON_PINK, 93)
        box.set_lefttop(boxContextHeat, bar_index - 5, vpHigh)
        box.set_rightbottom(boxContextHeat, bar_index + 20, vpLow)
        box.set_bgcolor(boxContextHeat, heatCol)
        box.set_border_color(boxContextHeat, color.new(NEON_DARK, 100))
    else
        box.set_lefttop(boxContextHeat, hideX, na)
        box.set_rightbottom(boxContextHeat, hideX, na)

    // ----- Context Badge (v3.0: HUGE size) -----
    if showImpact and i_showContextBadge
        float atrOffset = not na(atr14) ? atr14 * 1.2 : syminfo.mintick * 100
        float badgeY = contextBias == BULLISH ? low - atrOffset : high + atrOffset

        label.set_xy(labelContextBadge, bar_index, badgeY)
        label.set_text(labelContextBadge, badgeText)
        label.set_color(labelContextBadge, badgeColor)
        label.set_textcolor(labelContextBadge, badgeTextColor)
        label.set_style(labelContextBadge, contextBias == BULLISH ? label.style_label_up : label.style_label_down)
        label.set_size(labelContextBadge, size.huge)
    else
        label.set_xy(labelContextBadge, hideX, na)

    // ----- POC Reaction Badge (v3.0: LARGE size) -----
    if showImpact and i_showPocReaction and (inPocZone or pocExit) and not na(pocPrice)
        string pocBadgeText = ''
        color pocBadgeCol = NEON_PURPLE
        color pocBadgeTextCol = NEON_WHITE

        if pocEnter
            pocBadgeText := 'â—† POC\nTOUCH'
            pocBadgeCol := color.new(NEON_GOLD, 10)
            pocBadgeTextCol := NEON_DARK
        else if inPocZone
            pocBadgeText := 'â— POC\nZONE'
            pocBadgeCol := color.new(NEON_GOLD, 30)
            pocBadgeTextCol := NEON_WHITE
        else if pocExit
            pocBadgeText := 'â—‹ POC\nEXIT'
            pocBadgeCol := color.new(NEON_PURPLE, 40)
            pocBadgeTextCol := NEON_WHITE

        label.set_xy(labelPocReaction, bar_index, pocPrice)
        label.set_text(labelPocReaction, pocBadgeText)
        label.set_color(labelPocReaction, pocBadgeCol)
        label.set_textcolor(labelPocReaction, pocBadgeTextCol)
        label.set_size(labelPocReaction, size.large)
    else
        label.set_xy(labelPocReaction, hideX, na)

    // ----- VP Full Histogram (Pro mode) -----
    if i_mode == MODE_PRO and boxesInitialized and not na(vpHigh) and vpMaxVolume > 0 and not na(vpRowSize) and vpRowSize > 0
        int startX = vpStartBar > 0 ? vpStartBar : bar_index - i_vpLookback

        for i = 0 to i_vpRows - 1
            if i < array.size(boxesVpFull) and i < array.size(volumeByPrice)
                float vol = array.get(volumeByPrice, i)
                float bVol = array.get(bullVolume, i)
                box b = array.get(boxesVpFull, i)

                if vol > 0
                    int barW = math.max(1, int(math.round((vol / vpMaxVolume) * i_vpWidth)))
                    float priceBottom = vpLow + i * vpRowSize
                    float priceTop = priceBottom + vpRowSize

                    float bullRatio = vol > 0 ? bVol / vol : 0.5
                    bool isHvn = vol > vpMaxVolume * 0.7
                    bool isLvn = vol < vpMaxVolume * 0.3

                    color barCol = isHvn ? i_hvnColor : isLvn ? i_lvnColor : bullRatio > 0.5 ? i_bullVolColor : i_bearVolColor

                    box.set_lefttop(b, startX, priceTop)
                    box.set_rightbottom(b, startX + barW, priceBottom)
                    box.set_bgcolor(b, barCol)
                    box.set_border_color(b, color.new(barCol, 30))
                else
                    box.set_lefttop(b, startX, na)
                    box.set_rightbottom(b, startX, na)
    else if boxesInitialized and array.size(boxesVpFull) > 0
        for i = 0 to array.size(boxesVpFull) - 1
            box b = array.get(boxesVpFull, i)
            box.set_lefttop(b, hideX, na)
            box.set_rightbottom(b, hideX, na)

//=============================================================================
// UI LAYER: SMA Lines & Trend Ribbon
//=============================================================================

p_sma20 = plot(i_showSma and i_showSma20 ? sma20 : na, 'SMA 20', i_sma20Color, i_smaWidth)
p_sma50 = plot(i_showSma and i_showSma50 ? sma50 : na, 'SMA 50', i_sma50Color, i_smaWidth)
plot(i_showSma and i_showSma200 ? sma200 : na, 'SMA 200', i_sma200Color, i_smaWidth)

// v3.0: NEON Trend Ribbon
bool showRibbon = (i_mode == MODE_IMPACT or i_mode == MODE_PRO) and i_showTrendRibbon and i_showSma
color ribbonCol = sma20 > sma50 ? color.new(NEON_CYAN, 88) : color.new(NEON_PINK, 88)
fill(p_sma20, p_sma50, showRibbon ? ribbonCol : na, title='Trend Ribbon')

//=============================================================================
// UI LAYER: SMA Cross Signals (v3.0: NEON Enhanced - HUGE labels)
//=============================================================================

// v3.0: NEON cross signals with HUGE size and multiline text
// Minor crosses (20Ã—50)
plotshape(i_showSmaCross and goldenCross20x50, 'Golden Cross 20Ã—50', shape.triangleup, location.belowbar, color.new(NEON_CYAN, 15), size=size.huge, text='â–²\nGOLDEN\nCROSS', textcolor=NEON_WHITE)
plotshape(i_showSmaCross and deadCross20x50, 'Death Cross 20Ã—50', shape.triangledown, location.abovebar, color.new(NEON_PINK, 15), size=size.huge, text='â–¼\nDEATH\nCROSS', textcolor=NEON_WHITE)

// Major crosses (50Ã—200)
plotshape(i_showSmaCross and goldenCross50x200, 'MAJOR Golden Cross', shape.triangleup, location.belowbar, color.new(NEON_GOLD, 15), size=size.huge, text='â­\nMAJOR\nGOLDEN', textcolor=NEON_DARK)
plotshape(i_showSmaCross and deadCross50x200, 'MAJOR Death Cross', shape.triangledown, location.abovebar, color.new(NEON_PINK, 0), size=size.huge, text='ðŸ’¥\nMAJOR\nDEATH', textcolor=NEON_WHITE)

// Pulse effect (Impact/Pro) - v3.0: size.normal minimum
bool showPulse = i_mode == MODE_IMPACT or i_mode == MODE_PRO
plotshape(showPulse and i_showSmaCross and goldenPulse20x50 and not goldenCross20x50, 'GC Pulse', shape.circle, location.belowbar, color.new(NEON_CYAN, 50), size=size.normal)
plotshape(showPulse and i_showSmaCross and deadPulse20x50 and not deadCross20x50, 'DC Pulse', shape.circle, location.abovebar, color.new(NEON_PINK, 50), size=size.normal)

//=============================================================================
// UI LAYER: POC Reaction History (persistent markers)
//=============================================================================

bool showPocMarker = (i_mode == MODE_IMPACT or i_mode == MODE_PRO) and i_showPocReaction
float pocMarkerPrice = showPocMarker and pocEnter ? pocPrice : na
plot(pocMarkerPrice, 'POC Reaction', NEON_GOLD, 4, plot.style_circles)

//=============================================================================
// UI LAYER: Information Table (v3.0: NEON Dark Panel with LARGE text)
//=============================================================================

var table tblInfo = table.new(position.bottom_right, 2, 7, frame_color=NEON_DARK, frame_width=4, border_color=NEON_GOLD, border_width=2)

if barstate.islast
    // v3.0: Score-based header color
    color scoreCol = f_score_color(contextScore)
    string scoreBar = f_score_bar(contextScore)

    // Header row
    table.cell(tblInfo, 0, 0, 'STATUS', bgcolor=NEON_DARK, text_color=NEON_GOLD, text_size=size.large)
    table.cell(tblInfo, 1, 0, mainIcon + ' ' + mainStatus, bgcolor=NEON_DARK, text_color=mainColor, text_size=size.large, text_halign=text.align_right)

    // Score row with visual bar
    table.cell(tblInfo, 0, 1, 'Score', bgcolor=NEON_DARK, text_color=NEON_GOLD, text_size=size.large)
    table.cell(tblInfo, 1, 1, str.tostring(contextScore) + ' ' + scoreBar, bgcolor=NEON_DARK, text_color=scoreCol, text_size=size.large, text_halign=text.align_right)

    // Zone
    string zoneDisplay = priceZone == 'above_vah' ? 'Above VAH â†‘' : priceZone == 'below_val' ? 'Below VAL â†“' : priceZone == 'at_poc' ? 'At POC â—' : 'In VA â€”'
    color zoneCol = priceZone == 'above_vah' ? NEON_CYAN : priceZone == 'below_val' ? NEON_PINK : priceZone == 'at_poc' ? NEON_GOLD : NEON_PURPLE
    table.cell(tblInfo, 0, 2, 'Zone', bgcolor=NEON_DARK, text_color=NEON_GOLD, text_size=size.large)
    table.cell(tblInfo, 1, 2, zoneDisplay, bgcolor=NEON_DARK, text_color=zoneCol, text_size=size.large, text_halign=text.align_right)

    // Trend
    string trendDisplay = smaBullAligned ? 'â–² BULL (20>50>200)' : smaBearAligned ? 'â–¼ BEAR (20<50<200)' : 'â€” FLAT'
    color trendCol = smaBullAligned ? NEON_CYAN : smaBearAligned ? NEON_PINK : NEON_PURPLE
    table.cell(tblInfo, 0, 3, 'Trend', bgcolor=NEON_DARK, text_color=NEON_GOLD, text_size=size.large)
    table.cell(tblInfo, 1, 3, trendDisplay, bgcolor=NEON_DARK, text_color=trendCol, text_size=size.large, text_halign=text.align_right)

    // POC State
    color pocStateCol = pocState == 'ENTER' ? NEON_GREEN : pocState == 'IN' ? NEON_GOLD : pocState == 'EXIT' ? NEON_ORANGE : NEON_PURPLE
    table.cell(tblInfo, 0, 4, 'POC', bgcolor=NEON_DARK, text_color=NEON_GOLD, text_size=size.large)
    table.cell(tblInfo, 1, 4, pocState, bgcolor=NEON_DARK, text_color=pocStateCol, text_size=size.large, text_halign=text.align_right)

    // Action Hint
    table.cell(tblInfo, 0, 5, 'Hint', bgcolor=NEON_DARK, text_color=NEON_GOLD, text_size=size.large)
    table.cell(tblInfo, 1, 5, actionGuide, bgcolor=NEON_DARK, text_color=NEON_WHITE, text_size=size.large, text_halign=text.align_right)

    // Version
    table.cell(tblInfo, 0, 6, 'IFA-VP', bgcolor=NEON_DARK, text_color=color.new(NEON_GOLD, 50), text_size=size.normal)
    table.cell(tblInfo, 1, 6, 'v3.0 NEON ' + i_mode, bgcolor=NEON_DARK, text_color=color.new(NEON_PURPLE, 30), text_size=size.normal, text_halign=text.align_right)

//=============================================================================
// ALERTS (v3.0: NEON Enhanced messages)
//=============================================================================

if i_alertsEnabled and barstate.isconfirmed
    if i_alertPoc and pocEnter
        alert('â—† POC TOUCH: Price entered POC zone at ' + str.tostring(close, format.mintick), alert.freq_once_per_bar_close)

    if i_alertCross and goldenCross20x50
        alert('â–² GOLDEN CROSS (20Ã—50): Bullish momentum at ' + str.tostring(close, format.mintick), alert.freq_once_per_bar_close)

    if i_alertCross and deadCross20x50
        alert('â–¼ DEATH CROSS (20Ã—50): Bearish momentum at ' + str.tostring(close, format.mintick), alert.freq_once_per_bar_close)

    if i_alertCross and goldenCross50x200
        alert('â­ MAJOR GOLDEN CROSS (50Ã—200): Strong bullish signal at ' + str.tostring(close, format.mintick), alert.freq_once_per_bar_close)

    if i_alertCross and deadCross50x200
        alert('ðŸ’¥ MAJOR DEATH CROSS (50Ã—200): Strong bearish signal at ' + str.tostring(close, format.mintick), alert.freq_once_per_bar_close)

    if i_alertContext and contextChanged
        string ctxStatus = ''
        if contextScore >= 80
            ctxStatus := contextBias == BULLISH ? 'SUPER BUY' : 'SUPER SELL'
        else if contextScore >= 70
            ctxStatus := contextBias == BULLISH ? 'POWER BUY' : 'POWER SELL'
        else if contextScore >= 60
            ctxStatus := contextBias == BULLISH ? 'STRONG BUY' : 'STRONG SELL'
        else
            ctxStatus := contextBias == BULLISH ? 'BUY' : 'SELL'
        alert('Context â†’ ' + ctxStatus + ' ' + str.tostring(contextScore), alert.freq_once_per_bar_close)

// Alert conditions for TradingView alert dialog
alertcondition(pocEnter, 'POC Touch', 'Price entered POC zone')
alertcondition(goldenCross20x50, 'Golden Cross 20Ã—50', 'Golden Cross 20Ã—50')
alertcondition(deadCross20x50, 'Death Cross 20Ã—50', 'Death Cross 20Ã—50')
alertcondition(goldenCross50x200, 'MAJOR Golden Cross', 'Golden Cross 50Ã—200')
alertcondition(deadCross50x200, 'MAJOR Death Cross', 'Death Cross 50Ã—200')
alertcondition(contextChanged, 'Context Change', 'Market context changed')
alertcondition(isLongFavorable, 'Long Favorable', 'Long favorable condition met')
alertcondition(isShortFavorable, 'Short Favorable', 'Short favorable condition met')
