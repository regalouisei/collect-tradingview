// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=6
indicator("Rolling SSA Oscillator [LuxAlgo]", "LuxAlgo - Rolling SSA", overlay = false, calc_bars_count = 2000)

//---------------------------------------------------------------------------------------------------------------------}
// Settings
//---------------------------------------------------------------------------------------------------------------------{
int windowInput    = input.int(20, "Window", minval = 5, maxval = 100, tooltip = "The embedding window (L). This defines the resolution and cycle capture.")
int periodInput    = windowInput
int trainingInput  = windowInput * 2

GROUP_STYLE        = "Style"
bool showLT        = input.bool(true, "Long Term Periodic", inline = "LT", group = GROUP_STYLE)
bool showST        = input.bool(true, "Short Term Periodic", inline = "ST", group = GROUP_STYLE)
bool normalizeInput = input.bool(false, "Normalize", tooltip = "When enabled, divides each component by the sum of their absolute values. This keeps the combined amplitude within a -1 to 1 range.", group = GROUP_STYLE)

DATA                    = #DBDBDB
HEADERS                 = #808080
BACKGROUND              = #161616
BORDERS                 = #2E2E2E

TOP_RIGHT               = 'Top Right'
BOTTOM_RIGHT            = 'Bottom Right'
BOTTOM_LEFT             = 'Bottom Left'

TINY                    = 'Tiny'
SMALL                   = 'Small'
NORMAL                  = 'Normal'
LARGE                   = 'Large'
HUGE                    = 'Huge'

DASHBOARD_GROUP         = 'Dashboard'

dashboardInput          = input.bool(true, 'Dashboard', group = DASHBOARD_GROUP)
dashboardPositionInput  = input.string(TOP_RIGHT, 'Position', group = DASHBOARD_GROUP, options = [TOP_RIGHT, BOTTOM_RIGHT, BOTTOM_LEFT])
dashboardSizeInput      = input.string(SMALL, 'Size', group = DASHBOARD_GROUP, options = [TINY, SMALL, NORMAL, LARGE, HUGE])

var parsedDashboardPosition = switch dashboardPositionInput
    TOP_RIGHT       => position.top_right
    BOTTOM_RIGHT    => position.bottom_right
    BOTTOM_LEFT     => position.bottom_left

var parsedDashboardSize     = switch dashboardSizeInput
    TINY            => size.tiny
    SMALL           => size.small
    NORMAL          => size.normal
    LARGE           => size.large
    HUGE            => size.huge

//---------------------------------------------------------------------------------------------------------------------}
// Functions
//---------------------------------------------------------------------------------------------------------------------{
// Sorts eigenvectors matrix columns based on eigenvalues array (descending)
sortEigen(matrix<float> vectors, array<float> values) =>
    int size = values.size()
    array<int> indices = array.new<int>(size)
    for i = 0 to size - 1
        indices.set(i, i)
    
    for i = 0 to size - 2
        for j = 0 to size - i - 2
            if nz(values.get(indices.get(j))) < nz(values.get(indices.get(j + 1)))
                temp = indices.get(j)
                indices.set(j, indices.get(j + 1))
                indices.set(j + 1, temp)
    
    matrix<float> sortedVectors = matrix.new<float>(vectors.rows(), vectors.columns())
    for col = 0 to size - 1
        int oldCol = indices.get(col)
        for row = 0 to vectors.rows() - 1
            sortedVectors.set(row, col, vectors.get(row, oldCol))
    sortedVectors

// Reconstruct only the last point of a specific component (n = N-1)
reconstructLastPoint(matrix<float> V, int k, array<float> y, int L, int N) =>
    int K = N - L + 1
    float pcLast = 0.0
    for i = 0 to L - 1
        pcLast += matrix.get(V, i, k) * array.get(y, (K - 1) + i)
    matrix.get(V, L - 1, k) * pcLast

// Dashboard helper functions
cell(table t_able, int column, int row, string data, color = #FFFFFF, align = text.align_right, color background = na, float height = 0) => 
    t_able.cell(column, row, data, text_color = color, text_size = parsedDashboardSize, text_halign = align, bgcolor = background, height = height)

divider(table t_able, int row, int lastColumn) =>    
    string rowDivider = '━━━━━━━━━━━━━━━━━━━━'
    t_able.merge_cells(0, row, lastColumn, row)
    cell(t_able, 0, row, rowDivider, align = text.align_center, height = 0.5, color = BORDERS)

// Average period calculation from crosses
getRollingPeriod(float src) =>
    var array<int> crossIndices = array.new<int>(0)
    if ta.cross(src, 0)
        array.push(crossIndices, bar_index)
        if array.size(crossIndices) > 10
            array.remove(crossIndices, 0)
    
    float avgPeriod = na
    if array.size(crossIndices) > 1
        float totalDist = 0.0
        for i = 1 to array.size(crossIndices) - 1
            totalDist += array.get(crossIndices, i) - array.get(crossIndices, i-1)
        avgPeriod := (totalDist / (array.size(crossIndices) - 1)) * 2
    avgPeriod

//---------------------------------------------------------------------------------------------------------------------}
// Core SSA Logic
//---------------------------------------------------------------------------------------------------------------------{
var float ltOsc = na
var float stOsc = na

if bar_index >= trainingInput
    // 1. Collect price data
    array<float> y = array.new<float>(0)
    for i = 0 to trainingInput - 1
        array.push(y, close[trainingInput - 1 - i])

    // 2. Compute Covariance Matrix S (LxL)
    matrix<float> S = matrix.new<float>(periodInput, periodInput, 0.0)
    int nRowsX = trainingInput - periodInput + 1
    for i = 0 to periodInput - 1
        for j = i to periodInput - 1
            float sum = 0.0
            for k = 0 to nRowsX - 1
                sum += array.get(y, k + i) * array.get(y, k + j)
            matrix.set(S, i, j, sum)
            matrix.set(S, j, i, sum)

    // 3. Eigendecomposition
    array<float>  evals = matrix.eigenvalues(S)
    matrix<float> evecs = matrix.eigenvectors(S)
    
    if not array.includes(evals, na)
        matrix<float> sortedV = sortEigen(evecs, evals)

        // 4. Reconstruct Rolling Components
        float rc1Last = reconstructLastPoint(sortedV, 1, y, periodInput, trainingInput)
        float rc2Last = reconstructLastPoint(sortedV, 2, y, periodInput, trainingInput)
        float rc3Last = reconstructLastPoint(sortedV, 3, y, periodInput, trainingInput)
        float rc4Last = reconstructLastPoint(sortedV, 4, y, periodInput, trainingInput)

        ltOsc := rc1Last + rc2Last
        stOsc := rc3Last + rc4Last
        
        if normalizeInput
            float denominator = math.abs(ltOsc) + math.abs(stOsc)
            if denominator > 0
                ltOsc /= denominator
                stOsc /= denominator

//---------------------------------------------------------------------------------------------------------------------}
// Visuals
//---------------------------------------------------------------------------------------------------------------------{
// Signature colors
BULL_COLOR = #089981
BEAR_COLOR = #f23645
ST_COLOR   = #90bff9

pLT = plot(showLT ? ltOsc : na, "Long Term Periodic", color = ltOsc > 0 ? BULL_COLOR : BEAR_COLOR, linewidth = 1)
pST = plot(showST ? stOsc : na, "Short Term Periodic", color = ST_COLOR, linestyle = plot.linestyle_dotted, linewidth = 1)
p0  = plot(0, "Zero Level", color = na, display = display.none)

fill(pLT, p0, ltOsc > 0 ? color.new(BULL_COLOR, 90) : color.new(BEAR_COLOR, 90), "Long Term Fill")

hline(0, "Zero Line", color = color.new(color.gray, 50), linestyle = hline.style_dotted)

//---------------------------------------------------------------------------------------------------------------------}
// Dashboard
//---------------------------------------------------------------------------------------------------------------------{
var table t_able = table.new(parsedDashboardPosition, 2, 5, bgcolor = BACKGROUND, border_width = 0, frame_color = BORDERS, frame_width = 1, force_overlay = true)

float periodLT = getRollingPeriod(ltOsc)
float periodST = getRollingPeriod(stOsc)

if barstate.islast and dashboardInput
    t_able.clear(0, 0, 1, 4)
    t_able.merge_cells(0, 0, 1, 0)
    cell(t_able, 0, 0, "SSA Rolling Stats", color = DATA, align = text.align_center)
    divider(t_able, 1, 1)
    
    cell(t_able, 0, 2, "Long Term Period", color = HEADERS, align = text.align_left)
    cell(t_able, 1, 2, str.tostring(periodLT, "#.##"), color = DATA)
    
    divider(t_able, 3, 1)
    
    cell(t_able, 0, 4, "Short Term Period", color = HEADERS, align = text.align_left)
    cell(t_able, 1, 4, str.tostring(periodST, "#.##"), color = DATA)
else if barstate.islast
    t_able.clear(0, 0, 1, 4)

//---------------------------------------------------------------------------------------------------------------------}
