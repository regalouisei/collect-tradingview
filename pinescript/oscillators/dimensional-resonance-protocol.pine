//@version=5
indicator("Dimensional Resonance Protocol", shorttitle="ğŸŒDRP", overlay=true, max_lines_count=500, max_labels_count=500, max_bars_back=1000)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIMENSIONAL RESONANCE PROTOCOL
// Phase Space â€¢ Recurrence â€¢ Transfer Entropy â€¢ Emergence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ CORE DIMENSIONAL SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
embedding_dimension = input.int(5, "Embedding Dimension", minval=3, maxval=10, group="ğŸŒ Phase Space", 
     tooltip="Dimension for phase space reconstruction (Takens' theorem).\n\n" +
     "THEORY: Markets exist in higher-dimensional space.\n" +
     "We reconstruct this using time-delay embedding.\n\n" +
     "â€¢ LOW (3-4): Simple dynamics, faster\n" +
     "â€¢ MEDIUM (5-6): Balanced complexity (default: 5)\n" +
     "â€¢ HIGH (7-10): Complex dynamics, more data needed\n\n" +
     "Based on Takens' Embedding Theorem from dynamical systems theory.")
time_delay = input.int(3, "Time Delay (Ï„)", minval=1, maxval=10, group="ğŸŒ Phase Space",
     tooltip="Time delay for phase space embedding.\n\n" +
     "OPTIMAL Ï„ should be where autocorrelation first crosses zero\n" +
     "or first minimum of mutual information.\n\n" +
     "â€¢ FAST MARKETS: 1-2\n" +
     "â€¢ NORMAL: 3-4 (default: 3)\n" +
     "â€¢ SLOW MARKETS: 5-10\n\n" +
     "Too low = redundant dimensions\n" +
     "Too high = loss of dynamical connection")
recurrence_threshold = input.float(0.1, "Recurrence Threshold (Îµ)", minval=0.01, maxval=0.5, step=0.01, group="ğŸŒ Phase Space",
     tooltip="Threshold for recurrence detection.\n\n" +
     "Two states are 'recurrent' if their distance < Îµ Ã— std_dev\n\n" +
     "â€¢ TIGHT (0.01-0.05): Very similar states only\n" +
     "â€¢ MEDIUM (0.08-0.15): Balanced (default: 0.10)\n" +
     "â€¢ LOOSE (0.20-0.50): More liberal matching\n\n" +
     "Used in Recurrence Quantification Analysis (RQA)")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”¬ ENTROPY & COMPLEXITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
perm_order = input.int(4, "Permutation Order", minval=3, maxval=7, group="ğŸ”¬ Entropy & Complexity",
     tooltip="Order for permutation entropy calculation.\n\n" +
     "PERMUTATION ENTROPY measures complexity by analyzing\n" +
     "the distribution of ordinal patterns in the data.\n\n" +
     "â€¢ LOW (3): Fast, coarse complexity measure\n" +
     "â€¢ MEDIUM (4-5): Balanced (default: 4)\n" +
     "â€¢ HIGH (6-7): Fine-grained, needs more data\n\n" +
     "Number of possible patterns = order!\n" +
     "Order 4 = 24 patterns, Order 5 = 120 patterns")
entropy_window = input.int(30, "Entropy Window", minval=15, maxval=100, group="ğŸ”¬ Entropy & Complexity",
     tooltip="Lookback for entropy calculations.\n\n" +
     "â€¢ SHORT (15-25): Responsive to recent changes\n" +
     "â€¢ MEDIUM (30-50): Stable measure (default: 30)\n" +
     "â€¢ LONG (60-100): Smooth, slower to adapt\n\n" +
     "Should be >> perm_order! for reliable estimation")
lyapunov_window = input.int(20, "Lyapunov Window", minval=10, maxval=50, group="ğŸ”¬ Entropy & Complexity",
     tooltip="Window for Lyapunov exponent estimation.\n\n" +
     "LYAPUNOV EXPONENT measures sensitivity to initial conditions:\n" +
     "â€¢ Î» > 0: Chaotic (unpredictable)\n" +
     "â€¢ Î» â‰ˆ 0: Edge of chaos (critical state)\n" +
     "â€¢ Î» < 0: Stable (predictable)\n\n" +
     "Signals are prioritized when Î» < 0 (predictable state)")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”— CAUSAL INFERENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
enable_transfer_entropy = input.bool(true, "Enable Transfer Entropy Analysis", group="ğŸ”— Causal Inference",
     tooltip="Measure CAUSAL information flow between variables.\n\n" +
     "TRANSFER ENTROPY (Schreiber, 2000) quantifies:\n" +
     "'How much does knowing X reduce uncertainty about Y's future?'\n\n" +
     "Unlike correlation, TE is:\n" +
     "â€¢ Directional (Xâ†’Y â‰  Yâ†’X)\n" +
     "â€¢ Non-linear\n" +
     "â€¢ Detects actual causation\n\n" +
     "We measure TE between:\n" +
     "â€¢ Volume â†’ Price\n" +
     "â€¢ Volatility â†’ Momentum\n" +
     "â€¢ Structure â†’ Direction")
te_history = input.int(5, "TE History Length", minval=2, maxval=15, group="ğŸ”— Causal Inference",
     tooltip="How much history to use for transfer entropy.\n\n" +
     "TE measures: H(Y_future | Y_past) - H(Y_future | Y_past, X_past)\n\n" +
     "â€¢ SHORT (2-4): Quick causal detection\n" +
     "â€¢ MEDIUM (5-8): Balanced (default: 5)\n" +
     "â€¢ LONG (10-15): Deep causal analysis")
te_bins = input.int(6, "TE Discretization Bins", minval=4, maxval=12, group="ğŸ”— Causal Inference",
     tooltip="Bins for discretizing continuous data.\n\n" +
     "Transfer entropy requires discrete data.\n" +
     "We discretize into this many bins.\n\n" +
     "â€¢ FEW (4-5): Coarse, robust\n" +
     "â€¢ MEDIUM (6-8): Balanced (default: 6)\n" +
     "â€¢ MANY (9-12): Fine-grained, needs more data")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒŠ HILBERT PHASE COHERENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
enable_phase_coherence = input.bool(true, "Enable Phase Coherence", group="ğŸŒŠ Phase Coherence",
     tooltip="Detect phase synchronization across dimensions.\n\n" +
     "HILBERT TRANSFORM gives us instantaneous phase.\n" +
     "When multiple market dimensions are IN PHASE,\n" +
     "we have COHERENCE - a high-probability state.\n\n" +
     "Dimensions analyzed:\n" +
     "â€¢ Price momentum phase\n" +
     "â€¢ Volume intensity phase\n" +
     "â€¢ Volatility cycle phase\n" +
     "â€¢ Structural tension phase\n\n" +
     "Based on phase synchronization in complex systems.")
coherence_threshold = input.float(0.7, "Coherence Threshold", minval=0.3, maxval=0.95, step=0.05, group="ğŸŒŠ Phase Coherence",
     tooltip="Minimum phase coherence to confirm signals.\n\n" +
     "Phase Locking Value (PLV) ranges from 0 to 1:\n" +
     "â€¢ 0.0: Completely random phases\n" +
     "â€¢ 0.5: Moderate coherence\n" +
     "â€¢ 1.0: Perfect synchronization\n\n" +
     "â€¢ LOOSE (0.3-0.5): More signals, less reliable\n" +
     "â€¢ BALANCED (0.6-0.75): Good filter (default: 0.7)\n" +
     "â€¢ STRICT (0.8-0.95): Fewer, higher-quality signals")
hilbert_smooth = input.int(8, "Hilbert Smoothing", minval=3, maxval=20, group="ğŸŒŠ Phase Coherence",
     tooltip="Smoothing for Hilbert transform components.\n\n" +
     "Hilbert transform can be noisy on raw data.\n" +
     "This applies EMA smoothing before phase extraction.\n\n" +
     "â€¢ LOW (3-5): More responsive, noisier phases\n" +
     "â€¢ MEDIUM (6-10): Balanced (default: 8)\n" +
     "â€¢ HIGH (12-20): Smooth phases, more lag")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ FRACTAL DIMENSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
enable_fractal = input.bool(true, "Enable Fractal Dimension", group="ğŸ“ Fractal Analysis",
     tooltip="Calculate Higuchi Fractal Dimension.\n\n" +
     "FRACTAL DIMENSION (FD) measures complexity:\n" +
     "â€¢ FD â‰ˆ 1.0: Smooth, trending\n" +
     "â€¢ FD â‰ˆ 1.5: Random walk (Brownian motion)\n" +
     "â€¢ FD â‰ˆ 2.0: Space-filling, highly complex\n\n" +
     "TRADING IMPLICATIONS:\n" +
     "â€¢ FD < 1.4: Trending (momentum strategies)\n" +
     "â€¢ FD > 1.6: Random/choppy (avoid or mean-revert)\n" +
     "â€¢ FD â‰ˆ 1.5: Critical transition point\n\n" +
     "Based on Higuchi's method (1988)")
fractal_kmax = input.int(8, "Fractal K-max", minval=4, maxval=20, group="ğŸ“ Fractal Analysis",
     tooltip="Maximum k for Higuchi FD calculation.\n\n" +
     "Higher kmax = more scales analyzed.\n\n" +
     "â€¢ LOW (4-6): Faster, less accurate\n" +
     "â€¢ MEDIUM (7-10): Balanced (default: 8)\n" +
     "â€¢ HIGH (12-20): Accurate, slower")
fractal_window = input.int(50, "Fractal Window", minval=30, maxval=200, group="ğŸ“ Fractal Analysis",
     tooltip="Lookback window for fractal dimension.\n\n" +
     "â€¢ SHORT (30-50): Responsive FD (default: 50)\n" +
     "â€¢ MEDIUM (60-100): Stable FD\n" +
     "â€¢ LONG (120-200): Very smooth FD")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ€ EMERGENCE DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
emergence_threshold = input.float(0.75, "Emergence Threshold", minval=0.5, maxval=0.95, step=0.05, group="ğŸŒ€ Emergence",
     tooltip="Threshold for emergence signal detection.\n\n" +
     "EMERGENCE occurs when:\n" +
     "â€¢ Multiple dimensions achieve coherence\n" +
     "â€¢ Entropy enters predictable regime\n" +
     "â€¢ Causal flows align\n" +
     "â€¢ Lyapunov indicates stability\n\n" +
     "The Emergence Score combines all these.\n\n" +
     "â€¢ SENSITIVE (0.5-0.65): More signals\n" +
     "â€¢ BALANCED (0.7-0.8): Default (0.75)\n" +
     "â€¢ STRICT (0.85-0.95): Rare, strong signals")
require_causal_gate = input.bool(true, "Require Causal Gate", group="ğŸŒ€ Emergence",
     tooltip="Only signal when causal flow confirms.\n\n" +
     "CAUSAL GATE requires:\n" +
     "â€¢ For BUY: Volumeâ†’Price TE is positive\n" +
     "â€¢ For SELL: Volumeâ†’Price TE is positive\n" +
     "â€¢ Net causal flow matches direction\n\n" +
     "This filters out moves lacking causal support.")
require_stability = input.bool(true, "Require Stability Zone", group="ğŸŒ€ Emergence",
     tooltip="Only signal when Lyapunov exponent < 0.\n\n" +
     "STABILITY ZONE means:\n" +
     "â€¢ Market is in predictable state\n" +
     "â€¢ Small errors don't explode\n" +
     "â€¢ Technical patterns have meaning\n\n" +
     "Avoids signaling during chaotic regimes.")
signal_cooldown = input.int(5, "Signal Cooldown (bars)", minval=1, maxval=50, group="ğŸŒ€ Emergence",
     tooltip="Minimum bars between signals.\n\n" +
     "Prevents signal spam when conditions persist.\n\n" +
     "â€¢ FAST (1-3): Allow rapid signals\n" +
     "â€¢ NORMAL (4-8): Balanced (default: 5)\n" +
     "â€¢ SLOW (10-20): Very selective\n" +
     "â€¢ ULTRA (25-50): Only major moves")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SIGNAL CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
momentum_period = input.int(14, "Momentum Period", minval=5, maxval=50, group="ğŸ¯ Signal Config", tooltip="Base period for momentum calculations.")
structure_lookback = input.int(20, "Structure Lookback", minval=10, maxval=100, group="ğŸ¯ Signal Config", tooltip="Lookback for support/resistance detection.")
volatility_period = input.int(14, "Volatility Period", minval=5, maxval=50, group="ğŸ¯ Signal Config", tooltip="ATR period for volatility calculations.")
volume_ma_period = input.int(20, "Volume MA Period", minval=10, maxval=50, group="ğŸ¯ Signal Config", tooltip="Period for volume moving average.")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LABEL MANAGEMENT SYSTEM 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var array<label> signal_labels = array.new<label>(0)
max_labels = 50  
if array.size(signal_labels) > max_labels
    label old_label = array.shift(signal_labels)
    label.delete(old_label)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ VISUAL SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
c_emergence_bull = input.color(#00FFAA, "Emergence Bull", group="ğŸ¨ Theme")
c_emergence_bear = input.color(#FF0066, "Emergence Bear", group="ğŸ¨ Theme")
c_coherence = input.color(#00BFFF, "Coherence Field", group="ğŸ¨ Theme")
c_chaos = input.color(#FF4444, "Chaos Warning", group="ğŸ¨ Theme")
c_stable = input.color(#44FF44, "Stable Zone", group="ğŸ¨ Theme")
c_neutral = input.color(#888888, "Neutral", group="ğŸ¨ Theme")
c_dashboard_bg = input.color(#0a0a14, "Dashboard Background", group="ğŸ¨ Theme")
c_gold = input.color(#FFD700, "Highlight", group="ğŸ¨ Theme")
show_coherence_field = input.bool(true, "Show Coherence Field", group="ğŸ‘ï¸ Visibility")
show_stability_zones = input.bool(true, "Show Stability/Chaos Zones", group="ğŸ‘ï¸ Visibility")
show_emergence_flash = input.bool(true, "Show Emergence Flash", group="ğŸ‘ï¸ Visibility")
show_causal_flow = input.bool(true, "Show Causal Flow Lines", group="ğŸ‘ï¸ Visibility")
show_dimension_ribbons = input.bool(true, "Show Dimension Ribbons", group="ğŸ‘ï¸ Visibility")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_dashboard = input.bool(true, "Show Dashboard", group="ğŸ“Š Dashboard")
dashboard_position = input.string("Top Right", "Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group="ğŸ“Š Dashboard")
dashboard_size = input.string("Small", "Size", options=["Tiny", "Small", "Normal"], group="ğŸ“Š Dashboard")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILITY FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_atan2(float y, float x) =>
    float result = 0.0
    if x > 0
        result := math.atan(y / x)
    else if x < 0 and y >= 0
        result := math.atan(y / x) + math.pi
    else if x < 0 and y < 0
        result := math.atan(y / x) - math.pi
    else if x == 0 and y > 0
        result := math.pi / 2
    else if x == 0 and y < 0
        result := -math.pi / 2
    else
        result := 0.0
    result
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_embed(float src, int dim, int tau) =>
    float sum_sq = 0.0
    for i = 0 to dim - 1
        float val = nz(src[i * tau], src)
        sum_sq += val * val
    math.sqrt(sum_sq)
// â”€â”€â”€ PERMUTATION ENTROPY â”€â”€â”€
f_permutation_entropy(float src, int order, int window) =>
    int factorial = 1
    for i = 2 to order
        factorial *= i
    var array<int> pattern_counts = array.new<int>(factorial, 0)
    for i = 0 to factorial - 1
        array.set(pattern_counts, i, 0)
    int total_patterns = 0
    for w = 0 to window - order
        float sum = 0.0
        for i = 0 to order - 1
            float rank = 0.0
            for j = 0 to order - 1
                if i != j and nz(src[w + j]) < nz(src[w + i])
                    rank += 1.0
            sum += rank * math.pow(order, i)
        int pattern_idx = int(sum) % factorial
        array.set(pattern_counts, pattern_idx, array.get(pattern_counts, pattern_idx) + 1)
        total_patterns += 1
    // Calculate entropy
    float entropy = 0.0
    for i = 0 to factorial - 1
        float p = array.get(pattern_counts, i) / math.max(total_patterns, 1)
        if p > 0
            entropy -= p * math.log(p)
    // Normalize by maximum entropy
    float max_entropy = math.log(factorial)
    entropy / max_entropy
// â”€â”€â”€ HILBERT TRANSFORM APPROXIMATION â”€â”€â”€
// Get instantaneous phase using Hilbert-like transformation
f_hilbert_phase(float src, int smooth_period) =>
    float smoothed = ta.ema(src, smooth_period)
    float deriv = smoothed - smoothed[1]
    float amplitude = math.sqrt(smoothed * smoothed + deriv * deriv * 4)
    float phase = f_atan2(deriv * 2, smoothed)
    [phase, amplitude]
// â”€â”€â”€ PHASE LOCKING VALUE â”€â”€â”€
// Measure phase synchronization between two signals
f_phase_lock_value(float phase1, float phase2, int window) =>
    float sum_cos = 0.0
    float sum_sin = 0.0
    for i = 0 to window - 1
        float diff = nz(phase1[i]) - nz(phase2[i])
        sum_cos += math.cos(diff)
        sum_sin += math.sin(diff)
    math.sqrt(sum_cos * sum_cos + sum_sin * sum_sin) / window
// â”€â”€â”€ HIGUCHI FRACTAL DIMENSION â”€â”€â”€
f_higuchi_fd(float src, int window, int kmax) =>
    float sum_L = 0.0
    float sum_logk = 0.0
    float sum_logL = 0.0
    float sum_logk2 = 0.0
    int valid_k = 0
    for k = 1 to kmax
        float L_k = 0.0
        int count = 0
        for m = 1 to k
            float L_m = 0.0
            int n_max = int((window - m) / k)
            if n_max > 0
                for i = 1 to n_max
                    int idx1 = m + i * k - 1
                    int idx2 = m + (i - 1) * k - 1
                    if idx1 < window and idx2 < window
                        L_m += math.abs(nz(src[idx1]) - nz(src[idx2]))
                float norm = (window - 1) / (k * n_max * k)
                L_m *= norm
                L_k += L_m
                count += 1
        if count > 0
            L_k /= count
            if L_k > 0
                float log_k = math.log(1.0 / k)
                float log_L = math.log(L_k)
                sum_logk += log_k
                sum_logL += log_L
                sum_logk2 += log_k * log_k
                sum_L += log_k * log_L
                valid_k += 1
    float fd = 1.5
    if valid_k > 1
        float denom = valid_k * sum_logk2 - sum_logk * sum_logk
        if math.abs(denom) > 1e-10
            fd := (valid_k * sum_L - sum_logk * sum_logL) / denom
            fd := math.max(1.0, math.min(2.0, fd))
    fd
// â”€â”€â”€ LYAPUNOV EXPONENT ESTIMATION â”€â”€â”€
f_lyapunov_estimate(float src, int window) =>
    float sum_log = 0.0
    int count = 0
    for i = 1 to window - 1
        float delta0 = math.abs(nz(src[i + 1]) - nz(src[i]))
        float delta1 = math.abs(nz(src[i]) - nz(src[i - 1]))
        if delta1 > 1e-10
            float ratio = delta0 / delta1
            if ratio > 0
                sum_log += math.log(ratio)
                count += 1
    count > 0 ? sum_log / count : 0.0
// â”€â”€â”€ TRANSFER ENTROPY APPROXIMATION â”€â”€â”€
f_transfer_entropy(float source, float target, int history, int bins, int window) =>
    float src_min = ta.lowest(source, window)
    float src_max = ta.highest(source, window)
    float tgt_min = ta.lowest(target, window)
    float tgt_max = ta.highest(target, window)
    float src_range = math.max(src_max - src_min, 1e-10)
    float tgt_range = math.max(tgt_max - tgt_min, 1e-10)
    int src_bin = int((source - src_min) / src_range * (bins - 1))
    int tgt_bin = int((target - tgt_min) / tgt_range * (bins - 1))
    int tgt_future_bin = int((target[0] - tgt_min) / tgt_range * (bins - 1))
    src_bin := math.max(0, math.min(bins - 1, src_bin))
    tgt_bin := math.max(0, math.min(bins - 1, tgt_bin))
    tgt_future_bin := math.max(0, math.min(bins - 1, tgt_future_bin))
    // This is an approximation using recent autocorrelation structure
    float src_predictability = 1.0 - ta.stdev(source, history) / math.max(ta.stdev(source, window), 1e-10)
    float tgt_predictability = 1.0 - ta.stdev(target, history) / math.max(ta.stdev(target, window), 1e-10)
    // Cross-predictability
    float correlation = ta.correlation(source, target, history)
    float lagged_corr = ta.correlation(source[history], target, history)
    // TE approximation: how much does knowing source reduce uncertainty in target's future
    float te = math.max(0, math.abs(lagged_corr) - math.abs(correlation) * 0.5)
    te *= math.sign(lagged_corr)
    te
// â”€â”€â”€ RECURRENCE RATE â”€â”€â”€
f_recurrence_rate(float src, int window, float threshold) =>
    float std = ta.stdev(src, window)
    float eps = threshold * std
    int recurrences = 0
    int total_pairs = 0
    for i = 0 to window - 1
        for j = i + 1 to window - 1
            float dist = math.abs(nz(src[i]) - nz(src[j]))
            if dist < eps
                recurrences += 1
            total_pairs += 1
    total_pairs > 0 ? recurrences / total_pairs : 0.0
// â”€â”€â”€ DETERMINISM  â”€â”€â”€
f_determinism(float src, int window, float threshold, int min_diag) =>
    float std = ta.stdev(src, window)
    float eps = threshold * std
    // Count diagonal structures 
    int diag_count = 0
    int total_recur = 0
    int current_diag = 0
    for i = 1 to window - 1
        float dist1 = math.abs(nz(src[i]) - nz(src[i-1]))
        float dist2 = math.abs(nz(src[0]) - nz(src[i]))
        bool recur = dist2 < eps
        bool diag_continues = dist1 < eps and recur
        if diag_continues
            current_diag += 1
        else
            if current_diag >= min_diag
                diag_count += current_diag
            current_diag := recur ? 1 : 0
        if recur
            total_recur += 1
    total_recur > 0 ? diag_count / total_recur : 0.0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIMENSION EXTRACTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Base series
float price_momentum = ta.roc(close, momentum_period)
float vol_intensity = volume / ta.sma(volume, volume_ma_period)
float volatility = ta.atr(volatility_period) / close * 100
float structure_position = (close - ta.lowest(low, structure_lookback)) / 
     math.max(ta.highest(high, structure_lookback) - ta.lowest(low, structure_lookback), 1e-10)
// Normalize dimensions
float norm_momentum = (price_momentum - ta.sma(price_momentum, 50)) / math.max(ta.stdev(price_momentum, 50), 1e-10)
float norm_volume = (vol_intensity - 1.0) / math.max(ta.stdev(vol_intensity, 50), 1e-10)
float norm_volatility = (volatility - ta.sma(volatility, 50)) / math.max(ta.stdev(volatility, 50), 1e-10)
float norm_structure = structure_position * 2 - 1  // -1 to +1
// Phase space embedding
float phase_magnitude = f_embed(close, embedding_dimension, time_delay)
float phase_magnitude_norm = (phase_magnitude - ta.sma(phase_magnitude, 50)) / math.max(ta.stdev(phase_magnitude, 50), 1e-10)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENTROPY & COMPLEXITY CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float perm_entropy = f_permutation_entropy(close, perm_order, entropy_window)
float lyapunov = f_lyapunov_estimate(close, lyapunov_window)
float fractal_dim = enable_fractal ? f_higuchi_fd(close, fractal_window, fractal_kmax) : 1.5
float recurrence = f_recurrence_rate(close, entropy_window, recurrence_threshold)
float determinism = f_determinism(close, entropy_window, recurrence_threshold, 2)
// Classify entropy regime
int entropy_regime = perm_entropy < 0.3 ? 0 : 
                     perm_entropy < 0.5 ? 1 : 
                     perm_entropy < 0.7 ? 2 :  
                     perm_entropy < 0.85 ? 3 : 4  
string entropy_regime_name = entropy_regime == 0 ? "CRYSTALLINE" :
                             entropy_regime == 1 ? "ORDERED" :
                             entropy_regime == 2 ? "MODERATE" :
                             entropy_regime == 3 ? "COMPLEX" : "CHAOTIC"
// Stability classification based on Lyapunov
bool is_stable = lyapunov < 0
bool is_critical = math.abs(lyapunov) < 0.1
bool is_chaotic = lyapunov > 0.2
string stability_state = is_stable ? "STABLE" : is_critical ? "CRITICAL" : "CHAOTIC"
// Fractal regime
string fractal_regime = fractal_dim < 1.35 ? "TRENDING" : fractal_dim < 1.45 ? "PERSISTENT" : fractal_dim < 1.55 ? "RANDOM" : fractal_dim < 1.65 ? "ANTI-PERSIST" : "COMPLEX"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HILBERT PHASE COHERENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[phase_momentum, amp_momentum] = f_hilbert_phase(price_momentum, hilbert_smooth)
[phase_volume, amp_volume] = f_hilbert_phase(vol_intensity, hilbert_smooth)
[phase_volatility, amp_volatility] = f_hilbert_phase(volatility, hilbert_smooth)
[phase_structure, amp_structure] = f_hilbert_phase(structure_position, hilbert_smooth)
// Calculate pairwise phase locking
float plv_mom_vol = enable_phase_coherence ? f_phase_lock_value(phase_momentum, phase_volume, 20) : 0.5
float plv_mom_struct = enable_phase_coherence ? f_phase_lock_value(phase_momentum, phase_structure, 20) : 0.5
float plv_vol_struct = enable_phase_coherence ? f_phase_lock_value(phase_volume, phase_structure, 20) : 0.5
// Overall coherence score
float phase_coherence = (plv_mom_vol + plv_mom_struct + plv_vol_struct) / 3.0
// Coherence direction - which way are the phases pointing?
float coherence_direction = math.sin(phase_momentum) + math.sin(phase_volume) * 0.5 + math.sin(phase_structure) * 0.5
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRANSFER ENTROPY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float te_vol_to_price = enable_transfer_entropy ? 
     f_transfer_entropy(vol_intensity, close, te_history, te_bins, entropy_window) : 0.0
float te_volatility_to_mom = enable_transfer_entropy ? 
     f_transfer_entropy(volatility, price_momentum, te_history, te_bins, entropy_window) : 0.0
float te_struct_to_price = enable_transfer_entropy ? 
     f_transfer_entropy(structure_position, close, te_history, te_bins, entropy_window) : 0.0
// Net causal flow
float net_causal_flow = te_vol_to_price + te_volatility_to_mom * 0.5 + te_struct_to_price
// Causal flow direction 
bool is_causal_bullish = net_causal_flow > 0.1
bool is_causal_bearish = net_causal_flow < -0.1
// Causal gate: is there clear causal support?
bool causal_gate_bull = te_vol_to_price > 0 and net_causal_flow > 0.05
bool causal_gate_bear = te_vol_to_price > 0 and net_causal_flow < -0.05
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIMENSIONAL RESONANCE CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Calculate dimensional alignment
float dim_alignment = 0.0
float weight_sum = 0.0
// Momentum dimension contribution
float mom_score = norm_momentum > 0 ? math.min(norm_momentum, 3) / 3 : math.max(norm_momentum, -3) / 3
dim_alignment += mom_score * 0.3
weight_sum += 0.3
// Volume dimension contribution
float vol_score = norm_volume > 0 ? math.min(norm_volume, 3) / 3 : 0
dim_alignment += vol_score * mom_score * 0.2  
weight_sum += 0.2
// Structure dimension contribution
float struct_score = norm_structure 
dim_alignment += struct_score * 0.25
weight_sum += 0.25
// Volatility expansion (confirming moves)
float vol_expansion = norm_volatility > 0.5 ? 0.5 : 0
dim_alignment += vol_expansion * math.sign(mom_score) * 0.15
weight_sum += 0.15
// Recurrence contribution (pattern repetition)
float recur_score = determinism > 0.5 ? 0.3 : -0.1
dim_alignment += recur_score * math.sign(mom_score) * 0.1
weight_sum += 0.1
float dimensional_resonance = dim_alignment / weight_sum
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EMERGENCE SCORE CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float emergence_score = 0.0
float emergence_direction = 0.0
// Component 1: Phase Coherence
float coherence_contribution = phase_coherence * 0.20
emergence_score += coherence_contribution
// Component 2: Entropy in predictable zone 
float entropy_contribution = perm_entropy < 0.6 ? (0.6 - perm_entropy) / 0.6 * 0.15 : 0
emergence_score += entropy_contribution
// Component 3: Lyapunov stability 
float lyap_contribution = is_stable ? 0.12 : is_critical ? 0.08 : 0
emergence_score += lyap_contribution
// Component 4: Fractal dimension trending 
float fd_contribution = fractal_dim < 1.45 ? (1.45 - fractal_dim) / 0.45 * 0.12 : 0
emergence_score += fd_contribution
// Component 5: Dimensional resonance 
float resonance_contribution = math.abs(dimensional_resonance) * 0.12
emergence_score += resonance_contribution
emergence_direction := dimensional_resonance
// Component 6: Causal flow strength
float causal_contribution = math.abs(net_causal_flow) * 0.09
emergence_score += causal_contribution
if net_causal_flow > 0
    emergence_direction += 0.2
else if net_causal_flow < 0
    emergence_direction -= 0.2
// Component 7: Phase Space Embedding
float phase_space_contribution = 0.0
if math.abs(phase_magnitude_norm) > 1.0
    phase_space_contribution := math.min(math.abs(phase_magnitude_norm), 3.0) / 3.0 * 0.10
    if phase_magnitude_norm > 0 and norm_momentum > 0
        emergence_direction += 0.15
    else if phase_magnitude_norm < 0 and norm_momentum < 0
        emergence_direction -= 0.15
emergence_score += phase_space_contribution
// Component 8: Recurrence Quality 
float recurrence_contribution = 0.0
if determinism > 0.3 and recurrence > 0.1 and recurrence < 0.8
    recurrence_contribution := determinism * 0.10
emergence_score += recurrence_contribution
emergence_score := math.min(1.0, emergence_score)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL TRACKING 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var int total_signals = 0
var int emergence_signals = 0
var int resonance_signals = 0
var int last_signal_bar = -999  
int bars_since_signal = bar_index - last_signal_bar
bool cooldown_ok = bars_since_signal >= signal_cooldown
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL GENERATION 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool high_coherence = phase_coherence >= coherence_threshold
bool emergence_active = emergence_score >= emergence_threshold
bool direction_bullish = emergence_direction > 0.2
bool direction_bearish = emergence_direction < -0.2
// Gate conditions
bool causal_ok = require_causal_gate ? (direction_bullish ? causal_gate_bull : direction_bearish ? causal_gate_bear : false) : true
bool stability_ok = require_stability ? (is_stable or is_critical) : true
// Price confirmation
bool price_confirms_bull = close > open
bool price_confirms_bear = close < open
// Signal quality
float signal_quality = emergence_score * phase_coherence
bool premium_signal = signal_quality > 0.7
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RAW CONDITIONS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool raw_emergence_buy = emergence_active and direction_bullish and high_coherence and 
                         causal_ok and stability_ok and price_confirms_bull
bool raw_emergence_sell = emergence_active and direction_bearish and high_coherence and 
                          causal_ok and stability_ok and price_confirms_bear
bool raw_resonance_buy = not raw_emergence_buy and dimensional_resonance > 0.6 and 
                         fractal_dim < 1.5 and price_confirms_bull and not is_chaotic
bool raw_resonance_sell = not raw_emergence_sell and dimensional_resonance < -0.6 and 
                          fractal_dim < 1.5 and price_confirms_bear and not is_chaotic
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FINAL SIGNALS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool emergence_buy = raw_emergence_buy and cooldown_ok
bool emergence_sell = raw_emergence_sell and cooldown_ok and not emergence_buy
bool resonance_buy = raw_resonance_buy and cooldown_ok and not emergence_buy and not emergence_sell
bool resonance_sell = raw_resonance_sell and cooldown_ok and not emergence_buy and not emergence_sell and not resonance_buy
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UPDATE TRACKING 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool any_signal = emergence_buy or emergence_sell or resonance_buy or resonance_sell
if any_signal
    last_signal_bar := bar_index
if emergence_buy or emergence_sell
    total_signals += 1
    emergence_signals += 1
if resonance_buy or resonance_sell
    total_signals += 1
    resonance_signals += 1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VISUALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Coherence field background
float coherence_intensity = phase_coherence > 0.5 ? (phase_coherence - 0.5) * 2 : 0
color coherence_color = coherence_direction > 0 ? c_emergence_bull : coherence_direction < 0 ? c_emergence_bear : c_coherence
int coherence_trans = int(98 - coherence_intensity * 10)
bgcolor(show_coherence_field and phase_coherence > 0.5 ? color.new(coherence_color, coherence_trans) : na, title="Coherence Field")
// Stability/Chaos zones
color stability_color = is_stable ? c_stable : is_critical ? c_gold : c_chaos
int stability_trans = is_stable ? 95 : is_critical ? 90 : 85
bgcolor(show_stability_zones ? color.new(stability_color, stability_trans) : na, title="Stability Zone")
// Emergence flash
bgcolor(show_emergence_flash and emergence_buy ? color.new(c_emergence_bull, 80) : na, title="Emergence Bull Flash")
bgcolor(show_emergence_flash and emergence_sell ? color.new(c_emergence_bear, 80) : na, title="Emergence Bear Flash")
// Dimension ribbons
plot(show_dimension_ribbons ? ta.ema(close, 8) : na, "Dim 1 (Fast)", color=color.new(c_emergence_bull, 60), linewidth=1)
plot(show_dimension_ribbons ? ta.ema(close, 21) : na, "Dim 2 (Med)", color=color.new(c_coherence, 60), linewidth=1)
plot(show_dimension_ribbons ? ta.ema(close, 55) : na, "Dim 3 (Slow)", color=color.new(c_emergence_bear, 60), linewidth=1)
// Causal flow visualization
float flow_plot = show_causal_flow ? ta.ema(close, 13) : na
color flow_color = net_causal_flow > 0.1 ? c_emergence_bull : 
                   net_causal_flow < -0.1 ? c_emergence_bear : c_neutral
plot(flow_plot, "Causal Flow", color=flow_color, linewidth=2, style=plot.style_line)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL MARKERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
plotshape(emergence_buy and premium_signal, "â˜… Premium Buy", 
     shape.labelup, location.belowbar, c_emergence_bull, 
     text="â˜…", textcolor=color.black, size=size.tiny)
plotshape(emergence_sell and premium_signal, "â˜… Premium Sell", 
     shape.labeldown, location.abovebar, c_emergence_bear, 
     text="â˜…", textcolor=color.white, size=size.tiny)
plotshape(emergence_buy and not premium_signal, "â—† Emergence Buy", 
     shape.diamond, location.belowbar, c_emergence_bull, 
     size=size.tiny)
plotshape(emergence_sell and not premium_signal, "â—† Emergence Sell", 
     shape.diamond, location.abovebar, c_emergence_bear, 
     size=size.tiny)
plotshape(resonance_buy, "â–² Resonance Buy", 
     shape.triangleup, location.belowbar, 
     color.new(c_emergence_bull, 30), size=size.tiny)
plotshape(resonance_sell, "â–¼ Resonance Sell", 
     shape.triangledown, location.abovebar, 
     color.new(c_emergence_bear, 30), size=size.tiny)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table dash = table.new(
     dashboard_position == "Top Left" ? position.top_left : 
     dashboard_position == "Top Right" ? position.top_right : 
     dashboard_position == "Bottom Left" ? position.bottom_left : position.bottom_right,
     4, 20, bgcolor=color.new(c_dashboard_bg, 5), 
     frame_color=color.new(c_gold, 50), frame_width=1,
     border_color=color.new(c_gold, 80), border_width=1)
string txt_size = dashboard_size == "Tiny" ? size.tiny : 
                  dashboard_size == "Small" ? size.small : size.normal
if barstate.islast and show_dashboard
    int row = 0
    table.cell(dash, 0, row, "ğŸŒ€", text_color=c_gold, text_size=txt_size)
    table.cell(dash, 1, row, "Dimensional Resonance Protocol", text_color=c_gold, text_size=txt_size)
    table.cell(dash, 2, row, "DRP", text_color=c_gold, text_size=txt_size)
    table.cell(dash, 3, row, "", text_size=size.tiny)
    row += 1
    table.cell(dash, 0, row, "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", text_color=color.new(c_gold, 60), text_size=size.tiny)
    table.merge_cells(dash, 0, row, 3, row)
    row += 1
    table.cell(dash, 0, row, "EMERGENCE", text_color=color.gray, text_size=txt_size)
    string emerg_bar = ""
    for i = 0 to 9
        emerg_bar += i < emergence_score * 10 ? "â–ˆ" : "â–‘"
    color emerg_color = emergence_score > 0.75 ? c_emergence_bull : emergence_score > 0.5 ? c_gold : color.gray
    table.cell(dash, 1, row, emerg_bar, text_color=emerg_color, text_size=size.tiny)
    table.cell(dash, 2, row, str.tostring(emergence_score * 100, "#") + "%", text_color=emerg_color, text_size=txt_size)
    table.cell(dash, 3, row, emergence_direction > 0 ? "â†—" : emergence_direction < 0 ? "â†˜" : "â†’", 
         text_color=emergence_direction > 0 ? c_emergence_bull : emergence_direction < 0 ? c_emergence_bear : color.gray, 
         text_size=txt_size)
    row += 1
    table.cell(dash, 0, row, "COHERENCE", text_color=color.gray, text_size=txt_size)
    string coh_bar = ""
    for i = 0 to 9
        coh_bar += i < phase_coherence * 10 ? "â–ˆ" : "â–‘"
    color coh_color = phase_coherence >= coherence_threshold ? c_coherence : color.gray
    table.cell(dash, 1, row, coh_bar, text_color=coh_color, text_size=size.tiny)
    table.cell(dash, 2, row, str.tostring(phase_coherence * 100, "#") + "%", text_color=coh_color, text_size=txt_size)
    table.cell(dash, 3, row, phase_coherence >= coherence_threshold ? "âœ“" : "â—‹", text_color=coh_color, text_size=txt_size)
    row += 1
    table.cell(dash, 0, row, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.new(color.gray, 60), text_size=size.tiny)
    table.merge_cells(dash, 0, row, 3, row)
    row += 1
    table.cell(dash, 0, row, "ENTROPY", text_color=color.gray, text_size=txt_size)
    color ent_color = entropy_regime <= 1 ? c_stable : entropy_regime <= 2 ? c_gold : c_chaos
    table.cell(dash, 1, row, entropy_regime_name, text_color=ent_color, text_size=txt_size)
    table.cell(dash, 2, row, str.tostring(perm_entropy, "#.##"), text_color=ent_color, text_size=txt_size)
    table.cell(dash, 3, row, "", text_size=size.tiny)
    row += 1
    table.cell(dash, 0, row, "LYAPUNOV", text_color=color.gray, text_size=txt_size)
    color lyap_color = is_stable ? c_stable : is_critical ? c_gold : c_chaos
    table.cell(dash, 1, row, stability_state, text_color=lyap_color, text_size=txt_size)
    table.cell(dash, 2, row, str.tostring(lyapunov, "#.###"), text_color=lyap_color, text_size=txt_size)
    table.cell(dash, 3, row, is_stable ? "â—" : is_critical ? "â—" : "â—‹", text_color=lyap_color, text_size=txt_size)
    row += 1
    table.cell(dash, 0, row, "FRACTAL", text_color=color.gray, text_size=txt_size)
    color fd_color = fractal_dim < 1.45 ? c_emergence_bull : fractal_dim < 1.55 ? c_gold : c_emergence_bear
    table.cell(dash, 1, row, fractal_regime, text_color=fd_color, text_size=txt_size)
    table.cell(dash, 2, row, str.tostring(fractal_dim, "#.##"), text_color=fd_color, text_size=txt_size)
    table.cell(dash, 3, row, "", text_size=size.tiny)
    row += 1
    table.cell(dash, 0, row, "PHASE-SPACE", text_color=color.gray, text_size=txt_size)
    color ps_color = math.abs(phase_magnitude_norm) > 2 ? c_emergence_bull : 
                     math.abs(phase_magnitude_norm) > 1 ? c_gold : color.gray
    string ps_state = math.abs(phase_magnitude_norm) > 2 ? "STRONG" :
                      math.abs(phase_magnitude_norm) > 1 ? "ACTIVE" : "QUIET"
    table.cell(dash, 1, row, ps_state, text_color=ps_color, text_size=txt_size)
    table.cell(dash, 2, row, str.tostring(phase_magnitude_norm, "#.##"), text_color=ps_color, text_size=txt_size)
    table.cell(dash, 3, row, "d=" + str.tostring(embedding_dimension) + " Ï„=" + str.tostring(time_delay), 
         text_color=color.gray, text_size=size.tiny)
    row += 1    
    table.cell(dash, 0, row, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.new(color.gray, 60), text_size=size.tiny)
    table.merge_cells(dash, 0, row, 3, row)
    row += 1
    table.cell(dash, 0, row, "CAUSAL", text_color=color.gray, text_size=txt_size)
    color te_color = net_causal_flow > 0.1 ? c_emergence_bull : net_causal_flow < -0.1 ? c_emergence_bear : color.gray
    string te_dir = net_causal_flow > 0.1 ? "BULL" : net_causal_flow < -0.1 ? "BEAR" : "NEUTRAL"
    table.cell(dash, 1, row, te_dir, text_color=te_color, text_size=txt_size)
    table.cell(dash, 2, row, str.tostring(net_causal_flow, "#.###"), text_color=te_color, text_size=txt_size)
    table.cell(dash, 3, row, net_causal_flow > 0.1 ? "â†’P" : net_causal_flow < -0.1 ? "Pâ†" : "â—‹", text_color=te_color, text_size=txt_size)
    row += 1
    table.cell(dash, 0, row, "Vâ†’P", text_color=color.gray, text_size=size.tiny)
    table.cell(dash, 1, row, str.tostring(te_vol_to_price, "#.###"), text_color=te_vol_to_price > 0 ? c_stable : c_chaos, text_size=size.tiny)
    table.cell(dash, 2, row, "", text_size=size.tiny)
    table.cell(dash, 3, row, "", text_size=size.tiny)
    row += 1
    table.cell(dash, 0, row, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.new(color.gray, 60), text_size=size.tiny)
    table.merge_cells(dash, 0, row, 3, row)
    row += 1
    table.cell(dash, 0, row, "RESONANCE", text_color=color.gray, text_size=txt_size)
    string res_bar = ""
    float abs_res = math.abs(dimensional_resonance)
    for i = 0 to 9
        res_bar += i < abs_res * 10 ? "â–ˆ" : "â–‘"
    color res_color = dimensional_resonance > 0.3 ? c_emergence_bull : 
                      dimensional_resonance < -0.3 ? c_emergence_bear : color.gray
    table.cell(dash, 1, row, res_bar, text_color=res_color, text_size=size.tiny)
    table.cell(dash, 2, row, str.tostring(dimensional_resonance, "#.##"), text_color=res_color, text_size=txt_size)
    table.cell(dash, 3, row, "", text_size=size.tiny)
    row += 1
    table.cell(dash, 0, row, "RECURRENCE", text_color=color.gray, text_size=txt_size)
    table.cell(dash, 1, row, str.tostring(recurrence * 100, "#") + "%", text_color=recurrence > 0.3 ? c_stable : color.gray, text_size=txt_size)
    table.cell(dash, 2, row, "DET: " + str.tostring(determinism * 100, "#") + "%", text_color=determinism > 0.5 ? c_stable : color.gray, text_size=size.tiny)
    table.cell(dash, 3, row, "", text_size=size.tiny)
    row += 1
    table.cell(dash, 0, row, "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", text_color=color.new(c_gold, 60), text_size=size.tiny)
    table.merge_cells(dash, 0, row, 3, row)
    row += 1
    string state = emergence_buy or emergence_sell ? "EMERGENCE" : 
                   resonance_buy or resonance_sell ? "RESONANCE" : 
                   is_chaotic ? "CHAOS" : "SCANNING"
    color state_color = emergence_buy or resonance_buy ? c_emergence_bull : emergence_sell or resonance_sell ? c_emergence_bear : is_chaotic ? c_chaos : color.gray
    string state_icon = emergence_buy ? "ğŸš€" : emergence_sell ? "ğŸ’«" : resonance_buy ? "â–²" : resonance_sell ? "â–¼" : is_chaotic ? "âš " : "â—"
    table.cell(dash, 0, row, "STATE", text_color=color.gray, text_size=txt_size)
    table.cell(dash, 1, row, state_icon, text_color=state_color, text_size=txt_size)
    table.cell(dash, 2, row, state, text_color=state_color, text_size=txt_size)
    table.cell(dash, 3, row, "", text_size=size.tiny)
    row += 1
    table.cell(dash, 0, row, "SIGNALS", text_color=color.gray, text_size=size.tiny)
    table.cell(dash, 1, row, "E:" + str.tostring(emergence_signals), text_color=c_gold, text_size=size.tiny)
    table.cell(dash, 2, row, "R:" + str.tostring(resonance_signals), text_color=c_coherence, text_size=size.tiny)
    table.cell(dash, 3, row, "", text_size=size.tiny)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(emergence_buy and premium_signal, "â˜… Premium Emergence BUY", "â˜… EMERGENCE BUY\n{{ticker}} @ {{close}}")
alertcondition(emergence_sell and premium_signal, "â˜… Premium Emergence SELL", "â˜… EMERGENCE SELL\n{{ticker}} @ {{close}}")
alertcondition(emergence_buy and not premium_signal, "â—† Emergence BUY", "â—† EMERGENCE BUY\n{{ticker}} @ {{close}}")
alertcondition(emergence_sell and not premium_signal, "â—† Emergence SELL", "â—† EMERGENCE SELL\n{{ticker}} @ {{close}}")
alertcondition(resonance_buy, "â–² Resonance BUY", "â–² RESONANCE BUY\n{{ticker}} @ {{close}}")
alertcondition(resonance_sell, "â–¼ Resonance SELL", "â–¼ RESONANCE SELL\n{{ticker}} @ {{close}}")
alertcondition(is_chaotic and not is_chaotic[1], "âš  Chaos Warning", "âš   Market entering chaotic regime\n{{ticker}}")
if emergence_buy and premium_signal
    alert("â˜… EMERGENCE BUY | " + syminfo.ticker + " @ " + str.tostring(close) + 
         " | Coherence: " + str.tostring(phase_coherence * 100, "#") + "%" +
         " | Emergence: " + str.tostring(emergence_score * 100, "#") + "%", alert.freq_once_per_bar)
if emergence_sell and premium_signal
    alert("â˜… EMERGENCE SELL | " + syminfo.ticker + " @ " + str.tostring(close) + 
         " | Coherence: " + str.tostring(phase_coherence * 100, "#") + "%" +
         " | Emergence: " + str.tostring(emergence_score * 100, "#") + "%", alert.freq_once_per_bar)
