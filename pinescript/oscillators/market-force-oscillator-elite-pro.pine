//@version=6
// -----------------------------------------------------------------------------
//  Market Force Oscillator - Elite Pro **v4.6**
//  Key improvements vs v4.5
//    1) Added multi-method cycle detection matching NewMapForTraders R20:
//       - Zero-Crossing: measures actual price oscillation period
//       - Peak-to-Peak: measures swing high/low intervals
//       - Autocorrelation: correlation-based period detection
//       - Composite: weighted average of all methods (recommended)
//    2) Enhanced debug table shows all cycle methods
//    3) Composite mode gracefully handles when individual methods fail
// -----------------------------------------------------------------------------
indicator('Market Force Oscillator Elite Pro v4.6', overlay = false, max_labels_count = 50)

// ---------- CONSTANTS ----------
int SECS_PER_DAY = 86400
int SECS_PER_YEAR = 31536000
float SAFE_EPS = 1e-6
float PRICE_EPS = math.max(syminfo.mintick, 1e-12)
float TWO_PI = 4 * math.asin(1) // 2π ≈ 6.283

// ---------- PRESET SELECTOR ----------
profile = input.string('Balanced', 'Preset', options = ['Conservative', 'Balanced', 'Aggressive'], tooltip = 'If preset != Balanced, only base cycle length and signal threshold are overridden.')

// ---------- BASE INPUTS ----------
string inp_group_main = 'Main Settings'
inp_length = input.int(14, 'Base Cycle Length', minval = 1, group = inp_group_main, tooltip = 'Used when Cycle Detector Mode = Off, and as fallback length for fixed-length calculations.')
inp_sig_thresh = input.float(1.0, 'Signal quality threshold', group = inp_group_main)
vol_length = input.int(14, 'Volume MA length', minval = 1, group = inp_group_main)
ob_level = input.float(1.5, 'Overbought level (z-score)', group = inp_group_main, tooltip = 'Since oscillator is z-normalized, typical range is +/-2-3. Default 1.5 = moderately overbought.')
os_level = input.float(-1.5, 'Oversold level (z-score)', group = inp_group_main, tooltip = 'Mirror of overbought. Default -1.5 = moderately oversold.')

osc_mode = input.string('Exhaustion (accel - force)', 'Oscillator mode', options = ['Exhaustion (accel - force)', 'Momentum (accel + force)'], group = inp_group_main)

higher_tf = input.timeframe('240', 'Higher-timeframe for trend', group = inp_group_main)
show_signals = input.bool(true, 'Show signal markers', group = inp_group_main)
show_divs = input.bool(true, 'Show divergence markers', group = inp_group_main)
show_bands = input.bool(true, 'Show OB/OS fill bands', group = inp_group_main)

// ---------- CYCLE DETECTOR ----------
string inp_group_cycle = 'Cycle Detector'
cycle_mode = input.string('Off', 'Cycle Detector Mode', options = ['Off', 'Original Ehlers', 'Zero-Crossing', 'Peak-to-Peak', 'Autocorrelation', 'Composite'], group = inp_group_cycle, tooltip = 'Composite averages all methods, down-weighting those at boundaries. Recommended for robustness.')
cycle_src = input.source(close, 'Cycle Source', group = inp_group_cycle)
cycle_src_smooth_len = input.int(0, 'Cycle Source Smooth (EMA)', minval = 0, maxval = 100, group = inp_group_cycle, tooltip = '0 = off. Applies EMA smoothing before cycle detection.')
ehlers_lim = input.int(100, 'Search Limit (bars)', minval = 20, maxval = 200, group = inp_group_cycle, tooltip = 'How far back to search for a full cycle. Higher = can detect longer cycles.')
ehlers_alpha = input.float(0.25, 'Ehlers Smoothing Alpha', minval = 0.05, maxval = 0.9, step = 0.05, group = inp_group_cycle, tooltip = 'Lower = smoother cycle estimate. 0.25 is typical.')
ehlers_min = input.int(6, 'Min Period', minval = 2, maxval = 20, group = inp_group_cycle)
ehlers_max = input.int(100, 'Max Period', minval = 30, maxval = 200, group = inp_group_cycle)
show_cycle = input.bool(false, 'Show Detected Cycle (data window)', group = inp_group_cycle)
smooth_cycle = input.bool(true, 'Smooth Cycle Length (RMA)', group = inp_group_cycle)
smooth_cycle_len = input.int(3, 'Cycle Smoothing Period', minval = 1, maxval = 20, group = inp_group_cycle)
show_debug_table = input.bool(false, 'Show Debug Table', group = inp_group_cycle)

// Alternative Cycle Method Settings
string inp_group_alt = 'Alternative Cycle Methods'
zc_smooth_len = input.int(5, 'Zero-Crossing Smooth Length', minval = 1, maxval = 20, group = inp_group_alt, tooltip = 'Smoothing for price before zero-crossing detection.')
pp_swing_pct = input.float(0.02, 'Peak-to-Peak Swing %', minval = 0.005, maxval = 0.1, step = 0.005, group = inp_group_alt, tooltip = 'Minimum % move to qualify as swing high/low.')
autocorr_max_lag = input.int(80, 'Autocorr Max Lag', minval = 20, maxval = 150, group = inp_group_alt)
autocorr_min_lag = input.int(4, 'Autocorr Min Lag', minval = 2, maxval = 20, group = inp_group_alt)
autocorr_window = input.int(50, 'Autocorr Window', minval = 20, maxval = 200, group = inp_group_alt)

// ---------- ADVANCED ----------
string inp_group_adv = 'Advanced Settings'
show_adv = input.bool(false, 'Show advanced settings', group = inp_group_adv)

enable_vp = show_adv ? input.bool(true, 'Enable volume profile weighting', group = inp_group_adv) : true
vp_len = show_adv ? input.int(20, 'VP length', minval = 1, group = inp_group_adv) : 20
vp_thresh = show_adv ? input.float(1.5, 'VP signif. thresh', step = 0.1, group = inp_group_adv) : 1.5
vp_ramp = show_adv ? input.float(1.0, 'VP thresh ramp', step = 0.1, minval = 0.0, tooltip = 'Soft ramp above threshold. 0 = hard cutoff.', group = inp_group_adv) : 1.0

momentum_factor = show_adv ? input.float(1.0, 'Momentum factor', step = 0.1, group = inp_group_adv) : 1.0
pivot_lookback = show_adv ? input.int(5, 'Pivot look-back', minval = 2, group = inp_group_adv) : 5
early_div = show_adv ? input.bool(false, 'Early divergence (half look-back)', group = inp_group_adv) : false
rel_vol_cap_max = show_adv ? input.float(10.0, 'Max rel-volume cap', step = 0.5, tooltip = 'Signal quality x cap; raise for high-liquidity assets', group = inp_group_adv) : 10.0
use_log_vol_cap = show_adv ? input.bool(false, 'Log scale volume contribution', group = inp_group_adv) : false
smooth_sig_qual = show_adv ? input.bool(false, 'Smooth signal quality (EMA)', group = inp_group_adv) : false
sig_qual_smooth_len = show_adv ? input.int(3, 'Signal quality smooth length', minval = 1, group = inp_group_adv) : 3
band_transp = show_adv ? input.int(90, 'OB/OS band transparency', 0, 100, group = inp_group_adv) : 90
bg_transp = show_adv ? input.int(92, 'Heat-map transparency', 0, 100, group = inp_group_adv) : 92
signal_cooldown = show_adv ? input.int(5, 'Signal cooldown (bars)', minval = 0, tooltip = 'Minimum bars between signals of the same type.', group = inp_group_adv) : 5
div_cooldown = show_adv ? input.int(5, 'Divergence cooldown (bars)', minval = 0, tooltip = 'Minimum bars between divergence signals.', group = inp_group_adv) : 5
div_filter_mode = show_adv ? input.string('Both', 'Divergence filter mode', options = ['One-shot', 'Cooldown', 'Both'], group = inp_group_adv, tooltip = 'One-shot: fire only on first detection. Cooldown: enforce minimum bars. Both: combine.') : 'Both'
use_trend_filter = show_adv ? input.bool(true, 'Require trend alignment', group = inp_group_adv, tooltip = 'If off, signals ignore HTF/LTF alignment.') : true
align_in_quality = show_adv ? input.bool(true, 'Use alignment in signal quality', group = inp_group_adv, tooltip = 'If off, signal quality ignores trend alignment.') : true
strict_na_guard = show_adv ? input.bool(true, 'Strict NA/zero guards', tooltip = 'Defensive guards against NA/zero values in early bars.', group = inp_group_adv) : true

// ---------- VOLATILITY ALERT ----------
string inp_group_vol = 'Volatility Alert'
hist_vol_lookback = show_adv ? input.int(30, 'Historical vol look-back', minval = 10, group = inp_group_vol) : 30
vol_alert_threshold_pct = show_adv ? input.float(50.0, 'Volatility alert (%)', group = inp_group_vol) : 50.0

// ---------- PRESET OVERRIDES ----------
base_length = profile == 'Conservative' ? 21 : profile == 'Aggressive' ? 10 : inp_length
sig_thresh = profile == 'Conservative' ? 1.2 : profile == 'Aggressive' ? 0.8 : inp_sig_thresh

// ---------- AUTO ATR CALIBRATION (timeframe-aware) ----------
float tf_sec = timeframe.in_seconds()
float tf_sec_safe = na(tf_sec) or tf_sec <= 0 ? float(SECS_PER_DAY) : tf_sec

float atr_mult_auto = tf_sec_safe <= 3600 ? 1.00 :
                      tf_sec_safe <= 4 * 3600 ? 0.85 :
                      tf_sec_safe <= 12 * 3600 ? 0.70 :
                      tf_sec_safe <= 24 * 3600 ? 0.55 :
                      tf_sec_safe <= 72 * 3600 ? 0.45 :
                      0.35

float dyn_atr_scale_auto = tf_sec_safe <= 3600 ? 0.30 :
                           tf_sec_safe <= 4 * 3600 ? 0.26 :
                           tf_sec_safe <= 12 * 3600 ? 0.22 :
                           tf_sec_safe <= 24 * 3600 ? 0.18 :
                           tf_sec_safe <= 72 * 3600 ? 0.14 :
                           0.12

int atr_len_auto = tf_sec_safe <= 4 * 3600 ? inp_length :
                   tf_sec_safe <= 12 * 3600 ? math.max(inp_length, 18) :
                   tf_sec_safe <= 24 * 3600 ? math.max(inp_length, 21) :
                   tf_sec_safe <= 72 * 3600 ? math.max(inp_length, 28) :
                   math.max(inp_length, 34)

// Soft cap ATR% by timeframe so higher-timeframe bands don't get excessively wide on high-vol assets.
float atr_pct_ref = tf_sec_safe <= 3600 ? 50.0 :
                     tf_sec_safe <= 24 * 3600 ? 35.0 :
                     tf_sec_safe <= 72 * 3600 ? 25.0 :
                     tf_sec_safe <= 14 * SECS_PER_DAY ? 14.0 :
                     10.0

// ---------- UTIL ----------
clamp(x, lo, hi) =>
    math.max(math.min(x, hi), lo)

nz_lag(src, n, fallback) =>
    n > 0 and bar_index >= n ? nz(src[n], fallback) : fallback

// =============================================================================
// CYCLE DETECTION METHOD 1: ORIGINAL EHLERS (Cumulative Phase Summation)
// =============================================================================

ehlers_dominant_cycle_fixed(src, lim, smooth_alpha, min_per, max_per) =>
    float val1 = src - nz(src[7])

    var float in_phase = 0.0
    in_phase := 1.25 * (nz(val1[4]) - 0.635 * nz(val1[2])) + 0.635 * nz(in_phase[3])

    var float quadrature = 0.0
    quadrature := nz(val1[2]) - 0.338 * val1 + 0.338 * nz(quadrature[2])

    var float real = 0.0
    real := 0.2 * (in_phase * nz(in_phase[1]) + quadrature * nz(quadrature[1])) + 0.8 * nz(real[1])

    var float imag = 0.0
    imag := 0.2 * (in_phase * nz(quadrature[1]) - nz(in_phase[1]) * quadrature) + 0.8 * nz(imag[1])

    float delta_phase = real != 0.0 ? math.atan(imag / real) : 0.0

    float inst_per = 0.0
    float val2 = 0.0

    for i = 0 to lim by 1
        val2 := val2 + (na(delta_phase[i]) ? delta_phase : nz(delta_phase[i]))
        if val2 > TWO_PI and inst_per == 0.0
            inst_per := float(i)
            break

    var float inst_per_prev = float(min_per + max_per) / 2
    if inst_per == 0.0
        inst_per := inst_per_prev
        inst_per
    inst_per_prev := inst_per

    inst_per := math.max(min_per, math.min(inst_per, max_per))

    var float dom_cycle = na
    dom_cycle := na(dom_cycle[1]) ? inst_per : smooth_alpha * inst_per + (1 - smooth_alpha) * nz(dom_cycle[1], inst_per)
    dom_cycle := clamp(dom_cycle, min_per, max_per)

    [dom_cycle, inst_per, delta_phase]

// =============================================================================
// CYCLE DETECTION METHOD 2: ZERO-CROSSING
// =============================================================================

zero_crossing_cycle(src, smooth_len, min_per, max_per) =>
    float ma = ta.sma(src, smooth_len * 3)
    float detrended = src - ma
    float smoothed = ta.sma(detrended, smooth_len)

    bool cross_up = ta.crossover(smoothed, 0)
    bool cross_down = ta.crossunder(smoothed, 0)
    bool any_cross = cross_up or cross_down

    var int bars_since_cross = 0
    var int last_half_period = 20

    if any_cross
        if bars_since_cross >= min_per / 2 and bars_since_cross <= max_per
            last_half_period := bars_since_cross
            last_half_period
        bars_since_cross := 0
        bars_since_cross
    else
        bars_since_cross := bars_since_cross + 1
        bars_since_cross

    float period = math.max(min_per, math.min(float(last_half_period) * 2, max_per))
    period

// =============================================================================
// CYCLE DETECTION METHOD 3: PEAK-TO-PEAK
// =============================================================================

peak_to_peak_cycle(src, swing_pct, min_per, max_per) =>
    var float last_swing_high = src
    var float last_swing_low = src
    var int bars_since_high = 0
    var int bars_since_low = 0
    var int last_high_to_high = 40
    var int last_low_to_low = 40

    float threshold = src * swing_pct

    bool new_high = src > last_swing_high + threshold
    bool new_low = src < last_swing_low - threshold

    if new_high
        if bars_since_high >= min_per and bars_since_high <= max_per
            last_high_to_high := bars_since_high
            last_high_to_high
        last_swing_high := src
        bars_since_high := 0
        bars_since_high
    else
        bars_since_high := bars_since_high + 1
        if bars_since_high > max_per
            last_swing_high := math.max(last_swing_high, src)
            last_swing_high

    if new_low
        if bars_since_low >= min_per and bars_since_low <= max_per
            last_low_to_low := bars_since_low
            last_low_to_low
        last_swing_low := src
        bars_since_low := 0
        bars_since_low
    else
        bars_since_low := bars_since_low + 1
        if bars_since_low > max_per
            last_swing_low := math.min(last_swing_low, src)
            last_swing_low

    float period = (float(last_high_to_high) + float(last_low_to_low)) / 2
    math.max(min_per, math.min(period, max_per))

// =============================================================================
// CYCLE DETECTION METHOD 4: AUTOCORRELATION
// =============================================================================

autocorr_cycle_v2(src, min_lag, max_lag, window) =>
    float best_corr = 0.0
    int best_lag = (min_lag + max_lag) / 2

    float ret = ta.change(src)

    for lag = min_lag to max_lag by 1
        if bar_index > lag + window
            float sum_x = 0.0
            float sum_y = 0.0
            float sum_xy = 0.0
            float sum_x2 = 0.0
            float sum_y2 = 0.0
            int n = 0

            for i = 0 to window - 1 by 1
                float x = nz(ret[i], 0)
                float y = nz(ret[i + lag], 0)
                sum_x := sum_x + x
                sum_y := sum_y + y
                sum_xy := sum_xy + x * y
                sum_x2 := sum_x2 + x * x
                sum_y2 := sum_y2 + y * y
                n := n + 1
                n

            if n > 10
                float mean_x = sum_x / n
                float mean_y = sum_y / n
                float cov = sum_xy / n - mean_x * mean_y
                float var_x = sum_x2 / n - mean_x * mean_x
                float var_y = sum_y2 / n - mean_y * mean_y
                float denom = math.sqrt(math.max(var_x * var_y, SAFE_EPS))
                float corr = cov / denom

                if corr > best_corr
                    best_corr := corr
                    best_lag := lag
                    best_lag

    [float(best_lag), best_corr]

// =============================================================================
// CALCULATE ALL CYCLE METHODS
// =============================================================================

int c_min = math.max(ehlers_min, 4)
int c_max = math.min(ehlers_max, 200)

// Prepare source
float cycle_src_sm = cycle_src_smooth_len > 0 ? ta.ema(cycle_src, cycle_src_smooth_len) : cycle_src

// Calculate all methods (always, for debug table)
[ehlers_cycle, ehlers_raw, ehlers_delta] = ehlers_dominant_cycle_fixed(cycle_src_sm, ehlers_lim, ehlers_alpha, c_min, c_max)
float zc_cycle = zero_crossing_cycle(cycle_src_sm, zc_smooth_len, c_min, c_max)
float pp_cycle = peak_to_peak_cycle(cycle_src_sm, pp_swing_pct, c_min, c_max)
[ac_cycle, ac_strength] = autocorr_cycle_v2(cycle_src_sm, autocorr_min_lag, autocorr_max_lag, autocorr_window)

// Composite: weighted average of all methods
// Weight by how "reasonable" each seems (not at min/max boundaries)
float eh_weight = ehlers_cycle > c_min + 2 and ehlers_cycle < c_max - 2 ? 1.5 : 0.5 // Favor Ehlers when valid
float zc_weight = zc_cycle > c_min + 2 and zc_cycle < c_max - 2 ? 1.0 : 0.3
float pp_weight = pp_cycle > c_min + 2 and pp_cycle < c_max - 2 ? 1.0 : 0.3
float ac_weight = ac_strength > 0.1 ? 1.0 : 0.3

float total_weight = eh_weight + zc_weight + pp_weight + ac_weight
float composite_cycle = (ehlers_cycle * eh_weight + zc_cycle * zc_weight + pp_cycle * pp_weight + ac_cycle * ac_weight) / total_weight

// Select based on mode
float detected_cycle = switch cycle_mode
    'Original Ehlers' => ehlers_cycle
    'Zero-Crossing' => zc_cycle
    'Peak-to-Peak' => pp_cycle
    'Autocorrelation' => ac_cycle
    'Composite' => composite_cycle
    => float(base_length)

// Effective length
float cycle_raw = cycle_mode != 'Off' ? detected_cycle : float(base_length)
int L_raw = math.max(3, int(math.round(cycle_raw)))
float L_smooth = smooth_cycle ? ta.rma(float(L_raw), smooth_cycle_len) : float(L_raw)
float length_display = math.max(3.0, nz(L_smooth, float(L_raw)))
int length = base_length // Pine built-ins require simple int lengths

// ---------- FORCE CALC ----------
calc_force() =>
    pr = math.max(high - low, PRICE_EPS)
    vpma = ta.sma(volume, vp_len)
    vpma_safe = math.max(nz(vpma, SAFE_EPS), SAFE_EPS)
    safe_vol = volume == 0 ? nz(volume[1], 1) : volume
    rv = enable_vp ? safe_vol / vpma_safe : 1.0
    float ramp = vp_ramp > 0 ? clamp((rv - vp_thresh) / vp_ramp, 0, 1) : rv >= vp_thresh ? 1 : 0
    vw = enable_vp ? 1 + ramp * math.log10(math.max(rv, 1.0)) : 1.0
    mom_raw = ta.roc(close, 1) / 100.0
    mom = clamp(mom_raw * momentum_factor, -0.05, 0.05)
    bp = safe_vol * ((close - low) / pr) * (1 + mom)
    sp = safe_vol * ((high - close) / pr) * (1 - mom)
    raw = (bp - sp) * vw
    smooth_len = int(math.round(math.max(1, length / 2)))
    force_ma = ta.ema(raw, smooth_len)
    mass = math.max(nz(ta.ema(safe_vol, vol_length), SAFE_EPS), SAFE_EPS)
    force_ma / mass

// ---------- OSCILLATOR ----------
force_val = calc_force()
accel = ta.change(ta.change(close))
osc_raw = osc_mode == 'Momentum (accel + force)' ? accel + force_val : accel - force_val
mean_osc = ta.sma(osc_raw, length)
float osc_std = ta.stdev(osc_raw, length)
float osc_mad = ta.sma(math.abs(osc_raw - mean_osc), length)
float osc_mad_sigma = osc_mad * 1.2533141373155001
bool osc_std_valid = not na(osc_std) and osc_std > 0
bool osc_mad_valid = not na(osc_mad_sigma) and osc_mad_sigma > 0
float osc_std_to_mad = osc_std_valid and osc_mad_valid ? osc_std / osc_mad_sigma : na
bool osc_std_outlier = osc_std_valid and osc_mad_valid and osc_std_to_mad > 20.0
float osc_scale = osc_std_outlier ? osc_mad_sigma : osc_std_valid ? osc_std : osc_mad_sigma
float osc_num = osc_raw - mean_osc
float osc_unclamped = not na(osc_scale) and osc_scale > 0 ? osc_num / osc_scale : na
osc = not na(osc_unclamped) ? clamp(osc_unclamped, -8.0, 8.0) : 0.0
osc_fix = barstate.isconfirmed ? osc : nz(osc[1])

// ---------- DYNAMIC LEVELS ----------
float close_safe = math.max(strict_na_guard ? nz(close, PRICE_EPS) : close, PRICE_EPS)
int atr_len = atr_len_auto
atr_pct = ta.atr(atr_len) / close_safe * 100
float atr_pct_eff = atr_pct / (1 + atr_pct / atr_pct_ref)
atr_factor = 1 + clamp(atr_pct_eff * dyn_atr_scale_auto * atr_mult_auto, 0, 2)
dyn_ob = ob_level * atr_factor
dyn_os = os_level * atr_factor

// ---------- TREND ALIGN ----------
ema_htf = request.security(syminfo.tickerid, higher_tf, ta.ema(close, length), lookahead = barmerge.lookahead_off)
flag_htf = close > ema_htf ? 1 : close < ema_htf ? -1 : 0
ema_ltf = ta.ema(close, length)
flag_ltf = close > ema_ltf ? 1 : close < ema_ltf ? -1 : 0
align = flag_htf == flag_ltf ? flag_ltf : 0
trend_ok_bull = not use_trend_filter or align > 0
trend_ok_bear = not use_trend_filter or align < 0
align_gate = align_in_quality and use_trend_filter ? math.abs(align) : 1.0

// ---------- SIGNAL QUALITY ----------
vol_sma = math.max(nz(ta.sma(volume, vol_length), SAFE_EPS), SAFE_EPS)
rv_cap = volume / vol_sma
vol_component = use_log_vol_cap ? math.max(0.0, math.log10(rv_cap + 1)) : math.min(rv_cap, rel_vol_cap_max)
sig_quality_raw = math.abs(osc_fix) * vol_component * align_gate
sig_quality = smooth_sig_qual ? ta.ema(sig_quality_raw, sig_qual_smooth_len) : sig_quality_raw
qual_pass = sig_quality > sig_thresh

var int last_bull_bar = na
var int last_bear_bar = na
bull_sig_raw = osc_fix > dyn_os and osc_fix[1] <= dyn_os and trend_ok_bull and qual_pass
bear_sig_raw = osc_fix < dyn_ob and osc_fix[1] >= dyn_ob and trend_ok_bear and qual_pass
bull_sig = bull_sig_raw and (signal_cooldown == 0 or na(last_bull_bar) or bar_index - last_bull_bar > signal_cooldown)
bear_sig = bear_sig_raw and (signal_cooldown == 0 or na(last_bear_bar) or bar_index - last_bear_bar > signal_cooldown)
if bull_sig
    last_bull_bar := bar_index
    last_bull_bar
if bear_sig
    last_bear_bar := bar_index
    last_bear_bar

// ---------- DIVERGENCE ----------
look = early_div ? math.max(1, int(pivot_lookback / 2)) : pivot_lookback
ph = ta.pivothigh(high, look, look)
pl = ta.pivotlow(low, look, look)
oph = ta.pivothigh(osc_fix, look, look)
opl = ta.pivotlow(osc_fix, look, look)

hi_last = ta.valuewhen(not na(ph), high, 0)
hi_prev = ta.valuewhen(not na(ph), high, 1)
osc_hi_l = ta.valuewhen(not na(oph), osc_fix, 0)
osc_hi_p = ta.valuewhen(not na(oph), osc_fix, 1)

lo_last = ta.valuewhen(not na(pl), low, 0)
lo_prev = ta.valuewhen(not na(pl), low, 1)
osc_lo_l = ta.valuewhen(not na(opl), osc_fix, 0)
osc_lo_p = ta.valuewhen(not na(opl), osc_fix, 1)

bear_div_raw = not na(hi_prev) and not na(osc_hi_p) and hi_last > hi_prev and osc_hi_l < osc_hi_p
bull_div_raw = not na(lo_prev) and not na(osc_lo_p) and lo_last < lo_prev and osc_lo_l > osc_lo_p

var int last_bull_div_bar = na
var int last_bear_div_bar = na
bull_div_prev = bar_index > 0 ? bull_div_raw[1] : false
bear_div_prev = bar_index > 0 ? bear_div_raw[1] : false
bull_div_os = bull_div_raw and not bull_div_prev
bear_div_os = bear_div_raw and not bear_div_prev
bull_div_cd = div_cooldown == 0 or na(last_bull_div_bar) or bar_index - last_bull_div_bar > div_cooldown
bear_div_cd = div_cooldown == 0 or na(last_bear_div_bar) or bar_index - last_bear_div_bar > div_cooldown

bull_div = div_filter_mode == 'One-shot' ? bull_div_os : div_filter_mode == 'Cooldown' ? bull_div_raw and bull_div_cd : bull_div_os and bull_div_cd
bear_div = div_filter_mode == 'One-shot' ? bear_div_os : div_filter_mode == 'Cooldown' ? bear_div_raw and bear_div_cd : bear_div_os and bear_div_cd

if bull_div
    last_bull_div_bar := bar_index
    last_bull_div_bar
if bear_div
    last_bear_div_bar := bar_index
    last_bear_div_bar

// ---------- PLOTS ----------
ob_plot = plot(show_bands ? dyn_ob : na, 'Dynamic OB', color = color.new(color.red, 0))
os_plot = plot(show_bands ? dyn_os : na, 'Dynamic OS', color = color.new(color.green, 0))
fill(ob_plot, os_plot, color = color.new(color.gray, band_transp))

plot(osc, 'Normalized oscillator', color = color.blue, linewidth = 2)
hline(0, 'Zero', color = color.gray)
plot(sig_quality, title = 'SigQuality', color = color.purple, display = display.data_window)
preset_code = profile == 'Conservative' ? 1 : profile == 'Aggressive' ? 2 : 0
plotchar(preset_code, title = 'Preset (0-Bal 1-Cons 2-Agg)', display = display.data_window)

// Show detected cycle in data window (optional)
plot(show_cycle ? detected_cycle : na, title = 'Detected Cycle', color = color.yellow, display = display.data_window)
plot(show_cycle ? length_display : na, title = 'Detected Length', color = color.lime, display = display.data_window)

bgcolor(osc > dyn_ob ? color.new(color.red, bg_transp) : osc < dyn_os ? color.new(color.green, bg_transp) : na)

plotshape(show_signals ? (bull_sig ? dyn_os : na) : na, 'Bull', location = location.absolute, color = color.green, style = shape.triangleup, size = size.small)
plotshape(show_signals ? (bear_sig ? dyn_ob : na) : na, 'Bear', location = location.absolute, color = color.red, style = shape.triangledown, size = size.small)
plotshape(show_divs ? (bull_div ? osc_fix : na) : na, 'Bull div', location = location.absolute, color = color.teal, style = shape.circle, size = size.tiny)
plotshape(show_divs ? (bear_div ? osc_fix : na) : na, 'Bear div', location = location.absolute, color = color.orange, style = shape.circle, size = size.tiny)

// ---------- ALERTS ----------
alertcondition(bull_sig, 'Bullish signal', 'Bullish signal')
alertcondition(bear_sig, 'Bearish signal', 'Bearish signal')
alertcondition(bull_div, 'Bullish divergence', 'Bullish divergence')
alertcondition(bear_div, 'Bearish divergence', 'Bearish divergence')

// ---------- VOL ALERT ----------
sec_per_bar = clamp(nz(time - time[1]) / 1000.0, 1, SECS_PER_DAY)
bpy = SECS_PER_YEAR / sec_per_bar
float prev_close_safe = math.max(strict_na_guard ? nz(close[1], close_safe) : nz(close[1], close), PRICE_EPS)
float log_ret = math.log(close_safe / prev_close_safe)
hist_vol = ta.stdev(log_ret, hist_vol_lookback) * math.sqrt(bpy) * 100
alertcondition(show_adv and hist_vol > vol_alert_threshold_pct, 'High volatility', 'Historical volatility above threshold')

// ---------- DEBUG TABLE (shows all methods) ----------
var table debug_tbl = na
if show_debug_table and barstate.islast and cycle_mode != 'Off'
    if na(debug_tbl)
        debug_tbl := table.new(position.top_right, 2, 9, bgcolor = color.new(color.black, 80))
    table.cell(debug_tbl, 0, 0, 'Orig Ehlers', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 0, str.tostring(ehlers_cycle, '#.#') + ' (raw:' + str.tostring(ehlers_raw, '#') + ')', text_color = cycle_mode == 'Original Ehlers' ? color.lime : color.gray, text_size = size.small)
    table.cell(debug_tbl, 0, 1, 'Zero-Cross', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 1, str.tostring(zc_cycle, '#.#'), text_color = cycle_mode == 'Zero-Crossing' ? color.lime : color.gray, text_size = size.small)
    table.cell(debug_tbl, 0, 2, 'Peak-Peak', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 2, str.tostring(pp_cycle, '#.#'), text_color = cycle_mode == 'Peak-to-Peak' ? color.lime : color.gray, text_size = size.small)
    table.cell(debug_tbl, 0, 3, 'Autocorr', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 3, str.tostring(ac_cycle, '#.#') + ' (' + str.tostring(ac_strength * 100, '#') + '%)', text_color = cycle_mode == 'Autocorrelation' ? color.lime : color.gray, text_size = size.small)
    table.cell(debug_tbl, 0, 4, 'Composite', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 4, str.tostring(composite_cycle, '#.#'), text_color = cycle_mode == 'Composite' ? color.lime : color.yellow, text_size = size.small)
    table.cell(debug_tbl, 0, 5, '---------', text_color = color.gray, text_size = size.small)
    table.cell(debug_tbl, 1, 5, '---------', text_color = color.gray, text_size = size.small)
    table.cell(debug_tbl, 0, 6, 'Selected', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 6, str.tostring(detected_cycle, '#.#'), text_color = color.yellow, text_size = size.small)
    table.cell(debug_tbl, 0, 7, 'Effective Len', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 7, str.tostring(length_display, '#.#'), text_color = color.lime, text_size = size.small)
    table.cell(debug_tbl, 0, 8, 'Mode', text_color = color.white, text_size = size.small)
    table.cell(debug_tbl, 1, 8, cycle_mode, text_color = color.aqua, text_size = size.small)
