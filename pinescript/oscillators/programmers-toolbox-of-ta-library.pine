// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RobertC4709

//@version=6 
indicator("Toolbox", 'Toolbox')
import TradingView/ta/12
import PineCoders/Time/5
import PineCoders/ConditionalAverages/2 as pc
//=================================================================================================///
//--------------------------------------------- COLORS --------------------------------------------///
//==================================================================//=============================///
color Aqua      = #00bcd4ff,    color Black     = #000000ff,    color Blue      = #0000ffff ///
color BlueFill  = #ffffff5c,    color Fuchsia   = #e040fbff,    color Gray      = #787b86ff ///
color Green     = #00ff00ff,    color GreenFill = #00ff0026,    color Lime      = #00e676ff ///
color Maroon    = #880e4fff,    color Navy      = #311b92ff,    color Olive     = #808000ff ///
color Orange    = #ff9800ff,    color OrangeFill= #ff980026,    color Purple    = #9c27b0ff ///
color Red       = #ff0000ff,    color RedFill   = #ff0000ff,    color Silver    = #b2b5beff ///
color Teal      = #089981ff,    color White     = #ffffffff,    color WhiteFill = #00000026 ///
color Yellow    = #fdd835ff,    color null      = #00000000                                   ///
//================================================================================================///
bool UsePrice           = input.bool(true, '', inline = 'j1')
string pPrice           = input.string('hl2', 'Price Line', ['high', 'open', 'close', 'low', 'hl2', 'hlc3', 'hlcc4', 'ohlc4', 'oc2', 'occ3'], 'Select usual Price Proxy', 'j1', active = UsePrice)
float pChartLine        = input.source(close, 'or select Chart Line Input', 'Feed an existing Chart Line\ninto Selected Function', 'j1q', active = not UsePrice)
int Brightness          = input.int(75, 'Line Brightness is', 0, 100, 5, '0 (off) to 100 (max)', 'jx1')
bool Fill               = input.bool(false, 'Fill:', 'Add Fill', 'jx1')
int fBrightness         = input.int(50, 'Brightness is', 0, 100, 5, 'Fill Brightness 0 (off) to 100 (max)', 'jx1')
fBrightness            := 100 - fBrightness
int bBrightness         = input.int(50, 'Background Brightness is', 0, 100, 5, '0 (off) to 100 (max)', 'jx2')
bBrightness            := 100 - bBrightness
int LineWidth           = input.int(3, 'Line Width is', 1, 25, 1, 'Thickness of Plot Line', 'jx2')

color FillColor         = Black
float Price             = switch pPrice
    'high'              => high
    'open'              => open
    'close'             => close
    'low'               => low
    'hl2'               => hl2
    'hlc3'              => hlc3
    'hlcc4'             => hlcc4
    'ohlc4'             => ohlc4
    'oc2'               => (open + close) / 2
    'occ3'              => (open + close + close) / 3

if not UsePrice
    Price := pChartLine
//==============================================//
//@function Examins slope of Value up/flat/down //
//@returns Green/White/Red color                //
Color(Value)=>                                  //
    int i = 100 - Brightness                   ///
    color Ans = color.rgb(255, 255, 255, i)   //
    if Value > Value[1]                        ///
        Ans := color.rgb(0, 255, 0, i)        //
    else if Value < Value[1]                   ///
        Ans := color.rgb(255, 0, 0, i)        //
    Ans                                         //
//==============================//==============//
//@function Now:Before else Now //
//@returns 1/0/-1 from slope    //
Direction(Now, Before) =>       //
    int Ans = 0                 //
    if na(Before)               //
        if Now > Now[1]         //
            Ans := 1            //
        else if Now < Now[1]    //
            Ans := -1           //
    else                        //
        if Now > Before         //
            Ans := 1            //
        else if Now < Before    //
            Ans := -1           //
    Ans                         //
//==============================//==========================//
//@function Money Flow Index: 0-100                         //
//@returns 100/0/-100 mapping                               //
TAmfiz(price, len) =>                                       //
    float mf = price * volume                               //
    float posMF = price > price[1] ? mf : 0                 //
    float negMF = price < price[1] ? mf : 0                 //
    float posSum = ta.sma(posMF, len)                       //
    float negSum = ta.sma(negMF, len)                       //
    float mfiz= 100 - 2 * (100 / (1 + (posSum / negSum)))   //
    mfiz                                                    //
//==============================================//==========//
//@function Relative Strength Index: 0-100      //
//@returns 100/0/-100 mapping                   //
TArsiz(price, len) =>                           //
    float RSIz = (ta.rsi(price, len) * 2) - 100 //
    RSIz                                        //
//======================================//======//
//@function Power input is 1-10         //
//@returns Proprietary Jurik Moving Avg //
Jurik(src, length, power) =>            //
    float beta = 0.45 * (length - 1) /  //
     (0.45 * (length - 1) + 2)          //
    float alpha = math.pow(beta, power) //
    float jma = 0,  float e0 = 0        //
    float e1 = 0,   float e2 = 0        //
//--------------------------------------//
    e0 := (1 - alpha) * src +           //
     alpha * nz(e0[1])                  //
    e1 := (src - e0) * (1 - beta) +     //
     beta * nz(e1[1])                   //
    e2 := (e0 + e1 - nz(jma[1])) *      //
     math.pow(1 - alpha, 2) +           //
     math.pow(alpha, 2) * nz(e2[1])     //
    jma := e2 + nz(jma[1])              //
    jma                                 //
//======================================//======//
// Reversion Index                              //
reversionIndex (float Price, int length) =>     //
    float d = Price - Price[1]                  //
    float ds = math.sum(d, length)              //
    float ads = math.sum(math.abs(d), length)   //
    float ratio = ads != 0.0 ? ds / ads : 0.0   //
    ratio                                       //
//----------------------------------------------//----------//
//@function Super Smoother Filter                           //
superSmoother(float Series, float Period) =>               ///
    var float ALPHA =  math.pi * math.sqrt(2.0) / Period    //
    var float BETA  =  math.exp(-ALPHA )                    //
    var float COEF2 = -math.pow(BETA, 2)                    //
    var float COEF1 =  math.cos( ALPHA ) * 2.0 * BETA       //
    var float COEF0 =  1.0 - COEF1 - COEF2                  //
    float sma2   = math.avg(Series, nz(Series[1], Series))  //
    float smooth = na, smooth := COEF0 *      sma2      +   //
                                 COEF1 *  nz(smooth[1]) +   //
                                 COEF2 *  nz(smooth[2])     //
//--------------------------//------------------------------//
//@function Reversion Index //
Reversion(Price, Length) => //     
    int riSmooth = 8        //
    int trSmooth = 4        //--------------//
    float ri = reversionIndex(Price, Length)///
    float sm = superSmoother(ri, riSmooth) ///
    float tr = superSmoother(ri, trSmooth)  //
    [sm, tr] // smooth, trigger             //
//==========================================//
//@function Geometric Moving Average        //
Gma(src, len) =>                           ///
    g = math.exp(ta.sma(math.log(src), len))//
//==========================================//
//@function creates a triangle              //
//@returns mult * angle(slope)              //
SlopeAngle(y, length, mult) =>              //
    float slope = mult * (y - y[1])         //
    float tangent = slope / length          //
    float slopeAngle = math.atan(tangent)   //
    float Ans = math.todegrees(slopeAngle)  //
    Ans                                     //
//==========================================//==============//
//@function calculates Money Flow Index. Uses Threshold.    //
//@returns [Index, Direction, Angle(Slope) * 2]             //
TAmfizt(price, len, threshold) =>                           //
    float mf = price * volume                               //
    float posMF = price > price[1] ? mf : 0                 //
    float negMF = price < price[1] ? mf : 0                ///
    float posSum = ta.tema(posMF, len)                     ///
    float negSum = ta.tema(negMF, len)                      //
    float mfiz = 100 - 2 * (100 / (1 + (posSum / negSum))) ///
    float slopeAngle = SlopeAngle(mfiz, len, 2)             //
    int direction = 0                                       //
    if mfiz >= threshold                                    //
        direction := 1                                      //
    else if mfiz < -threshold                               //
        direction := -1                                     //
    [mfiz, direction, slopeAngle]                           //
//==============================================//==========//
//@function calculates Relative Strength Index. //
//@returns [Index, Direction, Angle(Slope) * 2] //
TArsizt(price, len, threshold) =>               //
    float RSIz = (ta.rsi(price, len) * 2) - 100///
    float slopeAngle = SlopeAngle(RSIz, len, 2) //
    int direction = 0                           //
    if RSIz >= threshold                        //
        direction := 1                          //
    else if RSIz <= -threshold                  //
        direction := -1                         //
    [RSIz, direction, slopeAngle]               //
//==============================================//==============================//
// --------------------- Calculate Gaussian Moving Average ---------------------//
//==============================================================================//
//@function Calculates Gaussian Moving Average                                  //
//@returns Gaussian MA                                                          //
GaussianMA(src, length) =>                                                      //
    float gma = 0                                                               //
    float sumOfWeights = 0                                                      //
    float sigma = 1 // standard deviation                                       //
//------------------------------------------------------------------------------//
    for i = 0 to length - 1 by 1                                                //
        weight = math.exp(-math.pow((i - (length - 1)) / (2 * sigma), 2) / 2)   //
        value = ta.highest(src, i + 1) + ta.lowest(src, i + 1)                  //
        gma := gma + value * weight                                             //
        sumOfWeights := sumOfWeights + weight                                   //
//------------------------------------------------------------------------------//
    gma := gma / sumOfWeights / 2                                               //
    gma                                                                         //
//==============================================================================//
string dp           = 'First select one Price Indicator'
bool vstop          = input.bool(false, 'ATR Stop, Price, mult',                                    group = dp, tooltip = 'Trend-following trailing stop\n"Where should my stop be\nso I stay in trends, but\nexit volatility-adjusted\nstructure breaks?')
bool chandelier     = input.bool(false, 'Chandelier Exits, len, mult',                              group = dp, tooltip = "A volatility-based trailing stop\nfor trend-following systems.")
bool dema           = input.bool(false, 'DEMA, Price, len',                                         group = dp, tooltip = "Double Exponential Moving Average (EMA)\nSmoother and faster than EMA.")
bool ema            = input.bool(false, 'EMA, Price, len',                                          group = dp, tooltip = "Exponential Moving Average. Smooths prices.")
bool frama          = input.bool(false, 'Fractal Adaptive Moving Average, Price, len',              group = dp, tooltip = "A self-adjusting MA. Automatically changes\nspeed based on market structure.\nFast trends, Smooth chop. Reduced lag.")
bool gma            = input.bool(false, 'Geometric Moving Average',                                 group = dp, tooltip = 'Long-term trend analysis. Growth-rate modeling')
bool hma            = input.bool(false, 'Hull Moving Average, Price, len',                          group = dp, tooltip = "Low-lag, very smooth MA. Reduced lag")
bool jma            = input.bool(false, 'Jurik Moving Average, Price, len, power',                  group = dp, tooltip = "Proprietary Jurik Moving Average, power goes\nfrom 1-10. Gives excellent direction. Adjust power based on bar size.")
bool kama           = input.bool(false, "Kaufman's Adaptive Moving Average, Price, ema len, fast len, slow len",tooltip = 'Intelligent moving average.\n"Is Price moving directionally,\nor just noisy?"', group = dp)
bool Keltner        = input.bool(false, 'Keltner Channels, Price, len, mult',                       group = dp, tooltip = "Volatility-based Price envelope.\nWraps around an MA using ATR.\nUsed in trend-following\nand breakout systems.")
bool LinReg         = input.bool(false, 'Linear Regression Analysis, Price, len',                   group = dp, tooltip = "Quantify trend direction, strength,\nand deviation using statistics.")
bool Pv             = input.bool(false, 'Pivot Points, before, after',                              group = dp, tooltip = "Support/resistance levels from the\nprevious session. Objective, static, and\nself-fulfilling. Assume today’s trading range is\ninfluenced by yesterday's high, low, close.")
bool rma            = input.bool(false, 'Running Moving Average, Price, len',                       group = dp, tooltip = "Also called Wilder's Moving Average. A smoothed average used in RSI, ATR, ADX, DI.")
bool sar            = input.bool(false, 'Stop and Reverse, start, inc, max',                        group = dp, tooltip = "begin testing with: 0.005/0.01/0.05\nStop loss becomes entry in the opposite direction.\nExit the trade and reverse. Trend-following. Implemented as Parabolic SAR")
bool sma            = input.bool(false, 'Simple Moving Average, Price, len',                        group = dp, tooltip = 'Simple Moving Average')
bool SuperTrend     = input.bool(false, 'SuperTrend, mult, len',                                    group = dp, tooltip = "Volatility-based trend indicator.\nDynamic stop line and trend filter.\nBuilt on ATR. Adapts automatically\nto market conditions.")
bool swma           = input.bool(false, 'Symetrically Weighted Moving Average, Price)',             group = dp, tooltip = 'A center-weighted smoothing filter that\nreduces noise while preserving turning points.')
bool tema           = input.bool(false, 'TEMA, Price, len',                                         group = dp, tooltip = "Triple EMA. Low-lag. Responds faster than DEMA.")
bool trima          = input.bool(false, 'Triangular Moving Average, Price, len',                    group = dp, tooltip = 'Very smooth, heavily lagging MA.\nFilters noise. Highlights trends.\n"Smoother-of-smoothers."')
bool T3             = input.bool(false, 'Tillison MA, Price, len, vf',                              group = dp, tooltip = "T3 MA. Ultra-smooth, low-lag.\nTunable smoothing factor. Hugs trends.")
bool vwap           = input.bool(false, 'VWAP, Price',                                              group = dp, tooltip = "Volume-Weighted Average Price.\nDuring a session, weighted by volume.\nInstitutions use it to judge execution quality;\ntraders use it as intraday fair value,\ndynamic support/resistance,\nand a mean-reversion anchor.\nPrice > VWAP → buyers control\nPrice < VWAP → sellers control.")
bool vwma           = input.bool(false, 'Volume Weighted MA, Price, len',                           group = dp, tooltip = 'Volume-Weighted MA.\nMore weight to higher volume.\n“Where did Price move with participation?”')
bool wma            = input.bool(false, 'Weighted MA, Price, len',                                  group = dp, tooltip = "Weighted MA. More weight to recent prices.")
//===================================================================================================================================================================================================================================================================================================================================================================================
string v            = 'Then Select Variable(s)'
int len             = input.int(1, '(Fast) (Len) (Before) Variable is', 1, 250, 1, 'Fast Moving Average Length\nor Indicator Length or Before', 'k1', v)
int fastlen         = len
int midlen          = input.int(1, '(Mid Len) (After) (int) Variable is', 1, 250, 1, 'Mid Moving Average Length\nInteger Operand', 'k2', v)
int slen            = input.int(1, '(Slow Len) (Power) (Offset) Variable is', 1, 250, 1, 'Slow Moving Average Length\nor Jurik Moving Average "Power"', 'k3', v)
int slowlen         = slen
int elen            = input.int(1, '(Ema Len) (HHLL) Variable is', 1, 250, 1, 'Exponental Moving Average Length', 'k4', v)
int signal          = input.int(1, '(Smooth) (Signal) (Sigma) Variable is', 1, 100, 1, 'Smoothing Operand\nIndicator Signal', 'k5', v)
int ismooth         = signal

float mult          = input.float(1, '(Start) (Mult) Variable is', 0, 250, 0.1, 'PSAR Start\nMultiplier Operand', 'k6', v)
float fvar          = input.float(0, '(vf) (Increment) (Inc) Variable is', 0, 250, 0.01, 'T3 vf\nIncrement Operand\nPSAR Increment', 'k7', v)
float mvar          = input.float(0, '(Max) Variable is', 0, 250, 2, 'PSAR Maximum', 'k8', v)
//===================================================================================================================================================================================================================================================================================================================================================================================
string dw           = 'Then select one Window Indicator'
bool accdist        = input.bool(false, 'Accumulation/Distribution Index',                          group = dw, tooltip = 'Accumulation/Distribution Index is a\nvolume-based momentum indicator')
bool ao             = input.bool(false, 'Awesome Oscillator, Price. fMA, sMA',                      group = dw, tooltip = "Awesome Oscillator.\nMarket momentum comparing\nshort-term vs long-term Price.")
bool adx            = input.bool(false, 'ADX, Price, len, avg(int)',                                group = dw, tooltip = "Average Directional Index.\nTrend-strength: How strong.\nNot direction.")
bool alma           = input.bool(false, 'Arnaud Legoux Moving Average, Price, len, offset, sigma',  group = dw, tooltip = "Uses Gaussian distribution as\nweights for moving average.")
bool aroon          = input.bool(false, 'Aroon Oscillator, Price, len',                             group = dw, tooltip = "Trend Timing Identification.")
bool atr            = input.bool(false, 'ATR, len',                                                 group = dw, tooltip = 'Volatility. "How much is Price moving?"\nnot direction. Market’s speedometer.')
bool bb             = input.bool(false, 'Bollinger Bands, Price, len, mult',                        group = dw, tooltip = 'A volatility-based price envelope')
bool bbw            = input.bool(false, 'Bollinger Bands Width, Price, len, mult',                  group = dw, tooltip = 'The (upper - lower) Bollinger Band\ndivided by middle band.')
bool cmo            = input.bool(false, 'Chande Momentum Oscillator, Price, len',                   group = dw, tooltip = "Directional momentum.\nWithout smoothing lag.")
bool cog            = input.bool(false, 'Center of Gravity, Price, len',                            group = dw, tooltip = "Center of Gravity Oscillator. Very low-lag.\nFind cyclical turning points. Not trend-following.\nCycle/mean-reversion oscillator.")
bool cci            = input.bool(false, 'Commodity Channel Index, Price, len',                      group = dw, tooltip = 'Momentum-oscillator\nto identify cyclical extremes')
bool dev            = input.bool(false, 'Deviation, Price, len',                                    group = dw, tooltip = 'Price - SMA')
bool coppock        = input.bool(false, 'Coppock Curve, Price, len, slen, smooth',                  group = dw, tooltip = "Long-term momentum. Major market bottoms.\nPrimary trend/regime filter. Weekly charts.")
bool dm             = input.bool(false, 'DeMarker, len',                                            group = dw, tooltip = "Momentum oscillator. Spot exhaustion,\noverbought/oversold, and potential reversals.")
bool fastcci        = input.bool(false, 'Fast Commodity Channel Index, len',                        group = dw, tooltip = 'Proprietary fast momentum-oscillator\nto identify cyclical extremes')
bool fastdev        = input.bool(false, 'Fast Deviation, Price, len',                               group = dw, tooltip = 'Proprietary Price - DEMA')
bool fastMacd       = input.bool(false, 'Fast MACD, Price, fast len, slow len, signal',             group = dw, tooltip = "Fast trend-following. Shows direction,\nmomentum, and momentum shifts. Low lag.")
bool ft             = input.bool(false, 'Fisher Transform, Price, len',                             group = dw, tooltip = "Momentum/turning-point oscillator.\nTransforms Price into Gaussian distribution.")
bool ht             = input.bool(false, 'Hilbert Transform, len',                                   group = dw, tooltip = "Signal-processing. Extract market cycles,\nphase, and dominant cycle length.\nCycle radar, not a trend tool.")
bool ift            = input.bool(false, 'Inverse Fisher Transform, [data window]',                  group = dw, tooltip = "Normalization technique.\nConverts noisy oscillator to a smooth,\nbounded signal between −1 and +1.\nMake turning points clearer. Signal enhancer.")
bool iii            = input.bool(false, 'Intraday Intensity Index',                                 group = dw, tooltip = 'Intraday Intensity Index is a volume-weighted accumulation/distribution indicator\nthat measures buying vs. selling pressure\nwithin each bar.')
bool ker            = input.bool(false, "Kaufman's Efficiency Ratio, Price, len",                   group = dw, tooltip = "Market efficiency noise filter. Measures directional Price vs noise.\nDoes not measure direction — only trend quality.")
bool kcw            = input.bool(false, 'Keltner Channel Width, Price, len, mult',                  group = dw, tooltip = 'Width of Keltner Channel')
bool MaCD           = input.bool(false, 'MACD, Price, fast len, slow len, signal',                  group = dw, tooltip = "MA Convergence Divergence. Trend-following\nmomentum. Shows direction, momentum,\nand momentum shifts.")
bool Median         = input.bool(false, 'Median, Price, len',                                       group = dw, tooltip = "Median moving average. Trend-following\nmomentum. Shows direction, momentum,\nand momentum shifts.")
bool mfi            = input.bool(false, 'Money Flow Index, Price, len',                             group = dw, tooltip = "RSI-style oscillator with volume Input.")
bool mfiz           = input.bool(false, 'Money Flow Index Z, Price, len',                           group = dw, tooltip = "Zero based RSI-style oscillator with volume input.")
bool mfizt          = input.bool(false, 'Money Flow Index Zt, Price, len, signal',                  group = dw, tooltip = "Zero based RSI-style oscillator\nwith volume input and a Threshold filter.")
bool mom            = input.bool(false, 'Momentum, Price, len',                                     group = dw, tooltip = 'Measures the speed and strength of price movement')
bool nvi            = input.bool(false, 'Negative Volume Index',                                    group = dw, tooltip = 'Measures the speed and strength of negative price movement.')
bool obv            = input.bool(false, 'On Balance Volume',                                        group = dw, tooltip = 'A cumulative volume-momentum indicator, it attempts to measure buying and selling pressure.')
bool PcRank         = input.bool(false, 'Percent Rank, Price, len',                                 group = dw, tooltip = '"How extreme is this value,\ncompared to the last N bars?"')
bool pvi            = input.bool(false, 'Positive Volume Index',                                    group = dw, tooltip = 'Measures the speed and strength of positive price movement.')
bool pvt            = input.bool(false, 'Price Volume Trend',                                       group = dw, tooltip = 'Volume-weighted momentum indicator.\n“How much volume flowed relative to how far price actually moved?”')
bool rev            = input.bool(false, 'Reversion Index,Price, len',                               group = dw, tooltip = 'From John Ehlers via Pine Coders. A scalping, timing tool.')
bool roc            = input.bool(false, 'Rate of Change, Price, len',                               group = dw, tooltip = '"How much has Price moved\ncompared to N bars ago?"')
bool rsi            = input.bool(false, 'Relative Strength Index, Price, len',                      group = dw, tooltip = 'measures speed and persistence of gains vs losses\nmomentum, pullbacks, potential exhaustion.\n"Are recent gains outweighing\nrecent losses—and by how much?"')
bool rsiz           = input.bool(false, 'Relative Strength Index Z, Price, len',                    group = dw, tooltip = 'measures speed and persistence of gains vs losses\nmomentum, pullbacks, potential exhaustion.\nzero based RSI. "Are recent gains outweighing\nrecent losses—and by how much?"')
bool rsizt          = input.bool(false, 'Relative Strength Index Zt, Price, len, signal',           group = dw, tooltip = 'measures speed and persistence of gains vs losses\nmomentum, pullbacks, potential exhaustion.\nzero based RSI with a Threshold filter.\n"Are recent gains outweighing\nrecent losses—and by how much?"')
bool slope          = input.bool(false, "Slope, Price, len, mult",                                  group = dw, tooltip = "Price Slope. mult will scale with other indicators.")
bool Spearman       = input.bool(false, "Spearman's rci, Price, len",                               group = dw, tooltip = "Non-parametric momentum oscillator.\nMeasures how closely Price follows\ntrend. Popular in FX and futures.\nExcellent for trend quality and timing.")
bool std            = input.bool(false, 'Standard Deviation, Price, len',                           group = dw, tooltip = "Statistical volatility measure.\nHow widely Price varies around its mean.")
bool stoch          = input.bool(false, 'Stochastic, len',                                          group = dw, tooltip = 'Momentum oscillator. Compares current\nPrice to recent high–low range.\n"Is momentum accelerating or fading?"')
bool szo            = input.bool(false, 'Sentiment Zone Oscillator, Price, len',                    group = dw, tooltip = "Momentum + sentiment.\nBuying vs selling pressure,\nmaps it into zones.")
bool tr             = input.bool(false, 'True Range',                                               group = dw, tooltip = "Current bar's True Range")
bool trix           = input.bool(false, 'TRIX, signal, line, average',                              group = dw, tooltip = "Triple Exponential Average Oscillator.\nTrend-momentum. Measures the rate of change\nof TEMA. Slow but reliable momentum compass.")
bool tsi            = input.bool(false, 'True Strength Index, fast len, slow len',                  group = dw, tooltip = "Double-smoothed momentum oscillator.\nAggressive noise filtering directional momentum")
bool tsislope       = input.bool(false, 'True Strength Index, fast len, slow len, HHLL, signal',    group = dw, tooltip = "Double-smoothed momentum oscillator.\nAggressive noise filtering directional momentum\nTry len = 50, HHLL = 4, signal = 1-20")
bool ulcer          = input.bool(false, 'Ulcer Index, Price, len',                                  group = dw, tooltip = 'Downside-risk drawdown volatility indicator.\n"How painful is the drawdown?"')
bool ultimate       = input.bool(false, 'Ultimate Oscillator, Price, fast len, mid len, slow len',  group = dw, tooltip = '"Is buying pressure consistent across\nshort, medium, and long horizons?"')
bool variance       = input.bool(false, 'Variance, Price, len',                                     group = dw, tooltip = "Statistical measure of dispersion only\nno direction. Raw volatility.")
bool vhf            = input.bool(false, 'Vertical Horizontal Filter, Price, len',                   group = dw, tooltip = 'Trend vs range detector.\nregime filter, not signal generator.\n"Is the market moving vertically (trending)\n or horizontally (choping)?"')
bool vi             = input.bool(false, 'Volume Index',                                             group = dw, tooltip = '(Positive - Negative) Volume Index.')
bool vortex         = input.bool(false, 'Vortex Indicator, len',                                    group = dw, tooltip = "Trend direction + strength.\nWho’s in control (buyers or sellers)?")
bool vzo            = input.bool(false, 'Volume Zone Indicator, len',                               group = dw, tooltip = 'Volume-weighted momentum/sentiment oscillator\nclassifies flow into bullish, bearish, or neutral\nzones. "Is volume confirming upward\nor downward moves—and by how much?"')
bool wad            = input.bool(false, "Williams Accumulation/Distribution",                       group = dw, tooltip = 'Volume-Price indicator. "Is volume accumulating or distributing an instrument?"\n"Is volume supporting buying or selling pressure—even if Price hasn\’t moved much?"')
bool wpr            = input.bool(false, 'Williams %R, len',                                         group = dw, tooltip = 'Percent RangeFast momentum oscillator.\n"Is Price closing near the highs or lows\nof its recent range?"')
bool wprslope       = input.bool(false, 'Williams %R, HHLL, signal, len',                           group = dw, tooltip = 'Percent RangeFast momentum oscillator.\n"Is Price closing near the highs or lows\nof its recent range?"\nTry len = 50, HHLL = 4, signal = 1-20')
bool wvad           = input.bool(false, "Williams Variable Accumulation/Distribution",              group = dw, tooltip = 'Volume-Price accumulation."Is volume\nsupporting buying or selling right now?"\n"Is that pressure building over the last N bars?"')
//===================================================================================================================================================================================================================================================================================================================================================================================
string pe           = 'Then select Plotting Enhancements'
bool Detail         = not input.bool(false, 'Set No Detail', 'Do not draw indicator lines', 'jxz', group = pe)
int AvBars          = input.int(0, 'Plot Average Detail using Bars =', 0, 500, 1, 'Also plot the Average of the Indicator', 'jxz9', group = pe)
bool ColorAvg       = not input.bool(false, 'Set Average plot to white', 'Indicator Average will be white instead of red/green', 'jxzq', group = pe)
bool ColorX         = not input.bool(false, 'Set Detail plot to white', 'Indicator line(s) will be white\ninstead of red/green', 'jxzq', group = pe)
bool Combine        = input.bool(false, 'Combine price direction of 2 indicators onto background', 'Lower background will indicate the\ncombined direction of 2 indicators', 'jxz1', group = pe)
bool pCombine       = input.bool(false, 'Also add combined background to Price pane', 'Price  background will indicate the\ncombined direction of 2 indicators','jxz2', group = pe)
bool AddGaussian    = input.bool(false, 'Add Gaussian MA to selected indicator(s):', inline = 'jxz3', group = pe)
int GaussianBars    = input.int(1, 'Bars =', 1, 250, 1, 'Add an independent Gaussian Moving Average.', 'jxz3', group = pe)

int xDirection      = na 
int yDirection      = na
int xpDirection     = na
int ypDirection     = na

int BothDirection   = na
int AvgxyDirection  = na
int AvgxpypDirection= na
int xLineWidth      = 2
int aLineWidth      = xLineWidth
int xpLineWidth     = xLineWidth

float GMA           = na
float Avgxy         = na
float x             = na
float y             = na
float u             = na
float d             = na
float Avgxpyp       = na
float xp            = na
float yp            = na
float macd          = na
float macd_signal   = na
float histogram     = na
float Threshold     = na
float Center_Line   = na
bool  IsADX         = false
bool IsPivot        = false

var float Lastx     = na
var float Lasty     = na
var float Lastxp    = na
var float Lastyp    = na

color xColor        = White
color yColor        = na
color ypColor       = xColor
color aColor        = xColor
color xpColor       = xColor
color apColor       = xColor

var color LastXColor    = White
var color LastYColor    = White
var color LastXpColor   = White
var color LastYpColor   = White
var color stColor       = White

bool MaFill             = false
bool mfirsi             = false
bool Outline            = false

var bool UseLastXColor  = false
var bool UseLastXpColor = false
var bool UseLastYColor  = false
var bool UseLastYpColor = false
var bool colorHLxp      = false

if accdist
    x := ta.sma(ta.accdist / 1000, 3)

if adx
    [diPlus, diMinus, adxp] = ta.dmi(len, midlen)
    x := adxp, u := diPlus, d := diMinus, IsADX := true
    Center_Line := 20

if alma
    xp := ta.alma(Price, len, slen, signal)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if ao
    x := ta.ao(Price, len, slen)
    Center_Line := 0

if aroon
    [x1, y1] = ta.aroon(len)
    x := x1, y := y1

if atr
    x := ta.atr(len), y := na

if bb
    [_, x1, y1] = ta.bb(Price, len, mult)
    xp := x1, yp := y1

if bbw
    x := ta.bbw(Price, len, mult)
    
if chandelier
    [xp1, yp1] = ta.chandelier(len, 7, mult)
    xp := xp1, yp := yp1
    if na(xp)
        xp := Lastxp, UseLastXpColor := true
    else
        xpDirection := Direction(xp, Lastxp), Lastxp := xp, UseLastXpColor := false
    if na(yp)
        yp := Lastyp, UseLastYpColor := true
    else
        ypDirection := Direction(yp, Lastyp), Lastyp := yp, UseLastYpColor := false

if cci
    x := ta.cci(Price, len)
    Center_Line := 0

var float cci_ema = na
var float sum = na
var float mean_deviation = na

if fastcci
    cci_ema := ta.dema2(hlcc4, len)
    mean_deviation := ta.dema(math.abs(hlcc4 - cci_ema), len)
    x := (hlcc4 - cci_ema) / (0.015 * mean_deviation)
    Center_Line := 0

if cmo
    x := ta.cmo(Price, len)
    Center_Line := 0

if cog
    x := ta.cog(Price, len)

if coppock
    x := ta.coppock(Price, len, slen, ismooth)
    Center_Line := 0

if dema
    xp := ta.dema2(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if dev
    x := ta.dev(Price, len)
    Center_Line := 0

if fastdev
    x := Price - ta.dema2(Price, len)
    Center_Line := 0

if dm
    x := ta.dm(len)

if ema
    xp := ta.ema(Price, len) 
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if fastMacd and (len + slen + signal) > 0
    macd := ta.dema(Price, len) - ta.dema(Price, slen)
    macd_signal := ta.dema(macd, signal)
    histogram := macd - macd_signal
    Avgxy := macd_signal, x := macd, y := histogram
    Center_Line := 0, ColorAvg := false, AvBars := 0

if frama
    xp := ta.frama(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if ft
    x := ta.ft(Price, len)
    Center_Line := 0

if gma
    xp := Gma(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if hma
    xp := ta.hma(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if ht
    x := ta.ht(Price)
    Center_Line := 0

if iii
    x := ta.iii
    Center_Line := 0

if jma
    xp := Jurik(Price, len, slen)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if kama
    xp := ta.kama(Price, elen, len, slen)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if Keltner and (mult > 0)
    [middle, upper, lower] = ta.kc(Price, len, mult)
    Avgxpyp := middle, xp := upper, yp := lower
    xpDirection := Direction(xp, xp[1])
    ypDirection := Direction(yp, yp[1])

    if Fill
        FillColor := color.rgb(0, 0, 255, fBrightness)

if kcw
    x := ta.kcw(Price, len, mult)
    Center_Line := 0

if ker 
    x := ta.er(Price, len)

if LinReg and len > 1
    xp := ta.linreg(Price, len, 0)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if MaCD and (len + slen + signal) > 0
    [Line, Signal, Histogram] = ta.macd(Price, len, slen, signal)
    Avgxy := Signal, x := Line, y := Histogram
    Center_Line := 0, ColorAvg := false, AvBars := 0

if Median
    xp := ta.median(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if mfi
    x := ta.mfi(Price, len)
    Center_Line := 50

if mfiz
    x := TAmfiz(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if mfizt
    [mfix, direction, slopeAngle] = TAmfizt(Price, len, signal)
    x := mfix, xDirection := direction, Threshold := signal
    Center_Line := 0, Outline := true, ColorX := false, mfirsi := true

if mom
    x := ta.mom(Price, len)
    Center_Line := 0

if nvi
    x := ta.nvi

if obv
    x := ta.obv

if PcRank
    x := ta.percentrank(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if pvi
    x := ta.pvi

if Pv
    if not (chandelier or Keltner or vstop)
        xp := ta.pivothigh(len, midlen), yp := ta.pivotlow(len, midlen), IsPivot := true

        if na(xp)
            xp := Lastxp, UseLastXpColor := true
        else
            Lastxp := xp, UseLastXpColor := false
        if na(yp)
            yp := Lastyp, UseLastYpColor := true
        else
            Lastyp := yp, UseLastYpColor := false

        if Fill
            FillColor := color.rgb(0, 0, 255, fBrightness)

if pvt
    x := ta.pvt

if rev
    [x1, y1] = Reversion(Price, len)
    x := y1, y := x1, yColor := color.white

if rma
    xp := ta.rma2(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if roc 
    x := ta.roc(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if rsi
    x := ta.rsi(Price, len)
    Center_Line := 50

if rsiz
    x := TArsiz(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if rsizt
    [rsix, direction, slopeAngle] = TArsizt(Price, len, signal)
    x := rsix, xDirection := direction, Threshold := signal
    Center_Line := 0, Outline := true, ColorX := false, mfirsi := true

if sar
    xp := ta.sar(mult, fvar, mvar), MaFill := Fill
    if xp > close
        xpDirection := 1
    else if xp < close
        xpDirection := -1
    else
        xpDirection := 0

if sma
    xp := ta.sma(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if Spearman
    x := ta.rci(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if slope
    y := Jurik(Price, 35, 3)
    x := SlopeAngle(y, len, mult)
    y := na

if std 
    x := ta.stdev(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if stoch
    x := ta.stoch(Price, high, low, len)
    Center_Line := 0, Outline := true, ColorX := false

if SuperTrend
    [supertrend, dir] = ta.supertrend(mult, len)
    xp := supertrend, xpDirection := dir, MaFill := Fill, colorHLxp := true

if swma
    xp := ta.swma(Price)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if szo
    x := ta.szo(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if tema
    xp := ta.tema2(Price, len)
    xpDirection := Direction(xp, xp[1]), MaFill := Fill

if tr
    x := ta.tr
    
if trima
    xp := ta.trima(Price, len)
    xpDirection := Direction(xp, Lastxp), MaFill := Fill

if trix
    [Signal, Line, Histogram] = ta.trix(Price, len, ismooth)
    Avgxy := Signal, x := Line, y := Histogram
    Center_Line := 0, ColorAvg := false, AvBars := 0

var float HLscale = na
var float slopeangle = na
var int HHLLbars = na

if tsi or tsislope 
    x := ta.tsi(Price, len, slen)
    Center_Line := 0, Outline := true, ColorX := false
    if tsislope
        slopeangle := x - x[HHLLbars], HHLLbars := elen, HLscale := 100

if T3 
    xp := ta.t3Alt(Price, len, fvar)
    xpDirection := Direction(xp, Lastxp), MaFill := Fill

if ulcer
    x := ta.ulcerIndex(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if ultimate
    x := ta.uo(fastlen, midlen, slowlen)

if variance
    x := ta.variance(Price, len)
    Center_Line := 0, Outline := true, ColorX := false

if vhf
    x := ta.vhf(Price, len)

var float vislope = na 
if vi
    vislope := (ta.pvi - ta.nvi)/(ta.pvi + ta.nvi)
    x := ta.ift((vislope - vislope[3]) * 1000) * 100
    Center_Line := 0

if vortex
    [viPlus, viMinus ] = ta.vi(len)
    Avgxy := (viPlus + viMinus) / 2, x := viPlus, y := viMinus
    if Detail
        ColorAvg := false
        
if vstop
    [value, trend] = ta.vStop(Price, 7, mult)
    xp := value, MaFill := Fill, colorHLxp := true
    if trend
        xpDirection := 1
    else
        xpDirection := -1

if vwap 
    xp := ta.vwap(Price)
    xpDirection := Direction(xp, Lastxp), MaFill := Fill

if vwma 
    xp := ta.vwma(Price, len)
    xpDirection := Direction(xp, Lastxp), MaFill := Fill

if vzo
    x := ta.vzo(len)
    Center_Line := 0, Outline := true, ColorX := false

if wad
    x := ta.wad

if wma 
    xp := ta.wma(Price, len)
    xpDirection := Direction(xp, Lastxp), MaFill := Fill

if wpr 
    x := 100+ta.wpr(len)
    Center_Line := 0, Outline := true, ColorX := false

if wprslope 
    x := 100+ta.wpr(len)
    Center_Line := 0, Outline := true, ColorX := false,
    slopeangle := x - x[HHLLbars], HHLLbars := elen, HLscale := 1

if wvad
    x := ta.wvad
    Center_Line := 0, Outline := true, ColorX := false

if ift
    x := ta.ift(x)
    Center_Line := 0 

if AvBars > 1
    if not na(x)
        if na(y)
            Avgxy := ta.dema2(x, AvBars)
        else
            Avgxy := ta.dema2((x + y)/2, AvBars)
        if na(AvgxyDirection)
            AvgxyDirection := Direction(Avgxy, Avgxy[1])
    if not na(xp)
        if na(Avgxpyp)
            if na(yp)
                Avgxpyp := not (chandelier or SuperTrend or sar or T3 or vstop) ? ta.dema2(xp, AvBars) : na
            else
                Avgxpyp := (xp + yp)/2
        if na(AvgxpypDirection)
            AvgxpypDirection := Direction(Avgxpyp, Avgxpyp[1])

if ColorX
    if UseLastXColor
        xColor := LastXColor
    else
        xColor := Color(x), LastXColor := xColor
    if UseLastYColor
        yColor := LastYColor
    else
        yColor := na(yColor) ? Color(y) : yColor, LastYColor := yColor
    xLineWidth := LineWidth
    if UseLastXpColor
        xpColor := LastXpColor
    else if vstop
        if xpDirection == 1
            xpColor := Green
        else if xpDirection == -1
            xpColor := Red
    else
        xpColor := Color(xp), LastXpColor := xpColor
    if UseLastYpColor
        ypColor := LastYpColor 
    else
        ypColor := Color(yp), LastYpColor := ypColor
    xpLineWidth := LineWidth
else if IsPivot
    xpColor := Green, ypColor := Red

var LastapColor = White

if ColorAvg
    aColor := Color(Avgxy), aLineWidth := LineWidth
    if Pv
        if Direction(Avgxpyp, Avgxpyp[1]) == 0
            apColor := LastapColor
        else
            apColor := Color(Avgxpyp), LastapColor := apColor

if not na(AvgxyDirection)
    if AvgxyDirection < 0
        stColor := Green
    else if AvgxyDirection > 0
        stColor := Red

color FillGreen = color.rgb(0, 255, 0, fBrightness-10)
color FillRed = color.rgb(255, 0, 0, fBrightness-10)
color BgColor = null

xpDirection := Direction(xp, xp[1])
if not mfirsi
    xDirection := Direction(x, x[1])

if xpDirection == xDirection
    if xDirection > 0
        BgColor := FillGreen
    else if xDirection < 0
        BgColor := FillRed

bgcolor(Combine ? BgColor : na)
bgcolor(pCombine ? BgColor : na, force_overlay = true)

bool ColumnPlotX = Fill and Detail and na(y) and not na(Center_Line)
bool ColumnPlotY = Fill and Detail and not na(y) and not na(Center_Line)
plot(Detail and (Outline or not (ColumnPlotX or IsADX)) ? x : na, 'Plot xd', xColor, xLineWidth)
plot(Detail and not (ColumnPlotY or IsADX) ? y : na, 'Plot yd',na(yColor) ? xColor : yColor, xLineWidth)
plot(Avgxy, 'Average d', aColor, aLineWidth)

if colorHLxp
    if xp >= high
        xpColor := Red
    else if xp <= low
        xpColor := Green

xpLine = plot(Detail and (IsPivot or not na(xpDirection)) ? xp : na, 'Plot xp', chandelier ? Red : IsPivot ? Green : xpColor, xpLineWidth, force_overlay = true)
ypLine = plot(Detail and (IsPivot or not na(ypDirection)) ? yp : na, 'Plot yp', chandelier ? Green : IsPivot ? Red : ypColor, xpLineWidth, force_overlay =  true)
plot(na(AvgxpypDirection) ? na : Avgxpyp, 'Average xpyp', apColor, xLineWidth, force_overlay = true)

if not (na(y) or IsADX)
    Avgxy := (x + y)/2
if not na (yp)
    Avgxpyp := (xp + yp)/2

if Combine and not (na(x) or na(xp))
    if na(xDirection)
        xDirection := Direction(Avgxy, Avgxy[1])

    BothDirection := xDirection + Direction(Avgxpyp, Avgxpyp[1])

    if BothDirection > 0
        BgColor := color.rgb(0, 255, 0, bBrightness)
    else if BothDirection < 0
        BgColor := color.rgb(255, 0, 0, bBrightness)

xpBothLine = plot(BothDirection < 0 ? xp : na, "Up direction", stColor, xpLineWidth, plot.style_steplinebr,force_overlay = true)
ypBothLine = plot(BothDirection == 0 ? xp : na, "Flat direction", stColor, xpLineWidth, plot.style_steplinebr, force_overlay = true)
plot(BothDirection > 0 ? xp : na, "Down direction", stColor, xpLineWidth, plot.style_steplinebr, force_overlay = true)

var color LastGaussianColor = White

if IsPivot
    FillColor := null

if AddGaussian
    GMA := GaussianMA(Price, GaussianBars)
    BgColor := Color(GMA)
    if BgColor == LastGaussianColor
        BgColor := White
    LastGaussianColor := BgColor
plot(GMA, 'Gaussian Moving Average', BgColor, 2, force_overlay = true)
fill(xpBothLine, ypBothLine, FillColor)
fill(xpLine, ypLine, FillColor)
CenterLine = plot(Center_Line, 'Center Line', White, 1, plot.style_stepline)

int cMultiplier = MaCD ? 2 : 1

if not na(Center_Line)
    if ColumnPlotY
        if y >= Center_Line
            FillColor := FillGreen
        else
            FillColor := FillRed 
    else 
        if x >= (mfirsi ? Threshold : Center_Line)
            FillColor := FillGreen
        else if x <= (mfirsi ? -Threshold : Center_Line) 
            FillColor := FillRed

plot(ColumnPlotX ? (x-Center_Line)*cMultiplier : na, 'Plot xd', FillColor, xLineWidth*2, plot.style_columns)
plot(ColumnPlotY ? (y-Center_Line)*cMultiplier : na, 'Plot xd', FillColor, xLineWidth*2, plot.style_columns)

float Fill_Line_Value = na
color xpFillColor = null

if MaFill
    if xp > high
        xpFillColor := FillRed, Fill_Line_Value := high
    else if xp < low
        xpFillColor := FillGreen, Fill_Line_Value := low
else if IsPivot
    Fill_Line_Value := yp

xpFillLine = plot(Fill_Line_Value, 'Fill Line', null, 1, force_overlay = true)
fill(xpLine, xpFillLine, xpFillColor)

color uColor = null
color dColor = null
color AdxColor = null
color AdxFillColor = null

if IsADX
    AdxColor := Yellow
    if u > d
        uColor := Green, dColor := Gray
        AdxFillColor := color.new(Green, 50)
    if d > u
        uColor := Gray, dColor := Red
        AdxFillColor := color.new(Red, 50) 
uPlot = plot(u, 'diPlus', uColor, 2)
dPlot = plot(d, 'diMinus', Red, 2)
plot(x, 'ADX', AdxColor, 3)
fill(uPlot, dPlot, AdxFillColor)

var float HH = na 
var float LL = na
var float HHLLangle = na
BgColor := na

if HHLLbars > 0
    BgColor := null
    HH := ta.highest(x, HHLLbars)
    LL := ta.lowest(x, HHLLbars)
    HHLLangle := (HH-LL) * HLscale
    if HHLLangle > signal
        if slopeangle > 0
            BgColor := color.rgb(0, 255, 0, 70)
        else if slopeangle < 0 
            BgColor := color.rgb(255, 0, 0, 70)
bgcolor(BgColor, force_overlay = true)
