//@version=6
indicator("Market Entropy [Alpha Extract]", overlay=false, max_bars_back=5000)

// INPUTS
int entropy_length = input.int(50, "Entropy Window", minval=20, maxval=200, group="Core Settings")
int price_bins = input.int(20, "Distribution Bins", minval=10, maxval=50, group="Core Settings")
int signal_smooth = input.int(14, "Signal Smoothing", minval=1, maxval=50, group="Core Settings")
int adaptive_lookback = input.int(500, "Adaptive Calibration Period", minval=100, maxval=2000, group="Core Settings")

float percentile_low = input.float(30, "Structure Percentile", minval=10, maxval=50, step=5, group="Adaptive Thresholds", tooltip="Lower percentile = structure zone")
float percentile_high = input.float(70, "Chaos Percentile", minval=50, maxval=90, step=5, group="Adaptive Thresholds", tooltip="Upper percentile = chaos zone")

bool mtf_enabled = input.bool(true, "Multi-Timeframe Analysis", group="MTF Settings")
string mtf_tf1 = input.timeframe("15", "MTF 1", group="MTF Settings")
string mtf_tf2 = input.timeframe("60", "MTF 2", group="MTF Settings")
string mtf_tf3 = input.timeframe("240", "MTF 3", group="MTF Settings")

bool show_fills = input.bool(true, "Show Gradient Fills", group="Display")
bool show_divergence = input.bool(true, "Show Divergence", group="Display")
bool show_glow = input.bool(true, "Glow Effect", group="Display")
int entropy_line_width = input.int(3, "Entropy Line Width", minval=1, maxval=4, group="Display")
float div_marker_offset = input.float(10, "Divergence Marker Offset", minval=0.0, maxval=10.0, step=0.5, group="Display")
float bull_div_level = input.float(20.0, "Bull Div Level", minval=0.0, maxval=100.0, step=1.0, group="Display", tooltip="Only show bullish divergence below this entropy value.")
float bear_div_level = input.float(90.0, "Bear Div Level", minval=0.0, maxval=100.0, step=1.0, group="Display", tooltip="Only show bearish divergence above this entropy value.")

// SHANNON ENTROPY CORE ENGINE
f_entropy(float src, int len, int bins) =>
    float result = 0.5
    if bar_index >= len
        var price_arr = array.new<float>()
        array.clear(price_arr)
        
        float min_val = src
        float max_val = src
        
        for i = 0 to len - 1
            float val = src[i]
            array.push(price_arr, val)
            min_val := math.min(min_val, val)
            max_val := math.max(max_val, val)
        
        float range_val = max_val - min_val
        
        if range_val > 0
            float bin_size = range_val / bins
            var bin_counts = array.new<float>(bins, 0.0)
            array.fill(bin_counts, 0.0)
            
            for i = 0 to array.size(price_arr) - 1
                float val = array.get(price_arr, i)
                int bin_idx = int(math.floor((val - min_val) / bin_size))
                bin_idx := math.min(bin_idx, bins - 1)
                bin_idx := math.max(bin_idx, 0)
                
                float count = array.get(bin_counts, bin_idx)
                array.set(bin_counts, bin_idx, count + 1)
            
            float entropy = 0.0
            float total = float(len)
            
            for i = 0 to bins - 1
                float count = array.get(bin_counts, i)
                if count > 0
                    float prob = count / total
                    entropy -= prob * math.log(prob) / math.log(2)
            
            float max_entropy = math.log(bins) / math.log(2)
            result := entropy / max_entropy
    result

// ADAPTIVE PERCENTILE CALCULATION
f_percentile(float src, int len, float pct) =>
    float result = src
    if bar_index >= len
        var vals = array.new<float>()
        array.clear(vals)
        
        for i = 0 to len - 1
            array.push(vals, src[i])
        
        array.sort(vals, order.ascending)
        int idx = int(math.floor(array.size(vals) * pct / 100))
        idx := math.max(0, math.min(idx, array.size(vals) - 1))
        result := array.get(vals, idx)
    result

// ENTROPY CALCULATIONS
float price_entropy = f_entropy(close, entropy_length, price_bins)

float returns = ta.change(close) / close[1]
float return_entropy = f_entropy(returns, entropy_length, price_bins)

float vol_normalized = volume / ta.sma(volume, 20)
float volume_entropy = f_entropy(vol_normalized, entropy_length, price_bins)

float composite_raw = (price_entropy * 0.4) + (return_entropy * 0.35) + (volume_entropy * 0.25)
float composite = ta.ema(composite_raw, signal_smooth)

// ADAPTIVE THRESHOLD SYSTEM
float structure_threshold = f_percentile(composite, adaptive_lookback, percentile_low)
float chaos_threshold = f_percentile(composite, adaptive_lookback, percentile_high)
float mid_threshold = (structure_threshold + chaos_threshold) / 2

float entropy_min = f_percentile(composite, adaptive_lookback, 0)
float entropy_max = f_percentile(composite, adaptive_lookback, 100)
float entropy_range = entropy_max - entropy_min
float entropy_range_safe = entropy_range > 0 ? entropy_range : 1

float entropy_normalized = entropy_range > 0 ? ((composite - entropy_min) / entropy_range_safe) * 100 : 50
float entropy_smooth = ta.ema(entropy_normalized, 4)
float entropy_band_raw = ta.stdev(entropy_normalized, 20)
float entropy_band = math.min(nz(entropy_band_raw, 0.0) * 0.8, 12.0)
float entropy_upper = math.min(entropy_smooth + entropy_band, 100)
float entropy_lower = math.max(entropy_smooth - entropy_band, 0)

// MULTI-TIMEFRAME ENTROPY
float mtf1 = mtf_enabled ? request.security(syminfo.tickerid, mtf_tf1, composite, gaps=barmerge.gaps_off) : composite
float mtf2 = mtf_enabled ? request.security(syminfo.tickerid, mtf_tf2, composite, gaps=barmerge.gaps_off) : composite
float mtf3 = mtf_enabled ? request.security(syminfo.tickerid, mtf_tf3, composite, gaps=barmerge.gaps_off) : composite

float mtf_align = (math.abs(composite - mtf1) + math.abs(composite - mtf2) + math.abs(composite - mtf3)) / 3
bool mtf_confirmed = mtf_align < (entropy_range * 0.15)

// REGIME CLASSIFICATION
int regime = composite < structure_threshold ? 1 : composite > chaos_threshold ? -1 : 0
int regime_prev = regime[1]

float entropy_mom = ta.change(composite, 5)

float regime_strength = regime == 1 ? (structure_threshold - composite) / (structure_threshold - entropy_min) : regime == -1 ? (composite - chaos_threshold) / (entropy_max - chaos_threshold) : 0.0

// SIGNAL GENERATION
bool structure_signal = ta.crossunder(composite, structure_threshold) and entropy_mom < 0 and mtf_confirmed and regime_prev != 1
bool chaos_signal = ta.crossover(composite, chaos_threshold) and entropy_mom > 0 and mtf_confirmed and regime_prev != -1

// LEVEL SIGNALS
bool bullish_div = ta.crossunder(entropy_smooth, bull_div_level)
bool bearish_div = ta.crossover(entropy_smooth, bear_div_level)

// GRADIENT COLOR SYSTEM
color col_struct = #45977a
color col_chaos = #d15d5d
color col_neutral = #F2B84B
color col_div_bull = #22D1FF
color col_div_bear = #FF4D6D

color bull_primary = col_struct
color bull_secondary = color.rgb(0, 255, 76)
color bear_primary = col_chaos
color bear_secondary = #ff0011

f_blend(color c1, color c2, float t) =>
    int r = math.round(color.r(c1) + (color.r(c2) - color.r(c1)) * t)
    int g = math.round(color.g(c1) + (color.g(c2) - color.g(c1)) * t)
    int b = math.round(color.b(c1) + (color.b(c2) - color.b(c1)) * t)
    color.rgb(r, g, b)

get_dynamic_color(bool is_bullish, float strength) =>
    color base_color = is_bullish ? bull_primary : bear_primary
    color secondary_color = is_bullish ? bull_secondary : bear_secondary
    f_blend(secondary_color, base_color, strength)

float entropy_momentum = math.abs(ta.change(entropy_smooth, 3))
float entropy_momentum_max = nz(ta.highest(entropy_momentum, 50))
float entropy_intensity = entropy_momentum_max > 0 ? math.min(math.max(entropy_momentum / entropy_momentum_max, 0), 1) : 0

// VISUALIZATION
float struct_norm = entropy_range > 0 ? ((structure_threshold - entropy_min) / entropy_range_safe) * 100 : 50
float chaos_norm = entropy_range > 0 ? ((chaos_threshold - entropy_min) / entropy_range_safe) * 100 : 50
float mid_norm = entropy_range > 0 ? ((mid_threshold - entropy_min) / entropy_range_safe) * 100 : 50

bool entropy_bullish = entropy_smooth <= mid_norm
bool entropy_in_structure = entropy_smooth < struct_norm
bool entropy_in_chaos = entropy_smooth > chaos_norm
bool entropy_in_mid = not entropy_in_structure and not entropy_in_chaos
color line_color = entropy_in_mid ? col_neutral : entropy_in_structure ? get_dynamic_color(true, entropy_intensity) : get_dynamic_color(false, entropy_intensity)

int glow_line_width = entropy_line_width < 4 ? entropy_line_width + 1 : 4

int glow_transparency = int(math.round(70 + 15 * (1 - entropy_intensity)))
color glow_color = color.new(line_color, glow_transparency)
plot(show_glow ? entropy_smooth : na, "Entropy Glow", color=glow_color, linewidth=glow_line_width)
p_entropy = plot(entropy_smooth, "Entropy", color=line_color, linewidth=entropy_line_width)

p_struct = plot(struct_norm, "Structure", color=color.new(col_struct, 20), linewidth=2)
p_chaos = plot(chaos_norm, "Chaos", color=color.new(col_chaos, 20), linewidth=2)
p_mid = plot(mid_norm, "Neutral", color=color.new(col_neutral, 55), linewidth=1, style=plot.style_circles)

float mid_inner = (entropy_smooth + mid_norm) * 0.5
p_mid_inner = plot(mid_inner, "Entropy Mid Inner", display=display.none)

color mid_glow_color = entropy_in_mid ? col_neutral : entropy_bullish ? get_dynamic_color(true, 0.5) : get_dynamic_color(false, 0.5)
int mid_glow_alpha_strong = int(math.round(92 + 3 * (1 - entropy_intensity)))
int mid_glow_alpha_soft = int(math.round(96 + 2 * (1 - entropy_intensity)))
color mid_glow_strong = show_glow ? color.new(mid_glow_color, mid_glow_alpha_strong) : na
color mid_glow_soft = show_glow ? color.new(mid_glow_color, mid_glow_alpha_soft) : na
fill(p_entropy, p_mid_inner, color=mid_glow_strong, title="Entropy Mid Glow")
fill(p_mid_inner, p_mid, color=mid_glow_soft)

color fill_struct = show_fills ? color.new(col_struct, 92) : na
color fill_mid = show_fills ? color.new(col_neutral, 92) : na
color fill_chaos = show_fills ? color.new(col_chaos, 92) : na

fill(p_struct, p_mid, color=fill_struct)
fill(p_mid, p_chaos, color=fill_mid)

p_base = plot(0, color=na, display=display.none)
p_top = plot(100, color=na, display=display.none)
fill(p_base, p_struct, color=fill_struct)
fill(p_chaos, p_top, color=fill_chaos)

bool chaos_zone = show_fills and entropy_smooth > chaos_norm
bool struct_zone = show_fills and entropy_smooth < struct_norm

float chaos_grad_low = chaos_zone ? chaos_norm + (entropy_smooth - chaos_norm) * 0.33 : na
float chaos_grad_mid = chaos_zone ? chaos_norm + (entropy_smooth - chaos_norm) * 0.66 : na
float chaos_grad_top = chaos_zone ? entropy_smooth : na

float struct_grad_high = struct_zone ? struct_norm - (struct_norm - entropy_smooth) * 0.33 : na
float struct_grad_mid = struct_zone ? struct_norm - (struct_norm - entropy_smooth) * 0.66 : na
float struct_grad_low = struct_zone ? entropy_smooth : na

p_chaos_grad_low = plot(chaos_grad_low, "Chaos Grad Low", display=display.none)
p_chaos_grad_mid = plot(chaos_grad_mid, "Chaos Grad Mid", display=display.none)
p_chaos_grad_top = plot(chaos_grad_top, "Chaos Grad Top", display=display.none)

p_struct_grad_high = plot(struct_grad_high, "Struct Grad High", display=display.none)
p_struct_grad_mid = plot(struct_grad_mid, "Struct Grad Mid", display=display.none)
p_struct_grad_low = plot(struct_grad_low, "Struct Grad Low", display=display.none)

color chaos_grad_low_color = chaos_zone ? color.new(col_chaos, 92) : na
color chaos_grad_mid_color = chaos_zone ? color.new(col_chaos, 84) : na
color chaos_grad_top_color = chaos_zone ? color.new(col_chaos, 76) : na

color struct_grad_high_color = struct_zone ? color.new(col_struct, 92) : na
color struct_grad_mid_color = struct_zone ? color.new(col_struct, 84) : na
color struct_grad_low_color = struct_zone ? color.new(col_struct, 76) : na

fill(p_chaos, p_chaos_grad_low, color=chaos_grad_low_color)
fill(p_chaos_grad_low, p_chaos_grad_mid, color=chaos_grad_mid_color)
fill(p_chaos_grad_mid, p_chaos_grad_top, color=chaos_grad_top_color)

fill(p_struct, p_struct_grad_high, color=struct_grad_high_color)
fill(p_struct_grad_high, p_struct_grad_mid, color=struct_grad_mid_color)
fill(p_struct_grad_mid, p_struct_grad_low, color=struct_grad_low_color)

// SIGNALS
float bull_div_y = show_divergence and bullish_div ? math.max(entropy_smooth - div_marker_offset, 0) : na
float bear_div_y = show_divergence and bearish_div ? math.min(entropy_smooth + div_marker_offset, 100) : na

plotshape(bull_div_y, "Bull Div", style=shape.triangleup, location=location.absolute, color=color.new(col_div_bull, 0), size=size.tiny)
plotshape(bear_div_y, "Bear Div", style=shape.triangledown, location=location.absolute, color=color.new(col_div_bear, 0), size=size.tiny)
