// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © CharonQuant

//@version=6
// ______________________
//  (CharonQuant;:.:. .. )
//  T""""""""""""""""""""T
//  |.;....,..........;..|
//  |;;:: .  .    .      |
//  l;;;:. :   .     ..  ;
//  `;;:::.: .    .     .'
//   l;;:. ..  .     .: ;
//   `;;::.. .    .  ; .'
//    l;;:: .  .    /  ;
//     \;;:. .   .,'  /
//      `\;:.. ..'  .'
//        `\;:.. ..'
//          \;:. /
//           l; f
//           `;f'
//            ||
//            ;l.
//           ;: l
//          / ;  \
//        ,/  :   `.
//      ./' . :     `.
//     /' ,'  :       \
//    f  /  . :        i
//   ,' ;  .  :        `.
//   f ;  .   :      .  i
//  .'    :   :       . `.
//  f ,  .    ;       :  i
//  |    :  ,/`.       : |
//  |    ;,/;:. `.     . |
//  |___,/;;:. . .`._____|
// (!;:.:. .  CharonQuant)
//  """"""""""""""""""""""`
indicator("For Loop THMA ~ CharonQuant")
// ── Groups ────────────────────────────────────────────────────────────────
group_thma    = "THMA Core"
group_trend   = "Trend Filter (EMA)"
group_adx     = "ADX Trend Strength Filter"
group_forloop = "For-Loop Settings"

// ── Inputs ────────────────────────────────────────────────────────────────
len    = input.int(10,  "THMA Length",     minval=9,     group=group_thma, tooltip="Period used for the Triple Hull Moving Average (THMA).\nLower values = more responsive but more noise.")
src    = input.source(low, "Source Price",              group=group_thma)
emaLen = input.int(20,  "Trend EMA Length", minval=20, maxval=200, group=group_trend, tooltip="Length of the exponential moving average used as trend filter.\nPrice must be above this EMA for long signals (below for shorts).")

diLen       = input.int(13, "DI Length",        minval=1,  group=group_adx, tooltip="+DI and -DI period (Directional Movement Index).")
adxSmooth   = input.int(7,  "ADX Smoothing",    minval=1,  group=group_adx, tooltip="Smoothing period applied to the ADX line.\nLower values = faster ADX reaction.")
adxThreshold = input.int(27, "ADX Trend Threshold", minval=10, maxval=50, group=group_adx, tooltip="Minimum ADX value required to consider the market trending.\nSignals are blocked when ADX is below this level (helps avoid ranging/choppy markets).")

use_weighted = input.bool(false, "Weighted calculation", tooltip="Weights more to current price action", group=group_forloop)
from         = input.int(1,   "From number", tooltip="From which number does for loop perform calculations", group=group_forloop)
to_           = input.int(30,  "To number",   tooltip="To which number does for loop perform calculations", group=group_forloop)
long_level   = input.float(17, "Long",       tooltip="Long crossing point", group=group_forloop)
short_level  = input.float(-17,"Short",      tooltip="Short crossing point", group=group_forloop)
midline      = input.bool(false, "Midline signal", group=group_forloop)

// ── HMA helper ────────────────────────────────────────────────────────────
hma(src_, len_) =>
    wma1     = ta.wma(src_, math.floor(len_ / 2))
    wma_full = ta.wma(src_, len_)
    wma_diff = 2 * wma1 - wma_full
    ta.wma(wma_diff, math.floor(math.sqrt(len_)))

// ── THMA calculation ──────────────────────────────────────────────────────
hma1 = hma(src, len)
hma2 = hma(hma1, len)
hma3 = hma(hma2, len)
thma = 3 * hma1 - 3 * hma2 + hma3

// Replace 'med' directly with THMA
med = thma

// ── EMA filter ────────────────────────────────────────────────────────────
trendEma    = ta.ema(src, emaLen)
inUptrend   = src > trendEma
inDowntrend = src < trendEma

// ── ADX / DMI ─────────────────────────────────────────────────────────────
[diPlus, diMinus, adx] = ta.dmi(diLen, adxSmooth)
trending   = adx > adxThreshold
bullTrend  = diPlus > diMinus and trending
bearTrend  = diMinus > diPlus and trending

// ── For loop calc ─────────────────────────────────────────────────────────
counter = 0.0

dividor(int i, bool use) =>
    use ? i + 1 : 1

for i = from to to_
    counter := med > med[i] ? counter + 1/dividor(i, use_weighted) : counter - 1/dividor(i, use_weighted)

if use_weighted
    counter := (to_ - 1) * counter / ta.highest(math.abs(counter), 1000)

// ── Calculation variable for Midline crossing ─────────────────────────────
if midline
    long_level := 0.0
    short_level := 0.0

// ── Tren sp (transp?) ─────────────────────────────────────────────────────
trensp = (50 * (2 - math.abs(counter) / (to_ - 1))) - 50

// ── Trend and color defining ──────────────────────────────────────────────
var trend      = true
color BULL     = #D4A017
color BEAR     = #6B2A3A
color NEUTRAL  = color.gray

if counter > long_level
    trend   := true
    
if counter < short_level
    trend   := false
   

// ── Signals ────────────────────────────────────────────
finalLong  = trend and inUptrend and bullTrend
finalShort = not trend and inDowntrend and bearTrend

var CharonQuant = 0
if finalLong and not finalShort
    CharonQuant := 1
if finalShort
    CharonQuant := -1

// ── Plots ────────────────────────────────────────────────────────────────
t_color=CharonQuant==1?BULL:CharonQuant==-1?BEAR:NEUTRAL
hline(long_level, color =BULL)
hline(short_level, color = BEAR)
plot(counter, color = CharonQuant==1 ? BULL : CharonQuant ==-1 ? BEAR : na, linewidth = 1)
plot(counter, color = color.new(CharonQuant == -1 ? BEAR : BULL, 70), linewidth = 3)
plotcandle(open, high, low, close, 'BarColor', color = t_color, bordercolor = t_color, wickcolor = t_color, force_overlay = true)

// ── Alerts ────────────────────────────────────────────────────────────────
alertcondition(finalLong,  title="For Loop THMA Long",  message="For Loop THMA LONG {{exchange}}:{{ticker}}")
alertcondition(finalShort, title="For Loop THMA Short", message="For Loop THMA SHORT {{exchange}}:{{ticker}}")
