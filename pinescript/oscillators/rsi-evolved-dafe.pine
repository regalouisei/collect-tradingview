//@version=5
indicator("RSI: Evolved [DAFE]", shorttitle="RSI:E", overlay=false, max_labels_count=500, max_lines_count=500, max_boxes_count=500)
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                                                                                       â•‘
// â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â•‘
// â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â•‘
// â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â•‘
// â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â•  â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â•‘
// â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â•‘
// â•‘  â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•    â•šâ•â•â•â•â•â•â•  â•šâ•â•â•â•   â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•    â•‘
// â•‘                                                                                       â•‘
// â•‘                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                            â•‘
// â•‘                         âš¡ RSI: EVOLVED BY DAFE âš¡                                   â•‘
// â•‘                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                            â•‘
// â•‘                                                                                       â•‘
// â•‘                     ã€Œ  30+ RSI ENGINES â€¢ 15+ SMOOTHERS  ã€                            â•‘
// â•‘                     ã€Œ  SPECTRAL ANALYSIS â€¢ DIVERGENCE  ã€                             â•‘
// â•‘                     ã€Œ  QUANTUM ZONES â€¢ MULTI-TIMEFRAME  ã€                            â•‘
// â•‘                                                                                       â•‘
// â•‘                         DAFE Trading Systems - Dskyz                                  â•‘
// â•‘                                                                                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â„¹ï¸ TOOLTIP DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var string TT_ENGINE = "ğŸ§  MOMENTUM ENGINE SELECTION\n\nSelects the mathematical core driving the oscillator:\n\nâ€¢ CLASSIC: Time-tested calculations (Wilder, SMA, EMA).\nâ€¢ EXOTIC: Adaptive math (Laguerre, Vidya) that speeds up/slows down based on volatility.\nâ€¢ VOLUME: Weights price movement by Volume or Money Flow.\nâ€¢ DAFE PROPRIETARY: Physics-based engines (Quantum, Spectral, Kinetic) exclusive to this system."
var string TT_SMOOTH = "ğŸŒŠ SIGNAL SMOOTHING\n\nApplies a post-processing filter to the RSI line to reduce noise without significant lag.\n\nâ€¢ SuperSmoother/Gaussian: Best for removing high-frequency noise while keeping trend definition.\nâ€¢ JMA/Jurik: Best for low-lag responsiveness."
var string TT_FILTER = "ğŸ”¬ REGIME FILTER MODULE\n\nIntelligent pre-filtering of price data before RSI calculation:\n\nâ€¢ Volatility: Dampens signals during high volatility to prevent fake-outs.\nâ€¢ Trend: Aligns RSI bias with the longer-term trend.\nâ€¢ Composite: Blends all filters for maximum signal robustness."
var string TT_SIGNAL = "ğŸ“¡ SIGNAL LINE\n\nA moving average of the RSI itself. Crossovers between the RSI and Signal Line often precede price reversals and provide safer entry/exit points than OB/OS levels."
var string TT_BANDS  = "ğŸ“Š DYNAMIC VOLATILITY BANDS\n\nWraps the RSI in Bollinger or Keltner bands.\n\nâ€¢ SQUEEZE: When RSI bands contract, a violent move is imminent.\nâ€¢ BREAKOUT: RSI piercing the bands indicates a statistical extreme (2+ Sigma)."
var string TT_DIV    = "ğŸ”„ DIVERGENCE ENGINE\n\nDetects disconnects between Price and Momentum.\n\nâ€¢ Regular: Reversal signal (Price Lower Low, RSI Higher Low).\nâ€¢ Hidden: Trend Continuation signal (Price Higher Low, RSI Lower Low)."
var string TT_LEVELS = "ğŸ“ DYNAMIC ZONES\n\nStandard 70/30 levels fail in strong trends. Dynamic levels breathe with volatility.\n\nâ€¢ High Volatility: Levels widen (e.g., 85/15) to keep you in the trade.\nâ€¢ Low Volatility: Levels tighten (e.g., 60/40) to catch smaller range reversals."
var string TT_WAVE   = "ğŸ”® QUANTUM HORIZON\n\nVisualizes the 'History of Momentum' directly on the main chart.\n\nâ€¢ Displays the RSI wave history as a floating overlay.\nâ€¢ Allows you to see momentum structure without looking down at the oscillator pane."
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT GROUPS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string GRP_ENGINE   = "â•â•â•â•â•â•â•â•â•â• âš¡ RSI ENGINE âš¡ â•â•â•â•â•â•â•â•â•â•"
string GRP_SMOOTH   = "â•â•â•â•â•â•â•â•â•â• ğŸŒŠ SMOOTHER â•â•â•â•â•â•â•â•â•â•"
string GRP_FILTER   = "â•â•â•â•â•â•â•â•â•â• ğŸ”¬ FILTER MODULE â•â•â•â•â•â•â•â•â•â•"
string GRP_SIGNAL   = "â•â•â•â•â•â•â•â•â•â• ğŸ“¡ SIGNAL LINE â•â•â•â•â•â•â•â•â•â•"
string GRP_BANDS    = "â•â•â•â•â•â•â•â•â•â• ğŸ“Š RSI BANDS â•â•â•â•â•â•â•â•â•â•"
string GRP_DIVERG   = "â•â•â•â•â•â•â•â•â•â• ğŸ”„ DIVERGENCE â•â•â•â•â•â•â•â•â•â•"
string GRP_MTF      = "â•â•â•â•â•â•â•â•â•â• ğŸŒ MULTI-TIMEFRAME â•â•â•â•â•â•â•â•â•â•"
string GRP_LEVELS   = "â•â•â•â•â•â•â•â•â•â• ğŸ“ DYNAMIC LEVELS â•â•â•â•â•â•â•â•â•â•"
string GRP_VISUAL   = "â•â•â•â•â•â•â•â•â•â• ğŸ¨ VISUALS â•â•â•â•â•â•â•â•â•â•"
string GRP_DASH     = "â•â•â•â•â•â•â•â•â•â• ğŸ“± DASHBOARD â•â•â•â•â•â•â•â•â•â•"
string GRP_ALERT    = "â•â•â•â•â•â•â•â•â•â• ğŸ”” ALERTS â•â•â•â•â•â•â•â•â•â•"
string GRP_HORIZON  = "â•â•â•â•â•â•â•â•â•â• ğŸ”® QUANTUM HORIZON â•â•â•â•â•â•â•â•â•â•"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RSI ENGINE SELECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string RSI_CLASSIC  = "â”€â”€â”€â”€ CLASSIC â”€â”€â”€â”€"
string RSI_WILDER   = "Wilder's Original"
string RSI_CUTLER   = "Cutler's (SMA)"
string RSI_EMA      = "Exponential (EMA)"
string RSI_DEMA     = "Double EMA (DEMA)"
string RSI_TEMA     = "Triple EMA (TEMA)"
string RSI_WMA      = "Weighted (WMA)"
string RSI_HULL     = "Hull (HMA)"
string RSI_ZLEMA    = "Zero-Lag EMA"
string RSI_EXOTIC   = "â”€â”€â”€â”€ EXOTIC â”€â”€â”€â”€"
string RSI_LAGUERRE = "Laguerre Time-Warp"
string RSI_CONNORS  = "Connors RSI"
string RSI_STOCH    = "Stochastic RSI"
string RSI_RMI      = "Relative Momentum (RMI)"
string RSI_DYNAMIC  = "Dynamic Period RSI"
string RSI_VIDYA    = "VIDYA Adaptive"
string RSI_KAMA     = "KAMA Adaptive"
string RSI_FISHER   = "Fisher Transform RSI"
string RSI_INVERSE  = "Inverse Fisher RSI"
string RSI_COPPOCK  = "Coppock RSI"
string RSI_VOLUME   = "â”€â”€â”€â”€ VOLUME-BASED â”€â”€â”€â”€"
string RSI_VRSI     = "Volume-Weighted RSI"
string RSI_MFI      = "Money Flow RSI"
string RSI_VWRSI    = "VWAP-Weighted RSI"
string RSI_DAFE     = "â”€â”€â”€â”€ DAFE PROPRIETARY â”€â”€â”€â”€"
string RSI_QUANTUM  = "DAFE Quantum Fusion"
string RSI_SPECTRAL = "DAFE Spectral"
string RSI_KINETIC  = "DAFE Kinetic Energy"
string RSI_ENTROPY  = "DAFE Entropy Flow"
string RSI_NEURAL   = "DAFE Neural Blend"
string RSI_HARMONIC = "DAFE Harmonic"
string RSI_FRACTAL  = "DAFE Fractal Dimension"
string RSI_ULTIMATE = "DAFE Ultimate RSI"
i_rsi_type = input.string(RSI_QUANTUM, "RSI Calculation Engine", options=[
     RSI_CLASSIC, RSI_WILDER, RSI_CUTLER, RSI_EMA, RSI_DEMA, RSI_TEMA, RSI_WMA, RSI_HULL, RSI_ZLEMA,
     RSI_EXOTIC, RSI_LAGUERRE, RSI_CONNORS, RSI_STOCH, RSI_RMI, RSI_DYNAMIC, RSI_VIDYA, RSI_KAMA, RSI_FISHER, RSI_INVERSE, RSI_COPPOCK,
     RSI_VOLUME, RSI_VRSI, RSI_MFI, RSI_VWRSI,
     RSI_DAFE, RSI_QUANTUM, RSI_SPECTRAL, RSI_KINETIC, RSI_ENTROPY, RSI_NEURAL, RSI_HARMONIC, RSI_FRACTAL, RSI_ULTIMATE
     ], group=GRP_ENGINE, tooltip=TT_ENGINE)
i_rsi_len = input.int(14, "RSI Length", minval=2, maxval=200, group=GRP_ENGINE)
i_rsi_src = input.source(close, "Source", group=GRP_ENGINE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SMOOTHER SELECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string SM_NONE      = "None (Raw)"
string SM_SMA       = "SMA"
string SM_EMA       = "EMA"
string SM_WMA       = "WMA"
string SM_HMA       = "Hull MA"
string SM_DEMA      = "DEMA"
string SM_TEMA      = "TEMA"
string SM_ZLEMA     = "Zero-Lag EMA"
string SM_ALMA      = "ALMA"
string SM_T3        = "T3 Tilson"
string SM_VIDYA     = "VIDYA"
string SM_KAMA      = "KAMA"
string SM_SUPER     = "Ehlers SuperSmoother"
string SM_BUTTER    = "Butterworth"
string SM_GAUSS     = "Gaussian"
string SM_SINE      = "Sine-Weighted"
string SM_HAMMING   = "Hamming Window"
string SM_TRIANGULAR= "Triangular"
string SM_JURIK     = "Jurik-Style"
i_smooth_type = input.string(SM_SUPER, "Smoother Type", options=[
     SM_NONE, SM_SMA, SM_EMA, SM_WMA, SM_HMA, SM_DEMA, SM_TEMA, SM_ZLEMA, SM_ALMA, SM_T3,
     SM_VIDYA, SM_KAMA, SM_SUPER, SM_BUTTER, SM_GAUSS, SM_SINE, SM_HAMMING, SM_TRIANGULAR, SM_JURIK
     ], group=GRP_SMOOTH, tooltip=TT_SMOOTH)
i_smooth_len = input.int(5, "Smooth Length", minval=1, maxval=50, group=GRP_SMOOTH)
i_smooth_power = input.float(2.0, "Smooth Power/Factor", minval=0.1, maxval=5.0, step=0.1, group=GRP_SMOOTH)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILTER MODULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
i_filter_enable = input.bool(true, "Enable Filter Module", group=GRP_FILTER, tooltip=TT_FILTER)
string FLT_NONE     = "None"
string FLT_TREND    = "Trend Filter"
string FLT_VOL      = "Volatility Filter"
string FLT_MOM      = "Momentum Filter"
string FLT_RANGE    = "Range Filter"
string FLT_COMPOSITE= "Composite Filter"
i_filter_type = input.string(FLT_COMPOSITE, "Filter Type", options=[
     FLT_NONE, FLT_TREND, FLT_VOL, FLT_MOM, FLT_RANGE, FLT_COMPOSITE
     ], group=GRP_FILTER)
i_filter_str = input.float(1.0, "Filter Strength", minval=0.1, maxval=3.0, step=0.1, group=GRP_FILTER)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
i_signal_enable = input.bool(true, "Show Signal Line", group=GRP_SIGNAL, tooltip=TT_SIGNAL)
i_signal_len = input.int(9, "Signal Length", minval=1, maxval=50, group=GRP_SIGNAL)
i_signal_type = input.string(SM_EMA, "Signal Type", options=[
     SM_SMA, SM_EMA, SM_WMA, SM_HMA, SM_DEMA, SM_TEMA
     ], group=GRP_SIGNAL)
i_bands_enable = input.bool(true, "Show RSI Bands", group=GRP_BANDS, tooltip=TT_BANDS)
string BAND_BB      = "Bollinger Bands"
string BAND_KC      = "Keltner Channels"
string BAND_ENV     = "Envelope"
string BAND_STDEV   = "Standard Deviation"
i_bands_type = input.string(BAND_BB, "Band Type", options=[BAND_BB, BAND_KC, BAND_ENV, BAND_STDEV], group=GRP_BANDS)
i_bands_len = input.int(20, "Band Length", minval=5, maxval=100, group=GRP_BANDS)
i_bands_mult = input.float(2.0, "Band Multiplier", minval=0.5, maxval=5.0, step=0.1, group=GRP_BANDS)
i_div_enable = input.bool(true, "Enable Divergence Detection", group=GRP_DIVERG, tooltip=TT_DIV)
i_div_regular = input.bool(true, "Show Regular Divergences", group=GRP_DIVERG)
i_div_hidden = input.bool(true, "Show Hidden Divergences", group=GRP_DIVERG)
i_div_lookback = input.int(5, "Pivot Lookback", minval=2, maxval=20, group=GRP_DIVERG)
i_div_range = input.int(60, "Divergence Range", minval=10, maxval=200, group=GRP_DIVERG)
i_mtf_enable = input.bool(true, "Enable MTF Analysis", group=GRP_MTF)
i_mtf_tf1 = input.timeframe("60", "Timeframe 1", group=GRP_MTF)
i_mtf_tf2 = input.timeframe("240", "Timeframe 2", group=GRP_MTF)
i_mtf_tf3 = input.timeframe("D", "Timeframe 3", group=GRP_MTF)
i_horizon_enable = input.bool(true, "Enable Quantum Horizon Display", group=GRP_HORIZON, tooltip=TT_WAVE)
i_horizon_depth = input.int(50, "Wave History Depth", minval=20, maxval=100, group=GRP_HORIZON)
i_horizon_spacing = input.int(-60, "Horizon Spacing", minval=-150, maxval=0, group=GRP_HORIZON)
i_horizon_start_offset = input.int(60, "Starting Position Offset", minval=0, maxval=150, group=GRP_HORIZON)
string HORIZON_RSI = "RSI"
string HORIZON_MFI = "MFI"
string HORIZON_STOCH = "Stochastic RSI"
i_horizon_wave_type = input.string(HORIZON_RSI, "Wave Calculation Type", options=[HORIZON_RSI, HORIZON_MFI, HORIZON_STOCH], group=GRP_HORIZON)
i_horizon_wave_color = input.color(#9D00FF, "Primary Wave Color", group=GRP_HORIZON)
i_horizon_signal_color = input.color(#FFD700, "Signal Flow Color", group=GRP_HORIZON)
string GRP_TEMPORAL = "â•â•â•â•â•â•â•â•â•â• ğŸŒŠ TEMPORAL WAVE â•â•â•â•â•â•â•â•â•â•"
i_temporal_wave_enable = input.bool(true, "Enable Temporal Wave Display", group=GRP_TEMPORAL, 
     tooltip="Show multi-timeframe RSI wave visualization overlay on main chart")
string TEMPORAL_LOCATION_BOTTOM = "Bottom of Chart"
string TEMPORAL_LOCATION_TOP = "Top of Chart"
i_temporal_wave_location = input.string(TEMPORAL_LOCATION_BOTTOM, "Display Location", 
     options=[TEMPORAL_LOCATION_BOTTOM, TEMPORAL_LOCATION_TOP], group=GRP_TEMPORAL,
     tooltip="Choose whether to display waves at the top or bottom of the chart")
string TEMPORAL_RSI = "RSI"
string TEMPORAL_MFI = "MFI"
string TEMPORAL_STOCH = "Stochastic RSI"
i_temporal_wave_type = input.string(TEMPORAL_RSI, "Oscillator Type", 
     options=[TEMPORAL_RSI, TEMPORAL_MFI, TEMPORAL_STOCH], group=GRP_TEMPORAL)
i_temporal_wave_1_show = input.bool(true, "Show Horizon 1", group=GRP_TEMPORAL, inline="h1")
i_temporal_wave_1_period = input.int(14, "Period", group=GRP_TEMPORAL, inline="h1", minval=2, maxval=100)
i_temporal_wave_1_signal = input.int(14, "Signal", group=GRP_TEMPORAL, inline="h1", minval=2, maxval=100)
i_temporal_wave_2_show = input.bool(true, "Show Horizon 2", group=GRP_TEMPORAL, inline="h2")
i_temporal_wave_2_period = input.int(14, "Period", group=GRP_TEMPORAL, inline="h2", minval=2, maxval=100)
i_temporal_wave_2_signal = input.int(14, "Signal", group=GRP_TEMPORAL, inline="h2", minval=2, maxval=100)
i_temporal_wave_3_show = input.bool(true, "Show Horizon 3", group=GRP_TEMPORAL, inline="h3")
i_temporal_wave_3_period = input.int(14, "Period", group=GRP_TEMPORAL, inline="h3", minval=2, maxval=100)
i_temporal_wave_3_signal = input.int(14, "Signal", group=GRP_TEMPORAL, inline="h3", minval=2, maxval=100)
i_levels_dynamic = input.bool(true, "Use Dynamic Levels", group=GRP_LEVELS, tooltip=TT_LEVELS)
i_ob_level = input.int(70, "Overbought Level", minval=50, maxval=95, group=GRP_LEVELS)
i_os_level = input.int(30, "Oversold Level", minval=5, maxval=50, group=GRP_LEVELS)
i_extreme_ob = input.int(80, "Extreme Overbought", minval=60, maxval=99, group=GRP_LEVELS)
i_extreme_os = input.int(20, "Extreme Oversold", minval=1, maxval=40, group=GRP_LEVELS)
string VIS_QUANTUM  = "Quantum Gradient"
string VIS_SPECTRAL = "Spectral Flow"
string VIS_PLASMA   = "Plasma Heat"
string VIS_NEON     = "Neon Pulse"
string VIS_CLASSIC  = "Classic Style"
i_visual_theme = input.string(VIS_QUANTUM, "Visual Theme", options=[
     VIS_QUANTUM, VIS_SPECTRAL, VIS_PLASMA, VIS_NEON, VIS_CLASSIC
     ], group=GRP_VISUAL)
i_glow_enable = input.bool(true, "Enable Glow Effect", group=GRP_VISUAL)
i_fill_enable = input.bool(true, "Enable Zone Fills", group=GRP_VISUAL)
i_hist_enable = input.bool(true, "Show Momentum Histogram", group=GRP_VISUAL)
i_candle_color = input.bool(false, "Color Price Candles", group=GRP_VISUAL)
i_bg_zones = input.bool(true, "Show Background Zones", group=GRP_VISUAL)
i_dash_enable = input.bool(true, "Show Dashboard", group=GRP_DASH)
string DASH_FULL    = "Full Dashboard"
string DASH_COMPACT = "Compact"
string DASH_MINI    = "Mini"
i_dash_size = input.string(DASH_FULL, "Dashboard Size", options=[DASH_FULL, DASH_COMPACT, DASH_MINI], group=GRP_DASH)
i_dash_pos = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=GRP_DASH)
string DASH_MODE_OVERLAY = "Main Chart Overlay"
string DASH_MODE_PANEL   = "Indicator Panel"
i_dash_display_mode = input.string(DASH_MODE_PANEL, "Dashboard Location", 
     options=[DASH_MODE_OVERLAY, DASH_MODE_PANEL], group=GRP_DASH, 
     tooltip="Select whether dashboard appears on main price chart or within indicator panel")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLOR PALETTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
color DAFE_CYAN      = #00FFFF
color DAFE_MAGENTA   = #FF00FF
color DAFE_GOLD      = #FFD700
color DAFE_NEON_BLUE = #00BFFF
color DAFE_PURPLE    = #9D00FF
color DAFE_GREEN     = #00FF88
color DAFE_RED       = #FF0055
color DAFE_ORANGE    = #FF6600
color DAFE_PINK      = #FF69B4
color DAFE_ELECTRIC  = #7DF9FF
color DAFE_PLASMA    = #FF1493
color DAFE_VOID      = #0D0D1A
color DAFE_PANEL     = #0A0A14
color DAFE_BORDER    = #1E1E32
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_tanh(x) =>
    exp2x = math.exp(2 * x)
    (exp2x - 1) / (exp2x + 1)
f_up_down(src) =>
    change = src - src[1]
    up = math.max(change, 0)
    down = math.abs(math.min(change, 0))
    [up, down]
f_rsi_basic(src, len, ma_type) =>
    [up, down] = f_up_down(src)
    float avg_up = 0.0
    float avg_down = 0.0
    if ma_type == RSI_WILDER or ma_type == "RMA"
        avg_up := ta.rma(up, len)
        avg_down := ta.rma(down, len)
    else if ma_type == RSI_CUTLER or ma_type == "SMA"
        avg_up := ta.sma(up, len)
        avg_down := ta.sma(down, len)
    else if ma_type == RSI_EMA or ma_type == "EMA"
        avg_up := ta.ema(up, len)
        avg_down := ta.ema(down, len)
    else if ma_type == RSI_WMA or ma_type == "WMA"
        avg_up := ta.wma(up, len)
        avg_down := ta.wma(down, len)
    else
        avg_up := ta.rma(up, len)
        avg_down := ta.rma(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_dema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    2 * ema1 - ema2
f_tema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    ema3 = ta.ema(ema2, len)
    3 * ema1 - 3 * ema2 + ema3
f_hma(src, len) =>
    ta.wma(2 * ta.wma(src, len/2) - ta.wma(src, len), math.round(math.sqrt(len)))
f_zlema(src, len) =>
    lag = math.floor((len - 1) / 2)
    src_adj = src + (src - src[lag])
    ta.ema(src_adj, len)
f_vidya(src, len) =>
    alpha = 2.0 / (len + 1)
    mom_up = ta.mom(src, 1) > 0 ? ta.mom(src, 1) : 0.0
    mom_down = ta.mom(src, 1) < 0 ? -ta.mom(src, 1) : 0.0
    sum_up = math.sum(mom_up, 9)
    sum_down = math.sum(mom_down, 9)
    cmo = (sum_up - sum_down) / (sum_up + sum_down + 0.0001)
    var float vidya = na
    vidya := alpha * math.abs(cmo) * src + (1 - alpha * math.abs(cmo)) * nz(vidya[1], src)
    vidya
f_kama(src, len) =>
    change_sum = math.abs(src - src[len])
    volatility = math.sum(math.abs(src - src[1]), len)
    er = volatility != 0 ? change_sum / volatility : 0
    fast = 2.0 / (2 + 1)
    slow = 2.0 / (30 + 1)
    sc = math.pow(er * (fast - slow) + slow, 2)
    var float kama = na
    kama := sc * src + (1 - sc) * nz(kama[1], src)
    kama
f_supersmoother(src, len) =>
    a1 = math.exp(-1.414 * math.pi / len)
    b1 = 2 * a1 * math.cos(1.414 * math.pi / len)
    c2 = b1
    c3 = -a1 * a1
    c1 = 1 - c2 - c3
    var float ss = na
    ss := c1 * (src + nz(src[1])) / 2 + c2 * nz(ss[1]) + c3 * nz(ss[2])
    ss
f_butterworth(src, len) =>
    a1 = math.exp(-1.414 * math.pi / len)
    b1 = 2 * a1 * math.cos(1.414 * math.pi / len)
    c2 = b1
    c3 = -a1 * a1
    c1 = (1 - b1 + a1 * a1) / 4
    var float bw = na
    bw := c1 * (src + 2 * nz(src[1]) + nz(src[2])) + c2 * nz(bw[1]) + c3 * nz(bw[2])
    bw
f_gaussian(src, len, poles) =>
    beta = (1 - math.cos(2 * math.pi / len)) / (math.pow(2, 1.0/poles) - 1)
    alpha = -beta + math.sqrt(beta * beta + 2 * beta)
    var float gauss = na
    gauss := alpha * src + (1 - alpha) * nz(gauss[1])
    gauss
f_t3(src, len, factor) =>
    e1 = ta.ema(src, len)
    e2 = ta.ema(e1, len)
    gd1 = e1 * (1 + factor) - e2 * factor    
    e3 = ta.ema(gd1, len)
    e4 = ta.ema(e3, len)
    gd2 = e3 * (1 + factor) - e4 * factor   
    e5 = ta.ema(gd2, len)
    e6 = ta.ema(e5, len)
    gd3 = e5 * (1 + factor) - e6 * factor   
    gd3
f_sine_wma(src, len) =>
    sum = 0.0
    weight_sum = 0.0
    for i = 0 to len - 1
        weight = math.sin((i + 1) * math.pi / (len + 1))
        sum += src[i] * weight
        weight_sum += weight
    sum / weight_sum
f_hamming(src, len) =>
    sum = 0.0
    weight_sum = 0.0
    for i = 0 to len - 1
        weight = 0.54 - 0.46 * math.cos(2 * math.pi * i / (len - 1))
        sum += src[i] * weight
        weight_sum += weight
    sum / weight_sum
f_triangular(src, len) =>
    ta.sma(ta.sma(src, math.ceil(len/2)), math.floor(len/2) + 1)
f_jurik_smooth(src, len, power) =>
    beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
    alpha = math.pow(beta, power)
    var float j1 = na
    var float j2 = na
    var float jma = na
    j1 := (1 - alpha) * src + alpha * nz(j1[1])
    j2 := (src - j1) * (1 - beta) + beta * nz(j2[1])
    jma := j1 + j2
    jma
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RSI ENGINE FUNCTIONS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_rsi_dema(src, len) =>
    [up, down] = f_up_down(src)
    avg_up = f_dema(up, len)
    avg_down = f_dema(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_tema(src, len) =>
    [up, down] = f_up_down(src)
    avg_up = f_tema(up, len)
    avg_down = f_tema(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_hull(src, len) =>
    [up, down] = f_up_down(src)
    avg_up = f_hma(up, len)
    avg_down = f_hma(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_zlema(src, len) =>
    [up, down] = f_up_down(src)
    avg_up = f_zlema(up, len)
    avg_down = f_zlema(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_laguerre(src, len) =>
    gamma = 1.0 - (2.0 / (len + 1))
    var float L0 = 0.0, var float L1 = 0.0, var float L2 = 0.0, var float L3 = 0.0
    L0 := (1 - gamma) * src + gamma * nz(L0[1])
    L1 := -gamma * L0 + nz(L0[1]) + gamma * nz(L1[1])
    L2 := -gamma * L1 + nz(L1[1]) + gamma * nz(L2[1])
    L3 := -gamma * L2 + nz(L2[1]) + gamma * nz(L3[1])
    cu = (L0 >= L1 ? L0 - L1 : 0) + (L1 >= L2 ? L1 - L2 : 0) + (L2 >= L3 ? L2 - L3 : 0)
    cd = (L0 < L1 ? L1 - L0 : 0) + (L1 < L2 ? L2 - L1 : 0) + (L2 < L3 ? L3 - L2 : 0)
    denom = cu + cd == 0 ? 1 : cu + cd
    100 * cu / denom
f_rsi_connors(src, len) =>
    rsi_short = f_rsi_basic(src, 3, RSI_WILDER)
    var int streak = 0
    if src > src[1]
        streak := streak > 0 ? streak + 1 : 1
    else if src < src[1]
        streak := streak < 0 ? streak - 1 : -1
    else
        streak := 0
    rsi_streak = f_rsi_basic(streak, 2, RSI_WILDER)
    roc_val = (src - src[1]) / src[1] * 100
    count = 0
    for i = 1 to len * 7
        if roc_val > (src[i] - src[i+1]) / src[i+1] * 100
            count += 1
    pct_rank = count / (len * 7) * 100
    (rsi_short + rsi_streak + pct_rank) / 3
f_rsi_stoch(src, len) =>
    rsi_val = f_rsi_basic(src, len, RSI_WILDER)
    lowest_rsi = ta.lowest(rsi_val, len)
    highest_rsi = ta.highest(rsi_val, len)
    range_rsi = highest_rsi - lowest_rsi
    stoch = range_rsi == 0 ? 50 : (rsi_val - lowest_rsi) / range_rsi * 100
    stoch
f_rmi(src, len, mom_len) =>
    up = math.max(src - src[mom_len], 0)
    down = math.abs(math.min(src - src[mom_len], 0))
    avg_up = ta.rma(up, len)
    avg_down = ta.rma(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_dynamic(src, base_len) =>
    atr_val = ta.atr(14)
    atr_sma = ta.sma(atr_val, 50)
    vol_ratio = atr_sma != 0 ? atr_val / atr_sma : 1.0
    rsi_fast = f_rsi_basic(src, math.max(math.round(base_len / 2), 2), RSI_WILDER)
    rsi_mid = f_rsi_basic(src, base_len, RSI_WILDER)
    rsi_slow = f_rsi_basic(src, base_len * 2, RSI_WILDER)
    vol_clamped = math.max(math.min(vol_ratio, 2.0), 0.5)
    weight = (vol_clamped - 0.5) / 1.5  
    float result = 0.0
    if weight > 0.5
        fast_weight = (weight - 0.5) * 2
        result := rsi_fast * fast_weight + rsi_mid * (1 - fast_weight)
    else
        slow_weight = (0.5 - weight) * 2
        result := rsi_mid * (1 - slow_weight) + rsi_slow * slow_weight   
    result
f_rsi_vidya(src, len) =>
    [up, down] = f_up_down(src)
    avg_up = f_vidya(up, len)
    avg_down = f_vidya(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_kama(src, len) =>
    [up, down] = f_up_down(src)
    avg_up = f_kama(up, len)
    avg_down = f_kama(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_fisher(src, len) =>
    rsi_val = f_rsi_basic(src, len, RSI_WILDER)
    x = (rsi_val - 50) / 50 * 0.999
    fisher = 0.5 * math.log((1 + x) / (1 - x))
    50 + fisher * 20
f_rsi_inverse_fisher(src, len) =>
    rsi_val = f_rsi_basic(src, len, RSI_WILDER)
    x = (rsi_val - 50) / 10
    inv_fisher = (math.exp(2 * x) - 1) / (math.exp(2 * x) + 1)
    50 + inv_fisher * 50
f_rsi_coppock(src, len) =>
    roc1 = ta.roc(src, 14)
    roc2 = ta.roc(src, 11)
    coppock = ta.wma(roc1 + roc2, 10)
    lowest_cop = ta.lowest(coppock, len * 5)
    highest_cop = ta.highest(coppock, len * 5)
    range_cop = highest_cop - lowest_cop
    range_cop == 0 ? 50 : (coppock - lowest_cop) / range_cop * 100
f_rsi_volume(src, len) =>
    change = src - src[1]
    vol_up = change > 0 ? change * volume : 0
    vol_down = change < 0 ? math.abs(change) * volume : 0
    avg_up = ta.rma(vol_up, len)
    avg_down = ta.rma(vol_down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_mfi(src, len) =>
    typ = hlc3
    mf = typ * volume
    mf_pos = typ > typ[1] ? mf : 0
    mf_neg = typ < typ[1] ? mf : 0
    sum_pos = math.sum(mf_pos, len)
    sum_neg = math.sum(mf_neg, len)
    mf_ratio = sum_neg == 0 ? 100 : sum_pos / sum_neg
    100 - (100 / (1 + mf_ratio))
f_rsi_vwap(src, len) =>
    vwap_val = ta.vwap(src)
    deviation = src - vwap_val
    up = math.max(deviation - deviation[1], 0)
    down = math.abs(math.min(deviation - deviation[1], 0))
    avg_up = ta.rma(up, len)
    avg_down = ta.rma(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAFE PROPRIETARY ENGINES 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_rsi_quantum(src, len) =>
    r1 = f_rsi_basic(src, len, RSI_WILDER)
    r2 = f_rsi_basic(src, math.round(len * 1.618), RSI_WILDER)  // Golden ratio
    r3 = f_rsi_basic(src, math.round(len * 2.618), RSI_WILDER)  // Golden ratio^2
    vol_ratio = volume / ta.sma(volume, 20)
    vol_factor = math.min(vol_ratio, 2.0)
    mom = ta.mom(src, len)
    mom_norm = mom / ta.stdev(mom, len * 2)
    mom_factor = f_tanh(mom_norm) * 0.5 + 0.5
    blend = r1 * 0.5 + r2 * 0.3 + r3 * 0.2
    result = blend * (1 + (mom_factor - 0.5) * 0.2 * vol_factor)
    math.min(math.max(result, 0), 100)
f_rsi_spectral(src, len) =>
    fast_rsi = f_rsi_basic(src, math.round(len * 0.5), RSI_EMA)
    med_rsi = f_rsi_basic(src, len, RSI_WILDER)
    slow_rsi = f_rsi_basic(src, len * 2, RSI_WILDER)
    diff1 = math.abs(fast_rsi - med_rsi)
    diff2 = math.abs(med_rsi - slow_rsi)
    total_diff = diff1 + diff2 + 0.001
    w1 = 1 - diff1 / total_diff
    w2 = 1 - diff2 / total_diff
    total_w = w1 + w2 + 1
    (fast_rsi * w1 + med_rsi * 1 + slow_rsi * w2) / total_w
f_rsi_kinetic(src, len) =>
    mom = src - src[1]
    vol_norm = volume / ta.sma(volume, 50)
    kinetic = math.abs(mom) * math.sqrt(vol_norm)
    kinetic_dir = mom > 0 ? kinetic : -kinetic
    up = math.max(kinetic_dir, 0)
    down = math.abs(math.min(kinetic_dir, 0))    
    avg_up = ta.rma(up, len)
    avg_down = ta.rma(down, len)
    rs = avg_down == 0 ? 100 : avg_up / avg_down
    100 - (100 / (1 + rs))
f_rsi_entropy(src, len) =>
    log_ret = math.log(src / src[1])
    entropy = ta.stdev(log_ret, len)
    entropy_ma = ta.sma(entropy, len * 2)
    trend_rsi = f_rsi_basic(src, len, RSI_WILDER)
    entropy_ratio = entropy / entropy_ma
    entropy_factor = f_tanh(entropy_ratio - 1)
    result = trend_rsi + entropy_factor * (50 - trend_rsi) * 0.3
    math.min(math.max(result, 0), 100)
f_rsi_neural(src, len) =>
    input1 = f_rsi_basic(src, len, RSI_WILDER)
    input2 = f_rsi_basic(src, len, RSI_EMA)
    input3 = f_rsi_laguerre(src, len)
    input4 = f_rsi_volume(src, len)
    h1 = f_tanh((input1 - 50) / 25) * 50 + 50
    h2 = f_tanh((input2 - 50) / 25) * 50 + 50
    h3 = f_tanh((input3 - 50) / 25) * 50 + 50
    h4 = f_tanh((input4 - 50) / 25) * 50 + 50
    dev1 = ta.stdev(input1, len)
    dev2 = ta.stdev(input2, len)
    dev3 = ta.stdev(input3, len)
    dev4 = ta.stdev(input4, len)
    total_dev = dev1 + dev2 + dev3 + dev4 + 0.001
    w1 = dev1 / total_dev
    w2 = dev2 / total_dev
    w3 = dev3 / total_dev
    w4 = dev4 / total_dev
    (h1 * w1 + h2 * w2 + h3 * w3 + h4 * w4)
f_rsi_harmonic(src, len) =>
    r1 = f_rsi_basic(src, 8, RSI_WILDER)
    r2 = f_rsi_basic(src, 13, RSI_WILDER)
    r3 = f_rsi_basic(src, 21, RSI_WILDER)
    r4 = f_rsi_basic(src, 34, RSI_WILDER)
    n = 4.0
    harm_mean = n / (1/math.max(r1, 0.001) + 1/math.max(r2, 0.001) + 1/math.max(r3, 0.001) + 1/math.max(r4, 0.001))
    harm_mean
f_rsi_fractal(src, len) =>
    n1 = (ta.highest(high, len) - ta.lowest(low, len)) / len
    n2 = (ta.highest(high, len*2) - ta.lowest(low, len*2)) / (len*2)
    fd = n2 != 0 ? math.log(n1 / n2) / math.log(2) : 1.5
    fd := math.min(math.max(fd, 1.0), 2.0)
    base_rsi = f_rsi_basic(src, len, RSI_WILDER)
    fd_factor = (fd - 1.0) * 2  
    result = base_rsi + (50 - base_rsi) * fd_factor * 0.3
    result
f_rsi_ultimate(src, len) =>
    r_wilder = f_rsi_basic(src, len, RSI_WILDER)
    r_laguerre = f_rsi_laguerre(src, len)
    r_volume = f_rsi_volume(src, len)
    r_kinetic = f_rsi_kinetic(src, len)
    r_stoch = f_rsi_stoch(src, len)
    trend_ma = ta.ema(src, len * 2)
    trend_dir = src > trend_ma ? 1.0 : -1.0
    atr_norm = ta.atr(len) / ta.sma(ta.atr(len), len * 2)
    vol_factor = math.min(atr_norm, 2.0)
    vol_ratio = volume / ta.sma(volume, len)
    vol_weight = math.min(vol_ratio, 2.0)
    w1 = 0.25
    w2 = 0.20
    w3 = 0.20 * vol_weight
    w4 = 0.20 * vol_factor
    w5 = 0.15
    total_w = w1 + w2 + w3 + w4 + w5
    blend = (r_wilder * w1 + r_laguerre * w2 + r_volume * w3 + r_kinetic * w4 + r_stoch * w5) / total_w
    result = blend + trend_dir * (math.abs(blend - 50) * 0.1)
    math.min(math.max(result, 0), 100)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUANTUM HORIZON FUNCTIONS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_nexus_period_label(horizon_period) =>
    int total_seconds = timeframe.in_seconds(horizon_period)
    int period_minutes = total_seconds / 60
    int period_hours = total_seconds / 3600
    int period_days = total_seconds / 86400    
    string formatted_label = ""
    if period_hours >= 24
        formatted_label := str.tostring(period_days) + "D"
    else if period_hours >= 1
        formatted_label := str.tostring(period_hours) + "H"
    else if period_minutes >= 1
        formatted_label := str.tostring(period_minutes) + "M"
    else
        formatted_label := str.tostring(total_seconds) + "S"
    formatted_label
f_nexus_stoch_wave(wave_len) =>
    momentum_base = ta.rsi(close, wave_len)
    stoch_k = ta.sma(ta.stoch(momentum_base, momentum_base, momentum_base, 14), 3)
    stoch_k
f_nexus_render_horizon(wave_period, wave_smooth_len, target_horizon, history_len, position_offset, show_grid_labels) =>
    float primary_wave = switch i_horizon_wave_type
        HORIZON_RSI => ta.rsi(close, wave_period)
        HORIZON_MFI => ta.mfi(hlc3, wave_period)
        HORIZON_STOCH => f_nexus_stoch_wave(wave_period)
        => ta.rsi(close, wave_period)   
    float signal_wave = ta.sma(primary_wave, wave_smooth_len)
    [horizon_primary, horizon_signal] = request.security(syminfo.tickerid, target_horizon, [primary_wave, signal_wave])
    var array<chart.point> primary_coords = array.new<chart.point>()
    var array<chart.point> signal_coords = array.new<chart.point>()
    if barstate.islast
        primary_coords.clear()
        signal_coords.clear()
        line grid_center = line.new(bar_index + position_offset, 50, bar_index - history_len + position_offset, 50, style=line.style_dashed, color=color.new(color.gray, 60))
        line grid_upper = line.new(bar_index + position_offset, 70, bar_index - history_len + position_offset, 70, style=line.style_dashed, color=color.new(color.gray, 70))
        line grid_lower = line.new(bar_index + position_offset, 30, bar_index - history_len + position_offset, 30, style=line.style_dashed, color=color.new(color.gray, 70))
        line.delete(grid_center[1])
        line.delete(grid_upper[1])
        line.delete(grid_lower[1])
        linefill zone_fill = linefill.new(grid_upper, grid_lower, color.new(DAFE_PURPLE, 92))
        linefill.delete(zone_fill[1])
        for wave_idx = 0 to history_len - 1
            float wave_val = horizon_primary[wave_idx]
            float signal_val = horizon_signal[wave_idx]
            primary_coords.push(chart.point.from_index(bar_index - wave_idx + position_offset, wave_val))
            signal_coords.push(chart.point.from_index(bar_index - wave_idx + position_offset, signal_val))
        string direction_arrow = horizon_primary > horizon_signal ? " â–²" : " â–¼"
        label horizon_label = label.new(bar_index - int(history_len / 2) + position_offset, 18, 
             "Horizon: " + f_nexus_period_label(target_horizon) + direction_arrow, 
             style=label.style_label_up, textcolor=chart.fg_color, color=color(na))
        label.delete(horizon_label[1])
        if show_grid_labels
            label upper_ref = label.new(bar_index + position_offset, 70, "70", style=label.style_label_left, textcolor=chart.fg_color, color=color(na))
            label lower_ref = label.new(bar_index + position_offset, 30, "30", style=label.style_label_left, textcolor=chart.fg_color, color=color(na))
            label type_ref = label.new(bar_index + position_offset, 50, i_horizon_wave_type, style=label.style_label_left, textcolor=chart.fg_color, color=color(na))
            label.delete(upper_ref[1])
            label.delete(lower_ref[1])
            label.delete(type_ref[1])
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN RSI CALCULATION 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_calculate_rsi(src, len, rsi_type) =>
    float result = 50.0    
    if rsi_type == RSI_WILDER
        result := f_rsi_basic(src, len, RSI_WILDER)
    else if rsi_type == RSI_CUTLER
        result := f_rsi_basic(src, len, RSI_CUTLER)
    else if rsi_type == RSI_EMA
        result := f_rsi_basic(src, len, RSI_EMA)
    else if rsi_type == RSI_DEMA
        result := f_rsi_dema(src, len)
    else if rsi_type == RSI_TEMA
        result := f_rsi_tema(src, len)
    else if rsi_type == RSI_WMA
        result := f_rsi_basic(src, len, RSI_WMA)
    else if rsi_type == RSI_HULL
        result := f_rsi_hull(src, len)
    else if rsi_type == RSI_ZLEMA
        result := f_rsi_zlema(src, len)
    else if rsi_type == RSI_LAGUERRE
        result := f_rsi_laguerre(src, len)
    else if rsi_type == RSI_CONNORS
        result := f_rsi_connors(src, len)
    else if rsi_type == RSI_STOCH
        result := f_rsi_stoch(src, len)
    else if rsi_type == RSI_RMI
        result := f_rmi(src, len, 4)
    else if rsi_type == RSI_DYNAMIC
        result := f_rsi_dynamic(src, len)
    else if rsi_type == RSI_VIDYA
        result := f_rsi_vidya(src, len)
    else if rsi_type == RSI_KAMA
        result := f_rsi_kama(src, len)
    else if rsi_type == RSI_FISHER
        result := f_rsi_fisher(src, len)
    else if rsi_type == RSI_INVERSE
        result := f_rsi_inverse_fisher(src, len)
    else if rsi_type == RSI_COPPOCK
        result := f_rsi_coppock(src, len)
    else if rsi_type == RSI_VRSI
        result := f_rsi_volume(src, len)
    else if rsi_type == RSI_MFI
        result := f_rsi_mfi(src, len)
    else if rsi_type == RSI_VWRSI
        result := f_rsi_vwap(src, len)
    else if rsi_type == RSI_QUANTUM
        result := f_rsi_quantum(src, len)
    else if rsi_type == RSI_SPECTRAL
        result := f_rsi_spectral(src, len)
    else if rsi_type == RSI_KINETIC
        result := f_rsi_kinetic(src, len)
    else if rsi_type == RSI_ENTROPY
        result := f_rsi_entropy(src, len)
    else if rsi_type == RSI_NEURAL
        result := f_rsi_neural(src, len)
    else if rsi_type == RSI_HARMONIC
        result := f_rsi_harmonic(src, len)
    else if rsi_type == RSI_FRACTAL
        result := f_rsi_fractal(src, len)
    else if rsi_type == RSI_ULTIMATE
        result := f_rsi_ultimate(src, len)
    else
        result := f_rsi_basic(src, len, RSI_WILDER)   
    result
float rsi_raw = f_calculate_rsi(i_rsi_src, i_rsi_len, i_rsi_type)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// APPLY SMOOTHER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_apply_smoother(src, len, power, smooth_type) =>
    float result = src
    if smooth_type == SM_NONE
        result := src
    else if smooth_type == SM_SMA
        result := ta.sma(src, len)
    else if smooth_type == SM_EMA
        result := ta.ema(src, len)
    else if smooth_type == SM_WMA
        result := ta.wma(src, len)
    else if smooth_type == SM_HMA
        result := f_hma(src, len)
    else if smooth_type == SM_DEMA
        result := f_dema(src, len)
    else if smooth_type == SM_TEMA
        result := f_tema(src, len)
    else if smooth_type == SM_ZLEMA
        result := f_zlema(src, len)
    else if smooth_type == SM_ALMA
        result := ta.alma(src, len, 0.85, 6)
    else if smooth_type == SM_T3
        result := f_t3(src, len, 0.7)
    else if smooth_type == SM_VIDYA
        result := f_vidya(src, len)
    else if smooth_type == SM_KAMA
        result := f_kama(src, len)
    else if smooth_type == SM_SUPER
        result := f_supersmoother(src, len)
    else if smooth_type == SM_BUTTER
        result := f_butterworth(src, len)
    else if smooth_type == SM_GAUSS
        result := f_gaussian(src, len, power)
    else if smooth_type == SM_SINE
        result := f_sine_wma(src, len)
    else if smooth_type == SM_HAMMING
        result := f_hamming(src, len)
    else if smooth_type == SM_TRIANGULAR
        result := f_triangular(src, len)
    else if smooth_type == SM_JURIK
        result := f_jurik_smooth(src, len, power)
    else
        result := src
    result
float rsi_smooth = f_apply_smoother(rsi_raw, i_smooth_len, i_smooth_power, i_smooth_type)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• APPLY FILTER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_apply_filter(src, raw, filter_type, strength) =>
    float result = src
    if filter_type == FLT_NONE or not i_filter_enable
        result := src
    else if filter_type == FLT_TREND
        trend_ma = ta.ema(close, 50)
        trend_str = math.abs(close - trend_ma) / ta.atr(14)
        trend_factor = math.min(trend_str / 2, 1.0) * strength
        result := src + (raw - src) * (1 - trend_factor)
    else if filter_type == FLT_VOL
        vol_ratio = ta.atr(14) / ta.sma(ta.atr(14), 50)
        vol_factor = math.min(vol_ratio, 2.0)
        result := src * vol_factor + raw * (1 - math.min(vol_factor, 1.0))
    else if filter_type == FLT_MOM
        mom = ta.mom(close, 10)
        mom_norm = mom / ta.stdev(mom, 20)
        mom_factor = f_tanh(mom_norm) * strength
        result := src + mom_factor * (100 - src) * 0.1 - mom_factor * src * 0.1
    else if filter_type == FLT_RANGE
        range_val = ta.highest(high, 20) - ta.lowest(low, 20)
        range_norm = range_val / ta.sma(range_val, 50)
        range_factor = math.min(range_norm, 1.0)
        center_pull = (50 - src) * (1 - range_factor) * strength * 0.3
        result := src + center_pull
    else if filter_type == FLT_COMPOSITE
        trend_ma = ta.ema(close, 50)
        trend_bias = close > trend_ma ? 0.1 : -0.1
        vol_ratio = ta.atr(14) / ta.sma(ta.atr(14), 50)
        vol_smooth = math.max(2 - vol_ratio, 0.5)
        smooth_src = src * 0.7 + ta.ema(src, 3) * 0.3
        result := smooth_src + trend_bias * strength * 5
        result := result * vol_smooth / math.max(vol_smooth, 1)
    math.min(math.max(result, 0), 100)
float rsi_final = f_apply_filter(rsi_smooth, rsi_raw, i_filter_type, i_filter_str)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL LINE 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float signal_line = na
if i_signal_enable
    signal_line := f_apply_smoother(rsi_final, i_signal_len, 2.0, i_signal_type)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RSI BANDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float band_upper = na
float band_lower = na
float band_mid = na
if i_bands_enable
    if i_bands_type == BAND_BB
        band_mid := ta.sma(rsi_final, i_bands_len)
        dev = ta.stdev(rsi_final, i_bands_len) * i_bands_mult
        band_upper := band_mid + dev
        band_lower := band_mid - dev
    else if i_bands_type == BAND_KC
        band_mid := ta.ema(rsi_final, i_bands_len)
        atr_rsi = ta.atr(i_bands_len)
        rsi_range = ta.stdev(rsi_final, i_bands_len) * 2
        band_upper := band_mid + rsi_range * i_bands_mult
        band_lower := band_mid - rsi_range * i_bands_mult
    else if i_bands_type == BAND_ENV
        band_mid := ta.ema(rsi_final, i_bands_len)
        env = band_mid * (i_bands_mult / 100)
        band_upper := band_mid + env
        band_lower := band_mid - env
    else if i_bands_type == BAND_STDEV
        band_mid := ta.sma(rsi_final, i_bands_len)
        dev = ta.stdev(rsi_final, i_bands_len)
        band_upper := band_mid + dev * i_bands_mult
        band_lower := band_mid - dev * i_bands_mult
    band_upper := math.min(band_upper, 100)
    band_lower := math.max(band_lower, 0)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEVEL LINES 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
h_ob_static = hline(70, "OB Reference", color=color.new(color.gray, 90), linestyle=hline.style_dotted)
h_os_static = hline(30, "OS Reference", color=color.new(color.gray, 90), linestyle=hline.style_dotted)
h_mid = hline(50, "Midline", color=color.new(color.gray, 80), linestyle=hline.style_dotted)
fill(h_ob_static, h_os_static, color=color.new(DAFE_PURPLE, 95), title="Neutral Zone")
var line line_ob = na
var line line_os = na
var line line_extreme_ob = na
var line line_extreme_os = na
if barstate.islast
    line.delete(line_ob)
    line.delete(line_os)
    line.delete(line_extreme_ob)
    line.delete(line_extreme_os)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DYNAMIC LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float vol_ratio_levels = ta.atr(14) / ta.sma(ta.atr(14), 100)
float vol_adj = (vol_ratio_levels - 1) * 5
float dyn_ob = i_levels_dynamic ? math.min(i_ob_level + vol_adj, 85) : i_ob_level
float dyn_os = i_levels_dynamic ? math.max(i_os_level - vol_adj, 15) : i_os_level
float dyn_extreme_ob = i_levels_dynamic ? math.min(i_extreme_ob + vol_adj, 95) : i_extreme_ob
float dyn_extreme_os = i_levels_dynamic ? math.max(i_extreme_os - vol_adj, 5) : i_extreme_os
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEVEL LINES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
h_ob_ref = hline(70, "OB Ref", color=color.new(color.gray, 95), linestyle=hline.style_dotted)
h_os_ref = hline(30, "OS Ref", color=color.new(color.gray, 95), linestyle=hline.style_dotted)
fill(h_ob_ref, h_os_ref, color=color.new(DAFE_PURPLE, 95), title="Neutral Zone")
plot(dyn_ob, "Dynamic OB", color=color.new(DAFE_RED, 50), linewidth=1, style=plot.style_line)
plot(dyn_os, "Dynamic OS", color=color.new(DAFE_GREEN, 50), linewidth=1, style=plot.style_line)
plot(dyn_extreme_ob, "Extreme OB", color=color.new(DAFE_RED, 30), linewidth=1, style=plot.style_circles)
plot(dyn_extreme_os, "Extreme OS", color=color.new(DAFE_GREEN, 30), linewidth=1, style=plot.style_circles)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-TIMEFRAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float mtf_rsi1 = request.security(syminfo.tickerid, i_mtf_tf1, ta.rsi(close, i_rsi_len), lookahead=barmerge.lookahead_off)
float mtf_rsi2 = request.security(syminfo.tickerid, i_mtf_tf2, ta.rsi(close, i_rsi_len), lookahead=barmerge.lookahead_off)
float mtf_rsi3 = request.security(syminfo.tickerid, i_mtf_tf3, ta.rsi(close, i_rsi_len), lookahead=barmerge.lookahead_off)
float mtf_rsi1_val = i_mtf_enable ? mtf_rsi1 : na
float mtf_rsi2_val = i_mtf_enable ? mtf_rsi2 : na
float mtf_rsi3_val = i_mtf_enable ? mtf_rsi3 : na
int mtf_bull_count = (nz(mtf_rsi1, 50) > 50 ? 1 : 0) + (nz(mtf_rsi2, 50) > 50 ? 1 : 0) + (nz(mtf_rsi3, 50) > 50 ? 1 : 0)
string mtf_consensus = not i_mtf_enable ? "OFF" : mtf_bull_count == 3 ? "ALL BULL" : mtf_bull_count == 0 ? "ALL BEAR" : "MIXED"
color mtf_color = not i_mtf_enable ? color.gray : mtf_bull_count == 3 ? DAFE_GREEN : mtf_bull_count == 0 ? DAFE_RED : DAFE_GOLD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOMENTUM HISTOGRAM 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float momentum_hist = na
if i_hist_enable and i_signal_enable
    momentum_hist := rsi_final - signal_line
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIVERGENCE DETECTION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ph = ta.pivothigh(rsi_final, i_div_lookback, i_div_lookback)
pl = ta.pivotlow(rsi_final, i_div_lookback, i_div_lookback)
var float[] pivot_high_rsi = array.new_float(0)
var int[] pivot_high_bar = array.new_int(0)
var float[] pivot_high_price = array.new_float(0)
var float[] pivot_low_rsi = array.new_float(0)
var int[] pivot_low_bar = array.new_int(0)
var float[] pivot_low_price = array.new_float(0)
var bool reg_bull_div = false
var bool reg_bear_div = false
var bool hid_bull_div = false
var bool hid_bear_div = false
if i_div_enable
    if not na(ph)
        if array.size(pivot_high_rsi) >= 10
            array.shift(pivot_high_rsi)
            array.shift(pivot_high_bar)
            array.shift(pivot_high_price)
        array.push(pivot_high_rsi, rsi_final[i_div_lookback])
        array.push(pivot_high_bar, bar_index - i_div_lookback)
        array.push(pivot_high_price, high[i_div_lookback])
    if not na(pl)
        if array.size(pivot_low_rsi) >= 10
            array.shift(pivot_low_rsi)
            array.shift(pivot_low_bar)
            array.shift(pivot_low_price)
        array.push(pivot_low_rsi, rsi_final[i_div_lookback])
        array.push(pivot_low_bar, bar_index - i_div_lookback)
        array.push(pivot_low_price, low[i_div_lookback])
    reg_bull_div := false
    reg_bear_div := false
    hid_bull_div := false
    hid_bear_div := false
    if array.size(pivot_high_rsi) >= 2 and not na(ph)
        curr_rsi = array.get(pivot_high_rsi, array.size(pivot_high_rsi) - 1)
        prev_rsi = array.get(pivot_high_rsi, array.size(pivot_high_rsi) - 2)
        curr_price = array.get(pivot_high_price, array.size(pivot_high_price) - 1)
        prev_price = array.get(pivot_high_price, array.size(pivot_high_price) - 2)
        curr_bar = array.get(pivot_high_bar, array.size(pivot_high_bar) - 1)
        prev_bar = array.get(pivot_high_bar, array.size(pivot_high_bar) - 2)
        if curr_bar - prev_bar <= i_div_range
            if curr_price > prev_price and curr_rsi < prev_rsi and i_div_regular
                reg_bear_div := true
            if curr_price < prev_price and curr_rsi > prev_rsi and i_div_hidden
                hid_bear_div := true
    if array.size(pivot_low_rsi) >= 2 and not na(pl)
        curr_rsi = array.get(pivot_low_rsi, array.size(pivot_low_rsi) - 1)
        prev_rsi = array.get(pivot_low_rsi, array.size(pivot_low_rsi) - 2)
        curr_price = array.get(pivot_low_price, array.size(pivot_low_price) - 1)
        prev_price = array.get(pivot_low_price, array.size(pivot_low_price) - 2)
        curr_bar = array.get(pivot_low_bar, array.size(pivot_low_bar) - 1)
        prev_bar = array.get(pivot_low_bar, array.size(pivot_low_bar) - 2)
        if curr_bar - prev_bar <= i_div_range
            if curr_price < prev_price and curr_rsi > prev_rsi and i_div_regular
                reg_bull_div := true
            if curr_price > prev_price and curr_rsi < prev_rsi and i_div_hidden
                hid_bull_div := true
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VISUALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_get_theme_colors(theme, rsi_val, ob, os) =>
    color main_col = DAFE_CYAN
    color glow_col = DAFE_CYAN
    color bull_col = DAFE_GREEN
    color bear_col = DAFE_RED  
    if theme == VIS_QUANTUM
        main_col := color.from_gradient(rsi_val, 0, 100, DAFE_PURPLE, DAFE_CYAN)
        glow_col := color.from_gradient(rsi_val, 0, 100, color.new(DAFE_PURPLE, 60), color.new(DAFE_CYAN, 60))
        bull_col := DAFE_CYAN
        bear_col := DAFE_MAGENTA
    else if theme == VIS_SPECTRAL
        if rsi_val >= 80
            main_col := DAFE_RED
        else if rsi_val >= 60
            main_col := color.from_gradient(rsi_val, 60, 80, DAFE_ORANGE, DAFE_RED)
        else if rsi_val >= 40
            main_col := color.from_gradient(rsi_val, 40, 60, DAFE_GOLD, DAFE_ORANGE)
        else if rsi_val >= 20
            main_col := color.from_gradient(rsi_val, 20, 40, DAFE_CYAN, DAFE_GOLD)
        else
            main_col := color.from_gradient(rsi_val, 0, 20, DAFE_PURPLE, DAFE_CYAN)
        glow_col := color.new(main_col, 60)
        bull_col := DAFE_GREEN
        bear_col := DAFE_RED
    else if theme == VIS_PLASMA
        main_col := color.from_gradient(rsi_val, 0, 100, DAFE_NEON_BLUE, DAFE_PLASMA)
        glow_col := color.new(main_col, 50)
        bull_col := DAFE_ELECTRIC
        bear_col := DAFE_PLASMA
    else if theme == VIS_NEON
        main_col := rsi_val > ob ? DAFE_RED : rsi_val < os ? DAFE_GREEN : DAFE_ELECTRIC
        glow_col := color.new(main_col, 50)
        bull_col := DAFE_GREEN
        bear_col := DAFE_RED
    else 
        main_col := DAFE_PURPLE
        glow_col := color.new(DAFE_PURPLE, 70)
        bull_col := DAFE_GREEN
        bear_col := DAFE_RED
    [main_col, glow_col, bull_col, bear_col]
[main_color, glow_color, bull_color, bear_color] = f_get_theme_colors(i_visual_theme, rsi_final, dyn_ob, dyn_os)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKGROUND ZONES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
color bg_color = na
if i_bg_zones
    if rsi_final > dyn_extreme_ob
        bg_color := color.new(DAFE_RED, 90)
    else if rsi_final < dyn_extreme_os
        bg_color := color.new(DAFE_GREEN, 90)
    else if rsi_final > dyn_ob
        bg_color := color.new(DAFE_ORANGE, 93)
    else if rsi_final < dyn_os
        bg_color := color.new(DAFE_CYAN, 93)
bgcolor(bg_color, title="Zone Background")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEVEL LINES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float line_ob_val = dyn_ob
float line_os_val = dyn_os
float line_extreme_ob_val = dyn_extreme_ob
float line_extreme_os_val = dyn_extreme_os
if barstate.islast
    line.delete(line_ob)
    line.delete(line_os)
    line.delete(line_extreme_ob)
    line.delete(line_extreme_os)
    line_ob := line.new(bar_index - 100, line_ob_val, bar_index + 10, line_ob_val, 
         color=color.new(DAFE_RED, 50), style=line.style_dashed, width=1)
    line_os := line.new(bar_index - 100, line_os_val, bar_index + 10, line_os_val, 
         color=color.new(DAFE_GREEN, 50), style=line.style_dashed, width=1)
    line_extreme_ob := line.new(bar_index - 100, line_extreme_ob_val, bar_index + 10, line_extreme_ob_val, 
         color=color.new(DAFE_RED, 30), style=line.style_solid, width=1)
    line_extreme_os := line.new(bar_index - 100, line_extreme_os_val, bar_index + 10, line_extreme_os_val, 
         color=color.new(DAFE_GREEN, 30), style=line.style_solid, width=1)
fill(h_ob_ref, h_os_ref, color=color.new(DAFE_PURPLE, 95), title="Neutral Zone")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RSI BANDS PLOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float plot_band_upper = i_bands_enable ? band_upper : na
float plot_band_lower = i_bands_enable ? band_lower : na
float plot_band_mid = i_bands_enable ? band_mid : na
p_band_upper = plot(plot_band_upper, "Band Upper", color=color.new(DAFE_CYAN, 70), linewidth=1)
p_band_lower = plot(plot_band_lower, "Band Lower", color=color.new(DAFE_CYAN, 70), linewidth=1)
p_band_mid = plot(plot_band_mid, "Band Mid", color=color.new(DAFE_GOLD, 80), linewidth=1, style=plot.style_circles)
fill(p_band_upper, p_band_lower, color=color.new(DAFE_CYAN, 95), title="Band Fill")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN RSI PLOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float glow_val = i_glow_enable ? rsi_final : na
plot(glow_val, "Glow 3", color=color.new(glow_color, 90), linewidth=8)
plot(glow_val, "Glow 2", color=color.new(glow_color, 80), linewidth=5)
plot(glow_val, "Glow 1", color=color.new(glow_color, 60), linewidth=3)
p_rsi = plot(rsi_final, "RSI", color=main_color, linewidth=2)
float plot_signal = i_signal_enable ? signal_line : na
p_signal = plot(plot_signal, "Signal", color=color.new(DAFE_GOLD, 30), linewidth=1)
color fill_color = rsi_final > nz(signal_line, rsi_final) ? color.new(bull_color, 85) : color.new(bear_color, 85)
fill(p_rsi, p_signal, color=i_signal_enable ? fill_color : na, title="RSI/Signal Fill")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOMENTUM HISTOGRAM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
color hist_color_calc = na
float hist_val = na
if i_hist_enable and i_signal_enable and not na(momentum_hist)
    hist_val := 50 + momentum_hist
    if momentum_hist > 0
        hist_color_calc := momentum_hist > nz(momentum_hist[1]) ? color.new(DAFE_GREEN, 30) : color.new(DAFE_GREEN, 60)
    else
        hist_color_calc := momentum_hist < nz(momentum_hist[1]) ? color.new(DAFE_RED, 30) : color.new(DAFE_RED, 60)
plot(hist_val, "Momentum Hist", color=hist_color_calc, style=plot.style_columns, histbase=50)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIVERGENCE MARKERS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if i_div_enable
    if reg_bull_div and array.size(pivot_low_bar) >= 2
        prev_bar = array.get(pivot_low_bar, array.size(pivot_low_bar) - 2)
        curr_bar = array.get(pivot_low_bar, array.size(pivot_low_bar) - 1)
        prev_rsi = array.get(pivot_low_rsi, array.size(pivot_low_rsi) - 2)
        curr_rsi = array.get(pivot_low_rsi, array.size(pivot_low_rsi) - 1)
        label.new(curr_bar, curr_rsi - 5, "ğŸŸ¢", color=color.new(color.white, 100), 
             style=label.style_label_up, size=size.normal, textcolor=DAFE_GREEN,
             tooltip="Regular Bullish Divergence\nPrice: Lower Low\nRSI: Higher Low")
        line.new(prev_bar, prev_rsi, curr_bar, curr_rsi, color=DAFE_GREEN, width=2, style=line.style_solid)
    if reg_bear_div and array.size(pivot_high_bar) >= 2
        prev_bar = array.get(pivot_high_bar, array.size(pivot_high_bar) - 2)
        curr_bar = array.get(pivot_high_bar, array.size(pivot_high_bar) - 1)
        prev_rsi = array.get(pivot_high_rsi, array.size(pivot_high_rsi) - 2)
        curr_rsi = array.get(pivot_high_rsi, array.size(pivot_high_rsi) - 1)
        label.new(curr_bar, curr_rsi + 5, "ğŸ”´", color=color.new(color.white, 100), 
             style=label.style_label_down, size=size.normal, textcolor=DAFE_RED,
             tooltip="Regular Bearish Divergence\nPrice: Higher High\nRSI: Lower High")
        line.new(prev_bar, prev_rsi, curr_bar, curr_rsi, color=DAFE_RED, width=2, style=line.style_solid)
    if hid_bull_div and array.size(pivot_low_bar) >= 2
        prev_bar = array.get(pivot_low_bar, array.size(pivot_low_bar) - 2)
        curr_bar = array.get(pivot_low_bar, array.size(pivot_low_bar) - 1)
        prev_rsi = array.get(pivot_low_rsi, array.size(pivot_low_rsi) - 2)
        curr_rsi = array.get(pivot_low_rsi, array.size(pivot_low_rsi) - 1)
        label.new(curr_bar, curr_rsi - 5, "â¬†", color=color.new(DAFE_CYAN, 20), 
             style=label.style_label_up, size=size.small, textcolor=color.white,
             tooltip="Hidden Bullish Divergence\nPrice: Higher Low\nRSI: Lower Low\nTrend Continuation")
        line.new(prev_bar, prev_rsi, curr_bar, curr_rsi, color=DAFE_CYAN, width=1, style=line.style_dashed)
    if hid_bear_div and array.size(pivot_high_bar) >= 2
        prev_bar = array.get(pivot_high_bar, array.size(pivot_high_bar) - 2)
        curr_bar = array.get(pivot_high_bar, array.size(pivot_high_bar) - 1)
        prev_rsi = array.get(pivot_high_rsi, array.size(pivot_high_rsi) - 2)
        curr_rsi = array.get(pivot_high_rsi, array.size(pivot_high_rsi) - 1)
        label.new(curr_bar, curr_rsi + 5, "â¬‡", color=color.new(DAFE_MAGENTA, 20), 
             style=label.style_label_down, size=size.small, textcolor=color.white,
             tooltip="Hidden Bearish Divergence\nPrice: Lower High\nRSI: Higher High\nTrend Continuation")
        line.new(prev_bar, prev_rsi, curr_bar, curr_rsi, color=DAFE_MAGENTA, width=1, style=line.style_dashed)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL CONDITIONS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool cross_up_os = ta.crossover(rsi_final, dyn_os)
bool cross_down_ob = ta.crossunder(rsi_final, dyn_ob)
bool cross_up_mid = ta.crossover(rsi_final, 50)
bool cross_down_mid = ta.crossunder(rsi_final, 50)
bool extreme_ob_entry = rsi_final > dyn_extreme_ob and rsi_final[1] <= dyn_extreme_ob
bool extreme_os_entry = rsi_final < dyn_extreme_os and rsi_final[1] >= dyn_extreme_os
bool signal_cross_up = i_signal_enable and ta.crossover(rsi_final, signal_line)
bool signal_cross_down = i_signal_enable and ta.crossunder(rsi_final, signal_line)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN CHART SIGNALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
plotshape(cross_up_os, "OS Exit Signal", shape.triangleup, location.belowbar, 
     DAFE_GREEN, size=size.small, force_overlay=true)
plotshape(extreme_os_entry, "Extreme OS Signal", shape.diamond, location.belowbar, 
     DAFE_CYAN, size=size.tiny, force_overlay=true)
plotshape(signal_cross_up, "Signal Bullish Cross", shape.circle, location.belowbar, 
     color.new(DAFE_GREEN, 50), size=size.tiny, force_overlay=true)
plotshape(cross_down_ob, "OB Exit Signal", shape.triangledown, location.abovebar, 
     DAFE_RED, size=size.small, force_overlay=true)
plotshape(extreme_ob_entry, "Extreme OB Signal", shape.diamond, location.abovebar, 
     DAFE_MAGENTA, size=size.tiny, force_overlay=true)
plotshape(signal_cross_down, "Signal Bearish Cross", shape.circle, location.abovebar, 
     color.new(DAFE_RED, 50), size=size.tiny, force_overlay=true)
plotshape(reg_bull_div, "Bullish Divergence", shape.labelup, location.belowbar, 
     DAFE_GREEN, text="DIV", textcolor=color.white, size=size.small, force_overlay=true)
plotshape(reg_bear_div, "Bearish Divergence", shape.labeldown, location.abovebar, 
     DAFE_RED, text="DIV", textcolor=color.white, size=size.small, force_overlay=true)
plotshape(hid_bull_div, "Hidden Bull Div", shape.labelup, location.belowbar, 
     DAFE_CYAN, text="HD", textcolor=color.white, size=size.tiny, force_overlay=true)
plotshape(hid_bear_div, "Hidden Bear Div", shape.labeldown, location.abovebar, 
     DAFE_MAGENTA, text="HD", textcolor=color.white, size=size.tiny, force_overlay=true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RSI PANE SIGNALS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
plotshape(cross_up_os ? dyn_os : na, "OS Cross (RSI Pane)", shape.diamond, 
     location.absolute, DAFE_GREEN, size=size.tiny)
plotshape(cross_down_ob ? dyn_ob : na, "OB Cross (RSI Pane)", shape.diamond, 
     location.absolute, DAFE_RED, size=size.tiny)
plotshape(extreme_ob_entry ? dyn_extreme_ob : na, "Extreme OB (RSI Pane)", 
     shape.triangledown, location.absolute, DAFE_RED, size=size.tiny)
plotshape(extreme_os_entry ? dyn_extreme_os : na, "Extreme OS (RSI Pane)", 
     shape.triangleup, location.absolute, DAFE_GREEN, size=size.tiny)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CANDLE COLORING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
color candle_col = na
if i_candle_color
    if rsi_final > dyn_ob
        candle_col := DAFE_RED
    else if rsi_final < dyn_os
        candle_col := DAFE_GREEN
    else
        candle_col := color.from_gradient(rsi_final, dyn_os, dyn_ob, DAFE_CYAN, DAFE_MAGENTA)
barcolor(candle_col)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
dash_pos = i_dash_pos == "Top Right" ? position.top_right :
     i_dash_pos == "Top Left" ? position.top_left :
     i_dash_pos == "Bottom Right" ? position.bottom_right : position.bottom_left
bool dash_overlay_mode = i_dash_display_mode == DASH_MODE_OVERLAY
string rsi_state = rsi_final > dyn_extreme_ob ? "EXTREME OB" :
     rsi_final > dyn_ob ? "OVERBOUGHT" :
     rsi_final < dyn_extreme_os ? "EXTREME OS" :
     rsi_final < dyn_os ? "OVERSOLD" : "NEUTRAL"
color state_color = rsi_final > dyn_extreme_ob ? DAFE_RED :
     rsi_final > dyn_ob ? DAFE_ORANGE :
     rsi_final < dyn_extreme_os ? DAFE_GREEN :
     rsi_final < dyn_os ? DAFE_CYAN : color.gray
string trend_state = rsi_final > 50 ? (rsi_final > rsi_final[1] ? "BULLISH â†‘" : "BULLISH â†“") :
     (rsi_final < rsi_final[1] ? "BEARISH â†“" : "BEARISH â†‘")
color trend_color = rsi_final > 50 ? (rsi_final > rsi_final[1] ? DAFE_GREEN : DAFE_CYAN) :
     (rsi_final < rsi_final[1] ? DAFE_RED : DAFE_ORANGE)
string momentum_state = i_signal_enable and not na(momentum_hist) ?
     (momentum_hist > 0 ? (momentum_hist > momentum_hist[1] ? "STRONG +" : "WEAK +") :
     (momentum_hist < momentum_hist[1] ? "STRONG -" : "WEAK -")) : "N/A"
color momentum_color = i_signal_enable and not na(momentum_hist) ?
     (momentum_hist > 0 ? (momentum_hist > momentum_hist[1] ? DAFE_GREEN : color.new(DAFE_GREEN, 50)) :
     (momentum_hist < momentum_hist[1] ? DAFE_RED : color.new(DAFE_RED, 50))) : color.gray
if i_mtf_enable and not na(mtf_rsi1) and not na(mtf_rsi2) and not na(mtf_rsi3)
    bull_count = (mtf_rsi1 > 50 ? 1 : 0) + (mtf_rsi2 > 50 ? 1 : 0) + (mtf_rsi3 > 50 ? 1 : 0)
    mtf_consensus := bull_count == 3 ? "ALL BULLISH" : bull_count == 0 ? "ALL BEARISH" : "MIXED"
    mtf_color := bull_count == 3 ? DAFE_GREEN : bull_count == 0 ? DAFE_RED : DAFE_GOLD
string div_state = reg_bull_div ? "BULL DIV â†‘" : reg_bear_div ? "BEAR DIV â†“" :
     hid_bull_div ? "HID BULL" : hid_bear_div ? "HID BEAR" : "NONE"
color div_color = reg_bull_div or hid_bull_div ? DAFE_GREEN : reg_bear_div or hid_bear_div ? DAFE_RED : color.gray
string engine_name = str.replace(str.replace(str.replace(i_rsi_type, "DAFE ", ""), "â”€â”€â”€â”€ ", ""), " â”€â”€â”€â”€", "")
if str.length(engine_name) > 12
    engine_name := str.substring(engine_name, 0, 12) + ".."
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD RENDER LOGIC 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table dash_overlay = table.new(dash_pos, 4, 12, bgcolor=color.new(DAFE_VOID, 10), 
     border_width=1, border_color=DAFE_BORDER, frame_width=2, frame_color=DAFE_CYAN, force_overlay=true)
var table dash_panel = table.new(dash_pos, 4, 12, bgcolor=color.new(DAFE_VOID, 10), 
     border_width=1, border_color=DAFE_BORDER, frame_width=2, frame_color=DAFE_CYAN, force_overlay=false)
table dash = i_dash_display_mode == DASH_MODE_OVERLAY ? dash_overlay : dash_panel
if barstate.islast and i_dash_enable
    if i_dash_display_mode == DASH_MODE_OVERLAY
        table.clear(dash_panel, 0, 0, 3, 11)
    else
        table.clear(dash_overlay, 0, 0, 3, 11)
if i_dash_enable and barstate.islast
    if i_dash_size == DASH_FULL
        table.cell(dash, 0, 0, "âš¡ RSI: Evolved âš¡", text_color=DAFE_CYAN, bgcolor=color.new(DAFE_PURPLE, 70), 
             text_size=size.small, text_halign=text.align_center)
        table.merge_cells(dash, 0, 0, 3, 0)
        table.cell(dash, 0, 1, "ENGINE", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 1, engine_name, text_color=DAFE_GOLD, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 2, 1, "SMOOTH", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 3, 1, i_smooth_type == SM_NONE ? "RAW" : str.substring(i_smooth_type, 0, 6), 
             text_color=DAFE_ELECTRIC, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 0, 2, "RSI VALUE", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 2, str.tostring(rsi_final, "#.1"), text_color=main_color, bgcolor=DAFE_PANEL, text_size=size.normal)
        table.cell(dash, 2, 2, "SIGNAL", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 3, 2, i_signal_enable ? str.tostring(signal_line, "#.1") : "OFF", 
             text_color=DAFE_GOLD, bgcolor=DAFE_PANEL, text_size=size.normal)
        table.cell(dash, 0, 3, "STATE", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 3, rsi_state, text_color=state_color, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 2, 3, "TREND", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 3, 3, trend_state, text_color=trend_color, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 0, 4, "MOMENTUM", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 4, momentum_state, text_color=momentum_color, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 2, 4, "DIVERGENCE", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 3, 4, div_state, text_color=div_color, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 0, 5, "â•â•â• MULTI-TIMEFRAME â•â•â•", text_color=DAFE_PURPLE, bgcolor=color.new(DAFE_PURPLE, 85), 
             text_size=size.tiny, text_halign=text.align_center)
        table.merge_cells(dash, 0, 5, 3, 5)
        if i_mtf_enable
            table.cell(dash, 0, 6, i_mtf_tf1, text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 1, 6, str.tostring(mtf_rsi1, "#.0"), 
                 text_color=mtf_rsi1 > 50 ? DAFE_GREEN : DAFE_RED, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 2, 6, i_mtf_tf2, text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 3, 6, str.tostring(mtf_rsi2, "#.0"), 
                 text_color=mtf_rsi2 > 50 ? DAFE_GREEN : DAFE_RED, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 0, 7, i_mtf_tf3, text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 1, 7, str.tostring(mtf_rsi3, "#.0"), 
                 text_color=mtf_rsi3 > 50 ? DAFE_GREEN : DAFE_RED, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 2, 7, "CONSENSUS", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 3, 7, mtf_consensus, text_color=mtf_color, bgcolor=DAFE_PANEL, text_size=size.tiny)
        else
            table.cell(dash, 0, 6, "MTF DISABLED", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.merge_cells(dash, 0, 6, 3, 6)
            table.cell(dash, 0, 7, "", bgcolor=DAFE_PANEL)
            table.merge_cells(dash, 0, 7, 3, 7)
        table.cell(dash, 0, 8, "â•â•â• DYNAMIC LEVELS â•â•â•", text_color=DAFE_PURPLE, bgcolor=color.new(DAFE_PURPLE, 85), 
             text_size=size.tiny, text_halign=text.align_center)
        table.merge_cells(dash, 0, 8, 3, 8)
        table.cell(dash, 0, 9, "OB", text_color=DAFE_RED, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 9, str.tostring(dyn_ob, "#"), text_color=DAFE_RED, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 2, 9, "OS", text_color=DAFE_GREEN, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 3, 9, str.tostring(dyn_os, "#"), text_color=DAFE_GREEN, bgcolor=DAFE_PANEL, text_size=size.tiny)
        if i_bands_enable
            table.cell(dash, 0, 10, "UPPER", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 1, 10, str.tostring(band_upper, "#.0"), text_color=DAFE_CYAN, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 2, 10, "LOWER", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
            table.cell(dash, 3, 10, str.tostring(band_lower, "#.0"), text_color=DAFE_CYAN, bgcolor=DAFE_PANEL, text_size=size.tiny)
        else
            table.cell(dash, 0, 10, "", bgcolor=DAFE_PANEL)
            table.merge_cells(dash, 0, 10, 3, 10)
        table.cell(dash, 0, 11, "DAFE Trading Systems", text_color=color.new(DAFE_CYAN, 40), bgcolor=color.new(DAFE_VOID, 0), 
             text_size=size.tiny, text_halign=text.align_center)
        table.merge_cells(dash, 0, 11, 3, 11)   
    else if i_dash_size == DASH_COMPACT
        table.cell(dash, 0, 0, "âš¡ RSI NEXUS", text_color=DAFE_CYAN, bgcolor=color.new(DAFE_PURPLE, 70), text_size=size.tiny)
        table.merge_cells(dash, 0, 0, 1, 0)       
        table.cell(dash, 0, 1, "VALUE", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 1, str.tostring(rsi_final, "#.1"), text_color=main_color, bgcolor=DAFE_PANEL, text_size=size.small)        
        table.cell(dash, 0, 2, "STATE", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 2, rsi_state, text_color=state_color, bgcolor=DAFE_PANEL, text_size=size.tiny)       
        table.cell(dash, 0, 3, "TREND", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 3, trend_state, text_color=trend_color, bgcolor=DAFE_PANEL, text_size=size.tiny)      
        table.cell(dash, 0, 4, "DIV", text_color=color.gray, bgcolor=DAFE_PANEL, text_size=size.tiny)
        table.cell(dash, 1, 4, div_state, text_color=div_color, bgcolor=DAFE_PANEL, text_size=size.tiny)   
    else
        table.cell(dash, 0, 0, str.tostring(rsi_final, "#.0"), text_color=main_color, bgcolor=color.new(DAFE_VOID, 30), text_size=size.normal)
        table.cell(dash, 0, 1, rsi_state, text_color=state_color, bgcolor=color.new(DAFE_VOID, 30), text_size=size.tiny)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEMPORAL WAVE HELPER FUNCTIONS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_horizon_format(tf_input) =>
    int seconds_val = timeframe.in_seconds(tf_input)
    int minutes_val = seconds_val / 60
    int hours_val = minutes_val / 60
    int days_val = hours_val / 24
    string formatted = hours_val < 24 and hours_val >= 1 ? str.tostring(hours_val) + "H" : 
         minutes_val >= 1440 ? str.tostring(days_val) + "D" : 
         minutes_val < 60 and minutes_val > 1 ? str.tostring(minutes_val) + "M" : 
         minutes_val < 1 ? str.tostring(seconds_val) + "S" : tf_input
    formatted
f_temporal_stoch_momentum(period_len) =>
    float rsi_base = ta.rsi(close, period_len)
    float k_stoch = ta.sma(ta.stoch(rsi_base, rsi_base, rsi_base, 14), 3)
    k_stoch
f_rsi_to_price(rsi_val, price_low, price_high) =>
    price_low + (rsi_val / 100.0) * (price_high - price_low)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEMPORAL WAVE CALCULATIONS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_calc_temporal_pulse(wave_period) =>
    float result = switch i_temporal_wave_type
        TEMPORAL_RSI => ta.rsi(close, wave_period)
        TEMPORAL_MFI => ta.mfi(hlc3, wave_period)
        TEMPORAL_STOCH => f_temporal_stoch_momentum(wave_period)
        => ta.rsi(close, wave_period)
    result
float temporal_pulse_1 = f_calc_temporal_pulse(i_temporal_wave_1_period)
float temporal_flow_1 = ta.sma(temporal_pulse_1, i_temporal_wave_1_signal)
[horizon_pulse_1, horizon_flow_1] = request.security(syminfo.tickerid, i_mtf_tf1, [temporal_pulse_1, temporal_flow_1], lookahead=barmerge.lookahead_off)
float temporal_pulse_2 = f_calc_temporal_pulse(i_temporal_wave_2_period)
float temporal_flow_2 = ta.sma(temporal_pulse_2, i_temporal_wave_2_signal)
[horizon_pulse_2, horizon_flow_2] = request.security(syminfo.tickerid, i_mtf_tf2, [temporal_pulse_2, temporal_flow_2], lookahead=barmerge.lookahead_off)
float temporal_pulse_3 = f_calc_temporal_pulse(i_temporal_wave_3_period)
float temporal_flow_3 = ta.sma(temporal_pulse_3, i_temporal_wave_3_signal)
[horizon_pulse_3, horizon_flow_3] = request.security(syminfo.tickerid, i_mtf_tf3, [temporal_pulse_3, temporal_flow_3], lookahead=barmerge.lookahead_off)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEMPORAL WAVE PRICE SCALING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
int stability_lookback = 500
float stable_high = ta.highest(high, stability_lookback)
float stable_low = ta.lowest(low, stability_lookback)
float stable_range = stable_high - stable_low
bool display_at_top = i_temporal_wave_location == TEMPORAL_LOCATION_TOP
float wave_zone_height = stable_range * 0.18
float wave_zone_bottom = na
float wave_zone_top = na
if display_at_top
    wave_zone_top := stable_high - (stable_range * 0.05)
    wave_zone_bottom := wave_zone_top - wave_zone_height
else
    wave_zone_bottom := stable_low + (stable_range * 0.05)
    wave_zone_top := wave_zone_bottom + wave_zone_height
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEMPORAL WAVE POSITION CALC 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
int wave_history_depth = 50
int wave_gap = 10 
int wave_offset_1 = 10
int wave_offset_2 = wave_offset_1 + (i_temporal_wave_1_show ? (wave_history_depth + wave_gap) : 0)
int wave_offset_3 = wave_offset_2 + (i_temporal_wave_2_show ? (wave_history_depth + wave_gap) : 0)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEMPORAL WAVE GLOBAL STORAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var array<float> g_pulse_history_1 = array.new_float(50, 50.0)
var array<float> g_flow_history_1 = array.new_float(50, 50.0)
var array<float> g_pulse_history_2 = array.new_float(50, 50.0)
var array<float> g_flow_history_2 = array.new_float(50, 50.0)
var array<float> g_pulse_history_3 = array.new_float(50, 50.0)
var array<float> g_flow_history_3 = array.new_float(50, 50.0)
if barstate.isconfirmed or barstate.islast
    array.unshift(g_pulse_history_1, nz(horizon_pulse_1, 50.0))
    array.unshift(g_flow_history_1, nz(horizon_flow_1, 50.0))
    if array.size(g_pulse_history_1) > 50
        array.pop(g_pulse_history_1)
        array.pop(g_flow_history_1)
    array.unshift(g_pulse_history_2, nz(horizon_pulse_2, 50.0))
    array.unshift(g_flow_history_2, nz(horizon_flow_2, 50.0))
    if array.size(g_pulse_history_2) > 50
        array.pop(g_pulse_history_2)
        array.pop(g_flow_history_2)
    array.unshift(g_pulse_history_3, nz(horizon_pulse_3, 50.0))
    array.unshift(g_flow_history_3, nz(horizon_flow_3, 50.0))
    if array.size(g_pulse_history_3) > 50
        array.pop(g_pulse_history_3)
        array.pop(g_flow_history_3)
var array<chart.point> g_quantum_path_1 = array.new<chart.point>()
var array<chart.point> g_signal_path_1 = array.new<chart.point>()
var array<chart.point> g_quantum_path_2 = array.new<chart.point>()
var array<chart.point> g_signal_path_2 = array.new<chart.point>()
var array<chart.point> g_quantum_path_3 = array.new<chart.point>()
var array<chart.point> g_signal_path_3 = array.new<chart.point>()
var polyline g_quantum_wave_1 = na
var polyline g_signal_wave_1 = na
var polyline g_quantum_wave_2 = na
var polyline g_signal_wave_2 = na
var polyline g_quantum_wave_3 = na
var polyline g_signal_wave_3 = na
var line g_grid_center_1 = na
var line g_grid_upper_1 = na
var line g_grid_lower_1 = na
var line g_grid_center_2 = na
var line g_grid_upper_2 = na
var line g_grid_lower_2 = na
var line g_grid_center_3 = na
var line g_grid_upper_3 = na
var line g_grid_lower_3 = na
var box g_wave_bg_1 = na
var box g_wave_bg_2 = na
var box g_wave_bg_3 = na
var label g_horizon_label_1 = na
var label g_upper_ref_1 = na
var label g_lower_ref_1 = na
var label g_type_ref_1 = na
var label g_horizon_label_2 = na
var label g_horizon_label_3 = na
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TEMPORAL WAVE RENDERING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if i_temporal_wave_enable and barstate.islast
    if i_temporal_wave_1_show
        int wave_start_1 = bar_index + wave_offset_1
        int wave_end_1 = wave_start_1 + wave_history_depth
        array.clear(g_quantum_path_1)
        array.clear(g_signal_path_1)
        polyline.delete(g_quantum_wave_1)
        polyline.delete(g_signal_wave_1)
        line.delete(g_grid_center_1)
        line.delete(g_grid_upper_1)
        line.delete(g_grid_lower_1)
        label.delete(g_horizon_label_1)
        label.delete(g_upper_ref_1)
        label.delete(g_lower_ref_1)
        label.delete(g_type_ref_1)
        box.delete(g_wave_bg_1)
        float grid_30_price = f_rsi_to_price(30, wave_zone_bottom, wave_zone_top)
        float grid_50_price = f_rsi_to_price(50, wave_zone_bottom, wave_zone_top)
        float grid_70_price = f_rsi_to_price(70, wave_zone_bottom, wave_zone_top)
        g_wave_bg_1 := box.new(wave_start_1, wave_zone_top, wave_end_1, wave_zone_bottom,
             bgcolor=color.new(DAFE_VOID, 40), border_color=color.new(DAFE_PURPLE, 0), 
             border_width=2, force_overlay=true)
        g_grid_center_1 := line.new(wave_start_1, grid_50_price, wave_end_1, grid_50_price, 
             style=line.style_dashed, color=color.new(color.gray, 60), force_overlay=true)
        g_grid_upper_1 := line.new(wave_start_1, grid_70_price, wave_end_1, grid_70_price, 
             style=line.style_dotted, color=color.new(DAFE_RED, 70), force_overlay=true)
        g_grid_lower_1 := line.new(wave_start_1, grid_30_price, wave_end_1, grid_30_price, 
             style=line.style_dotted, color=color.new(DAFE_GREEN, 70), force_overlay=true)
        int hist_size_1 = math.min(array.size(g_pulse_history_1), wave_history_depth)
        for idx = 0 to hist_size_1 - 1
            float pulse_val = array.get(g_pulse_history_1, idx)
            float flow_val = array.get(g_flow_history_1, idx)
            float pulse_price = f_rsi_to_price(pulse_val, wave_zone_bottom, wave_zone_top)
            float flow_price = f_rsi_to_price(flow_val, wave_zone_bottom, wave_zone_top)
            array.push(g_quantum_path_1, chart.point.from_index(wave_end_1 - idx, pulse_price))
            array.push(g_signal_path_1, chart.point.from_index(wave_end_1 - idx, flow_price))
        string wave_dir_1 = nz(horizon_pulse_1, 50) > nz(horizon_flow_1, 50) ? " â–²" : " â–¼"
        string label_style_1 = display_at_top ? label.style_label_down : label.style_label_up
        float label_y_1 = display_at_top ? wave_zone_top : wave_zone_bottom
        g_horizon_label_1 := label.new(wave_start_1 + int(wave_history_depth / 2), label_y_1, 
             f_horizon_format(i_mtf_tf1) + wave_dir_1, 
             style=label_style_1, textcolor=DAFE_CYAN, color=color.new(DAFE_VOID, 30), 
             size=size.small, force_overlay=true)
        g_upper_ref_1 := label.new(wave_end_1 + 2, grid_70_price, "70", 
             style=label.style_label_left, textcolor=color.new(DAFE_RED, 30), color=color(na), 
             size=size.tiny, force_overlay=true)
        g_lower_ref_1 := label.new(wave_end_1 + 2, grid_30_price, "30", 
             style=label.style_label_left, textcolor=color.new(DAFE_GREEN, 30), color=color(na), 
             size=size.tiny, force_overlay=true)
        g_type_ref_1 := label.new(wave_end_1 + 2, grid_50_price, i_temporal_wave_type, 
             style=label.style_label_left, textcolor=color.new(color.gray, 30), color=color(na), 
             size=size.tiny, force_overlay=true)
        if array.size(g_quantum_path_1) > 1
            g_quantum_wave_1 := polyline.new(g_quantum_path_1, line_color=DAFE_PURPLE, line_width=2, force_overlay=true)
            g_signal_wave_1 := polyline.new(g_signal_path_1, line_color=DAFE_GOLD, line_width=1, force_overlay=true)
    if i_temporal_wave_2_show
        int wave_start_2 = bar_index + wave_offset_2
        int wave_end_2 = wave_start_2 + wave_history_depth
        array.clear(g_quantum_path_2)
        array.clear(g_signal_path_2)
        polyline.delete(g_quantum_wave_2)
        polyline.delete(g_signal_wave_2)
        line.delete(g_grid_center_2)
        line.delete(g_grid_upper_2)
        line.delete(g_grid_lower_2)
        label.delete(g_horizon_label_2)
        box.delete(g_wave_bg_2)
        float grid_30_price = f_rsi_to_price(30, wave_zone_bottom, wave_zone_top)
        float grid_50_price = f_rsi_to_price(50, wave_zone_bottom, wave_zone_top)
        float grid_70_price = f_rsi_to_price(70, wave_zone_bottom, wave_zone_top)
        g_wave_bg_2 := box.new(wave_start_2, wave_zone_top, wave_end_2, wave_zone_bottom,
             bgcolor=color.new(DAFE_VOID, 40), border_color=color.new(DAFE_CYAN, 0), 
             border_width=2, force_overlay=true)
        g_grid_center_2 := line.new(wave_start_2, grid_50_price, wave_end_2, grid_50_price, 
             style=line.style_dashed, color=color.new(color.gray, 60), force_overlay=true)
        g_grid_upper_2 := line.new(wave_start_2, grid_70_price, wave_end_2, grid_70_price, 
             style=line.style_dotted, color=color.new(DAFE_RED, 70), force_overlay=true)
        g_grid_lower_2 := line.new(wave_start_2, grid_30_price, wave_end_2, grid_30_price, 
             style=line.style_dotted, color=color.new(DAFE_GREEN, 70), force_overlay=true)
        int hist_size_2 = math.min(array.size(g_pulse_history_2), wave_history_depth)
        for idx = 0 to hist_size_2 - 1
            float pulse_val = array.get(g_pulse_history_2, idx)
            float flow_val = array.get(g_flow_history_2, idx)
            float pulse_price = f_rsi_to_price(pulse_val, wave_zone_bottom, wave_zone_top)
            float flow_price = f_rsi_to_price(flow_val, wave_zone_bottom, wave_zone_top)
            array.push(g_quantum_path_2, chart.point.from_index(wave_end_2 - idx, pulse_price))
            array.push(g_signal_path_2, chart.point.from_index(wave_end_2 - idx, flow_price))
        string wave_dir_2 = nz(horizon_pulse_2, 50) > nz(horizon_flow_2, 50) ? " â–²" : " â–¼"
        string label_style_2 = display_at_top ? label.style_label_down : label.style_label_up
        float label_y_2 = display_at_top ? wave_zone_top : wave_zone_bottom
        g_horizon_label_2 := label.new(wave_start_2 + int(wave_history_depth / 2), label_y_2, 
             f_horizon_format(i_mtf_tf2) + wave_dir_2, 
             style=label_style_2, textcolor=DAFE_CYAN, color=color.new(DAFE_VOID, 30), 
             size=size.small, force_overlay=true)
        if array.size(g_quantum_path_2) > 1
            g_quantum_wave_2 := polyline.new(g_quantum_path_2, line_color=DAFE_CYAN, line_width=2, force_overlay=true)
            g_signal_wave_2 := polyline.new(g_signal_path_2, line_color=DAFE_GOLD, line_width=1, force_overlay=true)
    if i_temporal_wave_3_show
        int wave_start_3 = bar_index + wave_offset_3
        int wave_end_3 = wave_start_3 + wave_history_depth
        array.clear(g_quantum_path_3)
        array.clear(g_signal_path_3)
        polyline.delete(g_quantum_wave_3)
        polyline.delete(g_signal_wave_3)
        line.delete(g_grid_center_3)
        line.delete(g_grid_upper_3)
        line.delete(g_grid_lower_3)
        label.delete(g_horizon_label_3)
        box.delete(g_wave_bg_3)
        float grid_30_price = f_rsi_to_price(30, wave_zone_bottom, wave_zone_top)
        float grid_50_price = f_rsi_to_price(50, wave_zone_bottom, wave_zone_top)
        float grid_70_price = f_rsi_to_price(70, wave_zone_bottom, wave_zone_top)
        g_wave_bg_3 := box.new(wave_start_3, wave_zone_top, wave_end_3, wave_zone_bottom,
             bgcolor=color.new(DAFE_VOID, 40), border_color=color.new(DAFE_MAGENTA, 0), 
             border_width=2, force_overlay=true)
        g_grid_center_3 := line.new(wave_start_3, grid_50_price, wave_end_3, grid_50_price, 
             style=line.style_dashed, color=color.new(color.gray, 60), force_overlay=true)
        g_grid_upper_3 := line.new(wave_start_3, grid_70_price, wave_end_3, grid_70_price, 
             style=line.style_dotted, color=color.new(DAFE_RED, 70), force_overlay=true)
        g_grid_lower_3 := line.new(wave_start_3, grid_30_price, wave_end_3, grid_30_price, 
             style=line.style_dotted, color=color.new(DAFE_GREEN, 70), force_overlay=true)
        int hist_size_3 = math.min(array.size(g_pulse_history_3), wave_history_depth)
        for idx = 0 to hist_size_3 - 1
            float pulse_val = array.get(g_pulse_history_3, idx)
            float flow_val = array.get(g_flow_history_3, idx)
            float pulse_price = f_rsi_to_price(pulse_val, wave_zone_bottom, wave_zone_top)
            float flow_price = f_rsi_to_price(flow_val, wave_zone_bottom, wave_zone_top)
            array.push(g_quantum_path_3, chart.point.from_index(wave_end_3 - idx, pulse_price))
            array.push(g_signal_path_3, chart.point.from_index(wave_end_3 - idx, flow_price))
        string wave_dir_3 = nz(horizon_pulse_3, 50) > nz(horizon_flow_3, 50) ? " â–²" : " â–¼"
        string label_style_3 = display_at_top ? label.style_label_down : label.style_label_up
        float label_y_3 = display_at_top ? wave_zone_top : wave_zone_bottom
        g_horizon_label_3 := label.new(wave_start_3 + int(wave_history_depth / 2), label_y_3, 
             f_horizon_format(i_mtf_tf3) + wave_dir_3, 
             style=label_style_3, textcolor=DAFE_CYAN, color=color.new(DAFE_VOID, 30), 
             size=size.small, force_overlay=true)
        if array.size(g_quantum_path_3) > 1
            g_quantum_wave_3 := polyline.new(g_quantum_path_3, line_color=DAFE_MAGENTA, line_width=2, force_overlay=true)
            g_signal_wave_3 := polyline.new(g_signal_path_3, line_color=DAFE_GOLD, line_width=1, force_overlay=true)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS 
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(ta.crossover(rsi_final, dyn_os), "RSI Oversold Exit", "RSI crossed above oversold level")
alertcondition(ta.crossunder(rsi_final, dyn_ob), "RSI Overbought Exit", "RSI crossed below overbought level")
alertcondition(ta.crossover(rsi_final, 50), "RSI Bullish Cross", "RSI crossed above 50")
alertcondition(ta.crossunder(rsi_final, 50), "RSI Bearish Cross", "RSI crossed below 50")
alertcondition(rsi_final > dyn_extreme_ob, "Extreme Overbought", "RSI in extreme overbought zone")
alertcondition(rsi_final < dyn_extreme_os, "Extreme Oversold", "RSI in extreme oversold zone")
alertcondition(reg_bull_div, "Bullish Divergence", "Regular bullish divergence detected")
alertcondition(reg_bear_div, "Bearish Divergence", "Regular bearish divergence detected")
alertcondition(hid_bull_div, "Hidden Bullish Divergence", "Hidden bullish divergence detected")
alertcondition(hid_bear_div, "Hidden Bearish Divergence", "Hidden bearish divergence detected")
alertcondition(i_signal_enable and ta.crossover(rsi_final, signal_line), "RSI Signal Bullish Cross", "RSI crossed above signal line")
alertcondition(i_signal_enable and ta.crossunder(rsi_final, signal_line), "RSI Signal Bearish Cross", "RSI crossed below signal line")
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                                                                                                               â•‘
// â•‘                           DAFE RSI: EVOLVED - THEORY & USER GUIDE                                             â•‘
// â•‘                                                                                                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 1. PHILOSOPHY: WHY 30+ ENGINES?                                                                               â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   Momentum is not one-dimensional. Standard RSI (Wilder's) assumes market cycles are constant. They are not.
//   The DAFE Evolved system allows you to match the Oscillator Math to the Market Physics.
//
//   â€¢ SCALPING: Needs speed. Use "Laguerre Time-Warp" or "DAFE Kinetic".
//   â€¢ SWING: Needs stability. Use "Volume-Weighted" or "DAFE Spectral".
//   â€¢ CRYPTO: Needs noise reduction. Use "DAFE Neural Blend" or "Connors RSI".
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 2. DAFE PROPRIETARY ENGINES (The "Special Sauce")                                                             â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   A. DAFE QUANTUM FUSION (Default)
//      Instead of looking at one timeframe, this engine calculates RSI on 3 harmonic timeframes simultaneously
//      (Length, Golden Ratio * Length, Golden RatioÂ² * Length). It then superimposes them based on Volume
//      and Momentum confidence. It is the most robust all-rounder.
//
//   B. DAFE KINETIC ENERGY
//      Momentum = Mass * Velocity. Standard RSI only looks at Velocity (Price Change).
//      Kinetic RSI weights every price move by Relative Volume (Mass).
//      â€¢ High Vol + Small Move = High Kinetic Build-up (Hidden Momentum).
//
//   C. DAFE SPECTRAL
//      Uses Signal Processing to analyze the frequency of price moves. It differentiates between "Signal" (Trend)
//      and "Noise" (Chop). It auto-adjusts its speed: Slow in chop, Fast in trends.
//
//   D. DAFE ENTROPY FLOW
//      Measures the "Disorder" of the market using information theory.
//      â€¢ High Entropy (Chaos): The RSI dampens to avoid false signals.
//      â€¢ Low Entropy (Order): The RSI sharpens to catch the breakout.
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 3. DYNAMIC LEVELS (The "Squeeze" Detector)                                                                    â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   Static 70/30 levels are dangerous in strong trends (Price stays >70 for days).
//   DAFE Dynamic Levels breathe with volatility.
//
//   â€¢ Volatility Expansion: Levels widen (e.g., to 85/15). This keeps you IN the trade during a pump.
//   â€¢ Volatility Compression: Levels tighten (e.g., to 60/40). This helps you catch reversals in range-bound chop.
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 4. QUANTUM HORIZON (Temporal Wave)                                                                            â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//   The "Wave" overlays on the main chart allow you to see the *History of Momentum*.
//   â€¢ Unlike a standard indicator that only shows the *current* value, the Quantum Horizon shows you the
//     path momentum took to get here.
//   â€¢ Use it to spot divergence visually on the main chart without needing the lower pane.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                                            DAFE TRADING SYSTEMS
//                                       "Quantifying the Unseen"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
