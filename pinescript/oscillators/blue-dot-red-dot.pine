//@version=5
indicator(title="Blue/Red Dot + Dynamic Green Line", shorttitle="B/R Dot + Green Line", overlay=true)

// === Stochastic Oscillator Inputs ===
grp_stoch = "Stochastic Settings"
periodK = input.int(10, title="%K Length", minval=1, group=grp_stoch)
smoothK = input.int(4, title="%K Smoothing", minval=1, group=grp_stoch)

// === Stochastic Bollinger Bands Inputs ===
grp_stoch_bb = "Stochastic Bollinger Bands Settings"
stochBB_len = input.int(15, minval=1, title="Stoch BB Length", group=grp_stoch_bb)
stochBB_mult = input.float(2.0, minval=0.001, maxval=50, title="Stoch BB StdDev", group=grp_stoch_bb)

// === MTF Signal Inputs ===
grp_mtf = "Multi-Timeframe (MTF) Settings"
useMTFSignals = input.bool(true, title="Enable MTF Signals (Yellow/Green Dots)", group=grp_mtf)

// MTF 1
tf1 = input.timeframe("15", "MTF 1", inline="mtf1", group=grp_mtf)
useTf1 = input.bool(true, "", inline="mtf1", group=grp_mtf)
// MTF 2
tf2 = input.timeframe("30", "MTF 2", inline="mtf2", group=grp_mtf)
useTf2 = input.bool(true, "", inline="mtf2", group=grp_mtf)
// MTF 3
tf3 = input.timeframe("45", "MTF 3", inline="mtf3", group=grp_mtf)
useTf3 = input.bool(true, "", inline="mtf3", group=grp_mtf)
// MTF 4
tf4 = input.timeframe("65", "MTF 4", inline="mtf4", group=grp_mtf)
useTf4 = input.bool(false, "", inline="mtf4", group=grp_mtf)
// MTF 5
tf5 = input.timeframe("D", "MTF 5", inline="mtf5", group=grp_mtf)
useTf5 = input.bool(false, "", inline="mtf5", group=grp_mtf)
// MTF 6
tf6 = input.timeframe("W", "MTF 6", inline="mtf6", group=grp_mtf)
useTf6 = input.bool(false, "", inline="mtf6", group=grp_mtf)

// === Line Appearance Settings (Blue/Red) ===
grp_lines = "Blue/Red Line Settings"
c_blueLine = input.color(color.blue, "Blue Line Color", group=grp_lines)
c_redLine  = input.color(color.red, "Red Line Color", group=grp_lines)
in_style   = input.string("Dotted", "Blue/Red Style", options=["Dotted", "Dashed", "Solid"], group=grp_lines)
in_width   = input.int(2, "Blue/Red Width", minval=1, group=grp_lines)
extend_val = input.int(3, "Extension Length (Bars)", minval=1, group=grp_lines)

// === Dr Wish Green Line Settings ===
grp_wish = "Dr Wish Green Line (Weekly Breakout)"
showGreenLine = input.bool(true, "Show Green Line", group=grp_wish)
wish_len      = input.int(52, "Lookback Length (Weeks)", minval=1, tooltip="Use 52 for 1-Year High. Use 250+ for approx All-Time High.", group=grp_wish)
wish_color    = input.color(color.green, "Green Line Color", group=grp_wish)
wish_style_in = input.string("Dotted", "Green Line Style", options=["Dotted", "Dashed", "Solid"], group=grp_wish)
wish_width    = input.int(2, "Green Line Width", minval=1, group=grp_wish)

// Internal Setting for Label Offset (How far right the text is)
label_offset = 3

// Convert string input to Pine line style
get_style(str) =>
    if str == "Solid"
        line.style_solid
    else if str == "Dashed"
        line.style_dashed
    else
        line.style_dotted

// Store styles
style_BlueRed = get_style(in_style)
style_Wish    = get_style(wish_style_in)

// === Base Calculations ===

// Calculate Stochastic %K line
stochK_raw = ta.stoch(close, high, low, periodK)
stochK = ta.sma(stochK_raw, smoothK)

// Calculate Bollinger Bands ON the Stochastic %K line
stochBB_basis = ta.sma(stochK, stochBB_len)
stochBB_dev = stochBB_mult * ta.stdev(stochK, stochBB_len)
stochBB_upper = stochBB_basis + stochBB_dev
stochBB_lower = stochBB_basis - stochBB_dev

// === "Dr Wish" Signal Logic (for all timeframes) ===
bool blueDotSignal = ta.crossover(stochK, stochBB_lower)
bool redDotSignal = ta.crossunder(stochK, stochBB_upper)

// === MTF Signal Logic ===

// Helper function to safely check for a signal, avoiding 'na' errors
f_safeCheck(signal) => 
    na(signal) ? false : signal

// Request signals from all 6 timeframes
[tf1_blue, tf1_red] = request.security(syminfo.tickerid, tf1, [blueDotSignal, redDotSignal], lookahead=barmerge.lookahead_off)
[tf2_blue, tf2_red] = request.security(syminfo.tickerid, tf2, [blueDotSignal, redDotSignal], lookahead=barmerge.lookahead_off)
[tf3_blue, tf3_red] = request.security(syminfo.tickerid, tf3, [blueDotSignal, redDotSignal], lookahead=barmerge.lookahead_off)
[tf4_blue, tf4_red] = request.security(syminfo.tickerid, tf4, [blueDotSignal, redDotSignal], lookahead=barmerge.lookahead_off)
[tf5_blue, tf5_red] = request.security(syminfo.tickerid, tf5, [blueDotSignal, redDotSignal], lookahead=barmerge.lookahead_off)
[tf6_blue, tf6_red] = request.security(syminfo.tickerid, tf6, [blueDotSignal, redDotSignal], lookahead=barmerge.lookahead_off)

// Check if current timeframe matches one of the MTF ones
isTf1 = timeframe.period == tf1
isTf2 = timeframe.period == tf2
isTf3 = timeframe.period == tf3
isTf4 = timeframe.period == tf4
isTf5 = timeframe.period == tf5
isTf6 = timeframe.period == tf6

// --- NEW Confluence Counting Logic ---
int mtfBlueCount = 0
int mtfRedCount = 0

if useMTFSignals
    // MTF 1
    if useTf1 and not isTf1
        mtfBlueCount += f_safeCheck(tf1_blue) ? 1 : 0
        mtfRedCount  += f_safeCheck(tf1_red) ? 1 : 0
    // MTF 2
    if useTf2 and not isTf2
        mtfBlueCount += f_safeCheck(tf2_blue) ? 1 : 0
        mtfRedCount  += f_safeCheck(tf2_red) ? 1 : 0
    // MTF 3
    if useTf3 and not isTf3
        mtfBlueCount += f_safeCheck(tf3_blue) ? 1 : 0
        mtfRedCount  += f_safeCheck(tf3_red) ? 1 : 0
    // MTF 4
    if useTf4 and not isTf4
        mtfBlueCount += f_safeCheck(tf4_blue) ? 1 : 0
        mtfRedCount  += f_safeCheck(tf4_red) ? 1 : 0
    // MTF 5
    if useTf5 and not isTf5
        mtfBlueCount += f_safeCheck(tf5_blue) ? 1 : 0
        mtfRedCount  += f_safeCheck(tf5_red) ? 1 : 0
    // MTF 6
    if useTf6 and not isTf6
        mtfBlueCount += f_safeCheck(tf6_blue) ? 1 : 0
        mtfRedCount  += f_safeCheck(tf6_red) ? 1 : 0

// --- Define the final plot condition ---
// We plot a signal only if the count is 2 or more
bool plotMtfBlue = mtfBlueCount >= 2
bool plotMtfRed = mtfRedCount >= 2


// === Dr Wish Green Line Calculation ===
weeklyHigh = request.security(syminfo.tickerid, "W", ta.highest(high, wish_len)[1], lookahead=barmerge.lookahead_on)

// Variable to hold the single active Green Line
var line wishLineID = na
var label wishLabelID = na // Label variable

if showGreenLine
    // 1. Delete the previous line and label (so we don't leave a trail)
    line.delete(wishLineID)
    label.delete(wishLabelID)
    
    if not na(weeklyHigh)
        // 2. Draw the new line at the CURRENT Weekly Breakout Level
        // It starts at the current bar and extends to the right
        wishLineID := line.new(bar_index, weeklyHigh, bar_index + extend_val, weeklyHigh, color=wish_color, style=style_Wish, width=wish_width)
        // Draw the label (Text Color changed to WHITE)
        // Added + label_offset to x coordinate
        wishLabelID := label.new(bar_index + extend_val + label_offset, weeklyHigh, text="GLB", color=color.new(color.white, 100), style=label.style_label_left, textcolor=color.white, size=size.small)

// === Plotting Dots ===

// --- Original Signals (Current Timeframe) ---
plotshape(blueDotSignal, style=shape.circle, location=location.belowbar, color=color.new(color.blue, 0), size=size.tiny, title="Blue Dot (TF Buy)")
plotshape(redDotSignal, style=shape.circle, location=location.abovebar, color=color.new(color.red, 0), size=size.tiny, title="Red Dot (TF Sell)")

// --- MTF Signals (Plotted on Current Timeframe) ---
plotshape(plotMtfBlue, style=shape.circle, location=location.belowbar, color=color.new(color.green,85), size=size.tiny, title="Green Dot (MTF Buy Confluence)")
plotshape(plotMtfRed, style=shape.circle, location=location.abovebar, color=color.new(color.yellow, 85), size=size.tiny, title="Yellow Dot (MTF Sell Confluence)")

// === Dynamic Line Drawing (Dots) ===
// Persistent variables to hold the ID of the active lines
var line blueLineID = na
var line redLineID = na
// Persistent variables to hold the ID of the active labels
var label blueLabelID = na
var label redLabelID = na

// 1. Logic for Blue Line (Buy)
if blueDotSignal
    // Delete previous blue line/label if it exists
    line.delete(blueLineID)
    label.delete(blueLabelID)
    // Create new line at the HIGH of the candle using Custom Settings
    blueLineID := line.new(bar_index, high, bar_index + 1, high, color=c_blueLine, style=style_BlueRed, width=in_width)
    // Create new label (Text Color changed to WHITE)
    // Added + label_offset to x coordinate
    blueLabelID := label.new(bar_index + 1 + label_offset, high, text="BD", color=color.new(color.white, 100), style=label.style_label_left, textcolor=color.white, size=size.small)

// 2. Logic for Red Line (Sell)
if redDotSignal
    // Delete previous red line/label if it exists
    line.delete(redLineID)
    label.delete(redLabelID)
    // Create new line at the HIGH of the candle using Custom Settings
    redLineID := line.new(bar_index, high, bar_index + 1, high, color=c_redLine, style=style_BlueRed, width=in_width)
    // Create new label (Text Color changed to WHITE)
    // Added + label_offset to x coordinate
    redLabelID := label.new(bar_index + 1 + label_offset, high, text="RD", color=color.new(color.white, 100), style=label.style_label_left, textcolor=color.white, size=size.small)

// 3. Keep extending the lines AND labels to the right on every new bar (custom length)
if not na(blueLineID)
    line.set_x2(blueLineID, bar_index + extend_val)
    // Keep label offset relative to extension
    label.set_x(blueLabelID, bar_index + extend_val + label_offset)

if not na(redLineID)
    line.set_x2(redLineID, bar_index + extend_val)
    // Keep label offset relative to extension
    label.set_x(redLabelID, bar_index + extend_val + label_offset)
