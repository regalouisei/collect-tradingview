// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © PhenLabs

//    ______      __                         ____  _                                          
//   / ____/___  / /__________  ____  __  __/ __ \(_)   _____  _________ ____  ____  ________ 
//  / __/ / __ \/ __/ ___/ __ \/ __ \/ / / / / / / / | / / _ \/ ___/ __ `/ _ \/ __ \/ ___/ _ \
// / /___/ / / / /_/ /  / /_/ / /_/ / /_/ / /_/ / /| |/ /  __/ /  / /_/ /  __/ / / / /__/  __/
///_____/_/ /_/\__/_/   \____/ .___/\__, /_____/_/ |___/\___/_/   \__, /\___/_/ /_/\___/\___/ 
//                          /_/    /____/                        /____/                       
//                          @PhenLabs - Version One

//@version=6
indicator('Entropy Divergence (No Repaint)', shorttitle = 'EDS', overlay = false, precision = 4)

// ══════════════════════════════════════════════════════════════════════════════
// ███ INPUT PARAMETERS ███
// ══════════════════════════════════════════════════════════════════════════════

// --- Entropy Settings ---
grpEntropy = '═══ Shannon Entropy Settings ═══'
entropyLength = input.int(20, 'Entropy Lookback Period', minval = 5, maxval = 100, tooltip = 'Number of bars used to calculate Shannon Entropy. Higher values = smoother but slower response.', group = grpEntropy)
entropyBins = input.int(10, 'Histogram Bins', minval = 5, maxval = 50, tooltip = 'Number of bins for probability distribution. More bins = finer granularity.', group = grpEntropy)
entropyThreshold = input.float(2.5, 'Low Entropy Threshold', minval = 0.5, maxval = 4.0, step = 0.1, tooltip = 'Signals only trigger when entropy drops below this value. Lower = more selective.', group = grpEntropy)
entropySmoothLen = input.int(3, 'Entropy Smoothing', minval = 1, maxval = 10, tooltip = 'EMA smoothing applied to raw entropy values.', group = grpEntropy)

// --- RSI Divergence Settings ---
grpRSI = '═══ RSI Divergence Settings ═══'
rsiLength = input.int(14, 'RSI Length', minval = 5, maxval = 50, group = grpRSI)
rsiSource = input.source(close, 'RSI Source', group = grpRSI)

// --- Divergence Detection Settings ---
grpDiv = '═══ Divergence Detection ═══'
pivotLookbackLeft = input.int(5, 'Pivot Lookback Left', minval = 2, maxval = 20, tooltip = 'Bars to the left for pivot detection.', group = grpDiv)
pivotLookbackRight = input.int(2, 'Pivot Lookback Right', minval = 1, maxval = 10, tooltip = 'Bars to the right for pivot confirmation. Lower = faster signals.', group = grpDiv)
divLookbackranges = input.int(60, 'Divergence Search ranges', minval = 20, maxval = 200, tooltip = 'Maximum bars to look back for divergence comparison.', group = grpDiv)
minDivBars = input.int(5, 'Min Bars Between Pivots', minval = 3, maxval = 30, tooltip = 'Minimum distance between pivots for valid divergence.', group = grpDiv)

// --- Visual Settings ---
grpVisual = '═══ Visual Customization ═══'
bullColor = input.color(color.new(#00E5FF, 0), 'Bullish Signal Color', group = grpVisual)
bearColor = input.color(color.new(#FF1744, 0), 'Bearish Signal Color', group = grpVisual)
entropyColorHigh = input.color(color.new(#FF6D00, 0), 'High Entropy Color', group = grpVisual)
entropyColorLow = input.color(color.new(#00C853, 0), 'Low Entropy Color', group = grpVisual)
showEntropyFill = input.bool(true, 'Show Low Entropy Zone Fill', group = grpVisual)
showDivergenceLines = input.bool(true, 'Show Divergence Lines', group = grpVisual)
signalSize = input.string('Normal', 'Signal Label Size', options = ['Tiny', 'Small', 'Normal', 'Large'], group = grpVisual)

// ══════════════════════════════════════════════════════════════════════════════
// ███ HELPER FUNCTIONS ███
// ══════════════════════════════════════════════════════════════════════════════

// Convert label size string to size constant
getLabelSize(sizeStr) =>
    switch sizeStr
        'Tiny' => size.tiny
        'Small' => size.small
        'Normal' => size.normal
        'Large' => size.large
        => size.normal


// ══════════════════════════════════════════════════════════════════════════════
// ███ SHANNON ENTROPY CALCULATION ███
// Mathematical basis: H(X) = -Σ p(x) * log₂(p(x))
// Measures uncertainty/randomness in price returns
// Lower entropy = more predictable price behavior = better for scalping
// ══════════════════════════════════════════════════════════════════════════════

// Calculate logarithmic returns for entropy analysis
// Using log returns provides better statistical properties than simple returns
priceReturns = math.log(close / close[1])

// Function to calculate Shannon Entropy over a lookback period
// This bins the returns into discrete categories and calculates probability distribution
calcShannonEntropy(float src, int length, int bins) =>
    // Find the ranges of returns in the lookback period
    float minVal = ta.lowest(src, length)
    float maxVal = ta.highest(src, length)
    float ranges = maxVal - minVal

    // Prevent division by zero in flat markets
    float binWidth = ranges > 0 ? ranges / bins : 1.0

    // Initialize array to store bin counts
    var array<float> binCounts = array.new_float(bins, 0.0)

    // Reset bin counts for fresh calculation
    for i = 0 to bins - 1 by 1
        array.set(binCounts, i, 0.0)

    // Count occurrences in each bin (histogram construction)
    for i = 0 to length - 1 by 1
        float val = src[i]
        // Determine which bin this value falls into
        int binIndex = ranges > 0 ? math.floor((val - minVal) / binWidth) : 0
        // Clamp to valid bin ranges
        binIndex := math.max(0, math.min(bins - 1, binIndex))
        array.set(binCounts, binIndex, array.get(binCounts, binIndex) + 1)

    // Calculate Shannon Entropy from probability distribution
    float entropy = 0.0
    for i = 0 to bins - 1 by 1
        float count = array.get(binCounts, i)
        if count > 0
            // Calculate probability for this bin
            float probability = count / length
            // Shannon Entropy formula: -p * log2(p)
            // Using natural log and converting: log2(x) = ln(x) / ln(2)
            entropy := entropy - probability * (math.log(probability) / math.log(2))
            entropy

    entropy

// Calculate raw entropy
float rawEntropy = calcShannonEntropy(priceReturns, entropyLength, entropyBins)

// Apply smoothing to reduce noise while maintaining responsiveness
float smoothedEntropy = ta.ema(rawEntropy, entropySmoothLen)

// Determine if current entropy is in "low" (tradeable) zone
bool isLowEntropy = smoothedEntropy < entropyThreshold


// ══════════════════════════════════════════════════════════════════════════════
// ███ RSI CALCULATION ███
// ══════════════════════════════════════════════════════════════════════════════

float rsiValue = ta.rsi(rsiSource, rsiLength)


// ══════════════════════════════════════════════════════════════════════════════
// ███ DIVERGENCE DETECTION ENGINE ███
// Detects when price and indicator move in opposite directions
// Bullish Divergence: Price makes Lower Low, Indicator makes Higher Low
// Bearish Divergence: Price makes Higher High, Indicator makes Lower High
// ══════════════════════════════════════════════════════════════════════════════

// --- Pivot Detection for Price ---
// Using ta.pivotlow/ta.pivothigh for robust pivot identification
float pricePivotLow = ta.pivotlow(low, pivotLookbackLeft, pivotLookbackRight)
float pricePivotHigh = ta.pivothigh(high, pivotLookbackLeft, pivotLookbackRight)

// --- Pivot Detection for RSI ---
float rsiPivotLow = ta.pivotlow(rsiValue, pivotLookbackLeft, pivotLookbackRight)
float rsiPivotHigh = ta.pivothigh(rsiValue, pivotLookbackLeft, pivotLookbackRight)

// --- Pivot Detection for Volume ---
float volPivotLow = ta.pivotlow(volume, pivotLookbackLeft, pivotLookbackRight)
float volPivotHigh = ta.pivothigh(volume, pivotLookbackLeft, pivotLookbackRight)

// Store pivot values and bar indices for divergence comparison
var float lastPriceLow = na
var int lastPriceLowBar = na
var float lastPriceHigh = na
var int lastPriceHighBar = na

var float lastRsiLow = na
var int lastRsiLowBar = na
var float lastRsiHigh = na
var int lastRsiHighBar = na

var float lastVolLow = na
var int lastVolLowBar = na
var float lastVolHigh = na
var int lastVolHighBar = na

// Previous pivot storage for divergence detection
var float prevPriceLow = na
var int prevPriceLowBar = na
var float prevPriceHigh = na
var int prevPriceHighBar = na

var float prevRsiLow = na
var float prevRsiHigh = na

var float prevVolLow = na
var float prevVolHigh = na

// Offset for pivot detection (pivots are confirmed pivotLookbackRight bars ago)
int pivotOffset = pivotLookbackRight

// Update pivot tracking when new pivots are detected
// Price Lows
if not na(pricePivotLow)
    prevPriceLow := lastPriceLow
    prevPriceLowBar := lastPriceLowBar
    lastPriceLow := pricePivotLow
    lastPriceLowBar := bar_index - pivotOffset
    lastPriceLowBar

// Price Highs
if not na(pricePivotHigh)
    prevPriceHigh := lastPriceHigh
    prevPriceHighBar := lastPriceHighBar
    lastPriceHigh := pricePivotHigh
    lastPriceHighBar := bar_index - pivotOffset
    lastPriceHighBar

// RSI Lows
if not na(rsiPivotLow)
    prevRsiLow := lastRsiLow
    lastRsiLow := rsiPivotLow
    lastRsiLowBar := bar_index - pivotOffset
    lastRsiLowBar

// RSI Highs
if not na(rsiPivotHigh)
    prevRsiHigh := lastRsiHigh
    lastRsiHigh := rsiPivotHigh
    lastRsiHighBar := bar_index - pivotOffset
    lastRsiHighBar

// Volume Lows
if not na(volPivotLow)
    prevVolLow := lastVolLow
    lastVolLow := volPivotLow
    lastVolLowBar := bar_index - pivotOffset
    lastVolLowBar

// Volume Highs
if not na(volPivotHigh)
    prevVolHigh := lastVolHigh
    lastVolHigh := volPivotHigh
    lastVolHighBar := bar_index - pivotOffset
    lastVolHighBar


// ══════════════════════════════════════════════════════════════════════════════
// ███ DIVERGENCE SIGNAL DETECTION ███
// All signals require barstate.isconfirmed to guarantee NO REPAINTING
// ══════════════════════════════════════════════════════════════════════════════

// --- RSI Bullish Divergence Detection ---
// Condition: Price makes Lower Low AND RSI makes Higher Low
bool rsiRegularBullDiv = false
if barstate.isconfirmed and not na(pricePivotLow) and not na(prevPriceLow) and not na(lastRsiLow) and not na(prevRsiLow)
    // Check if pivots are within valid ranges and minimum distance
    bool validranges = bar_index - pivotOffset - prevPriceLowBar <= divLookbackranges
    bool validDistance = bar_index - pivotOffset - prevPriceLowBar >= minDivBars
    // Price: Lower Low
    bool priceLowerLow = lastPriceLow < prevPriceLow
    // RSI: Higher Low (bullish divergence)
    bool rsiHigherLow = lastRsiLow > prevRsiLow

    rsiRegularBullDiv := validranges and validDistance and priceLowerLow and rsiHigherLow
    rsiRegularBullDiv

// --- RSI Bearish Divergence Detection ---
// Condition: Price makes Higher High AND RSI makes Lower High
bool rsiRegularBearDiv = false
if barstate.isconfirmed and not na(pricePivotHigh) and not na(prevPriceHigh) and not na(lastRsiHigh) and not na(prevRsiHigh)
    bool validranges = bar_index - pivotOffset - prevPriceHighBar <= divLookbackranges
    bool validDistance = bar_index - pivotOffset - prevPriceHighBar >= minDivBars
    // Price: Higher High
    bool priceHigherHigh = lastPriceHigh > prevPriceHigh
    // RSI: Lower High (bearish divergence)
    bool rsiLowerHigh = lastRsiHigh < prevRsiHigh

    rsiRegularBearDiv := validranges and validDistance and priceHigherHigh and rsiLowerHigh
    rsiRegularBearDiv

// --- Volume Bullish Divergence Detection ---
// Condition: Price makes Lower Low AND Volume makes Higher Low (increasing interest at lows)
bool volBullDiv = false
if barstate.isconfirmed and not na(pricePivotLow) and not na(prevPriceLow) and not na(lastVolLow) and not na(prevVolLow)
    bool validranges = bar_index - pivotOffset - prevPriceLowBar <= divLookbackranges
    bool validDistance = bar_index - pivotOffset - prevPriceLowBar >= minDivBars
    bool priceLowerLow = lastPriceLow < prevPriceLow
    bool volHigherLow = lastVolLow > prevVolLow

    volBullDiv := validranges and validDistance and priceLowerLow and volHigherLow
    volBullDiv

// --- Volume Bearish Divergence Detection ---
// Condition: Price makes Higher High AND Volume makes Lower High (decreasing conviction at highs)
bool volBearDiv = false
if barstate.isconfirmed and not na(pricePivotHigh) and not na(prevPriceHigh) and not na(lastVolHigh) and not na(prevVolHigh)
    bool validranges = bar_index - pivotOffset - prevPriceHighBar <= divLookbackranges
    bool validDistance = bar_index - pivotOffset - prevPriceHighBar >= minDivBars
    bool priceHigherHigh = lastPriceHigh > prevPriceHigh
    bool volLowerHigh = lastVolHigh < prevVolHigh

    volBearDiv := validranges and validDistance and priceHigherHigh and volLowerHigh
    volBearDiv


// ══════════════════════════════════════════════════════════════════════════════
// ███ FINAL SIGNAL GENERATION ███
// Combines entropy filter with divergence signals
// Signal only triggers when: Low Entropy + Confirmed Divergence + Bar Confirmed
// ══════════════════════════════════════════════════════════════════════════════

// --- Primary Signals (Entropy-Filtered) ---
bool bullSignal = barstate.isconfirmed and isLowEntropy and (rsiRegularBullDiv or volBullDiv)
bool bearSignal = barstate.isconfirmed and isLowEntropy and (rsiRegularBearDiv or volBearDiv)

// --- Signal Classification (for labeling) ---
string bullSignalType = rsiRegularBullDiv and volBullDiv ? 'RSI+VOL' : rsiRegularBullDiv ? 'RSI' : 'VOL'
string bearSignalType = rsiRegularBearDiv and volBearDiv ? 'RSI+VOL' : rsiRegularBearDiv ? 'RSI' : 'VOL'


// ══════════════════════════════════════════════════════════════════════════════
// ███ VISUAL RENDERING ███
// ══════════════════════════════════════════════════════════════════════════════

// --- Dynamic Entropy Color (gradient based on value) ---
// Interpolate between high entropy (oranges/red) and low entropy (green) colors
float entropyNormalized = math.max(0, math.min(1, (smoothedEntropy - 1) / 3))
color entropyDynamicColor = color.from_gradient(entropyNormalized, 0, 1, entropyColorLow, entropyColorHigh)

// --- Plot Entropy Line with dynamic coloring ---
plot(smoothedEntropy, 'Shannon Entropy', color = entropyDynamicColor, linewidth = 2, style = plot.style_line)

// --- Entropy Threshold Reference Line ---
hline(entropyThreshold, 'Entropy Threshold', color = color.new(color.white, 70), linestyle = hline.style_dashed)

// --- Low Entropy Zone Background Fill ---
float zeroLine = 0
bgcolor(showEntropyFill and isLowEntropy ? color.new(entropyColorLow, 85) : na, title = 'Low Entropy Zone')

// --- RSI Reference Plot (scaled to fit entropy pane) ---
float rsiScaled = rsiValue / 25 // Scale RSI (0-100) to fit entropy ranges (0-4)
plot(rsiScaled, 'RSI (Scaled)', color = color.new(#9C27B0, 50), linewidth = 1, style = plot.style_line)

// --- Volume Bars (normalized and scaled) ---
float volSMA = ta.sma(volume, 20)
float volNormalized = volSMA > 0 ? volume / volSMA * 1.5 : 0
plot(volNormalized, 'Volume (Normalized)', color = color.new(#2196F3, 60), style = plot.style_columns)


// ══════════════════════════════════════════════════════════════════════════════
// ███ SIGNAL LABELS AND MARKERS ███
// ══════════════════════════════════════════════════════════════════════════════

labelSz = getLabelSize(signalSize)

// --- Bullish Signal Labels ---
if bullSignal
    label.new(bar_index, smoothedEntropy - 0.3, text = '▲ LONG\n' + bullSignalType, style = label.style_label_up, color = color.new(bullColor, 10), textcolor = color.white, size = labelSz)

// --- Bearish Signal Labels ---
if bearSignal
    label.new(bar_index, smoothedEntropy + 0.3, text = '▼ SHORT\n' + bearSignalType, style = label.style_label_down, color = color.new(bearColor, 10), textcolor = color.white, size = labelSz)

// ══════════════════════════════════════════════════════════════════════════════
// ███ INFORMATION TABLE ███
// Displays current indicator state for quick reference
// ══════════════════════════════════════════════════════════════════════════════

var table infoTable = table.new(position.top_right, 2, 5, bgcolor = color.new(#1E1E1E, 10), border_color = color.new(color.white, 80), border_width = 1)

if barstate.islast
    // Header
    table.cell(infoTable, 0, 0, 'ENTROPY SCALPER', text_color = color.white, text_size = size.small, bgcolor = color.new(#333333, 0))
    table.merge_cells(infoTable, 0, 0, 1, 0)

    // Entropy Value
    table.cell(infoTable, 0, 1, 'Entropy', text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 1, str.tostring(smoothedEntropy, '#.###'), text_color = isLowEntropy ? entropyColorLow : entropyColorHigh, text_size = size.tiny)

    // Entropy State
    table.cell(infoTable, 0, 2, 'State', text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 2, isLowEntropy ? 'LOW ✓' : 'HIGH ✗', text_color = isLowEntropy ? entropyColorLow : entropyColorHigh, text_size = size.tiny)

    // RSI Value
    table.cell(infoTable, 0, 3, 'RSI', text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 3, str.tostring(rsiValue, '#.#'), text_color = rsiValue > 70 ? bearColor : rsiValue < 30 ? bullColor : color.white, text_size = size.tiny)

    // Signal Status
    string signalStatus = bullSignal ? '▲ LONG' : bearSignal ? '▼ SHORT' : '—'
    color signalCol = bullSignal ? bullColor : bearSignal ? bearColor : color.gray
    table.cell(infoTable, 0, 4, 'Signal', text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 4, signalStatus, text_color = signalCol, text_size = size.tiny)


// ══════════════════════════════════════════════════════════════════════════════
// ███ ALERTS ███
// ══════════════════════════════════════════════════════════════════════════════
alertcondition(bullSignal, title = 'EDS Bullish Signal', message = 'Entropy Divergence Scalper: BULLISH signal detected. Low entropy + {{plot_0}} divergence confirmed. Entropy: {{plot_0}}')

alertcondition(bearSignal, title = 'EDS Bearish Signal', message = 'Entropy Divergence Scalper: BEARISH signal detected. Low entropy + {{plot_0}} divergence confirmed. Entropy: {{plot_0}}')

alertcondition(bullSignal or bearSignal, title = 'EDS Any Signal', message = 'Entropy Divergence Scalper: Signal detected! Check chart for direction.')

alertcondition(ta.crossunder(smoothedEntropy, entropyThreshold), title = 'EDS Low Entropy Zone Entry', message = 'Entropy Divergence Scalper: Entering LOW ENTROPY zone. Watch for divergence signals.')


// ══════════════════════════════════════════════════════════════════════════════
// ███ NON-REPAINTING GUARANTEE ███
// This indicator is designed with strict non-repainting principles:
// 
// 1. ALL signals use barstate.isconfirmed - signals only appear after bar close
// 2. Pivot detection uses ta.pivotlow/ta.pivothigh which confirms pivots 
//    only after pivotLookbackRight bars have passed
// 3. No request.security() calls that could cause repainting
// 4. No future-looking functions (offset into future)
// 5. All calculations use historical data only
//
// VERIFICATION: Add this indicator to your chart and watch in real-time.
// Signals will ONLY appear after the bar closes, never during formation.
// ══════════════════════════════════════════════════════════════════════════════
