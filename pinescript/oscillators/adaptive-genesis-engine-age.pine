//@version=5
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘         ADAPTIVE GENESIS ENGINE (AGE)                                       â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
indicator("Adaptive Genesis Engine [AGE]", shorttitle="ğŸ§¬ AGE PRO", overlay=true, 
     max_bars_back=500, max_labels_count=100, max_lines_count=150, max_boxes_count=50, 
     max_polylines_count=100)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
group_age = "ğŸ§¬ Evolution Engine"
group_sig = "ğŸ“ˆ Signal Quality"
group_dvs = "ğŸ“Š Volatility Scaling"  
group_wfo = "ğŸ”¬ Walk-Forward"
group_vis = "ğŸ¨ Premium Visuals"
group_diag = "ğŸ” Diagnostics"
i_enableAGE = input.bool(true, "Enable AGE Evolution", group=group_age, tooltip="Master switch for evolutionary engine. When OFF, uses only seed strategies without evolution.")
i_maxPopulation = input.int(8, "Max Population", minval=4, maxval=12, group=group_age, tooltip="Maximum active strategies. Higher = more diversity but slower. Recommended: 6-8 for best balance.")
i_minPopulation = input.int(3, "Min Population", minval=2, maxval=4, group=group_age, tooltip="Minimum strategies to maintain. System never culls below this. Prevents population collapse.")
i_eliteCount = input.int(2, "Elite Preservation", minval=1, maxval=3, group=group_age, tooltip="Top N performers protected from culling. Ensures best DNA survives. Recommended: 2")
i_histSpawnInterval = input.int(30, "Historical: Spawn Interval", minval=10, maxval=100, group=group_age, tooltip="Bars between spawning during historical data. Lower = faster evolution. Default: 30 bars")
i_histCullInterval = input.int(60, "Historical: Cull Interval", minval=20, maxval=200, group=group_age, tooltip="Bars between culling during historical data. Should be 2x spawn interval. Default: 60 bars")
i_liveSpawnInterval = input.int(200, "Live: Spawn Interval", minval=100, maxval=500, group=group_age, tooltip="Bars between spawning during live trading. Much slower for stability. Default: 200 bars")
i_liveCullInterval = input.int(400, "Live: Cull Interval", minval=200, maxval=1000, group=group_age, tooltip="Bars between culling during live trading. Should be 2x live spawn. Default: 400 bars")
i_histMutationRate = input.float(0.20, "Historical: Mutation Rate", minval=0.05, maxval=0.40, step=0.05, group=group_age, tooltip="Probability of gene mutation during historical evolution. Higher = more exploration. Range: 5-40%, Default: 20%")
i_liveMutationRate = input.float(0.08, "Live: Mutation Rate", minval=0.02, maxval=0.20, step=0.02, group=group_age, tooltip="Mutation rate during live trading. Much lower for stability. Range: 2-20%, Default: 8%")
i_mutationStrength = input.float(0.12, "Mutation Strength", minval=0.05, maxval=0.25, step=0.01, group=group_age, tooltip="How much genes change when mutated (% of range). Higher = bigger jumps. Range: 5-25%, Default: 12%")
i_minProbability = input.float(0.65, "Min Signal Probability", minval=0.55, maxval=0.80, step=0.05, group=group_sig, tooltip="Minimum probability for entry. 65% = institutional grade, balanced quality/frequency. 70%+ = very selective, fewer signals.")
i_minConfluence = input.int(2, "Min Confluence Score", minval=1, maxval=3, group=group_sig, tooltip="Required indicator agreement: 1=any signal, 2=2 of 3 agree (recommended), 3=all 3 must agree (very selective)")
i_basePersistence = input.int(2, "Base Persistence Bars", minval=1, maxval=5, group=group_sig, tooltip="Base bars signal must persist. System adapts: high prob (75%+) enters faster, low prob needs more confirmation.")
i_cooldownBars = input.int(8, "Cooldown After Trade", minval=3, maxval=20, group=group_sig, tooltip="Bars to wait after exit before next entry. Prevents overtrading. Range: 3-20, Default: 8")
i_entropyLen = input.int(20, "Entropy Length", minval=10, maxval=50, group=group_sig, tooltip="Period for market order/disorder calculation. Lower = responsive, Higher = stable. Default: 20 works across timeframes.")
i_momentumLen = input.int(14, "Momentum Length", minval=5, maxval=30, group=group_sig, tooltip="Period for RSI/ROC momentum. Standard is 14. Lower = more signals, Higher = stronger signals.")
i_structureLen = input.int(50, "Structure Length", minval=20, maxval=100, group=group_sig, tooltip="Lookback for support/resistance detection. Defines swing range. 50 = medium-term, 100 = major structure.")
i_trendLen = input.int(50, "Trend EMA Length", minval=20, maxval=100, group=group_sig, tooltip="EMA for trend detection and direction bias. 50 = medium-term, 20 = short-term, 100 = long-term.")
i_atrPeriod = input.int(14, "ATR Period", minval=5, maxval=30, group=group_sig, tooltip="Period for ATR (stops/targets). Standard is 14. Represents typical volatility over this period.")
i_enableDVS = input.bool(true, "Enable DVS", group=group_dvs, tooltip="Dynamic Volatility Scaling adjusts position sizing and stops based on current vs historical volatility. Recommended: ON")
i_dvsMethod = input.string("Ensemble", "DVS Method", options=["ATR Ratio", "Parkinson", "Garman-Klass", "Ensemble"], group=group_dvs, tooltip="Volatility measurement: ATR Ratio=simple, Parkinson=high-low range, Garman-Klass=OHLC, Ensemble=median of all 3 (most robust)")
i_dvsMemory = input.int(100, "DVS Memory", minval=20, maxval=200, group=group_dvs, tooltip="Lookback for baseline volatility. Longer = slower regime adaptation. Default: 100 bars balances speed and stability.")
i_dvsSensitivity = input.float(0.7, "DVS Sensitivity", minval=0.3, maxval=1.5, step=0.1, group=group_dvs, tooltip="How much volatility affects scaling. 0.5=conservative, 0.7=balanced, 1.0=aggressive. Higher = bigger adjustments to vol spikes.")
i_enableWFO = input.bool(true, "Enable WFO", group=group_wfo, tooltip="Walk-Forward Optimization tests strategies on out-of-sample data before live use. Prevents overfitting. Recommended: ON")
i_wfoTrainBars = input.int(250, "Training Window", minval=100, maxval=500, group=group_wfo, tooltip="Bars for training/optimizing each strategy. Longer = more data but slower validation. Default: 250 (~1-2 months daily)")
i_wfoTestBars = input.int(75, "Testing Window", minval=30, maxval=200, group=group_wfo, tooltip="Out-of-sample validation bars. Should be ~30% of training window. Default: 75 bars.")
i_wfoMinTrades = input.int(5, "Min Trades for Validation", minval=3, maxval=15, group=group_wfo, tooltip="Minimum trades in train AND test periods before validation. Higher = more confident but slower. Default: 5")
i_wfoEfficiency = input.float(0.55, "WFO Efficiency Threshold", minval=0.3, maxval=0.9, step=0.05, group=group_wfo, tooltip="Min test/train performance ratio. 0.55 = test must be 55% as good as training. Higher = stricter, fewer validated strategies.")
i_theme = input.string("Neon Genesis", "Visual Theme",  options=["Neon Genesis", "Carbon Fiber", "Quantum Blue", "Aurora"],  group=group_vis, tooltip="Neon Genesis=cyberpunk, Carbon Fiber=industrial, Quantum Blue=quantum computing, Aurora=northern lights")
i_showGradientCloud = input.bool(true, "âš¡ Gradient Probability Cloud", group=group_vis, tooltip="Multi-layer gradient showing signal probability buildup 2-3 bars before entry. Premium visual feature.")
i_cloudLayers = input.int(7, "Cloud Gradient Layers", minval=3, maxval=15, group=group_vis, tooltip="Number of gradient layers in probability cloud. More = smoother but more CPU intensive. Default: 7")
i_showFitnessRibbon = input.bool(true, "ğŸ—ï¸ Population Fitness Ribbon", group=group_vis, tooltip="Multi-layer histogram showing fitness distribution of all active strategies. Shows population health.")
i_ribbonLayers = input.int(10, "Ribbon Layers", minval=5, maxval=20, group=group_vis, tooltip="Number of layers in fitness ribbon. More = finer detail. Default: 10")
i_showConfidenceHalo = input.bool(true, "â­• Signal Confidence Halo", group=group_vis, tooltip="Circular polyline around entry signals. Size and color scale with probability. Premium visual feature.")
i_showEvolutionMarkers = input.bool(true, "ğŸ”¬ Evolution Event Markers", group=group_vis, tooltip="Show diamond (spawn) and X (cull) markers when evolution events occur. Tracks genetic activity.")
i_showStopTarget = input.bool(true, "ğŸ¯ Stop/Target Lines", group=group_vis, tooltip="Show stop loss and take profit levels for active trades. Turn off for cleaner chart.")
i_showDash = input.bool(true, "ğŸ“Š Enhanced Dashboard", group=group_vis, tooltip="Comprehensive dashboard with population, performance, current signal, and active strategy details.")
i_showDiagnostics = input.bool(false, "ğŸ” Diagnostics Panel", group=group_diag, tooltip="Detailed signal diagnostics: pass/fail rates, rejection reasons. For optimization and debugging.")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEMES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
type PremiumTheme
    color long_primary
    color long_secondary
    color short_primary
    color short_secondary
    color exit_color
    color gradient_bull_strong
    color gradient_bull_mid
    color gradient_bull_weak
    color gradient_bear_strong
    color gradient_bear_mid
    color gradient_bear_weak
    color gradient_neutral
    color conf_elite
    color conf_strong
    color conf_good
    color conf_moderate
    color regime_trending
    color regime_choppy
    color regime_volatile
    color spawn_marker
    color cull_marker
    color elite_marker
    color validated_marker
    color panel_bg
    color panel_header
    color text_primary
    color text_secondary
    color metric_positive
    color metric_warning
    color metric_negative
f_getPremiumTheme(string themeName) =>
    PremiumTheme t = PremiumTheme.new()
    if themeName == "Neon Genesis"
        t.long_primary := #00FF9F
        t.long_secondary := #00D4AA
        t.short_primary := #FF006E
        t.short_secondary := #D4006E
        t.exit_color := #FFB800
        t.gradient_bull_strong := #00FF9F
        t.gradient_bull_mid := #00D4AA
        t.gradient_bull_weak := #00A89580
        t.gradient_bear_strong := #FF006E
        t.gradient_bear_mid := #D4006E
        t.gradient_bear_weak := #A8005580
        t.gradient_neutral := #8B7CC8
        t.conf_elite := #00FFF0
        t.conf_strong := #00D4AA
        t.conf_good := #00A895
        t.conf_moderate := #007C6E
        t.regime_trending := color.new(#003D34, 92)
        t.regime_choppy := color.new(#2C1A47, 93)
        t.regime_volatile := color.new(#4D0026, 93)
        t.spawn_marker := #00FFD4
        t.cull_marker := #FF4D6D
        t.elite_marker := #FFD700
        t.validated_marker := #00FF9F
        t.panel_bg := #0A0E27
        t.panel_header := #141B3D
        t.text_primary := #E0F8F7
        t.text_secondary := #8B9DC3
        t.metric_positive := #00FF9F
        t.metric_warning := #FFB800
        t.metric_negative := #FF006E 
    else if themeName == "Carbon Fiber"
        t.long_primary := #4FC3F7
        t.long_secondary := #29B6F6
        t.short_primary := #EF5350
        t.short_secondary := #E53935
        t.exit_color := #FFA726
        t.gradient_bull_strong := #4FC3F7
        t.gradient_bull_mid := #29B6F6
        t.gradient_bull_weak := #0288D180
        t.gradient_bear_strong := #EF5350
        t.gradient_bear_mid := #E53935
        t.gradient_bear_weak := #C6282880
        t.gradient_neutral := #78909C
        t.conf_elite := #00E5FF
        t.conf_strong := #4FC3F7
        t.conf_good := #29B6F6
        t.conf_moderate := #0288D1
        t.regime_trending := color.new(#1A237E, 93)
        t.regime_choppy := color.new(#212121, 93)
        t.regime_volatile := color.new(#4E342E, 94)
        t.spawn_marker := #4FC3F7
        t.cull_marker := #EF5350
        t.elite_marker := #FFD54F
        t.validated_marker := #4CAF50
        t.panel_bg := #0D0D0D
        t.panel_header := #1A1A1A
        t.text_primary := #ECEFF1
        t.text_secondary := #90A4AE
        t.metric_positive := #4FC3F7
        t.metric_warning := #FFA726
        t.metric_negative := #EF5350
    else if themeName == "Quantum Blue"
        t.long_primary := #5C6BC0
        t.long_secondary := #3F51B5
        t.short_primary := #F06292
        t.short_secondary := #EC407A
        t.exit_color := #BA68C8
        t.gradient_bull_strong := #7986CB
        t.gradient_bull_mid := #5C6BC0
        t.gradient_bull_weak := #3F51B580
        t.gradient_bear_strong := #F06292
        t.gradient_bear_mid := #EC407A
        t.gradient_bear_weak := #D8186880
        t.gradient_neutral := #9575CD
        t.conf_elite := #8C9EFF
        t.conf_strong := #7986CB
        t.conf_good := #5C6BC0
        t.conf_moderate := #3F51B5
        t.regime_trending := color.new(#1A237E, 92)
        t.regime_choppy := color.new(#311B92, 92)
        t.regime_volatile := color.new(#4A148C, 93)
        t.spawn_marker := #64B5F6
        t.cull_marker := #F06292
        t.elite_marker := #FDD835
        t.validated_marker := #7986CB
        t.panel_bg := #0A0D1F
        t.panel_header := #13172E
        t.text_primary := #E8EAF6
        t.text_secondary := #9FA8DA
        t.metric_positive := #7986CB
        t.metric_warning := #BA68C8
        t.metric_negative := #F06292
    else // Aurora
        t.long_primary := #00BFA5
        t.long_secondary := #00897B
        t.short_primary := #FF5722
        t.short_secondary := #E64A19
        t.exit_color := #AB47BC
        t.gradient_bull_strong := #00BFA5
        t.gradient_bull_mid := #00897B
        t.gradient_bull_weak := #00695C80
        t.gradient_bear_strong := #FF5722
        t.gradient_bear_mid := #E64A19
        t.gradient_bear_weak := #BF360C80
        t.gradient_neutral := #7E57C2
        t.conf_elite := #1DE9B6
        t.conf_strong := #00BFA5
        t.conf_good := #00897B
        t.conf_moderate := #00695C
        t.regime_trending := color.new(#004D40, 92)
        t.regime_choppy := color.new(#4A148C, 92)
        t.regime_volatile := color.new(#BF360C, 93)
        t.spawn_marker := #1DE9B6
        t.cull_marker := #FF5722
        t.elite_marker := #FFD740
        t.validated_marker := #00BFA5
        t.panel_bg := #0A1014
        t.panel_header := #12191F
        t.text_primary := #E0F2F1
        t.text_secondary := #80CBC4
        t.metric_positive := #00BFA5
        t.metric_warning := #AB47BC
        t.metric_negative := #FF5722
    t
PremiumTheme theme = f_getPremiumTheme(i_theme)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STORAGE & CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GENE_COUNT = 10
MAX_CAPACITY = 8
IDX_ENTROPY_SENS = 0
IDX_MOMENTUM_SENS = 1
IDX_STRUCTURE_SENS = 2
IDX_PROB_BOOST = 3
IDX_TREND_STRENGTH = 4
IDX_VOL_FILTER = 5
IDX_ATR_MULT = 6
IDX_STOP_MULT = 7
IDX_TARGET_MULT = 8
IDX_REGIME_ADAPT = 9
var array<float> GENE_MIN = array.from(0.5, 0.5, 0.5, -0.10, 0.3, 0.5, 1.5, 1.0, 1.5, 0.0)
var array<float> GENE_MAX = array.from(2.0, 2.0, 2.0,  0.10, 0.8, 1.5, 4.0, 2.5, 4.0, 1.0)
var array<int> strat_id = array.new<int>(MAX_CAPACITY, -1)
var array<int> strat_parent = array.new<int>(MAX_CAPACITY, -1)
var array<int> strat_generation = array.new<int>(MAX_CAPACITY, 0)
var array<int> strat_birth_bar = array.new<int>(MAX_CAPACITY, 0)
var array<bool> strat_active = array.new<bool>(MAX_CAPACITY, false)
var array<bool> strat_wfo_validated = array.new<bool>(MAX_CAPACITY, false)
var array<float> strat_dna = array.new<float>(MAX_CAPACITY * GENE_COUNT, 0.0)
var array<int> shadow_position = array.new<int>(MAX_CAPACITY, 0)
var array<float> shadow_entry = array.new<float>(MAX_CAPACITY, 0.0)
var array<float> shadow_stop = array.new<float>(MAX_CAPACITY, 0.0)
var array<float> shadow_target = array.new<float>(MAX_CAPACITY, 0.0)
var array<int> shadow_cooldown = array.new<int>(MAX_CAPACITY, 0)
var array<int> shadow_signal_age = array.new<int>(MAX_CAPACITY, 0)
var array<int> shadow_last_signal = array.new<int>(MAX_CAPACITY, 0)
var array<float> shadow_last_probability = array.new<float>(MAX_CAPACITY, 0.0)
var array<int> shadow_last_confluence = array.new<int>(MAX_CAPACITY, 0)
var array<int> strat_trades = array.new<int>(MAX_CAPACITY, 0)
var array<int> strat_wins = array.new<int>(MAX_CAPACITY, 0)
var array<float> strat_pnl = array.new<float>(MAX_CAPACITY, 0.0)
var array<float> strat_peak = array.new<float>(MAX_CAPACITY, 0.0)
var array<float> strat_dd = array.new<float>(MAX_CAPACITY, 0.0)
var array<float> strat_fitness = array.new<float>(MAX_CAPACITY, 0.0)
var array<int> wfo_train_trades = array.new<int>(MAX_CAPACITY, 0)
var array<int> wfo_train_wins = array.new<int>(MAX_CAPACITY, 0)
var array<float> wfo_train_pnl = array.new<float>(MAX_CAPACITY, 0.0)
var array<int> wfo_test_trades = array.new<int>(MAX_CAPACITY, 0)
var array<int> wfo_test_wins = array.new<int>(MAX_CAPACITY, 0)
var array<float> wfo_test_pnl = array.new<float>(MAX_CAPACITY, 0.0)
var array<float> wfo_efficiency = array.new<float>(MAX_CAPACITY, 0.0)
var array<int> diag_signals_evaluated = array.new<int>(MAX_CAPACITY, 0)
var array<int> diag_rejected_probability = array.new<int>(MAX_CAPACITY, 0)
var array<int> diag_rejected_confluence = array.new<int>(MAX_CAPACITY, 0)
var array<int> diag_rejected_trend = array.new<int>(MAX_CAPACITY, 0)
var array<int> diag_rejected_regime = array.new<int>(MAX_CAPACITY, 0)
var array<int> diag_rejected_volume = array.new<int>(MAX_CAPACITY, 0)
var array<int> diag_rejected_persistence = array.new<int>(MAX_CAPACITY, 0)
var array<int> diag_signals_passed = array.new<int>(MAX_CAPACITY, 0)
var int current_generation = 0
var int total_spawned = 0
var int total_culled = 0
var int total_wfo_passed = 0
var float MAS = 0.10
var int selected_strategy = -1
var int last_spawn_bar = 0
var int last_cull_bar = 0
var bool is_live_phase = false
var bool is_initialized = false
var int regime_type = 0
var array<linefill> prob_cloud_fills = array.new<linefill>()
var array<line> fitness_ribbon_lines = array.new<line>()
var polyline confidence_halo = na
var int signal_forming_age = 0
var float signal_forming_prob = 0.0
var int last_evolution_bar = 0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_get_gene(int idx, int gene) =>
    array.get(strat_dna, idx * GENE_COUNT + gene)
f_set_gene(int idx, int gene, float val) =>
    array.set(strat_dna, idx * GENE_COUNT + gene, val)
f_count_active() =>
    count = 0
    for i = 0 to MAX_CAPACITY - 1
        if array.get(strat_active, i)
            count += 1
    count
f_count_validated() =>
    count = 0
    for i = 0 to MAX_CAPACITY - 1
        if array.get(strat_active, i) and array.get(strat_wfo_validated, i)
            count += 1
    count
f_find_slot() =>
    slot = -1
    for i = 0 to MAX_CAPACITY - 1
        if not array.get(strat_active, i)
            slot := i
            break
    slot
f_random(int seed) =>
    x = (bar_index * 1103515245 + seed * 12345 + 1) % 2147483647
    float(x) / 2147483647.0
f_vol_atr(int period) =>
    ta.atr(period) / close
f_vol_parkinson(int period) =>
    float sum = 0.0
    for i = 0 to period - 1
        float hl = math.log(high[i] / math.max(low[i], 1e-10))
        sum += hl * hl
    math.sqrt(sum / (4.0 * period * math.log(2.0)))
f_vol_garman_klass(int period) =>
    float sum = 0.0
    for i = 0 to period - 1
        float hl = math.log(high[i] / math.max(low[i], 1e-10))
        float co = math.log(close[i] / math.max(open[i], 1e-10))
        sum += 0.5 * hl * hl - (2.0 * math.log(2.0) - 1.0) * co * co
    math.sqrt(math.max(sum / period, 0))
f_getDVS() =>
    float volCurrent = 0.0
    float volBaseline = 0.0 
    if i_dvsMethod == "ATR Ratio"
        volCurrent := f_vol_atr(14)
        volBaseline := ta.sma(f_vol_atr(14), i_dvsMemory)
    else if i_dvsMethod == "Parkinson"
        volCurrent := f_vol_parkinson(14)
        volBaseline := ta.sma(f_vol_parkinson(14), i_dvsMemory)
    else if i_dvsMethod == "Garman-Klass"
        volCurrent := f_vol_garman_klass(14)
        volBaseline := ta.sma(f_vol_garman_klass(14), i_dvsMemory)
    else 
        float v1 = f_vol_atr(14)
        float v2 = f_vol_parkinson(14)
        float v3 = f_vol_garman_klass(14)       
        float b1 = ta.sma(v1, i_dvsMemory)
        float b2 = ta.sma(v2, i_dvsMemory)
        float b3 = ta.sma(v3, i_dvsMemory)
        float r1 = b1 > 0 ? v1 / b1 : 1.0
        float r2 = b2 > 0 ? v2 / b2 : 1.0
        float r3 = b3 > 0 ? v3 / b3 : 1.0
        float med = r1 > r2 ? (r2 > r3 ? r2 : (r1 > r3 ? r3 : r1)) : (r1 > r3 ? r1 : (r2 > r3 ? r3 : r2))
        volCurrent := med
        volBaseline := 1.0
    float ratio = volBaseline > 0 ? volCurrent / volBaseline : 1.0
    float scaled = math.pow(ratio, i_dvsSensitivity)
    math.max(0.5, math.min(scaled, 2.5))
float dvsRatio = i_enableDVS ? ta.ema(f_getDVS(), 5) : 1.0
float trendEMA = ta.ema(close, i_trendLen)
float trendSlope = (trendEMA - trendEMA[10]) / trendEMA[10] * 100
int trendDir = trendSlope > 0.1 ? 1 : trendSlope < -0.1 ? -1 : 0
float trendStrength = math.abs(trendSlope)
f_detect_regime() =>
    atr_val = ta.atr(i_trendLen)
    price_range = ta.highest(high, i_trendLen) - ta.lowest(low, i_trendLen)
    directional = math.abs(close - close[i_trendLen])
    efficiency = price_range > 0 ? directional / price_range : 0.0
    vol_current = atr_val / close
    vol_avg = ta.sma(atr_val / close, i_trendLen)
    vol_ratio = vol_avg > 0 ? vol_current / vol_avg : 1.0
    if efficiency > 0.5 and vol_ratio < 1.3
        1
    else if vol_ratio > 1.5
        2
    else
        0
regime_type := f_detect_regime()
float volSMA = ta.sma(volume, 20)
bool volumeConfirm = volume > volSMA * 0.7
float atrValue = ta.atr(i_atrPeriod)
f_entropy_signal() =>
    float sum_up = 0.0
    float sum_dn = 0.0
    for i = 0 to i_entropyLen - 1
        chg = close[i] - close[i + 1]
        if chg > 0
            sum_up += chg
        else
            sum_dn -= chg
    total = sum_up + sum_dn
    if total == 0
        0.0
    else
        ratio = sum_up / total
        entropy = -1.0 * (ratio * math.log(math.max(ratio, 0.001)) + (1 - ratio) * math.log(math.max(1 - ratio, 0.001)))
        order = 1.0 - entropy / 0.693
        direction = sum_up > sum_dn ? 1.0 : -1.0
        order * direction
f_momentum_signal() =>
    rsi = ta.rsi(close, i_momentumLen)
    rsi_norm = (rsi - 50) / 50
    roc = ta.roc(close, i_momentumLen)
    roc_norm = math.max(-1, math.min(1, roc / 3))
    macd_fast = ta.ema(close, 12)
    macd_slow = ta.ema(close, 26)
    macd_hist = macd_fast - macd_slow
    macd_norm = math.max(-1, math.min(1, macd_hist / atrValue))
    (rsi_norm * 0.4 + roc_norm * 0.3 + macd_norm * 0.3)
f_structure_signal() =>
    hh = ta.highest(high, i_structureLen)
    ll = ta.lowest(low, i_structureLen)
    range_size = hh - ll
    if range_size == 0
        0.0
    else
        position = (close - ll) / range_size
        at_support = position < 0.2
        at_resistance = position > 0.8
        signal = 0.0
        if at_support and close > close[1]
            signal := 0.7
        else if at_resistance and close < close[1]
            signal := -0.7
        else if position > 0.5
            signal := close > hh[1] ? 0.5 : -0.3
        else
            signal := close < ll[1] ? -0.5 : 0.3
        signal
float entropySignal = f_entropy_signal()
float momentumSignal = f_momentum_signal()
float structureSignal = f_structure_signal()
f_adaptive_threshold(float sensitivity, float dvs) =>
    base = 0.30
    sens_adj = base / math.max(0.5, sensitivity)
    dvs_adj = dvs > 1.5 ? 0.95 : dvs < 0.7 ? 1.05 : 1.0
    math.max(0.15, math.min(0.50, sens_adj * dvs_adj))
f_calculate_signal(int idx) =>
    entropy_sens = f_get_gene(idx, IDX_ENTROPY_SENS)
    momentum_sens = f_get_gene(idx, IDX_MOMENTUM_SENS)
    structure_sens = f_get_gene(idx, IDX_STRUCTURE_SENS)
    prob_boost = f_get_gene(idx, IDX_PROB_BOOST)
    trend_req = f_get_gene(idx, IDX_TREND_STRENGTH)
    vol_filter = f_get_gene(idx, IDX_VOL_FILTER)
    regime_adapt = f_get_gene(idx, IDX_REGIME_ADAPT)
    adj_entropy = entropySignal * entropy_sens
    adj_momentum = momentumSignal * momentum_sens
    adj_structure = structureSignal * structure_sens
    thresh_ent = f_adaptive_threshold(entropy_sens, dvsRatio)
    thresh_mom = f_adaptive_threshold(momentum_sens, dvsRatio)
    thresh_str = f_adaptive_threshold(structure_sens, dvsRatio)
    long_votes = 0
    short_votes = 0
    if adj_entropy > thresh_ent
        long_votes += 1
    else if adj_entropy < -thresh_ent
        short_votes += 1
    if adj_momentum > thresh_mom
        long_votes += 1
    else if adj_momentum < -thresh_mom
        short_votes += 1
    if adj_structure > thresh_str
        long_votes += 1
    else if adj_structure < -thresh_str
        short_votes += 1
    
    confluence = math.max(long_votes, short_votes)
    direction = long_votes > short_votes ? 1 : short_votes > long_votes ? -1 : 0
    
    avg_signal = (math.abs(adj_entropy) + math.abs(adj_momentum) + math.abs(adj_structure)) / 3
    raw_prob = 0.50 + avg_signal * 0.25
    prob = raw_prob + prob_boost
    
    if regime_type == 1
        prob += 0.03 * regime_adapt
    else if regime_type == 2
        prob -= 0.05 * regime_adapt
    else
        prob -= 0.02 * regime_adapt
    
    if direction == trendDir
        prob += 0.04
    else if direction != 0 and trendDir != 0 and direction != trendDir
        prob -= 0.08
    
    if trendStrength < trend_req
        prob -= 0.03
    
    vol_threshold = volSMA * vol_filter
    if volume < vol_threshold
        prob -= 0.03
    
    if dvsRatio > 1.8
        prob -= 0.04
        confluence := confluence > 0 ? math.floor(confluence * 0.9) : 0
    else if dvsRatio < 0.7
        prob -= 0.02
    else if dvsRatio > 1.0 and dvsRatio < 1.3
        prob += 0.02
    
    if confluence >= 3
        prob += 0.05
    else if confluence >= 2
        prob += 0.02
    
    prob := math.max(0.35, math.min(0.88, prob))
    [direction, prob, confluence]

f_quality_gate(int direction, float probability, int confluence, int idx) =>
    array.set(diag_signals_evaluated, idx, array.get(diag_signals_evaluated, idx) + 1)
    
    if probability < i_minProbability
        array.set(diag_rejected_probability, idx, array.get(diag_rejected_probability, idx) + 1)
        false
    else if confluence < i_minConfluence
        array.set(diag_rejected_confluence, idx, array.get(diag_rejected_confluence, idx) + 1)
        false
    else if direction == 0
        array.set(diag_rejected_confluence, idx, array.get(diag_rejected_confluence, idx) + 1)
        false
    else if trendStrength > 0.5 and direction != trendDir and trendDir != 0
        array.set(diag_rejected_trend, idx, array.get(diag_rejected_trend, idx) + 1)
        false
    else if regime_type == 2 and probability < 0.72
        array.set(diag_rejected_regime, idx, array.get(diag_rejected_regime, idx) + 1)
        false
    else if not volumeConfirm
        array.set(diag_rejected_volume, idx, array.get(diag_rejected_volume, idx) + 1)
        false
    else
        array.set(diag_signals_passed, idx, array.get(diag_signals_passed, idx) + 1)
        true

f_required_persistence(float probability, int regime) =>
    base = i_basePersistence
    if probability >= 0.75
        base := math.max(1, base - 1)
    else if probability < 0.68
        base := base + 1
    if regime == 1
        base := math.max(1, base - 1)
    else if regime == 2
        base := base + 1
    math.max(1, math.min(5, base))

// Fitness & WFO
f_calculate_fitness(int idx) =>
    trades = array.get(strat_trades, idx)
    if trades < 3
        0.0
    else
        wins = array.get(strat_wins, idx)
        pnl = array.get(strat_pnl, idx)
        max_dd = array.get(strat_dd, idx)
        win_rate = float(wins) / float(trades)
        expectancy = pnl / trades
        norm_wr = win_rate
        norm_pnl = math.max(0, math.min(1, (pnl + 300) / 600))
        norm_expect = math.max(0, math.min(1, (expectancy + 30) / 60))
        norm_dd = math.max(0, math.min(1, 1 - max_dd / 15))
        quality_factor = trades < 50 ? 1.0 : trades < 100 ? 0.95 : 0.85
        fit = (0.30 * norm_wr + 0.30 * norm_pnl + 0.25 * norm_expect + 0.15 * norm_dd) * quality_factor
        if array.get(strat_wfo_validated, idx)
            eff = array.get(wfo_efficiency, idx)
            fit += (eff - 0.5) * 0.1
        evaluated = array.get(diag_signals_evaluated, idx)
        passed = array.get(diag_signals_passed, idx)
        if evaluated > 10
            efficiency = float(passed) / float(evaluated)
            fit += (efficiency - 0.1) * 0.05
        math.max(0, fit)

f_check_wfo(int idx) =>
    train_t = array.get(wfo_train_trades, idx)
    test_t = array.get(wfo_test_trades, idx)
    if train_t < i_wfoMinTrades or test_t < i_wfoMinTrades
        false
    else
        train_wr = float(array.get(wfo_train_wins, idx)) / float(train_t)
        test_wr = float(array.get(wfo_test_wins, idx)) / float(test_t)
        train_exp = array.get(wfo_train_pnl, idx) / train_t
        test_exp = array.get(wfo_test_pnl, idx) / test_t
        wr_eff = train_wr > 0 ? test_wr / train_wr : 0
        exp_eff = train_exp > 0.01 ? test_exp / train_exp : (test_exp > 0 ? 1.0 : 0)
        eff = (wr_eff + math.max(0, math.min(2, exp_eff))) / 2
        array.set(wfo_efficiency, idx, eff)
        eff >= i_wfoEfficiency

// Genetic Operators
f_select_parent(int seed) =>
    best = -1
    best_fit = -1.0
    for i = 0 to 2
        attempts = 0
        idx = -1
        while idx == -1 and attempts < 20
            candidate = int(f_random(seed + i * 100 + attempts) * MAX_CAPACITY)
            if array.get(strat_active, candidate)
                idx := candidate
            attempts += 1
        if idx >= 0
            fit = array.get(strat_fitness, idx)
            if fit > best_fit
                best_fit := fit
                best := idx
    best

f_select_for_trading(int seed) =>
    best = -1
    best_fit = -1.0
    for i = 0 to MAX_CAPACITY - 1
        if array.get(strat_active, i)
            fit = array.get(strat_fitness, i)
            if array.get(strat_wfo_validated, i)
                fit *= 1.3
            if fit > best_fit
                best_fit := fit
                best := i
    best

f_mutate(float val, int gene, int seed, float rate) =>
    if f_random(seed) < rate
        min_v = array.get(GENE_MIN, gene)
        max_v = array.get(GENE_MAX, gene)
        range_v = max_v - min_v
        noise = (f_random(seed + 1) - 0.5) * 2 * i_mutationStrength * range_v
        math.max(min_v, math.min(max_v, val + noise))
    else
        val

f_crossover(int p1, int p2, int child, int seed, float mut_rate) =>
    fit1 = array.get(strat_fitness, p1)
    fit2 = array.get(strat_fitness, p2)
    w1 = (fit1 + fit2) > 0 ? fit1 / (fit1 + fit2) : 0.5
    for g = 0 to GENE_COUNT - 1
        g1 = f_get_gene(p1, g)
        g2 = f_get_gene(p2, g)
        child_val = w1 * g1 + (1 - w1) * g2
        child_val := f_mutate(child_val, g, seed + g * 10, mut_rate)
        f_set_gene(child, g, child_val)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if barstate.isfirst and i_enableAGE and not is_initialized
    array.set(strat_id, 0, 0)
    array.set(strat_active, 0, true)
    array.set(strat_birth_bar, 0, 0)
    array.set(strat_wfo_validated, 0, not i_enableWFO)
    f_set_gene(0, IDX_ENTROPY_SENS, 1.0)
    f_set_gene(0, IDX_MOMENTUM_SENS, 1.0)
    f_set_gene(0, IDX_STRUCTURE_SENS, 1.0)
    f_set_gene(0, IDX_PROB_BOOST, 0.0)
    f_set_gene(0, IDX_TREND_STRENGTH, 0.4)
    f_set_gene(0, IDX_VOL_FILTER, 0.8)
    f_set_gene(0, IDX_ATR_MULT, 2.5)
    f_set_gene(0, IDX_STOP_MULT, 1.5)
    f_set_gene(0, IDX_TARGET_MULT, 2.5)
    f_set_gene(0, IDX_REGIME_ADAPT, 0.5)
    
    array.set(strat_id, 1, 1)
    array.set(strat_active, 1, true)
    array.set(strat_birth_bar, 1, 0)
    array.set(strat_wfo_validated, 1, not i_enableWFO)
    f_set_gene(1, IDX_ENTROPY_SENS, 0.7)
    f_set_gene(1, IDX_MOMENTUM_SENS, 1.5)
    f_set_gene(1, IDX_STRUCTURE_SENS, 0.8)
    f_set_gene(1, IDX_PROB_BOOST, 0.03)
    f_set_gene(1, IDX_TREND_STRENGTH, 0.5)
    f_set_gene(1, IDX_VOL_FILTER, 0.7)
    f_set_gene(1, IDX_ATR_MULT, 2.0)
    f_set_gene(1, IDX_STOP_MULT, 1.3)
    f_set_gene(1, IDX_TARGET_MULT, 3.0)
    f_set_gene(1, IDX_REGIME_ADAPT, 0.7)
    
    array.set(strat_id, 2, 2)
    array.set(strat_active, 2, true)
    array.set(strat_birth_bar, 2, 0)
    array.set(strat_wfo_validated, 2, not i_enableWFO)
    f_set_gene(2, IDX_ENTROPY_SENS, 1.5)
    f_set_gene(2, IDX_MOMENTUM_SENS, 0.8)
    f_set_gene(2, IDX_STRUCTURE_SENS, 0.7)
    f_set_gene(2, IDX_PROB_BOOST, -0.02)
    f_set_gene(2, IDX_TREND_STRENGTH, 0.6)
    f_set_gene(2, IDX_VOL_FILTER, 1.0)
    f_set_gene(2, IDX_ATR_MULT, 3.0)
    f_set_gene(2, IDX_STOP_MULT, 1.8)
    f_set_gene(2, IDX_TARGET_MULT, 2.5)
    f_set_gene(2, IDX_REGIME_ADAPT, 0.8)
    
    array.set(strat_id, 3, 3)
    array.set(strat_active, 3, true)
    array.set(strat_birth_bar, 3, 0)
    array.set(strat_wfo_validated, 3, not i_enableWFO)
    f_set_gene(3, IDX_ENTROPY_SENS, 0.8)
    f_set_gene(3, IDX_MOMENTUM_SENS, 0.9)
    f_set_gene(3, IDX_STRUCTURE_SENS, 1.4)
    f_set_gene(3, IDX_PROB_BOOST, 0.02)
    f_set_gene(3, IDX_TREND_STRENGTH, 0.35)
    f_set_gene(3, IDX_VOL_FILTER, 0.9)
    f_set_gene(3, IDX_ATR_MULT, 2.2)
    f_set_gene(3, IDX_STOP_MULT, 1.6)
    f_set_gene(3, IDX_TARGET_MULT, 2.8)
    f_set_gene(3, IDX_REGIME_ADAPT, 0.4)
    
    total_spawned := 4
    MAS := 0.08
    is_initialized := true

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN EVOLUTION LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if barstate.isrealtime and not is_live_phase
    is_live_phase := true

if i_enableAGE and bar_index > i_structureLen + 20
    mut_rate = is_live_phase ? i_liveMutationRate : i_histMutationRate
    spawn_int = is_live_phase ? i_liveSpawnInterval : i_histSpawnInterval
    cull_int = is_live_phase ? i_liveCullInterval : i_histCullInterval
    
    for i = 0 to MAX_CAPACITY - 1
        if array.get(strat_active, i)
            pos = array.get(shadow_position, i)
            entry = array.get(shadow_entry, i)
            stop = array.get(shadow_stop, i)
            target = array.get(shadow_target, i)
            cooldown = array.get(shadow_cooldown, i)
            
            if pos != 0
                exit_hit = false
                trade_pnl = 0.0
                if pos == 1
                    if low <= stop
                        trade_pnl := (stop - entry) / atrValue
                        exit_hit := true
                    else if high >= target
                        trade_pnl := (target - entry) / atrValue
                        exit_hit := true
                else
                    if high >= stop
                        trade_pnl := (entry - stop) / atrValue
                        exit_hit := true
                    else if low <= target
                        trade_pnl := (entry - target) / atrValue
                        exit_hit := true
                
                if exit_hit
                    new_trades = array.get(strat_trades, i) + 1
                    array.set(strat_trades, i, new_trades)
                    if trade_pnl > 0
                        array.set(strat_wins, i, array.get(strat_wins, i) + 1)
                    new_pnl = array.get(strat_pnl, i) + trade_pnl
                    array.set(strat_pnl, i, new_pnl)
                    peak = array.get(strat_peak, i)
                    if new_pnl > peak
                        array.set(strat_peak, i, new_pnl)
                    else
                        dd = peak - new_pnl
                        if dd > array.get(strat_dd, i)
                            array.set(strat_dd, i, dd)
                    age = bar_index - array.get(strat_birth_bar, i)
                    if age <= i_wfoTrainBars
                        array.set(wfo_train_trades, i, array.get(wfo_train_trades, i) + 1)
                        if trade_pnl > 0
                            array.set(wfo_train_wins, i, array.get(wfo_train_wins, i) + 1)
                        array.set(wfo_train_pnl, i, array.get(wfo_train_pnl, i) + trade_pnl)
                    else if age <= i_wfoTrainBars + i_wfoTestBars
                        array.set(wfo_test_trades, i, array.get(wfo_test_trades, i) + 1)
                        if trade_pnl > 0
                            array.set(wfo_test_wins, i, array.get(wfo_test_wins, i) + 1)
                        array.set(wfo_test_pnl, i, array.get(wfo_test_pnl, i) + trade_pnl)
                    array.set(shadow_position, i, 0)
                    array.set(shadow_cooldown, i, i_cooldownBars)
            
            if array.get(shadow_position, i) == 0
                if cooldown > 0
                    array.set(shadow_cooldown, i, cooldown - 1)
                else
                    [direction, probability, confluence] = f_calculate_signal(i)
                    array.set(shadow_last_probability, i, probability)
                    array.set(shadow_last_confluence, i, confluence)
                    last_sig = array.get(shadow_last_signal, i)
                    sig_age = array.get(shadow_signal_age, i)
                    if direction == last_sig and direction != 0
                        array.set(shadow_signal_age, i, sig_age + 1)
                    else
                        array.set(shadow_signal_age, i, direction != 0 ? 1 : 0)
                        array.set(shadow_last_signal, i, direction)
                    required_persist = f_required_persistence(probability, regime_type)
                    current_sig_age = array.get(shadow_signal_age, i)
                    passes_gate = f_quality_gate(direction, probability, confluence, i)
                    if current_sig_age >= required_persist and passes_gate
                        atr_m = f_get_gene(i, IDX_ATR_MULT)
                        stop_m = f_get_gene(i, IDX_STOP_MULT)
                        target_m = f_get_gene(i, IDX_TARGET_MULT)
                        atr_scaled = atrValue * atr_m * dvsRatio
                        if direction == 1
                            array.set(shadow_position, i, 1)
                            array.set(shadow_entry, i, close)
                            array.set(shadow_stop, i, close - atr_scaled * stop_m)
                            array.set(shadow_target, i, close + atr_scaled * target_m)
                        else
                            array.set(shadow_position, i, -1)
                            array.set(shadow_entry, i, close)
                            array.set(shadow_stop, i, close + atr_scaled * stop_m)
                            array.set(shadow_target, i, close - atr_scaled * target_m)
                        array.set(shadow_signal_age, i, 0)
                    else if current_sig_age >= required_persist and not passes_gate
                        array.set(diag_rejected_persistence, i, array.get(diag_rejected_persistence, i) + 1)
            
            array.set(strat_fitness, i, f_calculate_fitness(i))
            if i_enableWFO and not array.get(strat_wfo_validated, i)
                if f_check_wfo(i)
                    array.set(strat_wfo_validated, i, true)
                    total_wfo_passed += 1
    
    if bar_index - last_spawn_bar >= spawn_int
        if f_count_active() < i_maxPopulation
            slot = f_find_slot()
            if slot >= 0
                p1 = f_select_parent(bar_index)
                p2 = f_select_parent(bar_index + 500)
                if p1 >= 0 and p2 >= 0 and p1 != p2
                    f_crossover(p1, p2, slot, bar_index, mut_rate)
                    array.set(strat_id, slot, total_spawned)
                    array.set(strat_parent, slot, array.get(strat_id, p1))
                    array.set(strat_generation, slot, current_generation + 1)
                    array.set(strat_birth_bar, slot, bar_index)
                    array.set(strat_active, slot, true)
                    array.set(strat_wfo_validated, slot, false)
                    array.set(shadow_position, slot, 0)
                    array.set(shadow_cooldown, slot, 0)
                    array.set(shadow_signal_age, slot, 0)
                    array.set(shadow_last_signal, slot, 0)
                    array.set(shadow_last_probability, slot, 0.0)
                    array.set(shadow_last_confluence, slot, 0)
                    array.set(strat_trades, slot, 0)
                    array.set(strat_wins, slot, 0)
                    array.set(strat_pnl, slot, 0.0)
                    array.set(strat_peak, slot, 0.0)
                    array.set(strat_dd, slot, 0.0)
                    array.set(strat_fitness, slot, 0.0)
                    array.set(wfo_train_trades, slot, 0)
                    array.set(wfo_train_wins, slot, 0)
                    array.set(wfo_train_pnl, slot, 0.0)
                    array.set(wfo_test_trades, slot, 0)
                    array.set(wfo_test_wins, slot, 0)
                    array.set(wfo_test_pnl, slot, 0.0)
                    array.set(diag_signals_evaluated, slot, 0)
                    array.set(diag_rejected_probability, slot, 0)
                    array.set(diag_rejected_confluence, slot, 0)
                    array.set(diag_rejected_trend, slot, 0)
                    array.set(diag_rejected_regime, slot, 0)
                    array.set(diag_rejected_volume, slot, 0)
                    array.set(diag_rejected_persistence, slot, 0)
                    array.set(diag_signals_passed, slot, 0)
                    total_spawned += 1
                    current_generation := math.max(current_generation, array.get(strat_generation, slot))
                    last_evolution_bar := bar_index
        last_spawn_bar := bar_index
    
    if bar_index - last_cull_bar >= cull_int
        MAS := math.max(0.03, MAS * 0.995)
        active_count = f_count_active()
        if active_count > i_minPopulation
            worst_idx = -1
            worst_fit = 999.0
            for i = 0 to MAX_CAPACITY - 1
                if array.get(strat_active, i)
                    age = bar_index - array.get(strat_birth_bar, i)
                    if age > cull_int
                        fit = array.get(strat_fitness, i)
                        if i_enableWFO and not array.get(strat_wfo_validated, i)
                            fit *= 0.7
                        if fit < worst_fit
                            worst_fit := fit
                            worst_idx := i
            if worst_idx >= 0 and worst_fit < MAS
                elite_count = 0
                for i = 0 to MAX_CAPACITY - 1
                    if array.get(strat_active, i) and array.get(strat_fitness, i) > worst_fit
                        elite_count += 1
                if elite_count >= i_eliteCount
                    array.set(strat_active, worst_idx, false)
                    total_culled += 1
                    last_evolution_bar := bar_index
        last_cull_bar := bar_index
    
    selected_strategy := f_select_for_trading(bar_index)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMIUM VISUALIZATION SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sel_pos = selected_strategy >= 0 ? array.get(shadow_position, selected_strategy) : 0
sel_stop = selected_strategy >= 0 ? array.get(shadow_stop, selected_strategy) : na
sel_target = selected_strategy >= 0 ? array.get(shadow_target, selected_strategy) : na
sel_prob = selected_strategy >= 0 ? array.get(shadow_last_probability, selected_strategy) : 0.0
sel_conf = selected_strategy >= 0 ? array.get(shadow_last_confluence, selected_strategy) : 0
sel_sig_age = selected_strategy >= 0 ? array.get(shadow_signal_age, selected_strategy) : 0
sel_last_sig = selected_strategy >= 0 ? array.get(shadow_last_signal, selected_strategy) : 0
sel_id = selected_strategy >= 0 ? array.get(strat_id, selected_strategy) : -1
sel_gen = selected_strategy >= 0 ? array.get(strat_generation, selected_strategy) : 0
sel_validated = selected_strategy >= 0 ? array.get(strat_wfo_validated, selected_strategy) : false

if sel_last_sig != 0 and sel_sig_age > 0
    signal_forming_age := sel_sig_age
    signal_forming_prob := sel_prob
else
    signal_forming_age := 0
    signal_forming_prob := 0.0

// 1. GRADIENT PROBABILITY CLOUD
if i_showGradientCloud and signal_forming_age > 0 and signal_forming_prob >= i_minProbability
    if array.size(prob_cloud_fills) > 0
        for i = 0 to array.size(prob_cloud_fills) - 1
            linefill.delete(array.get(prob_cloud_fills, i))
        array.clear(prob_cloud_fills)
    
    is_long = sel_last_sig == 1
    start_bar = bar_index - signal_forming_age
    base_color = is_long ? theme.gradient_bull_mid : theme.gradient_bear_mid
    strong_color = is_long ? theme.gradient_bull_strong : theme.gradient_bear_strong
    
    layers = i_cloudLayers
    for layer = 0 to layers - 1
        layer_pct = float(layer) / float(layers - 1)
        trans_base = 92
        trans_range = 8
        trans = int(trans_base - trans_range * layer_pct * (signal_forming_prob - i_minProbability) / (1.0 - i_minProbability))
        layer_color = color.from_gradient(layer_pct, 0, 1, base_color, strong_color)
        atr_mult = 0.3 + (0.7 * layer_pct)
        top_level = high + atrValue * atr_mult
        bot_level = low - atrValue * atr_mult
        top_line = line.new(start_bar, top_level, bar_index, top_level, color=color.new(layer_color, trans), width=1)
        bot_line = line.new(start_bar, bot_level, bar_index, bot_level, color=color.new(layer_color, trans), width=1)
        fill = linefill.new(top_line, bot_line, color.new(layer_color, trans + 2))
        array.push(prob_cloud_fills, fill)

// Calculate base level outside conditional for consistency
float low_level = ta.lowest(low, 100)

// 2. FITNESS RIBBON
if i_showFitnessRibbon and barstate.islast
    if array.size(fitness_ribbon_lines) > 0
        for i = 0 to array.size(fitness_ribbon_lines) - 1
            line.delete(array.get(fitness_ribbon_lines, i))
        array.clear(fitness_ribbon_lines)
    
    float min_fit = 0.0
    float max_fit = 0.0
    for i = 0 to MAX_CAPACITY - 1
        if array.get(strat_active, i)
            fit = array.get(strat_fitness, i)
            if max_fit == 0.0 or fit > max_fit
                max_fit := fit
            if min_fit == 0.0 or fit < min_fit
                min_fit := fit
    
    if max_fit > 0
        ribbon_start = bar_index - 50
        layers = i_ribbonLayers
        base_level = low_level - atrValue * 1.5
        
        for layer = 0 to layers - 1
            fit_level = min_fit + (max_fit - min_fit) * (float(layer) / float(layers))
            count = 0
            for i = 0 to MAX_CAPACITY - 1
                if array.get(strat_active, i) and array.get(strat_fitness, i) >= fit_level
                    count += 1
            if count > 0
                layer_pct = float(layer) / float(layers - 1)
                ribbon_color = color.from_gradient(layer_pct, 0, 1, theme.gradient_bull_weak, theme.gradient_bull_strong)
                height = atrValue * 0.15 * (float(count) / float(f_count_active()))
                y_level = base_level + atrValue * 0.2 * layer
                ribbon_line = line.new(ribbon_start, y_level, bar_index, y_level, color=color.new(ribbon_color, 50), width=int(math.max(2, 6 * height / atrValue)))
                array.push(fitness_ribbon_lines, ribbon_line)

// 3. CONFIDENCE HALO
new_signal = (sel_pos == 1 or sel_pos == -1) and sel_pos[1] == 0

if i_showConfidenceHalo and new_signal
    if not na(confidence_halo)
        polyline.delete(confidence_halo)
    
    is_long = sel_pos == 1
    center_y = is_long ? low - atrValue * 0.5 : high + atrValue * 0.5
    radius = atrValue * (0.3 + 0.7 * (sel_prob - i_minProbability) / (1.0 - i_minProbability))
    halo_color = sel_prob >= 0.85 ? theme.conf_elite : 
                 sel_prob >= 0.75 ? theme.conf_strong : 
                 sel_prob >= 0.65 ? theme.conf_good : theme.conf_moderate
    var array<chart.point> circle_points = array.new<chart.point>()
    array.clear(circle_points)
    segments = 20
    for i = 0 to segments
        angle = (2 * math.pi * i) / segments
        x_offset = int(math.round(5 * math.cos(angle)))
        y_offset = radius * math.sin(angle)
        array.push(circle_points, chart.point.from_index(bar_index + x_offset, center_y + y_offset))
    confidence_halo := polyline.new(circle_points, closed=true, curved=false, line_color=color.new(halo_color, 40),  fill_color=color.new(halo_color, 88), line_width=2)
spawn_event = i_showEvolutionMarkers and bar_index == last_evolution_bar and total_spawned > total_spawned[1]
cull_event = i_showEvolutionMarkers and bar_index == last_evolution_bar and total_culled > total_culled[1]
plotshape(spawn_event, "Spawn", shape.diamond, location.bottom, color.new(theme.spawn_marker, 0), size=size.tiny)
plotshape(cull_event, "Cull", shape.xcross, location.bottom, color.new(theme.cull_marker, 0), size=size.tiny)
marker_trans = sel_prob >= 0.85 ? 0 : sel_prob >= 0.75 ? 10 : sel_prob >= 0.65 ? 20 : 35
plotshape(new_signal and sel_pos == 1, "Long Entry", shape.triangleup, location.belowbar, color.new(theme.long_primary, marker_trans), size=size.small)
plotshape(new_signal and sel_pos == -1, "Short Entry", shape.triangledown, location.abovebar, color.new(theme.short_primary, marker_trans), size=size.small)
plotshape(sel_pos == 0 and sel_pos[1] != 0, "Exit", shape.xcross, location.absolute,  color.new(theme.exit_color, 0), size=size.tiny)
plot(i_showStopTarget and sel_pos != 0 ? sel_stop : na, "Stop Loss", color.new(theme.short_primary, 60), 2, plot.style_linebr)
plot(i_showStopTarget and sel_pos != 0 ? sel_target : na, "Take Profit", color.new(theme.long_primary, 60), 2, plot.style_linebr)
ema_color = color.from_gradient(trendStrength, 0, 1, theme.gradient_neutral, trendDir == 1 ? theme.gradient_bull_strong : theme.gradient_bear_strong)
plot(trendEMA, "Dynamic Trend", color.new(ema_color, 50), 2)
bgcolor(regime_type == 1 ? theme.regime_trending : regime_type == 2 ? theme.regime_volatile : na)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENHANCED DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table dash = table.new(position.top_right, 5, 14, bgcolor=theme.panel_bg, border_width=1, border_color=color.new(theme.panel_header, 50))
var table diagPanel = na
if i_showDiagnostics
    diagPanel := table.new(position.bottom_right, 3, 8, bgcolor=theme.panel_bg, border_width=1, border_color=color.new(theme.panel_header, 50))
if barstate.islast and i_showDash and i_enableAGE
    active = f_count_active()
    validated = f_count_validated()
    phase_txt = is_live_phase ? "ğŸ”´ LIVE" : "âª HIST"
    regime_txt = regime_type == 1 ? "ğŸ“ˆ TREND" : regime_type == 2 ? "ğŸŒŠ CHAOS" : "â– CHOP"
    table.cell(dash, 0, 0, "ğŸ§¬ AGE PRO " + phase_txt, bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 1, 0, "POPULATION", bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 2, 0, "PERFORMANCE", bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 3, 0, "CURRENT SIGNAL", bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 4, 0, "ACTIVE STRATEGY", bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 0, 1, "Regime", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 0, 2, regime_txt, text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 0, 3, "DVS Ratio", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 0, 4, str.tostring(dvsRatio, "#.##"), text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 0, 5, "Trend", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 0, 6, trendDir == 1 ? "â–² BULL" : trendDir == -1 ? "â–¼ BEAR" : "â– FLAT", text_color=trendDir == 1 ? theme.metric_positive : trendDir == -1 ? theme.metric_negative : theme.text_secondary, text_size=size.small)
    table.cell(dash, 0, 7, "Strength", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 0, 8, str.tostring(trendStrength, "#.##"), text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 1, 1, "Active", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 1, 2, str.tostring(active) + "/" + str.tostring(i_maxPopulation), text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 1, 3, "Validated", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 1, 4, str.tostring(validated) + "/" + str.tostring(active), text_color=validated > 0 ? theme.metric_positive : theme.metric_warning, text_size=size.small)
    table.cell(dash, 1, 5, "Generation", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 1, 6, str.tostring(current_generation), text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 1, 7, "Spawned", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 1, 8, str.tostring(total_spawned), text_color=theme.metric_positive, text_size=size.small)
    table.cell(dash, 1, 9, "Culled", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 1, 10, str.tostring(total_culled), text_color=theme.metric_negative, text_size=size.small)
    tot_trades = 0
    tot_wins = 0
    tot_pnl = 0.0
    best_fit = 0.0
    for i = 0 to MAX_CAPACITY - 1
        if array.get(strat_active, i)
            tot_trades += array.get(strat_trades, i)
            tot_wins += array.get(strat_wins, i)
            tot_pnl += array.get(strat_pnl, i)
            best_fit := math.max(best_fit, array.get(strat_fitness, i))
    agg_wr = tot_trades > 0 ? float(tot_wins) / float(tot_trades) * 100 : 0
    table.cell(dash, 2, 1, "Total Trades", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 2, 2, str.tostring(tot_trades), text_color=theme.text_primary, text_size=size.small)
    table.cell(dash, 2, 3, "Win Rate", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 2, 4, str.tostring(agg_wr, "#.#") + "%",  text_color=agg_wr > 55 ? theme.metric_positive : agg_wr > 45 ? theme.metric_warning : theme.metric_negative, text_size=size.small)
    table.cell(dash, 2, 5, "Total P&L", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 2, 6, str.tostring(tot_pnl, "#.#") + "R", text_color=tot_pnl > 0 ? theme.metric_positive : theme.metric_negative, text_size=size.small)
    table.cell(dash, 2, 7, "Best Fitness", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 2, 8, str.tostring(best_fit, "#.###"), text_color=theme.metric_positive, text_size=size.small)
    table.cell(dash, 2, 9, "MAS", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(dash, 2, 10, str.tostring(MAS, "#.###"), text_color=theme.metric_warning, text_size=size.small)
    if selected_strategy >= 0
        sig_status = sel_pos == 1 ? "â–² LONG" : sel_pos == -1 ? "â–¼ SHORT" : signal_forming_age > 0 ? "â³ FORMING" : "â—‹ WAITING"
        sig_color = sel_pos == 1 ? theme.long_primary : sel_pos == -1 ? theme.short_primary : signal_forming_age > 0 ? theme.metric_warning : theme.text_secondary
        conf_level = sel_prob >= 0.85 ? "ğŸ”¥ ELITE" : sel_prob >= 0.75 ? "âœ“ STRONG" : sel_prob >= 0.65 ? "â—‹ GOOD" : "- LOW"
        conf_color = sel_prob >= 0.85 ? theme.conf_elite : sel_prob >= 0.75 ? theme.conf_strong : sel_prob >= 0.65 ? theme.conf_good : theme.conf_moderate
        table.cell(dash, 3, 1, "Status", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 3, 2, sig_status, text_color=sig_color, text_size=size.small)
        table.cell(dash, 3, 3, "Confidence", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 3, 4, str.tostring(sel_prob * 100, "#.#") + "%", text_color=conf_color, text_size=size.small)
        table.cell(dash, 3, 5, "Quality", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 3, 6, conf_level, text_color=conf_color, text_size=size.small)
        table.cell(dash, 3, 7, "Confluence", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 3, 8, str.tostring(sel_conf) + "/3", text_color=sel_conf >= 3 ? theme.metric_positive : sel_conf >= 2 ? theme.metric_warning : theme.metric_negative, text_size=size.small)
        table.cell(dash, 3, 9, "Age", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 3, 10, signal_forming_age > 0 ? str.tostring(signal_forming_age) + " bars" : sel_pos != 0 ? "IN TRADE" : "---", text_color=theme.text_primary, text_size=size.small)
    else
        table.cell(dash, 3, 1, "No Active", text_color=theme.metric_negative, text_size=size.small)
    if selected_strategy >= 0
        s_id = array.get(strat_id, selected_strategy)
        s_gen = array.get(strat_generation, selected_strategy)
        s_trades = array.get(strat_trades, selected_strategy)
        s_wins = array.get(strat_wins, selected_strategy)
        s_pnl = array.get(strat_pnl, selected_strategy)
        s_val = array.get(strat_wfo_validated, selected_strategy)
        s_fit = array.get(strat_fitness, selected_strategy)
        s_wr = s_trades > 0 ? float(s_wins) / float(s_trades) * 100 : 0
        val_txt = s_val ? "âœ“ VAL" : "â—‹ TRAIN"
        val_color = s_val ? theme.validated_marker : theme.metric_warning
        table.cell(dash, 4, 1, "Strategy ID", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 4, 2, "#" + str.tostring(s_id), text_color=theme.spawn_marker, text_size=size.small)
        table.cell(dash, 4, 3, "Validation", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 4, 4, val_txt, text_color=val_color, text_size=size.small)
        table.cell(dash, 4, 5, "Generation", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 4, 6, "G" + str.tostring(s_gen), text_color=theme.text_primary, text_size=size.small)
        table.cell(dash, 4, 7, "Fitness", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 4, 8, str.tostring(s_fit, "#.###"), text_color=s_fit > 0.5 ? theme.metric_positive : s_fit > 0.3 ? theme.metric_warning : theme.metric_negative, text_size=size.small)
        table.cell(dash, 4, 9, "Trades", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 4, 10, str.tostring(s_trades), text_color=theme.text_primary, text_size=size.small)
        table.cell(dash, 4, 11, "P&L", text_color=theme.text_secondary, text_size=size.tiny)
        table.cell(dash, 4, 12, str.tostring(s_pnl, "#.#") + "R (" + str.tostring(s_wr, "#") + "%)", text_color=s_pnl > 0 ? theme.metric_positive : theme.metric_negative, text_size=size.small)
    else
        table.cell(dash, 4, 1, "No Active", text_color=theme.metric_negative, text_size=size.small)
if barstate.islast and i_showDiagnostics and i_enableAGE and selected_strategy >= 0
    s_eval = array.get(diag_signals_evaluated, selected_strategy)
    s_passed = array.get(diag_signals_passed, selected_strategy)
    s_rej_prob = array.get(diag_rejected_probability, selected_strategy)
    s_rej_conf = array.get(diag_rejected_confluence, selected_strategy)
    s_rej_trend = array.get(diag_rejected_trend, selected_strategy)
    s_rej_regime = array.get(diag_rejected_regime, selected_strategy)
    s_rej_vol = array.get(diag_rejected_volume, selected_strategy)
    pass_rate = s_eval > 0 ? float(s_passed) / float(s_eval) * 100 : 0
    table.cell(diagPanel, 0, 0, "ğŸ” DIAGNOSTICS", bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(diagPanel, 1, 0, "COUNT", bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(diagPanel, 2, 0, "%", bgcolor=theme.panel_header, text_color=theme.text_primary, text_size=size.small)
    table.cell(diagPanel, 0, 1, "Evaluated", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 1, 1, str.tostring(s_eval), text_color=theme.text_primary, text_size=size.small)
    table.cell(diagPanel, 2, 1, "100%", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 0, 2, "âœ“ Passed", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 1, 2, str.tostring(s_passed), text_color=theme.metric_positive, text_size=size.small)
    table.cell(diagPanel, 2, 2, str.tostring(pass_rate, "#.#") + "%", text_color=theme.metric_positive, text_size=size.small)
    table.cell(diagPanel, 0, 3, "â¨¯ Probability", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 1, 3, str.tostring(s_rej_prob), text_color=theme.metric_negative, text_size=size.small)
    table.cell(diagPanel, 2, 3, s_eval > 0 ? str.tostring(s_rej_prob * 100 / s_eval, "#.#") + "%" : "0%", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 0, 4, "â¨¯ Confluence", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 1, 4, str.tostring(s_rej_conf), text_color=theme.metric_negative, text_size=size.small)
    table.cell(diagPanel, 2, 4, s_eval > 0 ? str.tostring(s_rej_conf * 100 / s_eval, "#.#") + "%" : "0%", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 0, 5, "â¨¯ Trend", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 1, 5, str.tostring(s_rej_trend), text_color=theme.metric_negative, text_size=size.small)
    table.cell(diagPanel, 2, 5, s_eval > 0 ? str.tostring(s_rej_trend * 100 / s_eval, "#.#") + "%" : "0%", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 0, 6, "â¨¯ Regime", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 1, 6, str.tostring(s_rej_regime), text_color=theme.metric_negative, text_size=size.small)
    table.cell(diagPanel, 2, 6, s_eval > 0 ? str.tostring(s_rej_regime * 100 / s_eval, "#.#") + "%" : "0%", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 0, 7, "â¨¯ Volume", text_color=theme.text_secondary, text_size=size.tiny)
    table.cell(diagPanel, 1, 7, str.tostring(s_rej_vol), text_color=theme.metric_negative, text_size=size.small)
    table.cell(diagPanel, 2, 7, s_eval > 0 ? str.tostring(s_rej_vol * 100 / s_eval, "#.#") + "%" : "0%", text_color=theme.text_secondary, text_size=size.tiny)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(new_signal and sel_pos == 1, "AGE Long", "ğŸ§¬ AGE PRO: Long Entry")
alertcondition(new_signal and sel_pos == -1, "AGE Short", "ğŸ§¬ AGE PRO: Short Entry")
alertcondition(sel_pos == 0 and sel_pos[1] != 0, "AGE Exit", "ğŸ§¬ AGE PRO: Exit")
plot(sel_id, "Strategy ID", display=display.status_line)
plot(current_generation, "Generation", display=display.status_line)
plot(sel_prob * 100, "Signal Prob %", display=display.status_line)
