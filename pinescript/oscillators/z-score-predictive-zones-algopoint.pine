//@version=5
// -----------------------------------------------------------------------------
// | Â© AlgoPoint                                                               |
// | Indicator: Z-Score Predictive Zones [AlgoPoint]                           |
// | Developer: Harmony Algo & AlgoPoint Collaboration                         |
// -----------------------------------------------------------------------------
indicator('Z-Score Predictive Zones [AlgoPoint]', overlay=false, max_labels_count = 500)

// ==========================================
// --- SETTINGS ---
// ==========================================

// Group: Z-Score Parameters
length = input.int(144, 'Z-Score Length', group="Z-Score Settings", tooltip="The period used to calculate the Mean and Standard Deviation.")
smooth = input.int(20, 'Smoothing (VWMA)', group="Z-Score Settings", tooltip="Smoothing factor to reduce noise in the Z-Score.")

// Group: Dynamic Zone Calculation
history_depth = input.int(25, 'Lookback Depth', group="Zone Calculation", tooltip="How many recent reversal points should be remembered to calculate the average Support/Resistance levels?")

// Group: Reversal Thresholds
z_thersh = input.float(1.5, "Thershold", step=0.1, group="Thresholds")
z_thresh_top = z_thersh
z_thresh_bot = -z_thersh

// Group: Visuals
labels_on_chart = input.bool(true, "Show Signal Dots on Chart", group="Visuals")

// ==========================================
// --- CALCULATIONS ---
// ==========================================

// 1. Z-Score Calculation
mean = ta.sma(close, length)
std_dev = ta.stdev(close, length)
raw_z = (close - mean) / std_dev
z_score = ta.vwma(raw_z, smooth) 

// 2. Reversal Detection (Peaks & Valleys)
ph = ta.pivothigh(z_score, 1, 1) 
pl = ta.pivotlow(z_score, 1, 1)  

// Filter reversals based on user thresholds
valid_top_reversal = not na(ph) and ph > z_thresh_top
valid_bot_reversal = not na(pl) and pl < z_thresh_bot

// 3. Dynamic Zone Calculation (Arrays)
var top_reversals = array.new_float(0)
var bot_reversals = array.new_float(0)

// Update Resistance Array
if valid_top_reversal
    array.unshift(top_reversals, ph)
    if array.size(top_reversals) > history_depth
        array.pop(top_reversals)

// Update Support Array
if valid_bot_reversal
    array.unshift(bot_reversals, pl)
    if array.size(bot_reversals) > history_depth
        array.pop(bot_reversals)

// Calculate Average Reversal Levels
avg_top_level = array.size(top_reversals) > 0 ? array.avg(top_reversals) : 2.0
avg_bot_level = array.size(bot_reversals) > 0 ? array.avg(bot_reversals) : -2.0

// 4. RSI Color Logic (Gradient)
rsi = ta.rsi(close ,14)
rsima = ta.ema(rsi, 9)
// Gradient color based on RSI-MA
othercolors = rsima > 80 ? #822f90 : rsima > 60 ? #6f37ab : rsima < 20 ? #525d91 : rsima < 40 ? #5e49a6 : #673ab6

// ==========================================
// --- PLOTTING: OSCILLATOR PANE ---
// ==========================================

// Main Z-Score Line
plot(z_score, color=othercolors, title='Z-Score Oscillator', linewidth=2)
hline(0, "Zero Line", color=color.gray, linestyle=hline.style_dotted)

// Dynamic Reversal Levels (Oscillator)
plot(avg_top_level, "Avg Resistance (Osc)", color=color.new(#F23645, 20), linewidth=1, style=plot.style_stepline)
plot(avg_bot_level, "Avg Support (Osc)", color=color.new(#089981, 20), linewidth=1, style=plot.style_stepline)

// Oscillator Background Zones
fill(plot(avg_top_level, display=display.none), plot(avg_top_level + 0.5, display=display.none), color=color.new(#F23645, 90), title="Oscillator Resistance Zone")
fill(plot(avg_bot_level, display=display.none), plot(avg_bot_level - 0.5, display=display.none), color=color.new(#089981, 90), title="Oscillator Support Zone")

// ==========================================
// --- PLOTTING: MAIN CHART (OVERLAY) ---
// ==========================================

// Reverse Engineering: Calculate Price from Z-Score
// Price = Mean + (Z-Score * Standard Deviation)

// Calculate Price Bands
res_band_low = mean + (avg_top_level * std_dev)
res_band_high = mean + ((avg_top_level + 0.5) * std_dev) 

sup_band_high = mean + (avg_bot_level * std_dev)
sup_band_low = mean + ((avg_bot_level - 0.5) * std_dev) 

// Plot Price Bands on Main Chart (force_overlay=true)
p_res_top = plot(ta.vwma(res_band_high,4), title="Chart Resistance High", color=color.new(#F23645, 100), force_overlay=true)
p_res_bot = plot(ta.vwma(res_band_low,4), title="Chart Resistance Low", color=color.new(#F23645, 50), force_overlay=true)

p_sup_top = plot(ta.vwma(sup_band_high,4), title="Chart Support High", color=color.new(#089981, 50), force_overlay=true)
p_sup_bot = plot(ta.vwma(sup_band_low,4), title="Chart Support Low", color=color.new(#089981, 100), force_overlay=true)

// Fill Zones on Main Chart
fill(p_res_top, p_res_bot, color=color.new(#F23645, 85), title="Chart Resistance Fill")
fill(p_sup_top, p_sup_bot, color=color.new(#089981, 85), title="Chart Support Fill")

// ==========================================
// --- SIGNALS ---
// ==========================================

// Logic: Price enters the dynamic zone
short_signal = high > res_band_low and not (high[1] > res_band_low[1]) 
long_signal = low < sup_band_high and not (low[1] < sup_band_high[1])

// Plot Dots on Main Chart

y1 = low - (ta.atr(30) * 0.8)
y2 = high + (ta.atr(30) * 0.8)


if (labels_on_chart and long_signal)
    label.new(bar_index , y1, color=color.new(#089981,10), style=label.style_circle, textcolor=color.white, size=size.tiny, force_overlay = true)

if (labels_on_chart and short_signal)
    label.new(bar_index , y2, color=color.new(#F23645,10), style=label.style_circle, textcolor=color.white, size=size.tiny, force_overlay = true)
