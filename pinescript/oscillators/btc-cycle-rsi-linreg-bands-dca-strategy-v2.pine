//@version=6
// BTC Cycle RSI + LinReg Bands DCA Strategy (Yield + Cycle DCA, Hybrid Deploy) v2
// Core cycle structure inspired by Zeiierman's RSI + self-adjusting LinReg bands.
// Post-peak awareness, plunge-guarded sells, DCA taper, hybrid yield deploy.

strategy(
     "BTC Cycle RSI + LinReg Bands DCA Strategy v2",
     overlay          = false,
     max_labels_count = 500,
     max_lines_count  = 500,
     initial_capital  = 100000,
     commission_type  = strategy.commission.percent,
     commission_value = 0.05,
     slippage         = 5,
     default_qty_type = strategy.fixed,
     default_qty_value= 0
)

//----------------------------------------------------
// INPUTS — START DATE
//----------------------------------------------------
useStartDate = input.bool(
     true,
     "Use start date filter",
     group   = "Start Date",
     tooltip = "When enabled, all logic (phases, DCA, sells) only activates after the start date."
)
startYear = input.int(
     2013,
     "Start Year",
     minval  = 2000,
     maxval  = 2100,
     group   = "Start Date",
     tooltip = "Year from which the strategy logic begins."
)
startMonth = input.int(
     1,
     "Start Month",
     minval  = 1,
     maxval  = 12,
     group   = "Start Date",
     tooltip = "Month from which the strategy logic begins."
)
startDay = input.int(
     1,
     "Start Day",
     minval  = 1,
     maxval  = 31,
     group   = "Start Date",
     tooltip = "Day from which the strategy logic begins."
)

startTime   = timestamp(startYear, startMonth, startDay, 0, 0)
bool isLive = not useStartDate or time >= startTime

//----------------------------------------------------
// INPUTS — RSI + BANDS
//----------------------------------------------------
rsi_src_ = input.source(
     close,
     "RSI Source",
     group   = "RSI Settings",
     tooltip = "Price source used to compute RSI."
)
len = input.int(
     50,
     "RSI Length",
     group   = "RSI Settings",
     minval  = 2,
     maxval  = 250,
     tooltip = "Base RSI lookback before smoothing."
)
period = input.int(
     200,
     "LinReg Period",
     group   = "Linear Regression",
     minval  = 50,
     maxval  = 400,
     tooltip = "Lookback for the self-adjusting RSI regression bands."
)
deviations = input.float(
     2.0,
     "Deviation",
     step    = 0.1,
     minval  = 0.5,
     maxval  = 4.0,
     group   = "Linear Regression",
     tooltip = "Band width multiplier around the RSI regression line."
)
obLevel = input.int(
     65,
     "Overbought",
     group   = "Levels",
     minval  = 50,
     maxval  = 90,
     tooltip = "RSI level considered overbought / late bull."
)
osLevel = input.int(
     35,
     "Oversold",
     group   = "Levels",
     minval  = 10,
     maxval  = 50,
     tooltip = "RSI level considered oversold / deep bear."
)

//----------------------------------------------------
// INPUTS — DCA
//----------------------------------------------------
baseDCA = input.float(
     100,
     "Base DCA Amount (1x, USD)",
     step    = 10,
     minval  = 0,
     maxval  = 100000,
     group   = "DCA",
     tooltip = "Base weekly DCA in USD. Phase multiplier scales this."
)

//----------------------------------------------------
// INPUTS — LOGIC TOGGLES
//----------------------------------------------------
useFalseFilter = input.bool(
     true,
     "Require prior RSI > Overbought for sell signals?",
     group   = "Logic Toggles",
     tooltip = "If enabled, midline breakdown sells only fire after RSI has been overbought."
)
enableDCA = input.bool(
     true,
     "Enable DCA buys",
     group   = "Logic Toggles",
     tooltip = "Turn off to disable all external-capital DCA."
)
enableSells = input.bool(
     true,
     "Enable sequential sells",
     group   = "Logic Toggles",
     tooltip = "If disabled, no 20% / 40% rotations to the yield basket will occur."
)

//----------------------------------------------------
// INPUTS — YIELD MODEL
//----------------------------------------------------
yieldApr = input.float(
     11.0,
     "Yield basket APR (%)",
     step    = 0.1,
     minval  = 0.0,
     maxval  = 50.0,
     group   = "Yield Model",
     tooltip = "Approximate APR used to grow the simulated yield basket over time."
)
startingYieldBalance = input.float(
     0.0,
     "Starting yield basket balance (USD)",
     step    = 1000,
     minval  = 0,
     maxval  = 10000000,
     group   = "Yield Model",
     tooltip = "Seed the yield basket with an existing balance at the start date. Set to 0 to begin empty."
)
yieldDCAEnabled = input.bool(
     true,
     "Enable yield-funded DCA",
     group   = "Yield Model",
     tooltip = "When enabled, a portion of simulated yield is used to DCA during deep bears."
)
deepBearTargetFrac = input.float(
     20.0,
     "Deep bear: target % of starting yield to keep",
     step    = 1,
     minval  = 0,
     maxval  = 100,
     group   = "Yield Model",
     tooltip = "Minimum % of the yield basket preserved at start of deep bear."
)

//----------------------------------------------------
// INPUTS — HYBRID DEPLOY
//----------------------------------------------------
hybridMaxPctPool = input.float(
     4.0,
     "Max deploy per week (% of yield pool)",
     step    = 0.5,
     minval  = 0.1,
     maxval  = 50.0,
     group   = "Hybrid Deploy",
     tooltip = "Upper cap per week as a % of remaining deployable yield pool."
)
hybridDeployPct = input.float(
     25.0,
     "Deploy % of remaining pool per week",
     step    = 1,
     minval  = 1,
     maxval  = 100,
     group   = "Hybrid Deploy",
     tooltip = "Target fraction of remaining deployable pool each week."
)
hybridRampWeeks = input.float(
     25.0,
     "Weeks to ramp to full capacity",
     step    = 1,
     minval  = 1,
     maxval  = 200,
     group   = "Hybrid Deploy",
     tooltip = "Number of deep-bear weeks to go from starting capacity to 100% time factor."
)
hybridStartCapacity = input.float(
     10.0,
     "Starting capacity (%)",
     step    = 1,
     minval  = 1,
     maxval  = 50,
     group   = "Hybrid Deploy",
     tooltip = "Initial time-factor (as % of full capacity) on deep-bear entry."
)
hybridDrawdownPower = input.float(
     3.0,
     "Drawdown scaling exponent",
     step    = 0.1,
     minval  = 0.1,
     maxval  = 3.0,
     group   = "Hybrid Deploy",
     tooltip = "Exponent on (0.5 + drawdown). >1 = more aggressive at deeper discounts."
)

showSellIcons = input.bool(
     true,
     "Show sell signal icons",
     group   = "Labels",
     tooltip = "Toggle plotting of first/second sell markers on the RSI pane."
)

//----------------------------------------------------
// ZEIIERMAN RSI + SELF-ADJUSTING LINREG BANDS
//----------------------------------------------------
rsi = ta.wma(ta.rsi(rsi_src_, len), 5)
periodMinusOne = period - 1

Ex  = 0.0
Ey  = 0.0
Ex2 = 0.0
Exy = 0.0
ExEx = 0.0

for i = 0 to periodMinusOne
    closeI = rsi[i]
    Ex    += i
    Ey    += closeI
    Ex2   += i * i
    Exy   += closeI * i
    ExEx  := Ex * Ex

float slope = na
if Ex2 != ExEx
    slope := (period * Exy - Ex * Ey) / (period * Ex2 - ExEx)

ilinearRegression = (Ey - slope * Ex) / period
intercept         = ilinearRegression + bar_index * slope

deviation = 0.0
for i = 0 to periodMinusOne
    deviation += math.pow(rsi[i], 2) - (intercept - slope * bar_index[i])
    break

deviationNew   = deviations * math.sqrt(deviation / periodMinusOne)
startingPointY = ta.wma(ilinearRegression + slope / periodMinusOne, 5)

adjust_up   = startingPointY + ta.stdev(rsi, 20)
adjust_down = startingPointY - ta.stdev(rsi, 20)

a  = startingPointY - deviationNew + adjust_down / 20
c1 = startingPointY
b  = startingPointY + deviationNew - adjust_up / 20

Lower_Curve = ta.wma(a, 5)
Upper_Curve = ta.wma(b, 5)
Mid_Curve   = c1

//----------------------------------------------------
// PHASE DETECTION (post-peak awareness + DCA taper)
//----------------------------------------------------
var string phase    = "UNKNOWN"
var float  dcaMult  = 0.0
var bool   postPeak = false

rsiAboveMid = rsi > Mid_Curve
rsiBelowMid = rsi < Mid_Curve

isDeepBear      = rsi <= 50 and rsi <= Lower_Curve
isBearRecovery  = rsi <= 50 and rsi > Lower_Curve and rsi <= Mid_Curve
isEarlyBull     = rsi > Mid_Curve and rsi < 50
isBullConfirmed = rsi > 50 and rsi > Upper_Curve
isMatureBull    = rsi > obLevel
isBullBuilding  = rsi > 50 and not isBullConfirmed and not isMatureBull

if isLive
    if isMatureBull
        postPeak := true
    if isDeepBear
        postPeak := false

    if isMatureBull
        phase   := "MATURE_BULL"
        dcaMult := 0
    else if isBullConfirmed and not postPeak
        phase   := "BULL_CONFIRMED"
        dcaMult := 1
    else if isBullConfirmed and postPeak
        phase   := "DISTRIBUTION"
        dcaMult := 0.5
    else if isBullBuilding and not postPeak
        phase   := "BULL_BUILDING"
        dcaMult := 1
    else if isBullBuilding and postPeak
        phase   := "WEAKENING"
        dcaMult := 0.25
    else if isEarlyBull
        phase   := "EARLY_BULL"
        dcaMult := 2
    else if isBearRecovery
        phase   := "BEAR_RECOVERY"
        dcaMult := 3
    else if isDeepBear
        phase   := "DEEP_BEAR"
        dcaMult := 5
    else
        phase   := "UNKNOWN"
        dcaMult := 1

//----------------------------------------------------
// FALSE-CYCLE FILTER + SELL DETECTION (with plunge guard)
//----------------------------------------------------
var bool overboughtArmed     = false
var int  sellCount           = 0
var bool prevAboveMid        = false
var bool sellPausedByPlunge  = false
var bool dcaEnabledState     = true

if isLive
    if rsi > obLevel
        overboughtArmed := true
    if rsi < 50 and rsi < Mid_Curve
        overboughtArmed := false

sellFilterOk = (not useFalseFilter) or overboughtArmed

prevAboveMid      := rsi[1] > Mid_Curve[1]
midlineBreakDown  = prevAboveMid and rsiBelowMid

var string sellSignalText = "NONE"

if isLive
    // Plunge detection
    if sellCount == 1 and rsi <= Lower_Curve
        sellPausedByPlunge := true

    if barstate.isconfirmed and sellFilterOk and midlineBreakDown and not sellPausedByPlunge
        sellCount += 1
        if      sellCount == 1
            sellSignalText := "FIRST_SELL"
        else if sellCount == 2
            sellSignalText := "SECOND_SELL"
            dcaEnabledState := false
        else
            sellSignalText := "SELLS_DONE"
    else if barstate.isnew
        sellSignalText := "NONE"

    // Reset on new bull confirmation
    if isBullConfirmed
        sellCount          := 0
        sellPausedByPlunge := false

    // Deep bear re-arms DCA
    if isDeepBear
        dcaEnabledState := true

//----------------------------------------------------
// YIELD ACCOUNT (INTERNAL SIMULATION)
//----------------------------------------------------
var float yieldBalance       = 0.0
var bool  yieldSeeded        = false
var float deepBearStartYield = na
var bool  inDeepBearForYield = false
var int   weeksInBear        = 0
var float cycleHigh          = na

weeklyRate = (yieldApr / 100.0) / 52.0

if isLive
    // Seed the yield basket once on the first live bar
    if not yieldSeeded
        yieldBalance := startingYieldBalance
        yieldSeeded  := true

    yieldBalance := yieldBalance * (1 + weeklyRate)

    if isBullConfirmed and (na(cycleHigh) or close > cycleHigh)
        cycleHigh := close
    if isMatureBull and (na(cycleHigh) or close > cycleHigh)
        cycleHigh := close

    if isDeepBear and not inDeepBearForYield
        inDeepBearForYield := true
        deepBearStartYield := yieldBalance
        weeksInBear        := 0

    if isDeepBear
        weeksInBear += 1

    if not isDeepBear
        inDeepBearForYield := false
        deepBearStartYield := na
        weeksInBear        := 0

//----------------------------------------------------
// EXECUTION LOGIC — gated by isLive
//----------------------------------------------------
currentPosSize = strategy.position_size

// 1) BASE DCA
if isLive and enableDCA and dcaEnabledState and barstate.isconfirmed
    float dcaCash = baseDCA * dcaMult
    if dcaCash > 0
        float qtyCoins = dcaCash / close
        strategy.order(
             id        = "DCA_LONG",
             direction = strategy.long,
             qty       = qtyCoins,
             comment   = "Base DCA buy"
        )

// 2) YIELD-FUNDED DCA — HYBRID OPTIMAL DISTRIBUTION
bool yieldAccumPhase = isDeepBear

if isLive and yieldDCAEnabled and dcaEnabledState and yieldAccumPhase and barstate.isconfirmed and not na(deepBearStartYield)
    float targetFrac    = deepBearTargetFrac / 100.0
    float targetBalance = deepBearStartYield * targetFrac

    float remainingPool = math.max(0.0, yieldBalance - targetBalance)

    float startCap   = hybridStartCapacity / 100.0
    float timeFactor = math.min(1.0, startCap + (1.0 - startCap) * weeksInBear / hybridRampWeeks)

    float drawdownFraction = 0.0
    if not na(cycleHigh) and cycleHigh > 0
        drawdownFraction := math.max(0.0, (cycleHigh - close) / cycleHigh)
    float drawdownScale = math.pow(0.5 + drawdownFraction, hybridDrawdownPower)

    float maxPerWeek = remainingPool * (hybridMaxPctPool / 100.0)

    float desired     = math.min(remainingPool * (hybridDeployPct / 100.0), maxPerWeek * timeFactor)
    float yieldDcaCash = desired * drawdownScale

    yieldDcaCash := math.min(yieldDcaCash, yieldBalance)
    yieldDcaCash := math.max(yieldDcaCash, 0.0)

    if yieldDcaCash > 0
        float yQty = yieldDcaCash / close
        yieldBalance -= yieldDcaCash
        strategy.order(
             id        = "YIELD_DCA",
             direction = strategy.long,
             qty       = yQty,
             comment   = "Yield-funded DCA buy (hybrid)"
        )

// 3) SELLS: rotate % of stack -> yieldBalance
if isLive and enableSells and barstate.isconfirmed and currentPosSize > 0
    if sellSignalText == "FIRST_SELL"
        float qtyToClose  = currentPosSize * 0.20
        float cashProceeds = qtyToClose * close
        yieldBalance += cashProceeds
        strategy.order(
             id        = "FIRST_SELL",
             direction = strategy.short,
             qty       = qtyToClose,
             comment   = "Rotate 20% to yield"
        )

    if sellSignalText == "SECOND_SELL"
        float qtyToClose2   = strategy.position_size * 0.40
        float cashProceeds2 = qtyToClose2 * close
        yieldBalance += cashProceeds2
        strategy.order(
             id        = "SECOND_SELL",
             direction = strategy.short,
             qty       = qtyToClose2,
             comment   = "Rotate 40% to yield"
        )

//----------------------------------------------------
// PLOTS
//----------------------------------------------------
col = startingPointY > startingPointY[1] ? color.blue : color.red

prsi = plot(rsi,         color=color.new(col, 0),          title="RSI")
lc   = plot(Lower_Curve, color=color.new(color.red, 0),    title="Lower Curve")
mc   = plot(Mid_Curve,   color=color.new(color.aqua, 20),  title="Mid Curve")
uc   = plot(Upper_Curve, color=color.new(color.lime, 0),   title="Upper Curve")

fill(prsi, lc, color = rsi < a ? color.new(color.red,85)  : color.new(color.blue,100))
fill(prsi, uc, color = rsi > b ? color.new(color.lime,85) : color.new(color.blue,100))
fill(lc, uc,   color = color.new(color.blue,100))

hline(obLevel, "Overbought", color=color.new(color.red,40))
hline(50,      "Mid Line",   color=color.new(color.gray,50))
hline(osLevel, "Oversold",   color=color.new(color.green,40))

// Sell icons
if isLive and showSellIcons and sellSignalText == "FIRST_SELL"
    label.new(
         bar_index, rsi,
         text      = "◆",
         style     = label.style_label_down,
         color     = color.new(color.orange, 0),
         textcolor = color.white,
         size      = size.small
    )

if isLive and showSellIcons and sellSignalText == "SECOND_SELL"
    label.new(
         bar_index, rsi,
         text      = "◆",
         style     = label.style_label_down,
         color     = color.new(color.red, 0),
         textcolor = color.white,
         size      = size.small
    )

//----------------------------------------------------
// COMBINED WEALTH PLOTS
//----------------------------------------------------
btcValue    = strategy.position_size * close
totalWealth = btcValue + yieldBalance

plot(btcValue,     color=color.new(color.lime,  0), title="BTC Value (USD)")
plot(yieldBalance, color=color.new(color.orange,0), title="Yield Balance (USD)")
plot(totalWealth,  color=color.new(color.white, 0), title="Total Wealth (BTC + Yield, simulated)")

//----------------------------------------------------
// INFO TABLE
//----------------------------------------------------
var table infoTable = table.new(position.top_right, 2, 8, border_width=1)
if barstate.islast
    table.cell(infoTable, 0, 0, "Phase",        text_color=color.white, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 1, 0, phase,          text_color=color.white, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 0, 1, "DCA Mult",     text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(infoTable, 1, 1, str.tostring(dcaMult, "#.##x"), text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(infoTable, 0, 2, "Yield Bal.",   text_color=color.white, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 1, 2, "$" + str.tostring(yieldBalance, "#,###"), text_color=color.orange, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 0, 3, "BTC Value",    text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(infoTable, 1, 3, "$" + str.tostring(btcValue, "#,###"), text_color=color.lime, bgcolor=color.new(color.gray, 70))
    table.cell(infoTable, 0, 4, "Total Wealth", text_color=color.white, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 1, 4, "$" + str.tostring(totalWealth, "#,###"), text_color=color.white, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 0, 5, "Weeks in Bear", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(infoTable, 1, 5, str.tostring(weeksInBear), text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(infoTable, 0, 6, "Cycle High",   text_color=color.white, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 1, 6, na(cycleHigh) ? "N/A" : "$" + str.tostring(cycleHigh, "#,###"), text_color=color.white, bgcolor=color.new(color.gray, 60))
    table.cell(infoTable, 0, 7, "Drawdown %",   text_color=color.white, bgcolor=color.new(color.gray, 70))
    float ddPct = na(cycleHigh) or cycleHigh == 0 ? 0.0 : (cycleHigh - close) / cycleHigh * 100
    table.cell(infoTable, 1, 7, str.tostring(ddPct, "#.#") + "%", text_color=color.red, bgcolor=color.new(color.gray, 70))
