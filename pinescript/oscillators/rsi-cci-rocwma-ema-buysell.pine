//@version=6
indicator("CERROC v1.6", overlay=false, max_labels_count=500)

//======================================================================
// 0) FONCTIONS
//======================================================================

clamp(val) =>
    math.max(0.0, math.min(100.0, val))

ma(source, length, type) =>
    switch type
        "SMA"  => ta.sma(source, length)
        "EMA"  => ta.ema(source, length)
        "SMMA" => ta.rma(source, length)
        "WMA"  => ta.wma(source, length)
        "VWMA" => ta.vwma(source, length)
        "TEMA" =>
            ema1 = ta.ema(source, length)
            ema2 = ta.ema(ema1, length)
            ema3 = ta.ema(ema2, length)
            3 * (ema1 - ema2) + ema3
        "DEMA" =>
            ema1 = ta.ema(source, length)
            ema2 = ta.ema(ema1, length)
            2 * ema1 - ema2
        "LSMA" => ta.linreg(source, length, 0)
        "HMA"  => ta.wma(2 * ta.wma(source, length / 2) - ta.wma(source, length), math.floor(math.sqrt(length)))
        "ALMA" => ta.alma(source, length, 0.85, 6)

zscore(source, length) =>
    mean  = ta.sma(source, length)
    stdev = ta.stdev(source, length)
    stdev != 0 ? (source - mean) / stdev : 0.0

f_avgNearExtreme(float[] _arr, float _extreme, float _band, bool _isHigh) =>
    int sz = array.size(_arr)
    if sz == 0 or na(_extreme)
        na
    else
        float sum = 0.0
        int cnt = 0
        for i = 0 to sz - 1
            float v = array.get(_arr, i)
            bool ok = _isHigh ? (v <= _extreme and (_extreme - v) <= _band)
                              : (v >= _extreme and (v - _extreme) <= _band)
            if ok
                sum += v
                cnt += 1
        cnt > 0 ? sum / cnt : na



//======================================================================
// 2) INPUTS — EMA
//======================================================================


_rocEMA = input.bool(false, "——— Paramètres EMA ———")
useTrendFilter = input.bool(true, "Trader en tendance")
EMAlen = input.int(310, title="Période EMA",minval=1,step=10)
EMAslop = input.float(0.02, title="Pente min EMA",minval=0,step=0.01)
ShowEMA = input.bool(true, "Afficher EMA")




//======================================================================
// 2) INPUTS — ROCWMA
//======================================================================


_rocTitle = input.bool(false, "——— Paramètres ROC ———")
rocLen = input.int(55, title="Période ROC",minval=0,step=1)
maLen  = input.int(7, title="Période de la moyenne ROC",minval=0,step=1)
sigLen = input.int(10, title="Moyenne secondaire de seuil",minval=0,step=1)

srcRoc = input.source(hlcc4, title="Source de calcul")

ma_type = input.string(
     "TEMA",
     title="MA Type",
     options=["SMA","EMA","SMMA","WMA","VWMA","TEMA","DEMA","LSMA","HMA","ALMA"]
)

neutralThr = input.float(0, title="Taille zone neutre de transition",minval=0,step=0.1)

sigPct = input.float(
     75,
     title="Seuil de validation Buy/Sell (% du max ROC)",
     minval=0.0,
     maxval=100.0,
     step=5
)

//======================================================================
// 4) INPUTS — RSI (bloc 2) + Overlay CCI sur RSI + DOTS
//======================================================================
_rsiTitle = input.bool(false, "——— Paramètres du RSI ———")
rsiLenBase  = input.int(14, "Période RSI", minval=2)
rsiSrcBase  = input.source(close, "Source RSI")
//lenRSI2 = input.int(title="Période du RSI", minval=1, defval=14)
//srcRSI2 = input.source(defval=close, title="Source du RSI")
grpCal = "Calibration RSI sur plage horaire"
useSession = input.bool(true, "Activer calibration")
sess       = input.session("0000-0600","Fenetre horaire")
bandWidth  = input.float(20.0, "Offset bande intermédiaire", minval=2.0, step=1)


grpFb = "Bornes intermédiaires par défaut"
borneBasDef  = input.float(30.0, "Borne basse", minval=0.0, maxval=100.0,step=5)
borneHautDef = input.float(70.0, "Borne haute", minval=0.0, maxval=100.0,step=5)



dotOffset1 = 2.0
dotOffset2 = 8
dotOffset3 = 12

//======================================================================
// 3) INPUTS — CCI FILTER (pour ROCWMA) + STYLE
//======================================================================
_cciTitle = input.bool(false, "——— Paramètres du CCI ———")
cciPeriodBase   = input.int(20, "Période CCI", minval=2)
cciSmaLenBase   = input.int(14, "Longueur moyenne SMA CCI", minval=1)
cciVisScaleBase =200
useCCIFilter = input.bool(true, "Valider filtre CCI dynamique")
cciMaLenF =cciSmaLenBase
//cciLevelF    = input.int(100, "Seuil déclenchement Buy/Sell sur CCI", minval=1,step=5)
cciSlowBarsF = input.int(1, "Nb bougies pour valider une baisse du CCI", minval=1, maxval=10)
//useMoyCCI =input.bool(true,"Seuils CCI dynamiques")
cciEMAav   = input.int(1000, "Longueur moyennage CCI dynamique", minval=1,step=10)
showLevDyn   = input.bool(false, "Afficher les niveaux dynamiques")

colScheme = input.string(
     "Default",
     title="Color Scheme",
     options=["Default","Modern","Cool","Alternate","Bright"]
)

[bull, bear, neutral] = switch colScheme
    "Default"   => [#00ff73, #ff0040, #606060]
    "Modern"    => [#23d7e4, #e11179, #707070]
    "Cool"      => [#00ffcc, #1600db, #505050]
    "Alternate" => [#00ff80, #ff6600, #505050]
    "Bright"    => [#e8ec00, #f200fa, #505050]


showCCIOverlay2 = input.bool(false, "Debug stratégie")



//======================================================================
// 5) CALCULS — BASE RSI + CCI mappé (bloc Base)
//======================================================================
rsiBase = ta.rsi(rsiSrcBase, rsiLenBase)

cciRawBase = ta.cci(hlc3, cciPeriodBase)
cciSmaBase = ta.sma(cciRawBase, cciSmaLenBase)

cciMappedBase = 50.0 + 50.0 * (cciSmaBase / cciVisScaleBase)
cciMappedBase := math.max(0.0, math.min(100.0, cciMappedBase))

//======================================================================
// 6) CALCULS — CALIBRATION RSI (bornes extrêmes + intermédiaires)
//======================================================================
inSess    = useSession ? not na(time(timeframe.period, sess)) : false
enterSess = inSess and not inSess[1]
exitSess  = not inSess and inSess[1]

var float rsiHigh = na
var float rsiLow  = na
var float[] pivHi = array.new_float()
var float[] pivLo = array.new_float()

var float borneHautExt = na
var float borneBasExt  = na
var float borneHautMid = na
var float borneBasMid  = na

if enterSess
    rsiHigh := na
    rsiLow  := na
    array.clear(pivHi)
    array.clear(pivLo)

if inSess
    rsiHigh := na(rsiHigh) ? rsiBase : math.max(rsiHigh, rsiBase)
    rsiLow  := na(rsiLow)  ? rsiBase : math.min(rsiLow,  rsiBase)

temp1=ta.highest(rsiBase, 5)
temp2=ta.lowest(rsiBase, 5)
hiLocal = inSess and (rsiBase == temp1)
loLocal = inSess and (rsiBase == temp2)

if hiLocal
    array.push(pivHi, rsiBase)
if loLocal
    array.push(pivLo, rsiBase)

if exitSess
    tmpHi = f_avgNearExtreme(pivHi, rsiHigh, bandWidth, true)
    tmpLo = f_avgNearExtreme(pivLo, rsiLow,  bandWidth, false)

    borneHautExt := rsiHigh
    borneBasExt  := rsiLow

    borneHautMid := na(tmpHi) ? (rsiHigh - bandWidth) : tmpHi
    borneBasMid  := na(tmpLo) ? (rsiLow  + bandWidth) : tmpLo

borneHautMid_aff = inSess ? (rsiHigh - bandWidth) : borneHautMid
borneBasMid_aff  = inSess ? (rsiLow  + bandWidth) : borneBasMid

borneOK = not na(borneBasMid_aff) and not na(borneHautMid_aff)
borneBasMid_eff  = borneOK ? borneBasMid_aff  : borneBasDef
borneHautMid_eff = borneOK ? borneHautMid_aff : borneHautDef

borneHautExt_aff = inSess ? rsiHigh : borneHautExt
borneBasExt_aff  = inSess ? rsiLow  : borneBasExt

//======================================================================
// 7) CALCULS — ROCWMA + SIGNAL + MAX PER PERIOD + TRIGGERS
//======================================================================
roc = ta.roc(srcRoc, rocLen)

rocLo = ta.lowest(roc, rocLen)
rocHi = ta.highest(roc, rocLen)
den   = rocHi - rocLo
normalized_roc = den != 0 ? (roc - rocLo) / den : 0.0

base_ma       = ma(srcRoc, maLen, ma_type)
weighted_diff = normalized_roc * (srcRoc - base_ma)
rwma          = base_ma + weighted_diff

oscillator = zscore(rwma, rocLen)
signal     = ta.ema(oscillator, sigLen)

// Couleur histogram (mémoire neutre)
var color currentCol = na
var color prevColor  = na

inNeutralZone = oscillator > -neutralThr and oscillator < neutralThr
if inNeutralZone
    currentCol := prevColor
else
    currentCol := oscillator > neutralThr ? bull : oscillator < -neutralThr ? bear : neutral
prevColor := currentCol

// New period = entering neutral zone
enterNeutral = inNeutralZone and not inNeutralZone[1]

// Max histogram bar per period
var float maxBull    = 0.0
var float maxBearAbs = 0.0
var bool BullThrflag = false
var bool BearThrflag = false
var float bullThr = 0.0
var float bearThr = 0.0

if enterNeutral
    maxBull    := 0.0
    maxBearAbs := 0.0
    BearThrflag := false
    BullThrflag := false

if not inNeutralZone
    if oscillator < 0
        maxBull := na(maxBull) ? oscillator : math.min(maxBull, oscillator)
        bullThr := na(maxBull) ? na :  maxBull * (sigPct / 100.0)
        BullThrflag:=(signal >= bullThr)? true : false
    if oscillator >= 0
        maxBull := na(maxBull) ? oscillator : math.max(maxBull, oscillator)
        bearThr := na(maxBull) ? na : maxBull * (sigPct / 100.0)
        BearThrflag:=(signal <= bearThr)? true : false


// Signal slope
sigDown = signal < signal[1]
sigUp   = signal > signal[1]

// Conditions (inchangées)
bullBaseTrig = oscillator <= 0 and not inNeutralZone and not na(bullThr) and (BullThrflag) and sigUp
bearBaseTrig = oscillator >= 0 and not inNeutralZone and not na(bearThr) and (BearThrflag) and sigDown




//======================================================================
// 8) CALCULS — tendance
//======================================================================
emaVal  = ta.ema(close, EMAlen)
atrVal  = ta.atr(14)
Nb=50
slope   = (emaVal - emaVal[Nb]) / Nb
normSlope = slope / atrVal

trendUp   = (slope>=EMAslop)?true:false
trendDown = (slope<=-EMAslop)?true:false

//====================================================
// 2) Moyenne dynamique CCI
//====================================================
// --- CCI de base
var float LevelDyn=0.0

//cciRaw =cciSmaBase// ta.cci(hlc3, cciEMAlen)
//cciav  = ta.sma(cciRaw, 20)
cciAvg = ta.ema(cciSmaBase, cciEMAav)

cciDC = ta.sma(cciAvg, 200)
cciHP = cciAvg - cciDC

LevelDyn:=cciHP //+slope*80

var float LevelDynH=0.0
var float LevelDynB=0.0

if inSess
    LevelDynH:=borneHautMid_eff
    LevelDynB:=borneBasMid_eff
else
    if useCCIFilter
        LevelDynH:=borneHautMid_eff+LevelDyn
        LevelDynB:=borneBasMid_eff+LevelDyn
if not inSess and not useCCIFilter
    LevelDynH:=borneHautDef
    LevelDynB:=borneBasDef

//======================================================================
// 8) CALCULS — CCI FILTER (pour ROCWMA) + filtre EMA100
//======================================================================


//cciRawF = ta.cci(hlc3, cciPeriodBase)
cciMaF  =cciMappedBase// ta.sma(cciRawF, cciSmaLenBase)


// pente CCI sur N bougies
cciSellSlope = true
for i = 0 to cciSlowBarsF - 1
    cciSellSlope := cciSellSlope and (cciMaF[i] < cciMaF[i + 1])

cciBuySlope = true
for i = 0 to cciSlowBarsF - 1
    cciBuySlope := cciBuySlope and (cciMaF[i] > cciMaF[i + 1])

cciSellState =cciSellSlope  and  (cciMaF > LevelDynH)  //bleu foncé
cciBuyState  =cciBuySlope and (cciMaF < LevelDynB)  // jaune
plot(cciMaF, color=color.white, linewidth=1)
// Apply CCI filter (inchangé)
//bullTrig = useCCIFilter ? (bullBaseTrig and cciBuyState) : bullBaseTrig
//bearTrig = useCCIFilter ? (bearBaseTrig and cciSellState) : bearBaseTrig
bullTrig = bullBaseTrig and cciBuyState
bearTrig = bearBaseTrig and cciSellState

bullTrig :=useTrendFilter ? (bullTrig and trendUp) : bullTrig
bearTrig := useTrendFilter ?(bearTrig and trendDown):bearTrig



//======================================================================
// 9) CALCULS — RSI (bloc 2) + OVERLAY CCI SUR RSI (PATCH)
//======================================================================

// overlay basé sur cciRawF (comme ton code : il utilisait cci_raw du filtre)
cciMappedOverlay = 50.0 + 50.0 * (cciSmaBase / cciVisScaleBase)
cciMappedOverlay := math.max(0.0, math.min(100.0, cciMappedOverlay))

//LevelDyn2 = 50.0 + 50.0 * (LevelDyn / cciVisScaleBase)
//LevelDyn2 := math.max(0.0, math.min(100.0, LevelDyn2))


//======================================================================
// 10) AFFICHAGE — ROCWMA + BARCOLOR + TRIANGLES BUY/SELL
//======================================================================
plot(oscillator * 8, color=currentCol, style=plot.style_histogram, linewidth=2)
plot(signal * 8, color=color.white, linewidth=1)



plotshape(
     not inSess and bullTrig,
     title="Bull: signal <= X% max osc + falling",
     style=shape.triangleup,
     color=bull,
     text="buy",
     textcolor=bull,
     size=size.small,
     location=location.belowbar,
     force_overlay=true
)

plotshape(
     not inSess and bearTrig,
     title="Bear: signal >= -X% max osc + rising",
     style=shape.triangledown,
     color=bear,
     text="sell",
     textcolor=bear,
     size=size.small,
     location=location.abovebar,
     force_overlay=true
)

//======================================================================
// 11) AFFICHAGE — RSI (bloc 2) + zones 70/30 + fill
//======================================================================
//plot(rsi2, title="RSI", linewidth=2, color=#2962FF)
hline(50, title="Middle Line", color=#787B86, linestyle=hline.style_dotted)
obLevel = hline(70, title="Overbought", color=#787B86, linestyle=hline.style_dotted)
osLevel = hline(30, title="Oversold",  color=#787B86, linestyle=hline.style_dotted)
fill(obLevel, osLevel, title="Background", color=color.rgb(33, 150, 243, 90))

//======================================================================
// 12) AFFICHAGE — CCI SMA overlay sur RSI + seuils dynamiques
//======================================================================
plot(
     showCCIOverlay2 ? cciMappedOverlay : na,
     title="CCI SMA (mapped)",
     linewidth=2,
     color=color.orange
)

plot(
     showLevDyn ? LevelDynH : na,
     title="CCI +Level",
     color=color.rgb(5, 240, 13),
     linewidth=1
)

plot(
     showLevDyn ? LevelDynB : na,
     title="CCI -Level",
     color=color.rgb(4, 243, 12),
     linewidth=1
)


//======================================================================
// 13) AFFICHAGE — DOTS (ONE PER CONDITION) — (utilise cciMappedOverlay)
//======================================================================

// BUY
plot(
     showCCIOverlay2 and bullBaseTrig ? clamp(cciMappedOverlay - dotOffset1) : na,
     title="BUY ROCWMA",
     style=plot.style_circles,
     linewidth=3,
     color=color.rgb(255, 3, 28)
)

plot(
     showCCIOverlay2 and cciBuyState ? clamp(cciMappedOverlay - dotOffset2) : na,
     title="BUY CCI",
     style=plot.style_circles,
     linewidth=2,
     color=color.rgb(255, 234, 2)
)

plot(
     showCCIOverlay2 and (cciMaF < LevelDynB) ? clamp(cciMappedOverlay - dotOffset3) : na,
     title="BUY RSI",
     style=plot.style_circles,
     linewidth=2,
     color=color.rgb(4, 250, 16)
)

// SELL
plot(
     showCCIOverlay2 and bearBaseTrig ? clamp(cciMappedOverlay + dotOffset1) : na,
     title="SELL ROCWMA",
     style=plot.style_circles,
     linewidth=3,
     color=color.rgb(4, 238, 242)
)

plot(
     showCCIOverlay2 and cciSellState ? clamp(cciMappedOverlay + dotOffset2) : na,
     title="SELL CCI",
     style=plot.style_circles,
     linewidth=2,
     color=color.rgb(77, 1, 253)
)

plot(
     showCCIOverlay2 and (cciMaF> LevelDynH) ? clamp(cciMappedOverlay + dotOffset3) : na,
     title="SELL RSI",
     style=plot.style_circles,
     linewidth=2,
     color=color.rgb(244, 4, 248)
)

//======================================================================
// 14) AFFICHAGE — RSI (bloc Base) + CCI mappé Base + bornes calibration
//======================================================================
plot(rsiBase, "RSI", linewidth=2)
hline(50, "Milieu", linestyle=hline.style_dotted)

plot(cciMappedBase, "CCI SMA (mappé)", color=color.orange, linewidth=2)

plot(borneHautExt_aff, "Borne RSI extrême haute", color=color.white, linewidth=1)
plot(borneBasExt_aff,  "Borne RSI extrême basse", color=color.white, linewidth=1)


//======================================================================
// 14) AFFICHAGE — EMA
//======================================================================
plot(ShowEMA ? (ta.ema(close,EMAlen)):na, "EMA", color.blue,linewidth=2,force_overlay = true)
