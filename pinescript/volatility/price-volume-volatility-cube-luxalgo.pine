// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=6
indicator("Price-Volume-Volatility Cube [LuxAlgo]", "LuxAlgo - PVV Cube", overlay = true, scale = scale.none, max_lines_count = 500, max_labels_count = 500)

//---------------------------------------------------------------------------------------------------------------------}
// Constants & Inputs
//---------------------------------------------------------------------------------------------------------------------{
color BULL_COLOR = #089981
color BEAR_COLOR = #f23645
color CUBE_COLOR = color.new(chart.fg_color, 50)

int   lookbackInput      = input.int(100, "Lookback Period", minval = 5, group = "Cube Settings")
int   cubeSizeInput      = input.int(50, "Cube Base Width (Bars)", minval = 10, group = "Visuals")
int   xOffsetInput       = input.int(10, "Horizontal Offset (Bars)", group = "Position")

// Persistence for drawing cleanup
var line[] cubeLines         = array.new_line()
var label[] cubeLabels       = array.new_label()
var linefill[] cubeLinefills = array.new_linefill()

//---------------------------------------------------------------------------------------------------------------------}
// Functions & Methods
//---------------------------------------------------------------------------------------------------------------------{
// Cabinet Oblique Projection
// x: Volume (Horizontal), y: Volatility (Depth), z: Price (Vertical)
project(float x, float y, float z, int anchorX, float anchorY, int size, float height) =>
    // Depth settings (angle and scaling)
    float alpha = 0.5 // 0.5 * size for depth projection
    
    // x2d: Volume moves horizontally, Volatility moves at 45° angle
    float x2d = anchorX + (x * size) + (y * size * alpha)
    
    // y2d: Price moves strictly vertically, Volatility moves at 45° angle
    float y2d = anchorY + (z * height) + (y * height * alpha)
    
    [int(x2d), y2d]

//---------------------------------------------------------------------------------------------------------------------}
// Core Calculations
//---------------------------------------------------------------------------------------------------------------------{
// We must call series functions outside conditional blocks for consistency
float lowestP  = ta.lowest(close, lookbackInput)
float highestP = ta.highest(close, lookbackInput)
float lowestV  = ta.lowest(volume, lookbackInput)
float highestV = ta.highest(volume, lookbackInput)
float lowestT  = ta.lowest(ta.tr, lookbackInput)
float highestT = ta.highest(ta.tr, lookbackInput)

//---------------------------------------------------------------------------------------------------------------------}
// Visualization
//---------------------------------------------------------------------------------------------------------------------{
if barstate.islast
    // 0. Cleanup previous drawings
    if array.size(cubeLines) > 0
        for i = 0 to array.size(cubeLines) - 1
            line.delete(array.get(cubeLines, i))
        array.clear(cubeLines)

    if array.size(cubeLabels) > 0
        for i = 0 to array.size(cubeLabels) - 1
            label.delete(array.get(cubeLabels, i))
        array.clear(cubeLabels)

    if array.size(cubeLinefills) > 0
        for i = 0 to array.size(cubeLinefills) - 1
            linefill.delete(array.get(cubeLinefills, i))
        array.clear(cubeLinefills)

    // Ranges for normalization
    float pRange = highestP - lowestP
    float vRange = highestV - lowestV
    float tRange = highestT - lowestT

    int   anchorX = bar_index + xOffsetInput
    
    // Vertical position is now fixed to center the cube vertically on the pane
    float anchorY = 30.0
    
    // Height is now derived from the base width to maintain a perfect cube aspect ratio
    float hUnits  = float(cubeSizeInput)

    // 1. Project Cube Vertices (0 to 1 normalized coordinates)
    // Bottom Square (z = 0)
    [v0x, v0y] = project(0, 0, 0, anchorX, anchorY, cubeSizeInput, hUnits) // Front Left
    [v1x, v1y] = project(1, 0, 0, anchorX, anchorY, cubeSizeInput, hUnits) // Front Right
    [v2x, v2y] = project(1, 1, 0, anchorX, anchorY, cubeSizeInput, hUnits) // Back Right
    [v3x, v3y] = project(0, 1, 0, anchorX, anchorY, cubeSizeInput, hUnits) // Back Left
    
    // Top Square (z = 1)
    [v4x, v4y] = project(0, 0, 1, anchorX, anchorY, cubeSizeInput, hUnits) // Front Left
    [v5x, v5y] = project(1, 0, 1, anchorX, anchorY, cubeSizeInput, hUnits) // Front Right
    [v6x, v6y] = project(1, 1, 1, anchorX, anchorY, cubeSizeInput, hUnits) // Back Right
    [v7x, v7y] = project(0, 1, 1, anchorX, anchorY, cubeSizeInput, hUnits) // Back Left

    // 2. Draw Wireframe
    // Verticals
    array.push(cubeLines, line.new(v0x, v0y, v4x, v4y, color=CUBE_COLOR))
    array.push(cubeLines, line.new(v1x, v1y, v5x, v5y, color=CUBE_COLOR))
    array.push(cubeLines, line.new(v2x, v2y, v6x, v6y, color=CUBE_COLOR))
    array.push(cubeLines, line.new(v3x, v3y, v7x, v7y, color=CUBE_COLOR))
    
    // Bottom Face
    array.push(cubeLines, line.new(v0x, v0y, v1x, v1y, color=CUBE_COLOR))
    array.push(cubeLines, line.new(v1x, v1y, v2x, v2y, color=CUBE_COLOR, style=line.style_dashed))
    array.push(cubeLines, line.new(v2x, v2y, v3x, v3y, color=CUBE_COLOR, style=line.style_dashed))
    array.push(cubeLines, line.new(v3x, v3y, v0x, v0y, color=CUBE_COLOR, style=line.style_dashed))
    
    // Top Face
    array.push(cubeLines, line.new(v4x, v4y, v5x, v5y, color=CUBE_COLOR))
    array.push(cubeLines, line.new(v5x, v5y, v6x, v6y, color=CUBE_COLOR))
    array.push(cubeLines, line.new(v6x, v6y, v7x, v7y, color=CUBE_COLOR))
    array.push(cubeLines, line.new(v7x, v7y, v4x, v4y, color=CUBE_COLOR))

    // 3. Draw Mid-Surface (Z = 0.5)
    [ms0x, ms0y] = project(0, 0, 0.5, anchorX, anchorY, cubeSizeInput, hUnits)
    [ms1x, ms1y] = project(1, 0, 0.5, anchorX, anchorY, cubeSizeInput, hUnits)
    [ms2x, ms2y] = project(1, 1, 0.5, anchorX, anchorY, cubeSizeInput, hUnits)
    [ms3x, ms3y] = project(0, 1, 0.5, anchorX, anchorY, cubeSizeInput, hUnits)
    
    lineM1 = line.new(ms0x, ms0y, ms1x, ms1y, color=color.new(color.gray, 60), style=line.style_dotted)
    lineM2 = line.new(ms3x, ms3y, ms2x, ms2y, color=color.new(color.gray, 60), style=line.style_dotted)
    array.push(cubeLines, lineM1)
    array.push(cubeLines, lineM2)
    array.push(cubeLinefills, linefill.new(lineM1, lineM2, color.new(color.gray, 90)))

    // 4. Axis Labels & Origin
    array.push(cubeLabels, label.new(v0x, v0y, "0", color=#00000000, textcolor=CUBE_COLOR, size=size.small, style=label.style_label_right))
    array.push(cubeLabels, label.new(v1x, v1y, "Volume (X)", color=#00000000, textcolor=CUBE_COLOR, size=size.small, style=label.style_label_up))
    array.push(cubeLabels, label.new(v3x, v3y, "Volatility (Y)", color=#00000000, textcolor=CUBE_COLOR, size=size.small, style=label.style_label_right))
    array.push(cubeLabels, label.new(v4x, v4y, "Price (Z)", color=#00000000, textcolor=CUBE_COLOR, size=size.small, style=label.style_label_right))

    // 5. Data Path & Current Axis Projections
    for i = lookbackInput - 1 to 0
        // Normalizing current point [i] relative to the global min/max of the window
        float nV = vRange == 0 ? 0.5 : (volume[i] - lowestV) / vRange
        float nT = tRange == 0 ? 0.5 : (ta.tr[i] - lowestT) / tRange
        float nP = pRange == 0 ? 0.5 : (close[i] - lowestP) / pRange

        [px, py] = project(nV, nT, nP, anchorX, anchorY, cubeSizeInput, hUnits)
        
        // Dot Color: Gradient based on Price (nP) from Red to Green
        // Depth transparency (Min 50 at front, Max 90 at back)
        int trans = 50 + int(nT * 40)
        color dotColor = color.new(color.from_gradient(nP, 0, 1, BEAR_COLOR, BULL_COLOR), trans)
        
        // Render Dot (Size 2)
        array.push(cubeLabels, label.new(px, py, "", color=dotColor, style=label.style_circle, size=2))

        // Add axis connections for the most recent point only
        if i == 0
            [fx, fy] = project(nV, nT, 0, anchorX, anchorY, cubeSizeInput, hUnits)   // Floor Point
            [xx, xy] = project(nV, 0, 0, anchorX, anchorY, cubeSizeInput, hUnits)   // Volume Axis projection
            [yx, yy] = project(0, nT, 0, anchorX, anchorY, cubeSizeInput, hUnits)   // Volatility Axis projection
            [zx, zy] = project(0, 0, nP, anchorX, anchorY, cubeSizeInput, hUnits)   // Price Axis projection
            
            array.push(cubeLines, line.new(px, py, fx, fy, color=CUBE_COLOR, style=line.style_dotted))     // To Floor
            array.push(cubeLines, line.new(px, py, zx, zy, color=CUBE_COLOR, style=line.style_dotted))     // To Z Axis
            array.push(cubeLines, line.new(fx, fy, xx, xy, color=CUBE_COLOR, style=line.style_dotted))     // Floor to X Axis
            array.push(cubeLines, line.new(fx, fy, yx, yy, color=CUBE_COLOR, style=line.style_dotted))     // Floor to Y Axis
//---------------------------------------------------------------------------------------------------------------------}
