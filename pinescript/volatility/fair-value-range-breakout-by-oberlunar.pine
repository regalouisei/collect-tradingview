// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
// https://creativecommons.org/licenses/by-nc-sa/4.0/

// Derivative work on HTF Candle Architecture: ¬© BigBeluga
// https://it.tradingview.com/script/4vAJgM3K-HTF-Candle-Architecture-BigBeluga/

// Derivative work: Fair Value Gap MTF: ¬© Oberlunar
// https://it.tradingview.com/script/rz1Rtktr/

// Fair Value Range Breakout Strategy by ¬© Oberlunar

//@version=6
indicator("Fair Value Range Breakout [by Oberlunar]", overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 200, max_bars_back = 5000)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INPUTS (HTF candle architecture)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tf     = input.timeframe("120", "Timeframe", group = "HTF Candles")
offset = input.int(15, "Levels offset", minval = 0, group = "HTF Candles")

group1 = "CandleStick 1"
candle1_lvl = input.bool(true, "Candle 1", inline = "1", group = group1)
H1 = input.bool(true, "H", inline = "11", group = group1)
style11 = input.string("Dashed", "", ["Dashed", "Solid", "Dotted"], inline = "11", group = group1)
L1 = input.bool(true, "L", inline = "11", group = group1)
style12 = input.string("Dashed", "", ["Dashed", "Solid", "Dotted"], inline = "11", group = group1)
C1 = input.bool(true, "C", inline = "13", group = group1)
style13 = input.string("Solid", "", ["Dashed", "Solid", "Dotted"], inline = "13", group = group1)
O1 = input.bool(true, "O", inline = "13", group = group1)
style14 = input.string("Solid", "", ["Dashed", "Solid", "Dotted"], inline = "13", group = group1)
bullCol1 = input.color(color.rgb(0, 148, 207), "", inline = "col1", group = group1)
bearCol1 = input.color(color.rgb(248, 33, 108), "", inline = "col1", group = group1)

group2 = "CandleStick 2"
candle2_lvl = input.bool(false, "Candle 2", inline = "2", group = group2)
H2 = input.bool(true, "H", inline = "21", group = group2)
style21 = input.string("Dashed", "", ["Dashed", "Solid", "Dotted"], inline = "21", group = group2)
L2 = input.bool(true, "L", inline = "21", group = group2)
style22 = input.string("Dashed", "", ["Dashed", "Solid", "Dotted"], inline = "21", group = group2)
C2 = input.bool(true, "C", inline = "23", group = group2)
style23 = input.string("Solid", "", ["Dashed", "Solid", "Dotted"], inline = "23", group = group2)
O2 = input.bool(true, "O", inline = "23", group = group2)
style24 = input.string("Solid", "", ["Dashed", "Solid", "Dotted"], inline = "23", group = group2)
bullCol2 = input.color(color.rgb(0, 148, 207), "", inline = "col2", group = group2)
bearCol2 = input.color(color.rgb(248, 33, 108), "", inline = "col2", group = group2)

group3 = "CandleStick 3"
candle3_lvl = input.bool(false, "Candle 3", inline = "3", group = group3)
H3 = input.bool(true, "H", inline = "31", group = group3)
style31 = input.string("Dashed", "", ["Dashed", "Solid", "Dotted"], inline = "31", group = group3)
L3 = input.bool(true, "L", inline = "31", group = group3)
style32 = input.string("Dashed", "", ["Dashed", "Solid", "Dotted"], inline = "31", group = group3)
C3 = input.bool(true, "C", inline = "33", group = group3)
style33 = input.string("Solid", "", ["Dashed", "Solid", "Dotted"], inline = "33", group = group3)
O3 = input.bool(true, "O", inline = "33", group = group3)
style34 = input.string("Solid", "", ["Dashed", "Solid", "Dotted"], inline = "33", group = group3)
bullCol3 = input.color(color.rgb(0, 148, 207), "", inline = "col3", group = group3)
bearCol3 = input.color(color.rgb(248, 33, 108), "", inline = "col3", group = group3)

 

lbls = input.bool(false, "OHLC Text Labels (base)", group = "Style")


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// HTF FVG INPUTS
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
fvgGroup = "HTF FVG"
fvgEnabled    = input.bool(true, "Enable HTF FVG", group = fvgGroup)
fvgSource     = input.string("Wicks", "FVG Source", options = ["Wicks", "Bodies"], group = fvgGroup)
minGapTicks   = input.int(1, "Min gap (ticks)", minval = 0, group = fvgGroup)
maxFvgs       = input.int(5, "Keep last N FVGs", minval = 1, maxval = 20, group = fvgGroup)
fvgExtendBars = input.int(300, "Extend bars to the right", minval = 1, maxval = 5000, group = fvgGroup)
bullFvgCol    = input.color(color.new(color.aqua, 90), "Bull FVG color", group = fvgGroup)
bearFvgCol    = input.color(color.new(color.red, 90), "Bear FVG color", group = fvgGroup)
fvgOpacity    = input.int(85, "FVG fill opacity (0-100)", minval = 0, maxval = 100, group = fvgGroup)

sigGroup = "FVG Signals"
signalsEnabled    = input.bool(true, "Enable signals", group = sigGroup)
touchMode         = input.string("Close inside", "Touch mode", options = ["Close inside", "Wick touch"], group = sigGroup)
signalBufferTicks = input.int(0, "Exit buffer (ticks)", minval = 0, group = sigGroup)
oneSignalPerFvg   = input.bool(true, "One signal per FVG", group = sigGroup)
matchFvgDirection = input.bool(false, "Match FVG direction (Bull->Long, Bear->Short)", group = sigGroup)
signalScope       = input.string("Most recent", "Which FVG to trade", options = ["Most recent", "Any active"], group = sigGroup)
plotSignals       = input.bool(true, "Plot signals on chart", group = sigGroup)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ARRAYS (HTF candles)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var float[] O = array.new_float()
var float[] C = array.new_float()
var float[] H = array.new_float()
var float[] L = array.new_float()
var int[]   candlIndex = array.new_int()

realTimeClose     = close
var float realTimeHigh  = high
var float realTimeLow   = low
var float realTimeOpen  = open

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ARRAYS (FVG)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var float[] fvgTop    = array.new_float()
var float[] fvgBottom = array.new_float()
var int[]   fvgDir    = array.new_int()   // +1 bull, -1 bear
var int[]   fvgStart  = array.new_int()   // bar_index anchor
var bool[]  fvgUsed   = array.new_bool()  // for oneSignalPerFvg
var box[]   fvgBoxes  = array.new_box()

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// FUNCTIONS
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
styleLine(string style_) =>
    style_ == "Dashed" ? line.style_dashed :
     style_ == "Solid" ? line.style_solid :
     style_ == "Dotted" ? line.style_dotted : line.style_solid

convert_tf(string tf_) =>
    s = timeframe.in_seconds(tf_)
    m = timeframe.in_seconds(tf_) / 60
    h = timeframe.in_seconds(tf_) / 60 / 60
    d = timeframe.in_seconds(tf_) / 60 / 60 / 24
    h < 24 and h >= 1 ? str.tostring(h) + "H" :
     m >= 1440 ? str.tostring(d) + "D" :
     m < 60 and m >= 1 ? str.tostring(m) + "M" :
     m < 1 ? str.tostring(s) + "S" : tf_

// --- TP helper (come nel tuo ORB, ma usando High/Low della candela HTF)
 

// --- Main candle draw, with optional TP replace mode
drawCandle(float h, float l, float c, float o,
           int index, int index1, int off,
           bool levels, bool doH, bool doL, bool doO, bool doC,
           string stlH, string stlL, string stlC, string stlO,
           int indx, color bullCol, color bearCol
           ) =>

    if levels
        col = c > o ? bullCol : bearCol
        xC = index1 + off

        // synthetic wick + body (projected)
        line.delete(line.new(xC, h, xC, l, color = color.new(col,60), width = 3)[1])
        box.delete(box.new(xC-2, c, xC+2, o, bgcolor = color.new(col,60), border_color = col)[1])

        // candle number label
        label.delete(label.new(xC, h, str.tostring(indx), style = label.style_label_down,
            color = color.new(color.black,100), textcolor = chart.fg_color)[1])

        // if TP mode is ON for this candle, suppress OHLC TEXT labels (the ‚Äúwhite‚Äù ones),
        // but keep circles + lines if enabled.
        showOhlcText = lbls

        if doH
            line.delete(line.new(xC, h, index, h, style = styleLine(stlH), color = color.new(col,60))[1])
            if showOhlcText
                label.delete(label.new(index, h, str.tostring(h) + "\nHigh " + str.tostring(indx),
                    style = label.style_label_down, color = color.new(color.black,100), textcolor = chart.fg_color)[1])
            label.delete(label.new(index, h, style = label.style_none, color = color.new(col,60), textcolor = chart.fg_color, size = size.tiny)[1])

        if doL
            line.delete(line.new(xC, l, index, l, style = styleLine(stlL), color = color.new(col,60))[1])
            if showOhlcText
                label.delete(label.new(index, l, "Low " + str.tostring(indx) + "\n" + str.tostring(l),
                    style = label.style_label_up, color = color.new(color.black,100), textcolor = chart.fg_color)[1])
            label.delete(label.new(index, l, style = label.style_none, color = color.new(col,60), textcolor = chart.fg_color, size = size.tiny)[1])

        if doO
            line.delete(line.new(xC, o, index, o, style = styleLine(stlO), color = color.new(col,60))[1])
            if showOhlcText
                label.delete(label.new(index-2, o, "Open " + str.tostring(indx) + ": " + str.tostring(o),
                    style = label.style_label_right, color = color.new(chart.bg_color, 90), textcolor = chart.fg_color)[1])
            label.delete(label.new(index, o, style = label.style_none, color = color.new(col,60), textcolor = chart.fg_color, size = size.tiny)[1])

        if doC
            line.delete(line.new(xC, c, index, c, style = styleLine(stlC), color = color.new(col,60))[1])
            if showOhlcText
                label.delete(label.new(index-2, c, "Close " + str.tostring(indx) + ": " + str.tostring(c),
                    style = label.style_label_right, color = color.new(chart.bg_color, 90), textcolor = chart.fg_color)[1])
            label.delete(label.new(index, c, style = label.style_none, color = color.new(col,60), textcolor = chart.fg_color, size = size.tiny)[1])

 

// FVG candle hi/lo (wicks or bodies)
cHi(int idx) =>
    fvgSource == "Wicks" ? H.get(idx) : math.max(O.get(idx), C.get(idx))
cLo(int idx) =>
    fvgSource == "Wicks" ? L.get(idx) : math.min(O.get(idx), C.get(idx))

removeOldestFvg() =>
    if array.size(fvgTop) > 0
        box oldBox = array.shift(fvgBoxes)
        if not na(oldBox)
            box.delete(oldBox)
        array.shift(fvgTop)
        array.shift(fvgBottom)
        array.shift(fvgDir)
        array.shift(fvgStart)
        array.shift(fvgUsed)

addFvg(float top, float bottom, int dir, int startIdx) =>
    bool isDup = false
    if array.size(fvgTop) > 0
        isDup := (top == fvgTop.get(-1)) and (bottom == fvgBottom.get(-1)) and (dir == fvgDir.get(-1)) and (startIdx == fvgStart.get(-1))

    if not isDup
        col = dir == 1 ? bullFvgCol : bearFvgCol

        // IMPORTANT: typed var (fix NA type compile error)
        box b = na

        if fvgEnabled
            b := box.new(startIdx, top, startIdx + fvgExtendBars, bottom,
                 bgcolor = color.new(col, fvgOpacity),
                 border_color = col)
 

        array.push(fvgTop, top)
        array.push(fvgBottom, bottom)
        array.push(fvgDir, dir)
        array.push(fvgStart, startIdx)
        array.push(fvgUsed, false)
        array.push(fvgBoxes, b)

        while array.size(fvgTop) > maxFvgs
            removeOldestFvg()

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// HTF build (synthetic, no lookahead)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if timeframe.change(tf)
    realTimeHigh := high
    realTimeLow  := low
    realTimeOpen := open

    array.push(candlIndex, bar_index)

    array.push(O, realTimeOpen[1])
    array.push(C, close[1])
    array.push(H, realTimeHigh[1])
    array.push(L, realTimeLow[1])

    // Detect new HTF FVG when we have at least 3 closed HTF candles
    if fvgEnabled and array.size(H) >= 3
        aHi = cHi(-3)
        aLo = cLo(-3)
        cHi_ = cHi(-1)
        cLo_ = cLo(-1)

        minGap = minGapTicks * syminfo.mintick
        bull = aHi < (cLo_ - minGap)
        bear = aLo > (cHi_ + minGap)

        // Anchor: start of Candle C (newer closed) = candlIndex.get(-2)
        startIdx = array.size(candlIndex) >= 2 ? candlIndex.get(-2) : bar_index

        if bull
            // Zone: [A high .. C low]  => top = C low, bottom = A high
            addFvg(cLo_, aHi, 1, startIdx)

        if bear
            // Zone: [C high .. A low] => top = A low, bottom = C high
            addFvg(aLo, cHi_, -1, startIdx)

// update forming HTF extremes
realTimeHigh := math.max(realTimeHigh, high)
realTimeLow  := math.min(realTimeLow, low)

// Marks HTF boundaries visually.
bgcolor((timeframe.change(tf) ? color.new(chart.fg_color, 90) : color(na)))

atr = ta.atr(200)

// keep extending FVG boxes to the right
if fvgEnabled and array.size(fvgBoxes) > 0
    for i = 0 to array.size(fvgBoxes) - 1
        b = fvgBoxes.get(i)
        if not na(b)
            box.set_right(b, bar_index + fvgExtendBars)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Signals from HTF FVG zones
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
buf = signalBufferTicks * syminfo.mintick

calcLongShort(float top, float bottom) =>
    closeInsidePrev = (close[1] <= top) and (close[1] >= bottom)
    wickTouchNow    = (low <= top) and (high >= bottom)

    bool _long = false
    bool _short = false

    if touchMode == "Close inside"
        _long  := closeInsidePrev and (close > top + buf)
        _short := closeInsidePrev and (close < bottom - buf)
    else
        _long  := ((wickTouchNow and (close > top + buf)) or (closeInsidePrev and (close > top + buf)))
        _short := ((wickTouchNow and (close < bottom - buf)) or (closeInsidePrev and (close < bottom - buf)))

    [_long, _short]

bool longSig = false
bool shortSig = false

if signalsEnabled and array.size(fvgTop) > 0
    if signalScope == "Most recent"
        i = array.size(fvgTop) - 1
        top = fvgTop.get(i)
        bot = fvgBottom.get(i)
        dir = fvgDir.get(i)
        used = fvgUsed.get(i)

        [l, s] = calcLongShort(top, bot)

        if matchFvgDirection
            l := l and (dir == 1)
            s := s and (dir == -1)

        if not used
            longSig := l
            shortSig := s
            if oneSignalPerFvg and (longSig or shortSig)
                fvgUsed.set(i, true)
    else
        for i = array.size(fvgTop) - 1 to 0 by -1
            if not (longSig or shortSig)
                top = fvgTop.get(i)
                bot = fvgBottom.get(i)
                dir = fvgDir.get(i)
                used = fvgUsed.get(i)

                [l, s] = calcLongShort(top, bot)

                if matchFvgDirection
                    l := l and (dir == 1)
                    s := s and (dir == -1)

                if not used
                    if l
                        longSig := true
                        if oneSignalPerFvg
                            fvgUsed.set(i, true)
                    if s and not longSig
                        shortSig := true
                        if oneSignalPerFvg
                            fvgUsed.set(i, true)


plotshape(longSig,  title="FVG Long",  style=shape.triangleup,   location=location.belowbar, text="FVG\nLONG",  color=color.new(color.aqua, 0), textcolor=color.white, size=size.tiny)
plotshape(shortSig, title="FVG Short", style=shape.triangledown, location=location.abovebar, text="FVG\nSHORT", color=color.new(color.red, 0),  textcolor=color.white, size=size.tiny)

alertcondition(longSig,  title = "FVG Long",  message = "LTF closed above HTF FVG zone.")
alertcondition(shortSig, title = "FVG Short", message = "LTF closed below HTF FVG zone.")

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// DRAW last HTF candles (last bar only)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if barstate.islast
 

    // Candle 3 (tpMode = enableTpC123)
    if array.size(H) >= 2 and array.size(candlIndex) >= 3
        drawCandle(H.get(-2), L.get(-2), C.get(-2), O.get(-2),
            candlIndex.get(-3), bar_index + 15, offset,
            candle3_lvl, H3, L3, O3, C3,
            style31, style32, style33, style34, 3, bullCol3, bearCol3)

    // Candle 2 (tpMode = enableTpC123)
    if array.size(H) >= 1 and array.size(candlIndex) >= 2
        drawCandle(H.get(-1), L.get(-1), C.get(-1), O.get(-1),
            candlIndex.get(-2), bar_index + 20, offset,
            candle2_lvl, H2, L2, O2, C2,
            style21, style22, style23, style24, 2, bullCol2, bearCol2)

    // Candle 1 (forming) (tpMode = enableTpC123)
    if array.size(candlIndex) >= 1
        drawCandle(realTimeHigh, realTimeLow, realTimeClose, realTimeOpen,
            candlIndex.get(-1), bar_index + 25, offset,
            candle1_lvl, H1, L1, O1, C1,
            style11, style12, style13, style14, 1, bullCol1, bearCol1)

    // HTF label
    hiRecent = realTimeHigh
    if array.size(H) >= 1
        hiRecent := math.max(hiRecent, H.get(-1))
    if array.size(H) >= 2
        hiRecent := math.max(hiRecent, H.get(-2))
    if array.size(H) >= 3
        hiRecent := math.max(hiRecent, H.get(-3))

 

var table tSig = na
if na(tSig)
    // Anchor to the indicator pane center; fully transparent frame/border.
    tSig := table.new(position.bottom_right, 1, 1, frame_color=color.new(color.white, 100), border_width=0)

/// Update every bar to ensure consistency on timeframe/resize changes
table.cell( tSig, 0, 0,   text      = "üëÅ  ‚òÖ  Fair Value Range Breakout [by Oberlunar]  ‚òÖ  üëÅ",  text_color= color.new(color.white, 0),   bgcolor   = color.new(color.black, 100),  text_halign = text.align_center,  text_valign = text.align_center,  text_size   = size.normal   )
