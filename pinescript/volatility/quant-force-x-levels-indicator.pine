// ©️ QuantForceX Intelligence System

//@version=6
indicator("QuantForceX QX Intelligence Dashboard", 
     overlay=true, 
     max_lines_count=500,
     max_labels_count=500)

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 1: TYPE DEFINITIONS
// ═══════════════════════════════════════════════════════════════════════════════

type QXLevel
    string  ticker
    float   price
    string  name
    string  levelType
    color   col
    int     width
    string  style
    bool    enabled
    bool    is_synthetic
    int     rank

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 2: THEME CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════

g_theme = "═══ Design Theme ═══"
theme_select = input.string("Dark", "Color Theme", options=["Dark", "Medium Dark", "Medium Light", "Light"], group=g_theme)

get_theme_colors(string theme) =>
    color ceiling_c = na
    color floor_c = na
    color gravity_c = na
    color trigger_c = na
    color instability_c = na
    color label_bg_c = na
    
    switch theme
        "Dark" =>
            ceiling_c := #880e4f
            floor_c := #1b5e20
            gravity_c := #455a64
            trigger_c := #37474f
            instability_c := #bf360c
            label_bg_c := #000000
        "Medium Dark" =>
            ceiling_c := #ad1457
            floor_c := #2e7d32
            gravity_c := #546e7a
            trigger_c := #455a64
            instability_c := #d84315
            label_bg_c := #1a1a1a
        "Medium Light" =>
            ceiling_c := #c2185b
            floor_c := #388e3c
            gravity_c := #607d8b
            trigger_c := #546e7a
            instability_c := #e64a19
            label_bg_c := #2d2d2d
        "Light" =>
            ceiling_c := #d81b60
            floor_c := #43a047
            gravity_c := #78909c
            trigger_c := #607d8b
            instability_c := #f4511e
            label_bg_c := #424242
    [ceiling_c, floor_c, gravity_c, trigger_c, instability_c, label_bg_c]

[t_ceiling, t_floor, t_gravity, t_trigger, t_instability, t_label_bg] = get_theme_colors(theme_select)

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 3: COLOR OVERRIDES
// ═══════════════════════════════════════════════════════════════════════════════

g_override = "═══ Color Overrides ═══"
use_custom_colors   = input.bool(false, "Use Custom Colors", group=g_override)
custom_ceiling      = input.color(#880e4f, "Ceiling (Dark Ruby)", group=g_override)
custom_floor        = input.color(#1b5e20, "Floor (Forest Green)", group=g_override)
custom_gravity      = input.color(#455a64, "Gravity (Steel Blue)", group=g_override)
custom_trigger      = input.color(#37474f, "Trigger", group=g_override)
custom_instability  = input.color(#bf360c, "Instability (Ochre)", group=g_override)
custom_label_bg     = input.color(#000000, "Label Background", group=g_override)

var color COL_CEILING     = na
var color COL_FLOOR       = na
var color COL_GRAVITY     = na
var color COL_TRIGGER     = na
var color COL_INSTABILITY = na
var color COL_LABEL_BG    = na

COL_CEILING     := use_custom_colors ? custom_ceiling : t_ceiling
COL_FLOOR       := use_custom_colors ? custom_floor : t_floor
COL_GRAVITY     := use_custom_colors ? custom_gravity : t_gravity
COL_TRIGGER     := use_custom_colors ? custom_trigger : t_trigger
COL_INSTABILITY := use_custom_colors ? custom_instability : t_instability
COL_LABEL_BG    := use_custom_colors ? custom_label_bg : t_label_bg

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 4: DISPLAY SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════

g_visual = "═══ Display Settings ═══"
line_thickness      = input.int(2, "Primary Line Width", minval=1, maxval=4, group=g_visual)
label_position      = input.string("Right Edge", "Label Position", options=["Right Edge", "Centered", "Dynamic"], group=g_visual)
label_offset        = input.int(5, "Label Offset (bars)", minval=0, maxval=50, group=g_visual)
line_mode           = input.string("Infinite (Both Directions)", "Line Mode", options=["3 Days Range", "Infinite (Both Directions)"], group=g_visual)
show_ticker_info    = input.bool(true, "Show Info Panel", group=g_visual)
synth_suffix        = input.string("°", "Synthetic Suffix", group=g_visual, tooltip="Dezentes Suffix für synthetische Level")

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 5: RANK FILTER - Noise Reduction
// ═══════════════════════════════════════════════════════════════════════════════

g_filter = "═══ Level Filter ═══"
max_ceiling_levels      = input.int(1, "Max Ceiling Levels", minval=1, maxval=5, group=g_filter)
max_floor_levels        = input.int(1, "Max Floor Levels", minval=1, maxval=5, group=g_filter)
max_gravity_levels      = input.int(1, "Max Gravity Levels", minval=1, maxval=3, group=g_filter)
max_trigger_levels      = input.int(5, "Max Trigger Levels (T1-T10)", minval=1, maxval=10, group=g_filter)
max_dampener_levels     = input.int(5, "Max Dampener Levels (FD1-FD10)", minval=1, maxval=10, group=g_filter)
max_instability_levels  = input.int(2, "Max Instability Levels", minval=1, maxval=4, group=g_filter)

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 6: TIME SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════

g_time = "═══ Time Settings ═══"
timezone_input = input.string("Europe/Berlin", "Timezone", options=["Europe/Berlin", "America/New_York", "America/Chicago", "UTC", "Asia/Tokyo", "Asia/Hong_Kong", "Europe/London"], group=g_time)

is_new_day = ta.change(dayofweek(time, timezone_input)) != 0
bars_per_day = timeframe.isintraday ? math.round(1440 / timeframe.multiplier) : 1
three_days_bars = bars_per_day * 3
future_bars = math.min(three_days_bars, 499)

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 7: LOOKBACK SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════

g_lookback = "═══ Lookback Settings ═══"
enable_lookback = input.bool(true, "Enable 3-Day Lookback", group=g_lookback)
lookback_days   = input.int(3, "Lookback Days", minval=1, maxval=10, group=g_lookback)

lookback_bars = enable_lookback ? bars_per_day * lookback_days : 100

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 8: GLOBAL DATABASE
// ═══════════════════════════════════════════════════════════════════════════════

g_bulk = "═══ Global Database ═══"
enable_bulk = input.bool(true, "Enable Global Database", group=g_bulk)
bulk_input = input.text_area("", "Paste Levels (TICKER:Name, Price)", group=g_bulk, tooltip="Format: TICKER:Name, Price")

current_ticker = str.upper(syminfo.ticker)
current_root = str.upper(syminfo.root)

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 9: HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

detect_level_type(string name_lower) =>
    string detected = "custom"
    if str.contains(name_lower, "ceil") or str.contains(name_lower, "resist") or str.contains(name_lower, "call")
        detected := "ceiling"
    else if str.contains(name_lower, "floor") or str.contains(name_lower, "support") or str.contains(name_lower, "put")
        detected := "floor"
    else if str.contains(name_lower, "grav") or str.contains(name_lower, "hvl") or str.contains(name_lower, "node")
        detected := "gravity"
    else if str.contains(name_lower, "t1") or str.contains(name_lower, "t2") or str.contains(name_lower, "t3") or str.contains(name_lower, "t4") or str.contains(name_lower, "t5") or str.contains(name_lower, "t6") or str.contains(name_lower, "t7") or str.contains(name_lower, "t8") or str.contains(name_lower, "t9") or str.contains(name_lower, "t10") or str.contains(name_lower, "trigger")
        detected := "trigger"
    else if str.contains(name_lower, "fd") or str.contains(name_lower, "damp")
        detected := "dampener"
    else if str.contains(name_lower, "ig") or str.contains(name_lower, "instab") or str.contains(name_lower, "gate")
        detected := "instability"
    detected

extract_rank(string name_lower) =>
    int r = 0
    if str.contains(name_lower, "t1") or str.contains(name_lower, "fd1")
        r := 1
    else if str.contains(name_lower, "t2") or str.contains(name_lower, "fd2")
        r := 2
    else if str.contains(name_lower, "t3") or str.contains(name_lower, "fd3")
        r := 3
    else if str.contains(name_lower, "t4") or str.contains(name_lower, "fd4")
        r := 4
    else if str.contains(name_lower, "t5") or str.contains(name_lower, "fd5")
        r := 5
    else if str.contains(name_lower, "t6") or str.contains(name_lower, "fd6")
        r := 6
    else if str.contains(name_lower, "t7") or str.contains(name_lower, "fd7")
        r := 7
    else if str.contains(name_lower, "t8") or str.contains(name_lower, "fd8")
        r := 8
    else if str.contains(name_lower, "t9") or str.contains(name_lower, "fd9")
        r := 9
    else if str.contains(name_lower, "t10") or str.contains(name_lower, "fd10")
        r := 10
    r

get_level_color(string level_type) =>
    switch level_type
        "ceiling" => COL_CEILING
        "floor" => COL_FLOOR
        "gravity" => COL_GRAVITY
        "trigger" => COL_TRIGGER
        "dampener" => COL_TRIGGER
        "instability" => COL_INSTABILITY
        => COL_GRAVITY

get_level_width(string level_type) =>
    switch level_type
        "ceiling" => 2
        "floor" => 2
        "gravity" => 2
        => 1

get_level_style(string level_type) =>
    switch level_type
        "gravity" => "dotted"
        "dampener" => "dashed"
        "instability" => "dashed"
        => "solid"

normalize_ticker(string t) =>
    string result = str.upper(str.trim(t))
    result := str.replace_all(result, "$", "")
    result := str.replace_all(result, " ", "")
    result

round_to_mintick(float val) =>
    math.round(val / syminfo.mintick) * syminfo.mintick

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 10: INTELLIGENT AUTO-TICKER DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

// Major currencies
var string USD = "USD"
var string EUR = "EUR"
var string GBP = "GBP"
var string JPY = "JPY"
var string CHF = "CHF"
var string AUD = "AUD"
var string NZD = "NZD"
var string CAD = "CAD"

// Extract base and quote from ticker (e.g., GBPAUD -> GBP, AUD)
get_base_quote(string ticker) =>
    string base = ""
    string quote = ""
    string t = normalize_ticker(ticker)
    
    if str.length(t) >= 6
        base := str.substring(t, 0, 3)
        quote := str.substring(t, 3, 6)
    [base, quote]

// Check if ticker is a USD major
is_usd_major(string ticker) =>
    string t = normalize_ticker(ticker)
    str.contains(t, USD)

// Check if ticker is a cross pair (no USD)
is_cross_pair(string ticker) =>
    string t = normalize_ticker(ticker)
    not str.contains(t, USD)

// Determine required USD pairs for triangulation
get_required_usd_pairs(string base, string quote) =>
    string pair1 = ""
    string pair2 = ""
    string mode = ""
    
    // Base currency USD pair
    if base == EUR or base == GBP or base == AUD or base == NZD
        pair1 := base + USD
    else if base == JPY or base == CHF or base == CAD
        pair1 := USD + base
    
    // Quote currency USD pair
    if quote == EUR or quote == GBP or quote == AUD or quote == NZD
        pair2 := quote + USD
    else if quote == JPY or quote == CHF or quote == CAD
        pair2 := USD + quote
    
    // Determine calculation mode
    if str.length(pair1) > 0 and str.length(pair2) > 0
        bool base_usd_quote = str.startswith(pair1, USD)
        bool quote_usd_quote = str.startswith(pair2, USD)
        
        if base_usd_quote and quote_usd_quote
            mode := "divide_inverse"
        else if base_usd_quote and not quote_usd_quote
            mode := "divide"
        else if not base_usd_quote and quote_usd_quote
            mode := "multiply"
        else
            mode := "divide"
    
    [pair1, pair2, mode]

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 11: PARSE ALL LEVELS FROM BULK INPUT
// ═══════════════════════════════════════════════════════════════════════════════

parse_all_levels() =>
    array<QXLevel> parsed = array.new<QXLevel>()
    
    if enable_bulk and str.length(bulk_input) > 0
        lines = str.split(bulk_input, "\n")
        
        for i = 0 to array.size(lines) - 1
            line_str = str.trim(array.get(lines, i))
            
            if str.length(line_str) > 0
                string level_ticker = ""
                string rest_of_line = line_str
                
                if str.contains(line_str, ":")
                    colon_pos = str.pos(line_str, ":")
                    potential_ticker = str.substring(line_str, 0, colon_pos)
                    
                    if not str.contains(potential_ticker, ",")
                        level_ticker := normalize_ticker(potential_ticker)
                        rest_of_line := str.substring(line_str, colon_pos + 1)
                
                parts = str.split(rest_of_line, ",")
                
                if array.size(parts) >= 2
                    name_part = str.trim(array.get(parts, 0))
                    price_val = str.tonumber(str.trim(array.get(parts, 1)))
                    
                    if not na(price_val) and price_val > 0
                        name_lower = str.lower(name_part)
                        detected_type = detect_level_type(name_lower)
                        level_col = get_level_color(detected_type)
                        level_width = get_level_width(detected_type)
                        level_style = get_level_style(detected_type)
                        level_rank = extract_rank(name_lower)
                        
                        array.push(parsed, QXLevel.new(level_ticker, price_val, name_part, detected_type, level_col, level_width, level_style, true, false, level_rank))
    parsed

// Get levels for specific ticker
get_levels_for_ticker(array<QXLevel> all_levels, string ticker) =>
    array<QXLevel> filtered = array.new<QXLevel>()
    string norm_ticker = normalize_ticker(ticker)
    
    for i = 0 to array.size(all_levels) - 1
        lvl = array.get(all_levels, i)
        string lvl_ticker = normalize_ticker(lvl.ticker)
        if lvl_ticker == norm_ticker or str.contains(lvl_ticker, norm_ticker) or str.contains(norm_ticker, lvl_ticker)
            array.push(filtered, lvl)
    filtered

// Check if ticker exists in bulk input
ticker_exists_in_bulk(array<QXLevel> all_levels, string ticker) =>
    bool found = false
    string norm_ticker = normalize_ticker(ticker)
    
    for i = 0 to array.size(all_levels) - 1
        lvl = array.get(all_levels, i)
        if normalize_ticker(lvl.ticker) == norm_ticker
            found := true
            break
    found

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 12: SMART CROSS-PAIR TRIANGULATION ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

calculate_cross_levels_smart(array<QXLevel> all_levels, string base, string quote) =>
    array<QXLevel> synthetic = array.new<QXLevel>()
    
    [pair1, pair2, calc_mode] = get_required_usd_pairs(base, quote)
    
    if str.length(pair1) > 0 and str.length(pair2) > 0
        bool has_pair1 = ticker_exists_in_bulk(all_levels, pair1)
        bool has_pair2 = ticker_exists_in_bulk(all_levels, pair2)
        
        if has_pair1 and has_pair2
            array<QXLevel> levels_1 = get_levels_for_ticker(all_levels, pair1)
            array<QXLevel> levels_2 = get_levels_for_ticker(all_levels, pair2)
            
            // Count levels per type for rank filtering
            int ceil_count = 0
            int floor_count = 0
            int grav_count = 0
            int trig_count = 0
            int damp_count = 0
            int inst_count = 0
            
            for i = 0 to array.size(levels_1) - 1
                lvl1 = array.get(levels_1, i)
                
                for j = 0 to array.size(levels_2) - 1
                    lvl2 = array.get(levels_2, j)
                    
                    // Match by level type AND rank
                    if lvl1.levelType == lvl2.levelType and lvl1.rank == lvl2.rank
                        // Check rank filter limits
                        bool allow = false
                        
                        if lvl1.levelType == "ceiling" and ceil_count < max_ceiling_levels
                            ceil_count += 1
                            allow := true
                        else if lvl1.levelType == "floor" and floor_count < max_floor_levels
                            floor_count += 1
                            allow := true
                        else if lvl1.levelType == "gravity" and grav_count < max_gravity_levels
                            grav_count += 1
                            allow := true
                        else if lvl1.levelType == "trigger" and trig_count < max_trigger_levels and lvl1.rank <= max_trigger_levels
                            trig_count += 1
                            allow := true
                        else if lvl1.levelType == "dampener" and damp_count < max_dampener_levels and lvl1.rank <= max_dampener_levels
                            damp_count += 1
                            allow := true
                        else if lvl1.levelType == "instability" and inst_count < max_instability_levels
                            inst_count += 1
                            allow := true
                        
                        if allow
                            float synth_price = na
                            
                            if calc_mode == "multiply"
                                synth_price := lvl1.price * lvl2.price
                            else if calc_mode == "divide"
                                if lvl2.price != 0
                                    synth_price := lvl1.price / lvl2.price
                            else if calc_mode == "divide_inverse"
                                if lvl1.price != 0 and lvl2.price != 0
                                    synth_price := lvl2.price / lvl1.price
                            
                            if not na(synth_price) and synth_price > 0
                                synth_price := round_to_mintick(synth_price)
                                
                                string synth_name = lvl1.name + synth_suffix
                                synth_col = get_level_color(lvl1.levelType)
                                
                                array.push(synthetic, QXLevel.new("SYNTH", synth_price, synth_name, lvl1.levelType, synth_col, lvl1.width, lvl1.style, true, true, lvl1.rank))
    
    synthetic

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 13: MANUAL LEVELS
// ═══════════════════════════════════════════════════════════════════════════════

g_primary = "═══ QX Manual Levels ═══"
enable_manual   = input.bool(false, "Enable Manual Levels", group=g_primary)
enable_ceiling  = input.bool(true, "QX-Ceiling", group=g_primary, inline="c1")
qx_ceiling      = input.float(1.0950, "", step=0.0001, group=g_primary, inline="c1")
enable_floor    = input.bool(true, "QX-Floor", group=g_primary, inline="f1")
qx_floor        = input.float(1.0750, "", step=0.0001, group=g_primary, inline="f1")
enable_gravity  = input.bool(true, "QX-Gravity", group=g_primary, inline="g1")
qx_gravity      = input.float(1.0850, "", step=0.0001, group=g_primary, inline="g1")

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 14: RENDERING ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

get_line_style_enum(string s) =>
    switch s
        "solid"  => line.style_solid
        "dashed" => line.style_dashed
        "dotted" => line.style_dotted
        => line.style_solid

var array<line>  line_arr  = array.new<line>()
var array<label> label_arr = array.new<label>()

use_infinite = line_mode == "Infinite (Both Directions)"

get_label_x(int line_start, int line_end) =>
    int lbl_x = line_end + label_offset
    switch label_position
        "Right Edge" => lbl_x := line_end + label_offset
        "Centered"   => lbl_x := math.round((line_start + line_end) / 2)
        "Dynamic"    => lbl_x := bar_index + label_offset
    math.min(lbl_x, bar_index + 499)

get_label_style() =>
    label_position == "Centered" ? label.style_label_down : label.style_label_left

render_single_level(float price, string name, color col, int width, string style) =>
    if not na(price) and price > 0
        int line_start = bar_index - lookback_bars
        int line_end = math.min(bar_index + future_bars, bar_index + 499)
        
        line new_line = na
        if use_infinite
            new_line := line.new(bar_index - 1, price, bar_index, price, color=color.new(col, 20), style=get_line_style_enum(style), width=width, extend=extend.both)
        else
            new_line := line.new(line_start, price, line_end, price, color=color.new(col, 20), style=get_line_style_enum(style), width=width, extend=extend.none)
        array.push(line_arr, new_line)
        
        int lbl_x = use_infinite ? bar_index + label_offset : get_label_x(line_start, line_end)
        lbl_x := math.min(lbl_x, bar_index + 499)
        
        string display_price = str.tostring(price, format.mintick)
        label new_label = label.new(lbl_x, price, name + "  " + display_price, style=get_label_style(), color=COL_LABEL_BG, textcolor=col, size=size.small)
        array.push(label_arr, new_label)

// Main rendering logic
var string detected_mode = ""
var string detected_pair1 = ""
var string detected_pair2 = ""
var bool is_cross = false

if barstate.islast
    for old_ln in line_arr
        line.delete(old_ln)
    array.clear(line_arr)
    
    for old_lb in label_arr
        label.delete(old_lb)
    array.clear(label_arr)
    
    array<QXLevel> all_parsed = parse_all_levels()
    
    [base_ccy, quote_ccy] = get_base_quote(current_ticker)
    is_cross := is_cross_pair(current_ticker)
    
    // AUTO MODE: Cross-Pair Triangulation
    if enable_bulk and is_cross and str.length(base_ccy) == 3 and str.length(quote_ccy) == 3
        [p1, p2, mode] = get_required_usd_pairs(base_ccy, quote_ccy)
        detected_pair1 := p1
        detected_pair2 := p2
        detected_mode := mode
        
        bool has_p1 = ticker_exists_in_bulk(all_parsed, p1)
        bool has_p2 = ticker_exists_in_bulk(all_parsed, p2)
        
        if has_p1 and has_p2
            array<QXLevel> synth_levels = calculate_cross_levels_smart(all_parsed, base_ccy, quote_ccy)
            
            for i = 0 to array.size(synth_levels) - 1
                slvl = array.get(synth_levels, i)
                render_single_level(slvl.price, slvl.name, slvl.col, slvl.width, slvl.style)
    
    // DIRECT MODE: Ticker match from Global Database
    else if enable_bulk and not is_cross
        ticker_upper = current_ticker
        root_upper = current_root
        
        for i = 0 to array.size(all_parsed) - 1
            lvl = array.get(all_parsed, i)
            lvl_ticker = normalize_ticker(lvl.ticker)
            
            bool ticker_match = str.length(lvl.ticker) == 0
            if not ticker_match
                ticker_match := str.contains(ticker_upper, lvl_ticker) or str.contains(root_upper, lvl_ticker) or lvl_ticker == ticker_upper or lvl_ticker == root_upper
            
            if ticker_match
                render_single_level(lvl.price, lvl.name, lvl.col, lvl.width, lvl.style)
    
    // MANUAL MODE
    if enable_manual and not enable_bulk
        if enable_ceiling and qx_ceiling > 0
            render_single_level(qx_ceiling, "QX-CEILING", COL_CEILING, 2, "solid")
        if enable_floor and qx_floor > 0
            render_single_level(qx_floor, "QX-FLOOR", COL_FLOOR, 2, "solid")
        if enable_gravity and qx_gravity > 0
            render_single_level(qx_gravity, "QX-GRAVITY", COL_GRAVITY, 2, "dotted")

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 15: INFO PANEL
// ═══════════════════════════════════════════════════════════════════════════════

var table info_panel = na

if show_ticker_info and barstate.islast
    if not na(info_panel)
        table.delete(info_panel)
    
    [base_ccy, quote_ccy] = get_base_quote(current_ticker)
    
    int rows = is_cross ? 4 : 2
    info_panel := table.new(position.bottom_left, 2, rows, bgcolor=color.new(#000000, 80), border_width=0)
    
    table.cell(info_panel, 0, 0, "QX:", text_color=color.gray, text_size=size.tiny)
    table.cell(info_panel, 1, 0, current_ticker, text_color=COL_GRAVITY, text_size=size.tiny)
    
    if is_cross
        table.cell(info_panel, 0, 1, "MODE:", text_color=color.gray, text_size=size.tiny)
        table.cell(info_panel, 1, 1, "AUTO-CROSS", text_color=COL_CEILING, text_size=size.tiny)
        table.cell(info_panel, 0, 2, "SRC:", text_color=color.gray, text_size=size.tiny)
        table.cell(info_panel, 1, 2, detected_pair1 + " + " + detected_pair2, text_color=color.white, text_size=size.tiny)
        table.cell(info_panel, 0, 3, "CALC:", text_color=color.gray, text_size=size.tiny)
        table.cell(info_panel, 1, 3, detected_mode, text_color=color.white, text_size=size.tiny)
    else
        table.cell(info_panel, 0, 1, "MODE:", text_color=color.gray, text_size=size.tiny)
        table.cell(info_panel, 1, 1, "DIRECT", text_color=COL_FLOOR, text_size=size.tiny)

// ═══════════════════════════════════════════════════════════════════════════════
// SECTION 16: ALERTS
// ═══════════════════════════════════════════════════════════════════════════════

alertcondition(is_new_day, "QX New Trading Day", "New trading day started at 00:00")
