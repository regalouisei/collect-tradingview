// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© MarkitTick

//@version=6
indicator("Bernoulli Process: Trend Probability & Entropy [MarkitTick]", overlay = false)

// =============================================================================
// 1. CONSTANTS & CONFIGURATION
// =============================================================================
var string GRP_PROCESS = "Bernoulli Process Settings"
var string GRP_VISUAL  = "Visual & UI Settings"
var string GRP_ALERT   = "Automation & Alerts"

string mode = input.string("Price Action (Close > Open)", "Bernoulli Trial Definition", options = ["Price Action (Close > Open)", "Momentum (RSI > 50)", "Trend (Close > MA)"], group = GRP_PROCESS)
int length  = input.int(20, "Sample Window (N)", minval = 2, group = GRP_PROCESS, tooltip = "The number of trials used to estimate the probability parameter 'p'.")

color col_bull    = input.color(color.new(#00E676, 0), "Bullish Probability (p > 0.5)", group = GRP_VISUAL)
color col_bear    = input.color(color.new(#FF5252, 0), "Bearish Probability (p < 0.5)", group = GRP_VISUAL)
color col_entropy = input.color(color.new(#787B86, 60), "High Entropy Zone (Noise)", group = GRP_VISUAL)
color col_text    = input.color(color.white, "Dashboard Text", group = GRP_VISUAL)

float risk_reward = input.float(2.0, "Target R:R Ratio", group = GRP_ALERT)
float stop_atr    = input.float(1.5, "Stop Loss ATR Multiplier", group = GRP_ALERT)

// =============================================================================
// 2. MATHEMATICAL METHODS 
// =============================================================================

method calc_entropy(float p) =>
    (p <= 0.0 or p >= 1.0) ? 0.0 : -1.0 * (p * (math.log(p) / math.log(2)) + (1.0 - p) * (math.log(1.0 - p) / math.log(2)))

method calc_variance(float p) => p * (1.0 - p)

// =============================================================================
// 3. MAIN LOGIC EXECUTION
// =============================================================================

bool trial_outcome = false
if mode == "Price Action (Close > Open)"
    trial_outcome := close > open
else if mode == "Momentum (RSI > 50)"
    trial_outcome := ta.rsi(close, 14) > 50
else 
    trial_outcome := close > ta.sma(close, length)

float outcome_val = trial_outcome ? 1.0 : 0.0


float p_hat = math.sum(outcome_val, length) / length

float entropy  = p_hat.calc_entropy()     
float variance = p_hat.calc_variance()   

float std_dev_fair = math.sqrt(length * 0.25) 
float deviations   = (math.sum(outcome_val, length) - (0.5 * length))
float z_score      = deviations / std_dev_fair

// =============================================================================
// 4. PLOTTING & VISUALIZATION
// =============================================================================

color dyn_color = color.from_gradient(p_hat, 0.0, 1.0, col_bear, col_bull)
color final_col = entropy > 0.9 ? color.new(color.gray, 50) : dyn_color

plot(p_hat, "Bernoulli Probability (p)", color = final_col, linewidth = 2)

bgcolor(entropy > 0.95 ? col_entropy : na, title = "Max Entropy Regime")

hline(0.5, "Fair Coin (Random)", color = color.new(color.gray, 50), linestyle = hline.style_dashed)
hline(0.8, "Strong Bull Threshold", color = color.new(col_bull, 70), linestyle = hline.style_dotted)
hline(0.2, "Strong Bear Threshold", color = color.new(col_bear, 70), linestyle = hline.style_dotted)

// =============================================================================
// 5. DATA TABLE (Dashboard)
// =============================================================================

var table dash = table.new(position.top_right, 2, 4, border_width = 1, border_color = color.new(color.gray, 80))

if barstate.islast
    table.cell(dash, 0, 0, "Bernoulli Metrics", bgcolor = color.new(color.gray, 90), text_color = col_text, text_size = size.small)
    table.cell(dash, 1, 0, "Value", bgcolor = color.new(color.gray, 90), text_color = col_text, text_size = size.small)

    table.cell(dash, 0, 1, "Probability (p)", text_color = col_text, text_size = size.small)
    table.cell(dash, 1, 1, str.tostring(p_hat, "#.###"), text_color = p_hat > 0.5 ? col_bull : col_bear, text_size = size.small)

    table.cell(dash, 0, 2, "Entropy (Bits)", text_color = col_text, text_size = size.small)
    table.cell(dash, 1, 2, str.tostring(entropy, "#.###"), text_color = entropy > 0.9 ? color.red : color.gray, text_size = size.small)
    
    string regime = entropy > 0.9 ? "NOISE / CHOP" : (p_hat > 0.5 ? "BULL TREND" : "BEAR TREND")
    table.cell(dash, 0, 3, "Regime", text_color = col_text, text_size = size.small)
    table.cell(dash, 1, 3, regime, text_color = final_col, text_size = size.small)

// =============================================================================
// 6. AUTOMATION & ALERTS (Strict JSON)
// =============================================================================

bool signal_long  = ta.crossover(p_hat, 0.5) and entropy < 0.95
bool signal_short = ta.crossunder(p_hat, 0.5) and entropy < 0.95

float atr_val = ta.atr(14)
float entry_price = close
float sl_long     = entry_price - (atr_val * stop_atr)
float tp_long     = entry_price + ((entry_price - sl_long) * risk_reward)
float sl_short    = entry_price + (atr_val * stop_atr)
float tp_short    = entry_price - ((sl_short - entry_price) * risk_reward)

if signal_long
    string payload = '{"action": "long", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(entry_price, format.mintick) + ', "tp": ' + str.tostring(tp_long, format.mintick) + ', "sl": ' + str.tostring(sl_long, format.mintick) + '}'
    alert(payload, alert.freq_once_per_bar_close)

if signal_short
    string payload = '{"action": "short", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(entry_price, format.mintick) + ', "tp": ' + str.tostring(tp_short, format.mintick) + ', "sl": ' + str.tostring(sl_short, format.mintick) + '}'
    alert(payload, alert.freq_once_per_bar_close)

plotshape(signal_long, "Long Signal", shape.triangleup, location.bottom, col_bull, size = size.tiny)
plotshape(signal_short, "Short Signal", shape.triangledown, location.top, col_bear, size = size.tiny)
