"""
OpenClaw Backtest Results: volumetric-supply-and-demand-zones-boswaves
============================================================

--- SPY ---
  ERROR: object of type 'TvStrategy' has no len()

--- BTC ---
  ERROR: object of type 'TvStrategy' has no len()

--- QQQ ---
  ERROR: object of type 'TvStrategy' has no len()

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” volumetric-supply-and-demand-zones-boswaves
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    swing_len = 8
    impulse_mult = 1.2
    base_lookback = 3
    atr_length = 14
    max_zone_atr = 4.0
    merge_gap_atr = 0.3
    profile_rows = 10
    mitigation_type = "Wick"

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        self.atr = self.I(pta.atr, high, low, close, length=self.atr_length)
        
        self.demand_zones = []
        self.supply_zones = []
        self.zone_counter = 0
        
        self.last_pivot_high_bar = -1
        self.last_pivot_low_bar = -1

    def next(self):
        if len(self) < self.swing_len + self.base_lookback + 1:
            return
        
        current_atr = self.atr[-1]
        if np.isnan(current_atr) or current_atr == 0:
            return
        
        close_current = self.data.Close[-1]
        close_past = self.data.Close[-1 - self.swing_len]
        
        high_current = self.data.High[-1]
        low_current = self.data.Low[-1]
        
        is_pivot_high = True
        is_pivot_low = True
        
        for i in range(1, self.swing_len + 1):
            if len(self) >= i + 1:
                if self.data.High[-i] > self.data.High[-self.swing_len - 1]:
                    is_pivot_high = False
                if self.data.Low[-i] < self.data.Low[-self.swing_len - 1]:
                    is_pivot_low = False
        
        impulse_up = (close_current - close_past) >= (current_atr * self.impulse_mult)
        impulse_down = (close_past - close_current) >= (current_atr * self.impulse_mult)
        
        if is_pivot_low and impulse_up:
            if len(self) - self.last_pivot_low_bar > self.swing_len:
                zone_high = high_current
                zone_low = low_current
                
                for i in range(1, self.base_lookback + 1):
                    if len(self) >= i + 1:
                        zone_high = max(zone_high, self.data.High[-i])
                        zone_low = min(zone_low, self.data.Low[-i])
                
                zone_height = zone_high - zone_low
                max_height = current_atr * self.max_zone_atr
                
                if zone_height > max_height:
                    mid = (zone_high + zone_low) / 2
                    zone_high = mid + (max_height / 2)
                    zone_low = mid - (max_height / 2)
                
                self.demand_zones.append({
                    'id': self.zone_counter,
                    'type': 'demand',
                    'top': zone_high,
                    'bottom': zone_low,
                    'bar_created': len(self),
                    'touches': 0,
                    'status': 'fresh',
                    'active': True
                })
                self.zone_counter += 1
                self.last_pivot_low_bar = len(self)
        
        if is_pivot_high and impulse_down:
            if len(self) - self.last_pivot_high_bar > self.swing_len:
                zone_high = high_current
                zone_low = low_current
                
                for i in range(1, self.base_lookback + 1):
                    if len(self) >= i + 1:
                        zone_high = max(zone_high, self.data.High[-i])
                        zone_low = min(zone_low, self.data.Low[-i])
                
                zone_height = zone_high - zone_low
                max_height = current_atr * self.max_zone_atr
                
                if zone_height > max_height:
                    mid = (zone_high + zone_low) / 2
                    zone_high = mid + (max_height / 2)
                    zone_low = mid - (max_height / 2)
                
                self.supply_zones.append({
                    'id': self.zone_counter,
                    'type': 'supply',
                    'top': zone_high,
                    'bottom': zone_low,
                    'bar_created': len(self),
                    'touches': 0,
                    'status': 'fresh',
                    'active': True
                })
                self.zone_counter += 1
                self.last_pivot_high_bar = len(self)
        
        for zone in self.demand_zones:
            if not zone['active']:
                continue
            
            in_zone = (high_current >= zone['bottom'] and low_current <= zone['top'])
            
            if in_zone:
                if zone['status'] == 'fresh':
                    zone['status'] = 'tested'
                    zone['touches'] = 1
                elif zone['status'] == 'tested':
                    zone['touches'] += 1
            
            mitigated = False
            if self.mitigation_type == "Wick":
                mitigated = low_current < zone['bottom']
            else:
                mitigated = self.data.Close[-1] < zone['bottom']
            
            if mitigated:
                zone['active'] = False
                if not self.position:
                    self.buy()
        
        for zone in self.supply_zones:
            if not zone['active']:
                continue
            
            in_zone = (high_current >= zone['bottom'] and low_current <= zone['top'])
            
            if in_zone:
                if zone['status'] == 'fresh':
                    zone['status'] = 'tested'
                    zone['touches'] = 1
                elif zone['status'] == 'tested':
                    zone['touches'] += 1
            
            mitigated = False
            if self.mitigation_type == "Wick":
                mitigated = high_current > zone['top']
            else:
                mitigated = self.data.Close[-1] > zone['top']
            
            if mitigated:
                zone['active'] = False
                if self.position:
                    self.sell()
        
        if self.position and not any(zone['active'] for zone in self.supply_zones):
            self.sell()
        elif not self.position and any(zone['active'] for zone in self.demand_zones):
            if all(z['touches'] > 0 for z in self.demand_zones if z['active']):
                self.buy()