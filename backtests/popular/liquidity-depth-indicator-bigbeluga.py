"""
OpenClaw Backtest Results: liquidity-depth-indicator-bigbeluga
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "_calculat…" shape: (), returned value: -0.4203509970648224)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "_calculat…" shape: (), returned value: -0.505778727566367)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "_calculat…" shape: (), returned value: -0.4124811186585252)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — liquidity-depth-indicator-bigbeluga
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lookback_period = 300
    
    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # Calculate highest and lowest over lookback period
        self.highest = self.I(lambda x: pd.Series(x).rolling(window=self.lookback_period).max(), self.data.High)
        self.lowest = self.I(lambda x: pd.Series(x).rolling(window=self.lookback_period).min(), self.data.Low)
        
        # Calculate midpoint
        self.mid = self.I(lambda h, l: (h + l) / 2, self.highest, self.lowest)
        
        # Calculate volume-weighted price position
        self.vol_profile = self.I(self._calculate_volume_profile, close, volume)
        
    def _calculate_volume_profile(self, close, volume):
        """Calculate volume profile indicator for trading signal"""
        if len(close) < self.lookback_period:
            return 0.0
        
        recent_close = close.iloc[-1]
        recent_high = self.data.High[-1]
        recent_low = self.data.Low[-1]
        recent_mid = self.mid[-1]
        
        # Cumulative volume above and below midpoint
        vol_above_mid = 0.0
        vol_below_mid = 0.0
        
        lookback_data = min(self.lookback_period, len(close))
        for i in range(lookback_data):
            idx = -(lookback_data - i)
            if close.iloc[idx] > recent_mid:
                vol_above_mid += volume.iloc[idx]
            else:
                vol_below_mid += volume.iloc[idx]
        
        total_vol = vol_above_mid + vol_below_mid
        if total_vol == 0:
            return 0.0
        
        # Return ratio: positive favors buy (below mid), negative favors sell (above mid)
        return (vol_below_mid - vol_above_mid) / total_vol if total_vol > 0 else 0.0
    
    def next(self):
        current_close = self.data.Close[-1]
        current_mid = self.mid[-1]
        vol_profile = self.vol_profile[-1]
        
        # Buy signal: price near lower range, volume profile bullish
        if current_close < current_mid and vol_profile > 0.3:
            if not self.position:
                self.buy()
        
        # Sell signal: price near upper range, volume profile bearish
        elif current_close > current_mid and vol_profile < -0.3:
            if self.position:
                self.sell()
        
        # Exit on reversal at mid
        elif self.position and ((self.position.is_long and current_close > current_mid) or 
                                (self.position.is_short and current_close < current_mid)):
            self.sell()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    results = bt.run()
    print(results)
    bt.plot()