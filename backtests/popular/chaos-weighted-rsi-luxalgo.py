"""
OpenClaw Backtest Results: chaos-weighted-rsi-luxalgo
============================================================

--- SPY ---
  Return                    0.00%
  Buy & Hold Return         41.94%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- BTC ---
  Return                    0.00%
  Buy & Hold Return         46.22%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- QQQ ---
  Return                    0.00%
  Buy & Hold Return         42.67%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” chaos-weighted-rsi-luxalgo
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    rsiLengthInput = 14
    disorderLengthInput = 20
    sensitivityInput = 1.0
    divStrengthInput = 20

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        self.wrsi = self.I(self._calculate_chaos_weighted_rsi, close)
        self.pivot_high = self.I(self._calculate_pivot_high, self.wrsi)
        self.pivot_low = self.I(self._calculate_pivot_low, self.wrsi)

    def _calculate_chaos_weighted_rsi(self, close):
        wrsi_values = []
        
        for i in range(len(close)):
            if i < self.disorderLengthInput:
                wrsi_values.append(np.nan)
                continue
            
            lookback_close = close.iloc[i-self.disorderLengthInput+1:i+1]
            chaos = self._get_chaos(lookback_close, self.disorderLengthInput)
            
            base_alpha = 1.0 / self.rsiLengthInput
            adjusted_alpha = base_alpha * np.power(1.0 - chaos, self.sensitivityInput)
            adjusted_alpha = max(0.001, min(1.0, adjusted_alpha))
            
            if i == 0:
                wrsi_values.append(50)
                continue
            
            change = close.iloc[i] - close.iloc[i-1]
            gain = max(change, 0)
            loss = max(-change, 0)
            
            if len(wrsi_values) == 1:
                avg_gain = gain
                avg_loss = loss
            else:
                prev_gain = (wrsi_values[-1] / 100 * (1 + wrsi_values[-1] / 100)) if wrsi_values[-1] != 50 else 0.5
                prev_loss = ((100 - wrsi_values[-1]) / 100 * (1 + (100 - wrsi_values[-1]) / 100)) if wrsi_values[-1] != 50 else 0.5
                
                avg_gain = prev_gain + adjusted_alpha * (gain - prev_gain)
                avg_loss = prev_loss + adjusted_alpha * (loss - prev_loss)
            
            if avg_loss == 0:
                wrsi = 100
            else:
                rs = avg_gain / avg_loss
                wrsi = 100 - (100 / (1 + rs))
            
            wrsi_values.append(wrsi)
        
        return np.array(wrsi_values)

    def _get_chaos(self, src, length):
        max_val = src.max()
        min_val = src.min()
        price_range = max_val - min_val
        
        L = 0.0
        for i in range(length - 1):
            y1 = (src.iloc[i+1] - min_val) / price_range if price_range > 0 else 0.5
            y2 = (src.iloc[i] - min_val) / price_range if price_range > 0 else 0.5
            L += np.sqrt((y1 - y2)**2 + (1.0 / (length - 1))**2)
        
        fdi = 1.0 + np.log(L) / np.log(2.0 * (length - 1))
        chaos = max(0.0, min(1.0, (fdi - 1.0) / 0.5))
        return chaos

    def _calculate_pivot_high(self, wrsi):
        pivot_high = []
        for i in range(len(wrsi)):
            is_pivot = True
            if i < self.divStrengthInput or i >= len(wrsi) - self.divStrengthInput:
                pivot_high.append(np.nan)
                continue
            
            current = wrsi[i]
            for j in range(1, self.divStrengthInput + 1):
                if not np.isnan(wrsi[i-j]) and wrsi[i-j] >= current:
                    is_pivot = False
                    break
                if not np.isnan(wrsi[i+j]) and wrsi[i+j] >= current:
                    is_pivot = False
                    break
            
            pivot_high.append(current if is_pivot else np.nan)
        
        return np.array(pivot_high)

    def _calculate_pivot_low(self, wrsi):
        pivot_low = []
        for i in range(len(wrsi)):
            is_pivot = True
            if i < self.divStrengthInput or i >= len(wrsi) - self.divStrengthInput:
                pivot_low.append(np.nan)
                continue
            
            current = wrsi[i]
            for j in range(1, self.divStrengthInput + 1):
                if not np.isnan(wrsi[i-j]) and wrsi[i-j] <= current:
                    is_pivot = False
                    break
                if not np.isnan(wrsi[i+j]) and wrsi[i+j] <= current:
                    is_pivot = False
                    break
            
            pivot_low.append(current if is_pivot else np.nan)
        
        return np.array(pivot_low)

    def next(self):
        if len(self.wrsi) < 2:
            return
        
        if np.isnan(self.wrsi[-1]) or np.isnan(self.wrsi[-2]):
            return
        
        bullish_div = not np.isnan(self.pivot_low[-self.divStrengthInput]) and self.wrsi[-1] > 30
        bearish_div = not np.isnan(self.pivot_high[-self.divStrengthInput]) and self.wrsi[-1] < 70
        
        if crossover(self.wrsi, 30) or bullish_div:
            if not self.position:
                self.buy()
        elif crossover(70, self.wrsi) or bearish_div:
            if self.position:
                self.sell()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()