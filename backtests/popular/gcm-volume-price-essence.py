"""
OpenClaw Backtest Results: gcm-volume-price-essence
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ(λ,sma(3…,8)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "ema(λ(λ,sma(3…,8)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ(λ,sma(3…,8)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — gcm-volume-price-essence
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lengthFast = 8
    lengthSlow = 21
    lengthVolume = 14
    volImpact = 1.5
    smoothing = 5
    finalSmoothing = 3
    signalPeriod = 12
    divLookback = 3

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)

        # Volume ratio
        vol_sma_3 = self.I(pta.sma, volume, length=3)
        vol_sma_long = self.I(pta.sma, volume, length=self.lengthVolume)
        self.volume_ratio = vol_sma_3 / (vol_sma_long + 1e-10)

        # Price change and volume-weighted momentum
        self.price_change = self.I(lambda x: pd.Series(x).diff(), close)
        self.volume_weighted_momentum = self.I(
            lambda pc, vr: pc * np.log(1 + (vr * self.volImpact)),
            self.price_change,
            self.volume_ratio
        )

        # Flow calculations
        self.fast_flow = self.I(pta.ema, self.volume_weighted_momentum, length=self.lengthFast)
        self.slow_flow = self.I(pta.ema, self.volume_weighted_momentum, length=self.lengthSlow)
        flow_diff = self.I(lambda ff, sf: ff - sf, self.fast_flow, self.slow_flow)
        self.quantum_flow = self.I(pta.ema, flow_diff, length=self.smoothing)

        # Price velocity and acceleration
        self.price_velocity = self.I(
            lambda c: (pd.Series(c) - pd.Series(c).shift(self.lengthFast)) / self.lengthFast,
            close
        )
        self.price_acceleration = self.I(lambda pv: pd.Series(pv).diff(), self.price_velocity)

        # Flow strength
        flow_strength_calc = self.I(
            lambda pv, vr, pa: (pv * vr + pa) * 100,
            self.price_velocity,
            self.volume_ratio,
            self.price_acceleration
        )
        self.flow_strength = self.I(pta.ema, flow_strength_calc, length=self.smoothing)

        # Trend pressure
        rsi_val = self.I(pta.rsi, close, length=self.lengthFast)
        trend_pressure_calc = self.I(lambda r: pd.Series(r) - 50, rsi_val)
        self.trend_pressure = self.I(pta.ema, trend_pressure_calc, length=self.smoothing)

        # Composite index
        raw_composite = self.I(
            lambda qf, fs, tp: (qf * 50 + fs + tp) / 3,
            self.quantum_flow,
            self.flow_strength,
            self.trend_pressure
        )
        self.composite_index = self.I(pta.wma, raw_composite, length=self.finalSmoothing)
        self.baseline = self.I(pta.ema, self.composite_index, length=self.signalPeriod)

        # Anticipation signals
        self.flow_divergence = self.I(
            lambda ff, sf: crossover(ff, sf) or crossover(sf, ff),
            self.fast_flow,
            self.slow_flow
        )

        self.momentum_building = self.I(
            lambda ci: (pd.Series(ci).diff() > 0) & (pd.Series(ci) < -20),
            self.composite_index
        )

        self.momentum_fading = self.I(
            lambda ci: (pd.Series(ci).diff() < 0) & (pd.Series(ci) > 20),
            self.composite_index
        )

        # Divergence logic
        self.price_pushing_down = self.I(
            lambda l: pd.Series(l).diff() < 0,
            low
        )

        self.price_pushing_up = self.I(
            lambda h: pd.Series(h).diff() > 0,
            high
        )

        self.ind_rising = self.I(
            lambda ci: pd.Series(ci).diff() > 0,
            self.composite_index
        )

        self.ind_falling = self.I(
            lambda ci: pd.Series(ci).diff() < 0,
            self.composite_index
        )

    def next(self):
        if len(self.composite_index) < 2:
            return

        # Current values
        composite = self.composite_index[-1]
        baseline = self.baseline[-1]
        fast_flow = self.fast_flow[-1]
        slow_flow = self.slow_flow[-1]
        vol_ratio = self.volume_ratio[-1]

        # Anticipation conditions
        bullish_anticipation = (
            self.flow_divergence[-1] and
            fast_flow > slow_flow and
            composite < 0
        )

        bearish_anticipation = (
            self.flow_divergence[-1] and
            fast_flow < slow_flow and
            composite > 0
        )

        bullish_continuation = (
            self.momentum_building[-1] and
            vol_ratio > 1.2
        )

        bearish_continuation = (
            self.momentum_fading[-1] and
            vol_ratio > 1.2
        )

        # Divergence conditions
        div_bull = (
            self.price_pushing_down[-1] and
            self.ind_rising[-1]
        )

        div_bear = (
            self.price_pushing_up[-1] and
            self.ind_falling[-1]
        )

        # Entry signals
        if bullish_anticipation or bullish_continuation or div_bull:
            if not self.position:
                self.buy()
        elif bearish_anticipation or bearish_continuation or div_bear:
            if self.position:
                self.sell()

        # Baseline crossover exits
        if len(self.composite_index) > 1:
            if crossover(self.composite_index, self.baseline):
                if not self.position:
                    self.buy()
            elif crossover(self.baseline, self.composite_index):
                if self.position:
                    self.sell()