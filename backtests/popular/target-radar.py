"""
OpenClaw Backtest Results: target-radar
============================================================

--- SPY ---
  ERROR: '_Indicator' object has no attribute 'iloc'

--- BTC ---
  ERROR: '_Indicator' object has no attribute 'iloc'

--- QQQ ---
  ERROR: '_Indicator' object has no attribute 'iloc'

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” target-radar
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Forecast Engine
    h = 3
    lookback = 100
    wTrend = 0.30
    wMom = 0.30
    wVol = 0.20
    wVpr = 0.20
    retScale = 1.0
    
    # Uncertainty Band
    targetCov = 0.80
    resLookback = 200
    minHW = 0.005
    uncertTh = 0.08
    dirEps = 0.001
    
    # Signal Mode
    sigMode = "Breakout"
    minScore = 0.65
    
    # Signal Filters
    useConfGate = True
    useUncertGate = True
    useRegimeGate = True
    adxLen = 14
    trendTh = 25.0
    chopLen = 14
    chaosTh = 62.0

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # EMA based trend
        self.emaF = self.I(pta.ema, close, length=10)
        self.emaS = self.I(pta.ema, close, length=20)
        
        # RSI
        self.rsi = self.I(pta.rsi, close, length=14)
        
        # ATR
        self.atr = self.I(pta.atr, high, low, close, length=14)
        
        # ADX for regime
        adx_result = self.I(pta.adx, high, low, close, length=self.adxLen)
        self.adx = adx_result
        
        # EMA for signal modes
        self.ema9 = self.I(pta.ema, close, length=9)
        self.ema21 = self.I(pta.ema, close, length=21)
        self.ema20 = self.I(pta.ema, close, length=20)
        self.ema50 = self.I(pta.ema, close, length=50)
        
        # Bollinger Bands for mean reversion
        bb_result = self.I(pta.bbands, close, length=20, std=2)
        self.bb_mid = bb_result.iloc[:, 0]
        self.bb_upper = bb_result.iloc[:, 1]
        self.bb_lower = bb_result.iloc[:, 2]
        
        # Highest/Lowest for breakout
        self.hi20 = self.I(lambda x: pd.Series(x).rolling(20).max(), close)
        self.lo20 = self.I(lambda x: pd.Series(x).rolling(20).min(), close)
        
        # Volume SMA
        self.vol_sma = self.I(pta.sma, volume, length=20)

    def next(self):
        if len(self.data) < max(50, self.h + 1):
            return
        
        close = self.data.Close[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        volume = self.data.Volume[-1]
        
        # Get current indicator values
        rsi_val = self.rsi[-1]
        emaF_val = self.emaF[-1]
        emaS_val = self.emaS[-1]
        ema9_val = self.ema9[-1]
        ema21_val = self.ema21[-1]
        ema20_val = self.ema20[-1]
        ema50_val = self.ema50[-1]
        atr_val = self.atr[-1]
        adx_val = self.adx[-1]
        vol_sma_val = self.vol_sma[-1]
        
        # Trend Pullback signals
        tp_long = (ema20_val > ema50_val) and crossover(self.rsi, 30) and close > ema20_val
        tp_short = (ema20_val < ema50_val) and crossover(70, self.rsi) and close < ema20_val
        
        # Breakout signals
        hi20_val = self.hi20[-2] if len(self.hi20) > 1 else close
        lo20_val = self.lo20[-2] if len(self.lo20) > 1 else close
        vol_ok = volume > vol_sma_val * 1.3
        bo_long = crossover(self.data.Close, hi20_val) and vol_ok
        bo_short = crossover(lo20_val, self.data.Close) and vol_ok
        
        # Mean Reversion signals
        bb_mid_val = self.bb_mid[-1]
        bb_upper_val = self.bb_upper[-1]
        bb_lower_val = self.bb_lower[-1]
        
        if bb_mid_val > 0:
            z_score = (close - bb_mid_val) / max(bb_upper_val - bb_mid_val, 1e-10)
            mr_long = crossover(self.data.Close, bb_lower_val)
            mr_short = crossover(bb_upper_val, self.data.Close)
        else:
            mr_long = False
            mr_short = False
        
        # EMA Cross signals
        ema_long = crossover(self.ema9, self.ema21)
        ema_short = crossover(self.ema21, self.ema9)
        
        # Select signals based on mode
        if self.sigMode == "Trend Pullback":
            base_long = tp_long
            base_short = tp_short
        elif self.sigMode == "Breakout":
            base_long = bo_long
            base_short = bo_short
        elif self.sigMode == "Mean Reversion":
            base_long = mr_long
            base_short = mr_short
        else:  # EMA Cross
            base_long = ema_long
            base_short = ema_short
        
        # Regime check
        regime_ok = True
        if not np.isnan(adx_val):
            if adx_val > self.trendTh:
                regime = "TREND"
                if self.useRegimeGate and self.sigMode == "Mean Reversion":
                    regime_ok = False
            else:
                regime = "RANGE"
                if self.useRegimeGate and self.sigMode == "Trend Pullback":
                    regime_ok = False
        
        # Forecast direction (simplified)
        trend_signal = 1 if emaF_val > emaS_val else -1
        is_bullish = trend_signal > 0
        is_bearish = trend_signal < 0
        
        # Gate checks
        conf_gate_long = is_bullish if self.useConfGate else True
        conf_gate_short = is_bearish if self.useConfGate else True
        regime_gate = regime_ok if self.useRegimeGate else True
        
        # Entry logic
        if base_long and conf_gate_long and regime_gate:
            score = 0.40 + (0.25 if is_bullish else 0.0) + 0.15 + (0.20 if regime_ok else 0.0)
            if score >= self.minScore:
                if not self.position:
                    self.buy()
        
        if base_short and conf_gate_short and regime_gate:
            score = 0.40 + (0.25 if is_bearish else 0.0) + 0.15 + (0.20 if regime_ok else 0.0)
            if score >= self.minScore:
                if self.position:
                    self.position.close()
        
        # Exit on opposite signal
        if self.position and base_short:
            self.position.close()
        elif not self.position and base_long:
            self.buy()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()