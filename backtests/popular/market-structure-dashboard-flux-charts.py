"""
OpenClaw Backtest Results: market-structure-dashboard-flux-charts
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "sma(atr(14),20)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "sma(atr(14),20)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "sma(atr(14),20)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” market-structure-dashboard-flux-charts
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # EMA and Swing parameters
    ema_length = 9
    swing_length = 5
    atr_length = 14
    atr_avg_length = 20

    def init(self):
        # Calculate indicators
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # EMA for trend
        self.ema = self.I(pta.ema, close, length=self.ema_length)
        
        # ATR for volatility
        self.atr = self.I(pta.atr, high, low, close, length=self.atr_length)
        self.atr_avg = self.I(pta.sma, self.atr, length=self.atr_avg_length)
        
        # Track swing highs and lows using pivot points
        self.pivot_high = self.I(lambda x: self._calculate_pivot_high(x), high)
        self.pivot_low = self.I(lambda x: self._calculate_pivot_low(x), low)
        
        # Volume for confirmation
        volume = pd.Series(self.data.Volume)
        self.avg_volume = self.I(pta.sma, volume, length=20)

    def _calculate_pivot_high(self, high_series):
        """Calculate pivot highs"""
        result = np.full_like(high_series, np.nan, dtype=float)
        for i in range(self.swing_length, len(high_series) - self.swing_length):
            if high_series[i] == np.max(high_series[i-self.swing_length:i+self.swing_length+1]):
                result[i] = high_series[i]
        return result

    def _calculate_pivot_low(self, low_series):
        """Calculate pivot lows"""
        result = np.full_like(low_series, np.nan, dtype=float)
        for i in range(self.swing_length, len(low_series) - self.swing_length):
            if low_series[i] == np.min(low_series[i-self.swing_length:i+self.swing_length+1]):
                result[i] = low_series[i]
        return result

    def next(self):
        # Get current values
        current_price = self.data.Close[-1]
        ema_value = self.ema[-1]
        atr_value = self.atr[-1]
        atr_avg_value = self.atr_avg[-1]
        
        # Determine trend direction
        trend_bullish = current_price > ema_value
        trend_bearish = current_price < ema_value
        
        # Volatility state
        volatility_high = atr_value > atr_avg_value * 1.3
        volatility_normal = (atr_value >= atr_avg_value * 0.7) and (atr_value <= atr_avg_value * 1.3)
        
        # Volume confirmation
        volume_confirmed = self.data.Volume[-1] > self.avg_volume[-1]
        
        # Buy signals:
        # 1. Price above EMA (bullish trend)
        # 2. Normal or high volatility
        # 3. Volume confirmation
        # 4. Price near or bouncing from swing low
        if (not self.position and 
            trend_bullish and 
            volume_confirmed and
            (volatility_normal or volatility_high)):
            
            # Additional confirmation: price crossing above EMA
            if len(self.ema) > 1 and self.data.Close[-2] <= self.ema[-2] and current_price > ema_value:
                self.buy()
        
        # Sell signals:
        # 1. Price below EMA (bearish trend)
        # 2. Volume confirmation
        # 3. Exit long positions
        if self.position:
            # Exit if price crosses below EMA
            if len(self.ema) > 1 and self.data.Close[-2] >= self.ema[-2] and current_price < ema_value:
                self.position.close()
            # Exit if price drops significantly below entry
            elif current_price < self.position.open_price * 0.98:
                self.position.close()
            # Exit on profit target
            elif current_price > self.position.open_price * 1.02:
                self.position.close()