"""
OpenClaw Backtest Results: decycler-momentum-regime-filter-charonquant
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(roc(1),23)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "ema(roc(1),23)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(roc(1),23)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” decycler-momentum-regime-filter-charonquant
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    highpassLength = 8
    firstLength = 23
    secondLength = 17
    signalLength = 10

    def init(self):
        close = pd.Series(self.data.Close)
        
        # Ehlers Highpass Filter (Decycler Core)
        PI = 2 * np.arcsin(1)
        alphaArg = 2 * PI / (self.highpassLength * np.sqrt(2))
        
        # Calculate alpha
        cos_alphaArg = np.cos(alphaArg)
        if cos_alphaArg != 0:
            alpha = (np.cos(alphaArg) + np.sin(alphaArg) - 1) / np.cos(alphaArg)
        else:
            alpha = 0.0
        
        # Calculate highpass filter
        hp_values = np.zeros(len(close))
        decycler_values = np.zeros(len(close))
        
        for i in range(len(close)):
            if i == 0:
                hp_values[i] = 0
            elif i == 1:
                hp_values[i] = np.power(1 - (alpha / 2), 2) * (close.iloc[i] - 2 * close.iloc[i-1])
            else:
                hp_values[i] = (np.power(1 - (alpha / 2), 2) * (close.iloc[i] - 2 * close.iloc[i-1] + close.iloc[i-2]) +
                               2 * (1 - alpha) * hp_values[i-1] -
                               np.power(1 - alpha, 2) * hp_values[i-2])
            
            decycler_values[i] = close.iloc[i] - hp_values[i]
        
        self.decycler = self.I(lambda x: pd.Series(decycler_values), close)
        
        # PMO Calculation
        roc1 = self.I(pta.roc, close, length=1)
        pmo_temp = self.I(pta.ema, 10 * roc1, length=self.firstLength)
        self.pmo = self.I(pta.ema, pmo_temp, length=self.secondLength)
        self.signal = self.I(pta.ema, self.pmo, length=self.signalLength)
        
        self.regime = 0

    def next(self):
        # Current and previous decycler values
        decycler_curr = self.decycler[-1]
        decycler_prev = self.decycler[-2] if len(self.decycler) > 1 else decycler_curr
        
        # Decycler signals
        decyclerUp = decycler_curr > decycler_prev
        decyclerDown = decycler_curr < decycler_prev
        
        # PMO signals
        pmo_curr = self.pmo[-1]
        signal_curr = self.signal[-1]
        
        pmoBull = (pmo_curr > signal_curr) and (pmo_curr > 0)
        pmoBear = (pmo_curr < signal_curr) and (pmo_curr < 0)
        
        # Combined signals
        longSignal = decyclerUp and pmoBull
        shortSignal = decyclerDown and pmoBear
        
        # Regime management
        if longSignal and not shortSignal:
            self.regime = 1
        if shortSignal:
            self.regime = -1
        
        # Trading logic
        if self.regime == 1 and not self.position:
            self.buy()
        elif self.regime == -1 and self.position:
            self.sell()