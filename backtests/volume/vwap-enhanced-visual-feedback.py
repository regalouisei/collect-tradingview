"""
DS-TV Backtest Results: vwap-enhanced-visual-feedback
============================================================

--- SPY ---
  ERROR: Indicator "calculate…" error. See traceback above.

--- BTC ---
  ERROR: Indicator "calculate…" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "calculate…" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — vwap-enhanced-visual-feedback
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Parameters from the Pine Script
    anchor_mode = "Session"  # Session, Week, Month, Year, YTD, Half Year
    band_mult = 2.0
    show_bands = True

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # Calculate standard deviation for bands
        self.stdev = self.I(pta.stdev, close, length=30)
        
        # Calculate VWAP manually
        def calculate_vwap():
            hlc3 = (high + low + close) / 3
            
            # Determine reset points based on anchor mode
            if self.anchor_mode == "Session":
                # Daily reset
                dates = pd.to_datetime(self.data.index)
                period_change = dates.diff().dt.day != 0
                period_change.iloc[0] = True
            elif self.anchor_mode == "Week":
                dates = pd.to_datetime(self.data.index)
                period_change = dates.dt.isocalendar().week.diff() != 0
                period_change.iloc[0] = True
            elif self.anchor_mode == "Month":
                dates = pd.to_datetime(self.data.index)
                period_change = dates.dt.month.diff() != 0
                period_change.iloc[0] = True
            elif self.anchor_mode == "Year":
                dates = pd.to_datetime(self.data.index)
                period_change = dates.dt.year.diff() != 0
                period_change.iloc[0] = True
            elif self.anchor_mode == "YTD":
                dates = pd.to_datetime(self.data.index)
                period_change = dates.dt.year.diff() != 0
                period_change.iloc[0] = True
            elif self.anchor_mode == "Half Year":
                dates = pd.to_datetime(self.data.index)
                half_year = (dates.dt.month > 6).astype(int)
                period_change = half_year.diff() != 0
                period_change.iloc[0] = True
            else:
                period_change = pd.Series([True] + [False] * (len(hlc3) - 1))
            
            # Calculate VWAP with period resets
            vwap = np.zeros(len(hlc3))
            sum_src_vol = 0.0
            sum_vol = 0.0
            
            for i in range(len(hlc3)):
                if period_change.iloc[i]:
                    sum_src_vol = hlc3.iloc[i] * volume.iloc[i]
                    sum_vol = volume.iloc[i]
                else:
                    sum_src_vol += hlc3.iloc[i] * volume.iloc[i]
                    sum_vol += volume.iloc[i]
                
                if sum_vol > 0:
                    vwap[i] = sum_src_vol / sum_vol
                else:
                    vwap[i] = hlc3.iloc[i]
            
            return pd.Series(vwap, index=hlc3.index)
        
        self.vwap = self.I(calculate_vwap)
        
        # Upper and lower bands
        def upper_band():
            if self.stdev[-1] is not None:
                return self.vwap[-1] + (self.stdev[-1] * self.band_mult)
            return self.vwap[-1]
        
        def lower_band():
            if self.stdev[-1] is not None:
                return self.vwap[-1] - (self.stdev[-1] * self.band_mult)
            return self.vwap[-1]
        
        self.upper_band = self.I(lambda: pd.Series([self.vwap[-1] + (self.stdev[-1] * self.band_mult) if self.stdev[-1] is not None else self.vwap[-1]] * len(self.data.Close)))
        self.lower_band = self.I(lambda: pd.Series([self.vwap[-1] - (self.stdev[-1] * self.band_mult) if self.stdev[-1] is not None else self.vwap[-1]] * len(self.data.Close)))

    def next(self):
        # Trading logic: Buy when price is below lower band and trending up
        # Sell when price is above upper band and trending down
        
        close = self.data.Close[-1]
        vwap = self.vwap[-1]
        
        # Check if we have valid band values
        if self.stdev[-1] is not None:
            upper = vwap + (self.stdev[-1] * self.band_mult)
            lower = vwap - (self.stdev[-1] * self.band_mult)
        else:
            upper = vwap
            lower = vwap
        
        # Buy signal: price touches or crosses below lower band
        if len(self.data) > 1:
            prev_close = self.data.Close[-2]
            
            # Buy when price crosses above VWAP from below and is above lower band
            if prev_close <= vwap and close > vwap and close > lower:
                if not self.position:
                    self.buy()
            
            # Sell when price crosses below VWAP from above or touches upper band
            elif prev_close >= vwap and close < vwap:
                if self.position:
                    self.position.close()
            elif close >= upper:
                if self.position:
                    self.position.close()