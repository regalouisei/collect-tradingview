"""
DS-TV Backtest Results: srd786-micro-futures-scalping-indicator
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (502,); indicator "atr(H,L,14)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (732,); indicator "atr(H,L,14)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (502,); indicator "atr(H,L,14)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” srd786-micro-futures-scalping-indicator
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    trendLength = 9
    trendSlowLength = 21
    trendSource = 'close'
    rsiLength = 7
    rsiOverbought = 70
    rsiOversold = 30
    rsiSource = 'close'
    useVolume = True
    volumeSmaLength = 20
    scalpRange = 5
    tickSize = 0.25
    consolidationBars = 3

    def init(self):
        close = pd.Series(self.data.Close)
        volume = pd.Series(self.data.Volume)
        self.fastEMA = self.I(pta.ema, close, length=self.trendLength)
        self.slowEMA = self.I(pta.ema, close, length=self.trendSlowLength)
        self.rsiValue = self.I(pta.rsi, close, length=self.rsiLength)
        self.volumeSma = self.I(pta.sma, volume, length=self.volumeSmaLength)
        self.atrValue = self.I(pta.atr, high=self.data.High, low=self.data.Low, close=close, length=14)
        self.supportLevel = self.I(lambda: self.data.Low - (self.atrValue * 0.5), length=1)
        self.resistanceLevel = self.I(lambda: self.data.High + (self.atrValue * 0.5), length=1)
        self.isUptrend = self.I(lambda: self.fastEMA > self.slowEMA, length=1)
        self.isDowntrend = self.I(lambda: self.fastEMA < self.slowEMA, length=1)
        self.rsiOversoldCross = self.I(pta.crossover, self.rsiValue, self.rsiOversold)
        self.rsiOverboughtCross = self.I(pta.crossunder, self.rsiValue, self.rsiOverbought)
        self.fastCrossunderSlow = self.I(pta.crossunder, self.fastEMA, self.slowEMA)
        self.fastCrossoverSlow = self.I(pta.crossover, self.fastEMA, self.slowEMA)
        self.longCondition = self.I(lambda: self.isUptrend and self.rsiOversoldCross and self.useVolume and (self.data.Close - self.data.Open) >= (self.tickSize * self.scalpRange), length=1)
        self.shortCondition = self.I(lambda: self.isDowntrend and self.rsiOverboughtCross and self.useVolume and (self.data.Open - self.data.Close) >= (self.tickSize * self.scalpRange), length=1)
        self.longExit = self.I(lambda: self.fastCrossunderSlow and self.inLongPosition, length=1)
        self.shortExit = self.I(lambda: self.fastCrossoverSlow and self.inShortPosition, length=1)
        self.barsSinceLongSignal = 0
        self.barsSinceShortSignal = 0
        self.consolidatedLongCondition = self.I(lambda: self.longCondition and self.barsSinceLongSignal >= self.consolidationBars, length=1)
        self.consolidatedShortCondition = self.I(lambda: self.shortCondition and self.barsSinceShortSignal >= self.consolidationBars, length=1)
        self.entryLongPrice = float('nan')
        self.entryShortPrice = float('nan')
        self.inLongPosition = False
        self.inShortPosition = False

    def next(self):
        if self.consolidatedLongCondition and not self.inLongPosition:
            self.entryLongPrice = self.data.Close[0]
            self.inLongPosition = True
            self.inShortPosition = False
            self.entryShortPrice = float('nan')
        elif self.consolidatedShortCondition and not self.inShortPosition:
            self.entryShortPrice = self.data.Close[0]
            self.inShortPosition = True
            self.inLongPosition = False
            self.entryLongPrice = float('nan')
        if self.longExit and self.inLongPosition:
            self.inLongPosition = False
            self.entryLongPrice = float('nan')
        if self.shortExit and self.inShortPosition:
            self.inShortPosition = False
            self.entryShortPrice = float('nan')
        if self.consolidatedLongCondition and self.inShortPosition:
            self.inShortPosition = False
            self.entryShortPrice = float('nan')
            self.entryLongPrice = self.data.Close[0]
            self.inLongPosition = True
        if self.consolidatedShortCondition and self.inLongPosition:
            self.inLongPosition = False
            self.entryLongPrice = float('nan')
            self.entryShortPrice = self.data.Close[0]
            self.inShortPosition = True
        if self.inLongPosition and not np.isnan(self.entryLongPrice):
            self.currentPnl = (self.data.Close[0] - self.entryLongPrice) / self.data.Syminfo.Mintick
        else:
            self.currentPnl = float('nan')
        if self.inShortPosition and not np.isnan(self.entryShortPrice):
            self.currentPnl = (self.entryShortPrice - self.data.Close[0]) / self.data.Syminfo.Mintick
        else:
            self.currentPnl = float('nan')
        self.pnlString = "N/A" if np.isnan(self.currentPnl) else ("+" if self.currentPnl > 0 else "") + str(self.currentPnl)
        self.pnlColor = "color.lime" if self.currentPnl > 0 else "color.red" if self.currentPnl < 0 else "color.gray"