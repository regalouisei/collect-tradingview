"""
DS-TV Backtest Results: volume-delta-bubble-absorption
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — volume-delta-bubble-absorption
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lookback_period = 60
    z_score_threshold = 2.0
    absorption_ratio = 0.6
    calc_mode = "Adaptive"
    min_volume_fixed = 200

    def init(self):
        close = pd.Series(self.data.Close)
        open_ = pd.Series(self.data.Open)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)

        # Calculate Volume Delta (using close vs open as approximation)
        self.volume_delta = self.I(
            lambda: pd.Series(
                np.where(close > open_, volume, np.where(close < open_, -volume, volume * 0.5)),
                index=close.index
            )
        )

        # Calculate absolute delta
        self.abs_delta = self.I(lambda: pd.Series(np.abs(self.volume_delta), index=close.index))

        # Calculate EMA of absolute delta
        self.delta_mean = self.I(lambda: pta.ema(self.abs_delta, length=self.lookback_period) or pd.Series(0, index=close.index))

        # Calculate standard deviation
        self.delta_std = self.I(lambda: self.abs_delta.rolling(window=self.lookback_period).std() or pd.Series(0, index=close.index))

        # Calculate Z-Score
        def calc_zscore():
            result = np.where(
                self.delta_std > 0,
                (self.abs_delta - self.delta_mean) / self.delta_std,
                0
            )
            return pd.Series(result, index=close.index)

        self.z_score = self.I(calc_zscore)

        # Candle body calculations
        self.candle_body = self.I(lambda: pd.Series(np.abs(close - open_), index=close.index))
        self.avg_body = self.I(lambda: pta.sma(self.candle_body, length=20) or pd.Series(0, index=close.index))

        # Unusual volume detection
        def is_unusual():
            if self.calc_mode == "Adaptive":
                return np.abs(self.z_score) >= self.z_score_threshold
            else:
                return self.abs_delta >= self.min_volume_fixed

        self.is_unusual = self.I(is_unusual)

        # Absorption detection conditions
        self.is_small_body = self.I(lambda: self.candle_body < self.avg_body * self.absorption_ratio)
        self.is_high_volume = self.I(lambda: self.abs_delta > self.delta_mean * 1.5)

        # Bullish and bearish signals
        def calc_signals():
            is_bullish = np.zeros(len(close), dtype=bool)
            is_bearish = np.zeros(len(close), dtype=bool)
            is_bullish_abs = np.zeros(len(close), dtype=bool)
            is_bearish_abs = np.zeros(len(close), dtype=bool)

            for i in range(len(close)):
                if not self.is_unusual[i]:
                    continue

                if self.is_small_body[i] and self.is_high_volume[i]:
                    if self.volume_delta[i] > 0 and close[i] < high[i - 1] if i > 0 else False:
                        is_bearish_abs[i] = True
                    elif self.volume_delta[i] < 0 and close[i] > low[i - 1] if i > 0 else False:
                        is_bullish_abs[i] = True
                    else:
                        if self.volume_delta[i] > 0:
                            is_bullish_abs[i] = True
                        elif self.volume_delta[i] < 0:
                            is_bearish_abs[i] = True
                else:
                    if self.volume_delta[i] > 0:
                        is_bullish[i] = True
                    elif self.volume_delta[i] < 0:
                        is_bearish[i] = True

            return pd.Series(is_bullish, index=close.index), pd.Series(is_bearish, index=close.index), \
                   pd.Series(is_bullish_abs, index=close.index), pd.Series(is_bearish_abs, index=close.index)

        bulls, bears, bull_abs, bear_abs = calc_signals()
        self.is_bullish = self.I(lambda: bulls)
        self.is_bearish = self.I(lambda: bears)
        self.is_bullish_abs = self.I(lambda: bull_abs)
        self.is_bearish_abs = self.I(lambda: bear_abs)

    def next(self):
        # Buy signals: bullish volume delta or bullish absorption
        if self.is_bullish[-1] or self.is_bullish_abs[-1]:
            if not self.position:
                self.buy()

        # Sell signals: bearish volume delta or bearish absorption
        elif self.is_bearish[-1] or self.is_bearish_abs[-1]:
            if self.position:
                self.position.close()
            else:
                self.sell()


if __name__ == "__main__":
    from backtesting.test import GOOG

    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=0.002)
    stats = bt.run()
    print(stats)
    bt.plot()