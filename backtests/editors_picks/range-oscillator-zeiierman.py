"""
OpenClaw Backtest Results: range-oscillator-zeiierman
============================================================

--- SPY ---
  ERROR: Indicator "_calc_osc…(_calc_wei…,atr(200))" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_calc_osc…(_calc_wei…,atr(200))" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_calc_osc…(_calc_wei…,atr(200))" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — range-oscillator-zeiierman
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    length = 50
    mult = 2.0
    levelsInp = 2
    heatThresh = 1

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate ATR
        self.atr = self.I(pta.atr, high, low, close, length=200)
        
        # Calculate range ATR
        self.rangeATR = self.atr * self.mult
        
        # Calculate weighted moving average
        self.ma = self.I(self._calc_weighted_ma, close)
        
        # Calculate oscillator
        self.osc = self.I(self._calc_oscillator, close, self.ma, self.rangeATR)

    def _calc_weighted_ma(self, close_series):
        result = np.full(len(close_series), np.nan)
        for idx in range(len(close_series)):
            if idx < self.length:
                continue
            
            sum_weighted_close = 0.0
            sum_weights = 0.0
            
            for i in range(self.length):
                pos = idx - i
                if pos < 0 or pos >= len(close_series):
                    continue
                
                if pos + 1 >= len(close_series):
                    continue
                
                delta = abs(close_series.iloc[pos] - close_series.iloc[pos + 1])
                w = delta / close_series.iloc[pos + 1] if close_series.iloc[pos + 1] != 0 else 0
                sum_weighted_close += close_series.iloc[pos] * w
                sum_weights += w
            
            if sum_weights != 0:
                result[idx] = sum_weighted_close / sum_weights
        
        return pd.Series(result, index=close_series.index)

    def _calc_oscillator(self, close_series, ma_series, rangeATR_series):
        result = np.full(len(close_series), np.nan)
        for idx in range(len(close_series)):
            if np.isnan(ma_series.iloc[idx]) or np.isnan(rangeATR_series.iloc[idx]):
                continue
            
            if rangeATR_series.iloc[idx] != 0:
                result[idx] = 100 * (close_series.iloc[idx] - ma_series.iloc[idx]) / rangeATR_series.iloc[idx]
        
        return pd.Series(result, index=close_series.index)

    def next(self):
        if len(self) < self.length + 1:
            return
        
        if np.isnan(self.osc[-1]) or np.isnan(self.ma[-1]):
            return
        
        close = self.data.Close[-1]
        ma = self.ma[-1]
        rangeATR = self.rangeATR[-1]
        osc = self.osc[-1]
        
        # Buy signals
        if len(self) > 1:
            prev_osc = self.osc[-2]
            
            # Buy when oscillator crosses above -100 (oversold to neutral/bullish)
            if not np.isnan(prev_osc) and prev_osc <= -100 and osc > -100:
                if not self.position:
                    self.buy()
            
            # Buy on breakup
            if close > ma + rangeATR and not self.position:
                self.buy()
        
        # Sell signals
        if len(self) > 1:
            prev_osc = self.osc[-2]
            
            # Sell when oscillator crosses below 100 (overbought to neutral/bearish)
            if not np.isnan(prev_osc) and prev_osc >= 100 and osc < 100:
                if self.position:
                    self.sell()
            
            # Sell on breakdown
            if close < ma - rangeATR and self.position:
                self.sell()