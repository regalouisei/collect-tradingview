"""
OpenClaw Backtest Results: holographic-market-microstructure-alphanatt
============================================================

--- SPY ---
  ERROR: module 'pandas_ta' has no attribute 'highest'

--- BTC ---
  ERROR: module 'pandas_ta' has no attribute 'highest'

--- QQQ ---
  ERROR: module 'pandas_ta' has no attribute 'highest'

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” holographic-market-microstructure-alphanatt
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    microDepth = 50
    liquidityThreshold = 1.5
    imbalanceRatio = 2.0
    smartMoneyLength = 20
    accumThreshold = 70
    fractalPeriod = 5
    structureDepth = 3
    heatmapBars = 100
    heatmapLevels = 10

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)

        # ATR for liquidity void detection
        self.atr = self.I(pta.atr, high, low, close, length=14)

        # Volume SMA for liquidity void
        self.sma_vol = self.I(pta.sma, volume, length=20)

        # Order Flow Imbalance
        self.buy_volume = volume * (close - low) / (high - low + 1e-10)
        self.sell_volume = volume * (high - close) / (high - low + 1e-10)
        self.ofi_raw = self.buy_volume - self.sell_volume
        
        # Cumulative OFI
        self.ofi_cum = self.I(lambda x: pd.Series(x).cumsum(), self.ofi_raw.values)
        self.ofi_ma = self.I(pta.sma, pd.Series(self.ofi_cum), length=self.smartMoneyLength)

        # OFI normalized
        ofi_diff = pd.Series(self.ofi_cum) - pd.Series(self.ofi_ma)
        self.ofi_stdev = self.I(pta.stdev, ofi_diff, length=self.smartMoneyLength)
        self.ofi_normalized = (pd.Series(self.ofi_cum) - pd.Series(self.ofi_ma)) / (self.ofi_stdev + 1e-10)

        # Price ROC and Volume ROC for smart money detection
        self.price_roc = self.I(pta.roc, close, length=self.smartMoneyLength)
        self.volume_roc = self.I(pta.roc, volume, length=self.smartMoneyLength)

        # Linear regression for divergence
        self.price_linreg = self.I(pta.linreg, close, length=self.smartMoneyLength)
        self.volume_linreg = self.I(pta.linreg, volume, length=self.smartMoneyLength)

        # Highest and lowest for fractal detection
        self.highest = self.I(pta.highest, high, length=self.fractalPeriod * 2 + 1)
        self.lowest = self.I(pta.lowest, low, length=self.fractalPeriod * 2 + 1)

        self.position_open = False

    def next(self):
        if len(self) < max(self.smartMoneyLength, self.heatmapBars, self.fractalPeriod * 2 + 1) + 5:
            return

        # Detect liquidity void
        high_low_range = self.data.High[-1] - self.data.Low[-1]
        avg_range = self.atr[-1] if self.atr[-1] else 0
        void_threshold = avg_range * self.liquidityThreshold
        is_liquidity_void = (high_low_range > void_threshold and 
                             self.data.Volume[-1] < self.sma_vol[-1] * 0.7)

        # Smart money index
        price_roc_val = self.price_roc[-1] if self.price_roc[-1] else 0
        volume_roc_val = self.volume_roc[-1] if self.volume_roc[-1] else 0
        smart_money_index = 0
        if price_roc_val > 0 and volume_roc_val > self.accumThreshold:
            smart_money_index = 1
        elif price_roc_val < 0 and volume_roc_val > self.accumThreshold:
            smart_money_index = -1

        # Price/Volume divergence
        price_trend = self.price_linreg[-1] if self.price_linreg[-1] else 0
        volume_trend = self.volume_linreg[-1] if self.volume_linreg[-1] else 0
        is_divergence = ((price_trend > 0 and volume_trend < 0) or 
                         (price_trend < 0 and volume_trend > 0))

        # OFI signal
        ofi_norm = self.ofi_normalized[-1] if self.ofi_normalized[-1] else 0

        # Entry logic based on smart money and order flow
        entry_signal = False
        exit_signal = False

        # Buy signals: smart money accumulation + positive OFI or divergence bottom
        if smart_money_index == 1 and ofi_norm > 0.5 and not is_liquidity_void:
            entry_signal = True
        elif price_trend < 0 and volume_trend > 0 and ofi_norm > 1.0:
            entry_signal = True

        # Sell signals: smart money distribution or divergence top
        if smart_money_index == -1 and ofi_norm < -0.5:
            exit_signal = True
        elif price_trend > 0 and volume_trend < 0 and ofi_norm < -1.0:
            exit_signal = True

        # Liquidity void can trigger protective exit
        if is_liquidity_void and self.position:
            exit_signal = True

        # Execute trades
        if entry_signal and not self.position:
            self.buy()
            self.position_open = True
        elif exit_signal and self.position:
            self.sell()
            self.position_open = False


if __name__ == "__main__":
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, commission=.002, exclusive_orders=True)
    results = bt.run()
    print(results)