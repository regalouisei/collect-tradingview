"""
OpenClaw Backtest Results: per-bak-self-organized-criticality
============================================================

--- SPY ---
  ERROR: Indicator "λ(atr(14))" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ(atr(14))" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ(atr(14))" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — per-bak-self-organized-criticality
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lookback = 252
    skew_weight = 0.34
    vix_weight = 0.26
    credit_weight = 0.18
    pc_weight = 0.22
    alert_building = 40
    alert_elevated = 55
    alert_critical = 70

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate slope index using simplified components
        # For backtesting without external data sources, we'll use price-based proxies
        
        # Component 1: Tail Risk Proxy (using price volatility percentile)
        price_volatility = self.I(pta.atr, high, low, close, length=14)
        volatility_percentile = self.I(lambda x: pd.Series(x).rolling(self.lookback).apply(lambda y: (y[-1] - y.min()) / (y.max() - y.min() + 1e-10) * 100 if y.max() > y.min() else 50), price_volatility)
        self.skew_component = volatility_percentile * 0.7 + np.minimum(100, np.maximum(0, volatility_percentile)) * 0.3
        
        # Component 2: Volatility Regime (using price momentum and rate of change)
        roc = self.I(pta.roc, close, length=20)
        roc_abs = np.abs(roc) if isinstance(roc, (int, float)) else roc.abs()
        vix_proxy = self.I(lambda x: pd.Series(x).rolling(10).std() * 100, close)
        self.vix_component = np.minimum(100, np.maximum(0, vix_proxy)) * 0.4 + np.minimum(100, np.maximum(0, roc_abs * 2)) * 0.6
        
        # Component 3: Credit Stress Proxy (using downside volatility)
        returns = self.I(pta.roc, close, length=1)
        downside_vol = self.I(lambda x: pd.Series(np.minimum(x, 0)).rolling(20).std() * 100, returns)
        self.credit_component = np.minimum(100, np.maximum(0, downside_vol * 5))
        
        # Component 4: Positioning Proxy (using price extremes)
        highest = self.I(lambda x: pd.Series(x).rolling(self.lookback).max(), close)
        lowest = self.I(lambda x: pd.Series(x).rolling(self.lookback).min(), close)
        price_position = self.I(lambda x, h, l: (x - l) / (h - l + 1e-10) * 100 if isinstance(x, (int, float)) else ((x - l) / (h - l + 1e-10) * 100).clip(0, 100), close, highest, lowest)
        self.pc_component = np.minimum(100, np.maximum(0, price_position))
        
        # Composite Slope Index
        self.slope_index = self.I(
            lambda s, v, c, p: (s * self.skew_weight + v * self.vix_weight + c * self.credit_weight + p * self.pc_weight),
            self.skew_component,
            self.vix_component,
            self.credit_component,
            self.pc_component
        )
        
        # Smoothed index
        self.slope_smoothed = self.I(pta.ema, self.slope_index, length=2)
        
        # Rate of change
        self.slope_roc = self.I(pta.roc, self.slope_smoothed, length=10)

    def next(self):
        current_slope = self.slope_smoothed[-1]
        
        # Buy signal: crossing below alert_elevated (from higher level)
        if len(self.slope_smoothed) > 1:
            if crossover(self.slope_smoothed, self.alert_elevated):
                if not self.position:
                    self.buy()
        
        # Sell signal: crossing above alert_critical
        if len(self.slope_smoothed) > 1:
            if crossover(self.alert_critical, self.slope_smoothed):
                if self.position:
                    self.position.close()
        
        # Additional sell: if slope is accelerating upward from elevated levels
        if len(self.slope_roc) > 0 and current_slope > self.alert_elevated:
            if self.slope_roc[-1] > 5:
                if self.position:
                    self.position.close()
        
        # Stop loss: if entering critical zone
        if current_slope > self.alert_critical:
            if self.position:
                self.position.close()


if __name__ == "__main__":
    bt = Backtest(
        data := __import__('yfinance').download('SPY', start='2020-01-01', end='2024-01-01', progress=False),
        TvStrategy,
        cash=10000,
        commission=0.002
    )
    stats = bt.run()
    print(stats)