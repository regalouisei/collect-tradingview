"""
OpenClaw Backtest Results: volume-gaps-imbalances-zeiierman
============================================================

--- SPY ---
  ERROR: object of type 'TvStrategy' has no len()

--- BTC ---
  ERROR: object of type 'TvStrategy' has no len()

--- QQQ ---
  ERROR: object of type 'TvStrategy' has no len()

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” volume-gaps-imbalances-zeiierman
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    prd = 200
    rows = 50
    sum_sections = 20
    delta_threshold = 10.0

    def init(self):
        self.highest = self.I(lambda x: pd.Series(x).rolling(self.prd).max(), self.data.High)
        self.lowest = self.I(lambda x: pd.Series(x).rolling(self.prd).min(), self.data.Low)

    def next(self):
        if len(self) < self.prd:
            return

        hi = self.highest[-1]
        lo = self.lowest[-1]

        if hi == lo:
            return

        step = (hi - lo) / self.rows
        lvls = np.arange(lo, hi + step, step)

        bull_vols = np.zeros(len(lvls) - 1)
        bear_vols = np.zeros(len(lvls) - 1)

        lookback_start = max(0, len(self) - self.prd)
        for i in range(len(self) - 1, lookback_start - 1, -1):
            price = self.data.Close[i]
            is_bull = self.data.Close[i] > self.data.Open[i]
            vol = self.data.Volume[i]

            for j in range(len(lvls) - 1):
                level_low = lvls[j]
                level_high = lvls[j + 1]
                if level_low < price <= level_high:
                    if is_bull:
                        bull_vols[j] += vol
                    else:
                        bear_vols[j] += vol
                    break

        total_vols = bull_vols + bear_vols
        max_vol = np.max(total_vols) if len(total_vols) > 0 else 1.0
        if max_vol == 0:
            max_vol = 1.0

        row_count = len(lvls) - 1
        sec_rows = max(1, int(np.floor(row_count / self.sum_sections)))

        total_delta = 0.0
        section_count = 0

        for s in range(self.sum_sections):
            start_idx = s * sec_rows
            end_idx = row_count - 1 if s == self.sum_sections - 1 else min(row_count - 1, (s + 1) * sec_rows - 1)

            if start_idx > end_idx:
                continue

            seg_bull = np.sum(bull_vols[start_idx:end_idx + 1])
            seg_bear = np.sum(bear_vols[start_idx:end_idx + 1])
            seg_tot = seg_bull + seg_bear

            if seg_tot <= 0:
                continue

            delta_pct = (seg_bull - seg_bear) / seg_tot * 100.0
            total_delta += delta_pct
            section_count += 1

        if section_count > 0:
            avg_delta = total_delta / section_count
        else:
            avg_delta = 0.0

        current_price = self.data.Close[-1]
        price_in_upper_half = current_price > (hi + lo) / 2

        if not self.position:
            if avg_delta > self.delta_threshold and price_in_upper_half:
                self.buy()
            elif avg_delta < -self.delta_threshold and not price_in_upper_half:
                self.buy()
        else:
            if self.position.is_long:
                if avg_delta < -self.delta_threshold:
                    self.position.close()
            else:
                if avg_delta > self.delta_threshold:
                    self.position.close()


if __name__ == "__main__":
    from backtesting.test import SMA, GOOG

    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()