"""
OpenClaw Backtest Results: trend-line-methods-tlm
============================================================

--- SPY ---
  Return                    -24.33%
  Buy & Hold Return         41.94%
  Max Drawdown              -29.81%
  Sharpe Ratio              -1.09
  Sortino Ratio             -1.33
  Calmar Ratio              -0.44
  Profit Factor             0.28
  Expectancy                -0.82%
  SQN                       -2.30
  # Trades                  32
  Win Rate                  12.50%
  Best Trade                6.66%
  Worst Trade               -6.29%
  Avg Trade                 -0.83%
  Exposure Time             63.60%
  Equity Final              75671.02$
  Equity Peak               107562.56$
  Avg Drawdown              -7.67%
  Max Drawdown Duration     307 days 00:00:00
  Max Trade Duration        102 days 00:00:00
  Avg Trade Duration        15 days 00:00:00
  Ann. Return               -13.11%
  Ann. Volatility           11.99%

--- BTC ---
  Return                    -26.67%
  Buy & Hold Return         46.22%
  Max Drawdown              -41.23%
  Sharpe Ratio              -0.74
  Sortino Ratio             -0.82
  Calmar Ratio              -0.35
  Profit Factor             0.30
  Expectancy                -2.48%
  SQN                       -1.86
  # Trades                  13
  Win Rate                  38.46%
  Best Trade                5.65%
  Worst Trade               -10.44%
  Avg Trade                 -2.59%
  Exposure Time             30.64%
  Equity Final              73327.46$
  Equity Peak               112608.95$
  Avg Drawdown              -11.62%
  Max Drawdown Duration     554 days 00:00:00
  Max Trade Duration        43 days 00:00:00
  Avg Trade Duration        18 days 00:00:00
  Ann. Return               -14.35%
  Ann. Volatility           19.44%

--- QQQ ---
  Return                    -30.04%
  Buy & Hold Return         42.67%
  Max Drawdown              -35.79%
  Sharpe Ratio              -1.10
  Sortino Ratio             -1.31
  Calmar Ratio              -0.46
  Profit Factor             0.33
  Expectancy                -1.19%
  SQN                       -2.08
  # Trades                  31
  Win Rate                  19.35%
  Best Trade                8.82%
  Worst Trade               -7.49%
  Avg Trade                 -1.24%
  Exposure Time             89.80%
  Equity Final              69958.09$
  Equity Peak               105931.32$
  Avg Drawdown              -8.06%
  Max Drawdown Duration     551 days 00:00:00
  Max Trade Duration        136 days 00:00:00
  Avg Trade Duration        22 days 00:00:00
  Ann. Return               -16.48%
  Ann. Volatility           15.05%

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” trend-line-methods-tlm
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    pivot_left = 5
    pivot_right = 5
    point_count = 5
    length_lookback = 150
    len_channel_5pt = 100

    def init(self):
        self.high_idx_points = []
        self.high_val_points = []
        self.low_idx_points = []
        self.low_val_points = []
        
        self.high_trend_line_slope = None
        self.high_trend_line_intercept = None
        self.low_trend_line_slope = None
        self.low_trend_line_intercept = None
        
        self.five_pt_high_slope = None
        self.five_pt_high_intercept = None
        self.five_pt_low_slope = None
        self.five_pt_low_intercept = None
        
        self.buy_signal = False
        self.sell_signal = False

    def detect_pivot_high(self, idx):
        if idx < self.pivot_left + self.pivot_right:
            return None
        
        current_high = self.data.High[idx]
        for i in range(1, self.pivot_left + 1):
            if self.data.High[idx - i] >= current_high:
                return None
        
        for i in range(1, self.pivot_right + 1):
            if self.data.High[idx + i] >= current_high:
                return None
        
        return current_high

    def detect_pivot_low(self, idx):
        if idx < self.pivot_left + self.pivot_right:
            return None
        
        current_low = self.data.Low[idx]
        for i in range(1, self.pivot_left + 1):
            if self.data.Low[idx - i] <= current_low:
                return None
        
        for i in range(1, self.pivot_right + 1):
            if self.data.Low[idx + i] <= current_low:
                return None
        
        return current_low

    def update_pivot_span_trendline(self, current_idx):
        check_idx = current_idx - self.pivot_right
        
        if check_idx >= 0:
            pivot_high = self.detect_pivot_high(check_idx)
            if pivot_high is not None:
                piv_hi_idx = check_idx
                piv_hi_price = self.data.High[check_idx]
                self.high_idx_points.append(piv_hi_idx)
                self.high_val_points.append(piv_hi_price)
                
                while len(self.high_idx_points) > self.point_count:
                    self.high_idx_points.pop(0)
                    self.high_val_points.pop(0)
            
            pivot_low = self.detect_pivot_low(check_idx)
            if pivot_low is not None:
                piv_lo_idx = check_idx
                piv_lo_price = self.data.Low[check_idx]
                self.low_idx_points.append(piv_lo_idx)
                self.low_val_points.append(piv_lo_price)
                
                while len(self.low_idx_points) > self.point_count:
                    self.low_idx_points.pop(0)
                    self.low_val_points.pop(0)
        
        if len(self.high_idx_points) >= 2:
            far_hi_idx = self.high_idx_points[0]
            far_hi_val = self.high_val_points[0]
            near_hi_idx = self.high_idx_points[-1]
            near_hi_val = self.high_val_points[-1]
            
            hi_bar_diff = near_hi_idx - far_hi_idx
            if hi_bar_diff != 0:
                self.high_trend_line_slope = (near_hi_val - far_hi_val) / hi_bar_diff
            else:
                self.high_trend_line_slope = 0.0
            
            self.high_trend_line_intercept = far_hi_val - self.high_trend_line_slope * far_hi_idx
        else:
            self.high_trend_line_slope = None
            self.high_trend_line_intercept = None
        
        if len(self.low_idx_points) >= 2:
            far_lo_idx = self.low_idx_points[0]
            far_lo_val = self.low_val_points[0]
            near_lo_idx = self.low_idx_points[-1]
            near_lo_val = self.low_val_points[-1]
            
            lo_bar_diff = near_lo_idx - far_lo_idx
            if lo_bar_diff != 0:
                self.low_trend_line_slope = (near_lo_val - far_lo_val) / lo_bar_diff
            else:
                self.low_trend_line_slope = 0.0
            
            self.low_trend_line_intercept = far_lo_val - self.low_trend_line_slope * far_lo_idx
        else:
            self.low_trend_line_slope = None
            self.low_trend_line_intercept = None

    def calc_five_point_channel(self, current_idx):
        if current_idx < self.len_channel_5pt:
            return
        
        sum_x_hi = 0.0
        sum_y_hi = 0.0
        sum_xy_hi = 0.0
        sum_x2_hi = 0.0
        n_hi = 0
        
        sum_x_lo = 0.0
        sum_y_lo = 0.0
        sum_xy_lo = 0.0
        sum_x2_lo = 0.0
        n_lo = 0
        
        seg_len_base = max(1, int(self.len_channel_5pt / 5))
        
        for k in range(5):
            seg_start = k * seg_len_base
            remaining = self.len_channel_5pt - seg_start
            
            if remaining <= 0:
                break
            
            seg_len_k = seg_len_base if k < 4 else remaining
            
            max_hi = -np.inf
            barsAgo_hi = None
            for i in range(seg_len_k):
                sh = seg_start + i
                if current_idx - sh >= 0:
                    v = self.data.High[current_idx - sh]
                    if v > max_hi:
                        max_hi = v
                        barsAgo_hi = sh
            
            if barsAgo_hi is not None:
                x_hi = current_idx - barsAgo_hi
                y_hi = self.data.High[current_idx - barsAgo_hi]
                sum_x_hi += x_hi
                sum_y_hi += y_hi
                sum_xy_hi += x_hi * y_hi
                sum_x2_hi += x_hi * x_hi
                n_hi += 1
            
            min_lo = np.inf
            barsAgo_lo = None
            for i in range(seg_len_k):
                sl = seg_start + i
                if current_idx - sl >= 0:
                    v2 = self.data.Low[current_idx - sl]
                    if v2 < min_lo:
                        min_lo = v2
                        barsAgo_lo = sl
            
            if barsAgo_lo is not None:
                x_lo = current_idx - barsAgo_lo
                y_lo = self.data.Low[current_idx - barsAgo_lo]
                sum_x_lo += x_lo
                sum_y_lo += y_lo
                sum_xy_lo += x_lo * y_lo
                sum_x2_lo += x_lo * x_lo
                n_lo += 1
        
        if n_hi >= 2:
            nf_hi = float(n_hi)
            denom_hi = nf_hi * sum_x2_hi - sum_x_hi * sum_x_hi
            if denom_hi != 0.0:
                self.five_pt_high_slope = (nf_hi * sum_xy_hi - sum_x_hi * sum_y_hi) / denom_hi
                self.five_pt_high_intercept = (sum_y_hi - self.five_pt_high_slope * sum_x_hi) / nf_hi
            else:
                self.five_pt_high_slope = 0.0
                self.five_pt_high_intercept = sum_y_hi / nf_hi
        else:
            self.five_pt_high_slope = None
            self.five_pt_high_intercept = None
        
        if n_lo >= 2:
            nf_lo = float(n_lo)
            denom_lo = nf_lo * sum_x2_lo - sum_x_lo * sum_x_lo
            if denom_lo != 0.0:
                self.five_pt_low_slope = (nf_lo * sum_xy_lo - sum_x_lo * sum_y_lo) / denom_lo
                self.five_pt_low_intercept = (sum_y_lo - self.five_pt_low_slope * sum_x_lo) / nf_lo
            else:
                self.five_pt_low_slope = 0.0
                self.five_pt_low_intercept = sum_y_lo / nf_lo
        else:
            self.five_pt_low_slope = None
            self.five_pt_low_intercept = None

    def next(self):
        current_idx = len(self.data) - 1
        
        self.update_pivot_span_trendline(current_idx)
        self.calc_five_point_channel(current_idx)
        
        self.buy_signal = False
        self.sell_signal = False
        
        if (self.high_trend_line_slope is not None and 
            self.high_trend_line_intercept is not None and
            self.low_trend_line_slope is not None and
            self.low_trend_line_intercept is not None):
            
            x_current = current_idx
            high_line_value = self.high_trend_line_slope * x_current + self.high_trend_line_intercept
            low_line_value = self.low_trend_line_slope * x_current + self.low_trend_line_intercept
            
            current_close = self.data.Close[-1]
            
            if current_close < low_line_value and len(self.data) > 1:
                prev_close = self.data.Close[-2]
                if prev_close >= low_line_value:
                    self.buy_signal = True
            
            if current_close > high_line_value and len(self.data) > 1:
                prev_close = self.data.Close[-2]
                if prev_close <= high_line_value:
                    self.sell_signal = True
        
        if (self.five_pt_high_slope is not None and 
            self.five_pt_high_intercept is not None and
            self.five_pt_low_slope is not None and
            self.five_pt_low_intercept is not None):
            
            x_current = current_idx
            five_high_value = self.five_pt_high_slope * x_current + self.five_pt_high_intercept
            five_low_value = self.five_pt_low_slope * x_current + self.five_pt_low_intercept
            
            current_close = self.data.Close[-1]
            
            if current_close < five_low_value and len(self.data) > 1:
                prev_close = self.data.Close[-2]
                if prev_close >= five_low_value:
                    self.buy_signal = True
            
            if current_close > five_high_value and len(self.data) > 1:
                prev_close = self.data.Close[-2]
                if prev_close <= five_high_value:
                    self.sell_signal = True
        
        if self.buy_signal:
            if not self.position:
                self.buy()
        elif self.sell_signal:
            if self.position:
                self.sell()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()