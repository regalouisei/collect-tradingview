"""
OpenClaw Backtest Results: asset-drift-model
============================================================

--- SPY ---
  Return                    0.00%
  Buy & Hold Return         41.94%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- BTC ---
  Return                    0.00%
  Buy & Hold Return         46.22%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- QQQ ---
  Return                    0.00%
  Buy & Hold Return         42.67%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” asset-drift-model
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    HORIZON = 60
    SAMPLE_TOTAL = 756
    MIN_OBS_STRICT = 10
    MIN_OBS_ROBUST = 20
    T_CRIT_95 = 2.00
    T_CRIT_90 = 1.65
    MIN_DRIFT_ECON = 0.03
    MAX_DEV_SD = 1.5
    SIGN_Z_CRIT = 1.65
    ANN_FACTOR = 252.0 / HORIZON

    def init(self):
        self.classification = None
        self.prev_classification = None
        self.strong_evidence = False
        self.weak_evidence = False

    def f_median(self, arr):
        if len(arr) == 0:
            return 0.0
        sorted_arr = sorted(arr)
        n = len(sorted_arr)
        m = n // 2
        if n % 2 == 0:
            return (sorted_arr[m - 1] + sorted_arr[m]) / 2
        else:
            return sorted_arr[m]

    def f_collectAllReturns(self, src, horizon, maxBars):
        arr = []
        nPeriods = int(maxBars / horizon)
        for i in range(nPeriods):
            recentBar = i * horizon
            pastBar = (i + 1) * horizon
            if pastBar <= maxBars:
                if recentBar < len(src) and pastBar < len(src):
                    pRecent = src[recentBar]
                    pPast = src[pastBar]
                    if pPast > 0 and pRecent > 0:
                        arr.append(np.log(pRecent / pPast))
        return arr

    def f_arrayStats(self, arr):
        n = len(arr)
        if n < 3:
            return [0.0, 0.0, 0.0, 0, 0]
        
        mean = np.mean(arr)
        med = self.f_median(arr)
        sumSq = sum((v - mean) ** 2 for v in arr)
        sd = np.sqrt(sumSq / (n - 1))
        posCount = sum(1 for v in arr if v > 0)
        
        return [mean, med, sd, n, posCount]

    def f_hacSE(self, arr, mean):
        n = len(arr)
        if n < 3:
            return 0.0
        
        g0 = sum((arr[i] - mean) ** 2 for i in range(n)) / n
        g1 = sum((arr[i] - mean) * (arr[i - 1] - mean) for i in range(1, n)) / n
        hV = g0 + g1
        return np.sqrt(max(hV / n, 1e-14))

    def f_splitArray(self, arr, isFirstHalf):
        n = len(arr)
        if n < 2:
            return []
        
        halfN = n // 2
        if isFirstHalf:
            return arr[:halfN]
        else:
            return arr[halfN:]

    def f_vrTest(self, src, horizon, k, sampleBars):
        arr1 = self.f_collectAllReturns(src, horizon, sampleBars)
        arrK = self.f_collectAllReturns(src, horizon * k, sampleBars)
        
        [m1, md1, sd1, n1, pc1] = self.f_arrayStats(arr1)
        [mK, mdK, sdK, nK, pcK] = self.f_arrayStats(arrK)
        
        if sd1 < 1e-10 or n1 < self.MIN_OBS_STRICT or nK < 3:
            return [1.0, 0.0, False]
        
        var1 = sd1 * sd1
        varK = sdK * sdK
        vr = varK / (k * var1)
        vrSE = np.sqrt(2.0 * (2 * k - 1) * (k - 1) / (3.0 * k * nK))
        zVR = abs(vr - 1.0) / vrSE if vrSE > 1e-10 else 0.0
        vrSig = zVR > self.T_CRIT_90
        
        return [vr, zVR, vrSig]

    def f_mde(self, sd, n, tCrit):
        if n < self.MIN_OBS_STRICT or sd <= 0:
            return None
        return (sd / np.sqrt(n)) * tCrit * self.ANN_FACTOR

    def f_signTestZ(self, posCount, n):
        if n < self.MIN_OBS_STRICT:
            return 0.0
        return (float(posCount) - float(n) / 2) / np.sqrt(float(n) / 4)

    def next(self):
        if len(self.data) < self.SAMPLE_TOTAL:
            return
        
        close = np.array(self.data.Close)
        
        allReturns = self.f_collectAllReturns(close[::-1], self.HORIZON, self.SAMPLE_TOTAL)
        if len(allReturns) == 0:
            return
        
        [mF, mdF, sdF, nF, pcF] = self.f_arrayStats(allReturns)
        seF = self.f_hacSE(allReturns, mF)
        tF = mF / seF if seF > 1e-10 else 0.0
        
        arr1 = self.f_splitArray(allReturns, True)
        arr2 = self.f_splitArray(allReturns, False)
        
        [m1, md1, sd1, n1, pc1] = self.f_arrayStats(arr1)
        se1 = self.f_hacSE(arr1, m1)
        t1 = m1 / se1 if se1 > 1e-10 else 0.0
        
        [m2, md2, sd2, n2, pc2] = self.f_arrayStats(arr2)
        se2 = self.f_hacSE(arr2, m2)
        t2 = m2 / se2 if se2 > 1e-10 else 0.0
        
        [vr, zVR, vrSig] = self.f_vrTest(close[::-1], self.HORIZON, 5, self.SAMPLE_TOTAL)
        mde95 = self.f_mde(sdF, nF, self.T_CRIT_95)
        annDrift = mF * self.ANN_FACTOR
        zSign = self.f_signTestZ(pcF, nF)
        
        inferenceAllowed = (nF >= self.MIN_OBS_STRICT and 
                           n1 >= int(self.MIN_OBS_STRICT / 2) and 
                           n2 >= int(self.MIN_OBS_STRICT / 2))
        isRobust = nF >= self.MIN_OBS_ROBUST
        
        statSig = inferenceAllowed and abs(tF) > self.T_CRIT_95
        econSig = inferenceAllowed and abs(annDrift) >= self.MIN_DRIFT_ECON
        powerOK = inferenceAllowed and (mde95 is not None and abs(annDrift) >= mde95)
        medianSig = inferenceAllowed and abs(zSign) > self.SIGN_Z_CRIT
        medianDir = 1 if zSign > 0 else (-1 if zSign < 0 else 0)
        meanDir = 1 if mF > 0 else (-1 if mF < 0 else 0)
        signTestOK = inferenceAllowed and (not medianSig or medianDir == meanDir)
        meanMedOK = inferenceAllowed and ((mF > 0 and mdF > 0) or (mF < 0 and mdF < 0) or abs(mF) < 1e-10)
        
        sameSignMean = (m1 > 0 and m2 > 0) or (m1 < 0 and m2 < 0)
        pooledSD = np.sqrt((sd1 * sd1 + sd2 * sd2) / 2)
        levelDevSD = abs(m1 - m2) / pooledSD if pooledSD > 1e-10 else 0.0
        levelOK = levelDevSD <= self.MAX_DEV_SD
        sameSignT = (t1 > 0 and t2 > 0 and tF > 0) or (t1 < 0 and t2 < 0 and tF < 0)
        structOK = inferenceAllowed and sameSignMean and levelOK and sameSignT
        
        isMeanRev = vr < 1.0 and vrSig
        vrOK = inferenceAllowed and not isMeanRev
        
        direction = 1 if mF > 0 else (-1 if mF < 0 else 0)
        
        if not inferenceAllowed:
            classCode = 0
        elif not powerOK:
            classCode = 0
        elif not statSig:
            classCode = 0
        elif not signTestOK:
            classCode = 0
        elif not meanMedOK:
            classCode = 0
        elif not structOK:
            classCode = 0
        elif not vrOK:
            classCode = 0
        elif not econSig:
            classCode = 1
        else:
            classCode = 2
        
        self.prev_classification = self.classification
        self.strong_evidence = classCode == 2
        self.weak_evidence = classCode == 1
        self.classification = classCode * direction if classCode > 0 else 0
        
        if self.strong_evidence and self.classification > 0:
            if not self.position:
                self.buy()
        elif self.strong_evidence and self.classification < 0:
            if self.position:
                self.position.close()
        elif self.weak_evidence and self.classification > 0:
            if not self.position:
                self.buy()
        elif self.weak_evidence and self.classification < 0:
            if self.position:
                self.position.close()
        elif self.classification == 0:
            if self.position:
                self.position.close()


if __name__ == "__main__":
    bt = Backtest(
        pd.read_csv("data.csv", index_col=0, parse_dates=True),
        TvStrategy,
        cash=10000,
        commission=.002
    )
    stats = bt.run()
    print(stats)
    bt.plot()