"""
OpenClaw Backtest Results: volatility-risk-premium
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(_calc_rv_…,5)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "ema(_calc_rv_…,5)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(_calc_rv_…,5)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — volatility-risk-premium
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Core Settings
    rv_length = 20
    rv_method = "Close-to-Close"
    vrp_smoothing = 5
    vrp_lookback = 252
    
    # Regime Thresholds
    threshold_high = 5.0
    threshold_extreme = 10.0
    threshold_low = -2.0
    
    # Term Structure
    rv_short = 10
    rv_long = 60
    
    # Mean Reversion
    mr_zscore_threshold = 2.0
    bb_mult = 2.0
    vrp_momentum_length = 5

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate log returns
        self.log_ret = np.log(close / close.shift(1))
        
        # Realized Volatility - Close-to-Close method
        self.realized_vol = self.I(self._calc_rv_ctc, self.log_ret, self.rv_length)
        
        # VIX approximation using realized volatility with adjustment
        self.vix_approx = self.realized_vol * 1.2
        
        # VRP Raw (VIX - RV)
        self.vrp_raw = self.vix_approx - self.realized_vol
        
        # VRP Smoothed (EMA)
        self.vrp = self.I(pta.ema, self.vrp_raw, length=self.vrp_smoothing)
        
        # Statistics
        self.vrp_mean = self.I(pta.sma, self.vrp, length=self.vrp_lookback)
        self.vrp_stdev = self.I(pta.stdev, self.vrp, length=self.vrp_lookback)
        
        # Z-Score
        self.vrp_zscore = (self.vrp - self.vrp_mean) / np.maximum(self.vrp_stdev, 0.001)
        
        # Term Structure
        self.rv_short_val = self.I(self._calc_rv_ctc, self.log_ret, self.rv_short)
        self.rv_long_val = self.I(self._calc_rv_ctc, self.log_ret, self.rv_long)
        self.rv_slope = self.rv_long_val - self.rv_short_val
        
        # Bollinger Bands
        self.vrp_upper = self.vrp_mean + self.bb_mult * self.vrp_stdev
        self.vrp_lower = self.vrp_mean - self.bb_mult * self.vrp_stdev
        
        # Momentum
        self.vrp_roc = self.I(self._calc_roc, self.vrp, self.vrp_momentum_length)

    def _calc_rv_ctc(self, log_ret, length):
        """Calculate Close-to-Close realized volatility"""
        result = pd.Series(index=log_ret.index, dtype=float)
        for i in range(len(log_ret)):
            if i < length:
                result.iloc[i] = np.nan
            else:
                stdev = log_ret.iloc[i-length:i].std()
                result.iloc[i] = stdev * np.sqrt(252) * 100
        return result

    def _calc_roc(self, series, length):
        """Calculate Rate of Change"""
        result = pd.Series(index=series.index, dtype=float)
        for i in range(len(series)):
            if i < length:
                result.iloc[i] = np.nan
            else:
                result.iloc[i] = series.iloc[i] - series.iloc[i-length]
        return result

    def next(self):
        # Get current values
        vrp = self.vrp[-1]
        vrp_zscore = self.vrp_zscore[-1]
        vrp_prev = self.vrp[-2] if len(self.vrp) > 1 else vrp
        vrp_mean = self.vrp_mean[-1]
        rv_slope = self.rv_slope[-1]
        
        # Determine regime
        if vrp >= self.threshold_extreme:
            regime = "EXTREME"
        elif vrp >= self.threshold_high:
            regime = "HIGH"
        elif vrp >= 0:
            regime = "NORMAL"
        elif vrp >= self.threshold_low:
            regime = "LOW"
        else:
            regime = "NEGATIVE"
        
        # Mean Reversion Signals
        mr_overbought = vrp_zscore >= self.mr_zscore_threshold
        mr_oversold = vrp_zscore <= -self.mr_zscore_threshold
        mr_long = mr_oversold and vrp > vrp_prev
        mr_short = mr_overbought and vrp < vrp_prev
        
        # Entry Logic: Buy on mean reversion oversold signals
        if not self.position:
            if mr_long:
                self.buy()
            elif vrp < self.threshold_low and vrp > vrp_prev:
                self.buy()
        
        # Exit Logic: Sell on mean reversion overbought signals
        if self.position:
            if mr_short:
                self.position.close()
            elif vrp >= self.threshold_extreme:
                self.position.close()
            elif vrp >= self.threshold_high and vrp < vrp_prev:
                self.position.close()


if __name__ == "__main__":
    bt = Backtest(
        pd.read_csv("data.csv", index_col=0, parse_dates=True),
        TvStrategy,
        cash=10000,
        commission=0.002,
        exclusive_orders=True
    )
    
    stats = bt.run()
    print(stats)
    bt.plot()