"""
OpenClaw Backtest Results: volume-cluster-profile-vcp-zeiierman
============================================================

--- SPY ---
  ERROR: Indicator "_get_pivo…(20)" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_get_pivo…(20)" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_get_pivo…(20)" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — volume-cluster-profile-vcp-zeiierman
Generated by OpenClaw TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Parameters from the Pine Script
    lookback_bars = 250
    bins_count = 40
    cluster_sigma = 2.5
    max_clusters = 2
    swing_len = 20
    profile_width = 50

    def init(self):
        # Calculate pivot highs and lows for swing detection
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        close = pd.Series(self.data.Close)
        volume = pd.Series(self.data.Volume)
        
        # Store data for analysis
        self.pivot_highs = self.I(self._get_pivot_highs, high, self.swing_len)
        self.pivot_lows = self.I(self._get_pivot_lows, low, self.swing_len)
        
        # Track volume profile metrics
        self.poc_price = self.I(self._calculate_poc, close, volume, high, low, 
                                self.lookback_bars, self.bins_count, self.cluster_sigma, self.max_clusters)
        
    def _get_pivot_highs(self, high_series):
        """Detect pivot highs"""
        result = np.full(len(high_series), np.nan)
        for i in range(self.swing_len, len(high_series) - self.swing_len):
            if high_series.iloc[i] == high_series.iloc[i-self.swing_len:i+self.swing_len+1].max():
                result[i] = high_series.iloc[i]
        return result
    
    def _get_pivot_lows(self, low_series):
        """Detect pivot lows"""
        result = np.full(len(low_series), np.nan)
        for i in range(self.swing_len, len(low_series) - self.swing_len):
            if low_series.iloc[i] == low_series.iloc[i-self.swing_len:i+self.swing_len+1].min():
                result[i] = low_series.iloc[i]
        return result
    
    def _gauss(self, dist, sigma):
        """Gaussian function"""
        if sigma > 0.0:
            return np.exp(-(dist * dist) / (2.0 * sigma * sigma))
        return 1.0
    
    def _calculate_poc(self, close_series, volume_series, high_series, low_series, 
                       lookback, bins, sigma, max_clusters):
        """Calculate Point of Control based on volume clustering"""
        result = np.full(len(close_series), np.nan)
        
        for idx in range(lookback, len(close_series)):
            start = max(0, idx - lookback)
            
            high_slice = high_series.iloc[start:idx+1]
            low_slice = low_series.iloc[start:idx+1]
            close_slice = close_series.iloc[start:idx+1]
            volume_slice = volume_series.iloc[start:idx+1]
            
            min_price = low_slice.min()
            max_price = high_slice.max()
            price_range = max_price - min_price
            
            if price_range <= 1e-10:
                continue
            
            step = price_range / bins
            vol_bins = np.zeros(bins)
            
            # Populate volume bins
            for i, (c, v) in enumerate(zip(close_slice, volume_slice)):
                bin_idx = int(np.floor((c - min_price) / step))
                bin_idx = max(0, min(bins - 1, bin_idx))
                vol_bins[bin_idx] += v
            
            # Calculate statistics
            sum_vol = vol_bins.sum()
            avg_vol = sum_vol / bins if bins > 0 else 0
            var_vol = np.sum((vol_bins - avg_vol) ** 2) / bins if bins > 0 else 0
            std_vol = np.sqrt(var_vol) if var_vol > 0 else 0
            
            # Detect cluster peaks
            cluster_idxs = []
            for b in range(bins):
                left = vol_bins[b-1] if b > 0 else vol_bins[b]
                right = vol_bins[b+1] if b < bins - 1 else vol_bins[b]
                is_peak = vol_bins[b] >= left and vol_bins[b] >= right
                thresh = avg_vol if std_vol == 0 else avg_vol
                
                if is_peak and vol_bins[b] > thresh:
                    cluster_idxs.append(b)
            
            # Limit clusters
            if len(cluster_idxs) > max_clusters:
                cluster_idxs = sorted(cluster_idxs, 
                                     key=lambda x: vol_bins[x], 
                                     reverse=True)[:max_clusters]
            
            # Apply Gaussian smoothing
            vol_bins_ai = vol_bins.copy()
            if len(cluster_idxs) > 0:
                for b in range(bins):
                    enhanced = 0.0
                    for center_bin in cluster_idxs:
                        center_v = vol_bins[center_bin]
                        dist = abs(b - center_bin)
                        w = self._gauss(dist, sigma)
                        enhanced += center_v * w
                    vol_bins_ai[b] = enhanced / len(cluster_idxs)
            
            # Find POC (highest volume bin)
            if vol_bins_ai.max() > 0:
                poc_bin = np.argmax(vol_bins_ai)
                poc = min_price + (poc_bin + 0.5) * step
                result[idx] = poc
        
        return result
    
    def next(self):
        """Trading logic based on volume profile and swing levels"""
        if len(self) < self.lookback_bars + self.swing_len:
            return
        
        current_price = self.data.Close[-1]
        poc = self.poc_price[-1]
        
        pivot_high = self.pivot_highs[-1]
        pivot_low = self.pivot_lows[-1]
        
        # Entry logic: Buy when price bounces off lower support (low pivot) near lower POC
        if not np.isnan(pivot_low) and not np.isnan(poc):
            if current_price > pivot_low and self.data.Close[-2] <= pivot_low:
                if not self.position:
                    self.buy()
        
        # Entry logic: Sell when price rejects at upper resistance (high pivot) near upper POC
        if not np.isnan(pivot_high) and not np.isnan(poc):
            if current_price < pivot_high and self.data.Close[-2] >= pivot_high:
                if self.position:
                    self.sell()
        
        # Exit logic: Stop loss on opposite pivot, or trailing stop
        if self.position:
            if not np.isnan(pivot_high):
                if current_price > pivot_high:
                    self.sell()
        
        # Exit short positions
        if self.position and self.position.is_short:
            if not np.isnan(pivot_low):
                if current_price < pivot_low:
                    self.buy()


if __name__ == '__main__':
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()