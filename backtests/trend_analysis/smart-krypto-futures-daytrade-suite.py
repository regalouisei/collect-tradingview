"""
DS-TV Backtest Results: smart-krypto-futures-daytrade-suite
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "vwap" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "vwap" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "vwap" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” smart-krypto-futures-daytrade-suite
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # VWAP
        self.vwap = self.I(pta.vwap, high, low, close, volume)
        
        # EMA 9
        self.ema9 = self.I(pta.ema, close, length=9)
        
        # WMA 200
        self.wma200 = self.I(pta.wma, close, length=200)
        
        # EMA 50 (for trend confirmation)
        self.ema50 = self.I(pta.ema, close, length=50)
        
        # RSI 14 (for overbought/oversold confirmation)
        self.rsi = self.I(pta.rsi, close, length=14)
        
        # Track previous values for FVG logic
        self.high_2bars_ago = None
        self.low_2bars_ago = None
        self.close_1bar_ago = None
        self.open_1bar_ago = None

    def next(self):
        # Store historical values for FVG detection
        if len(self.data) >= 3:
            self.high_2bars_ago = self.data.High[-3]
            self.low_2bars_ago = self.data.Low[-3]
        
        if len(self.data) >= 2:
            self.close_1bar_ago = self.data.Close[-2]
            self.open_1bar_ago = self.data.Open[-2]
        
        current_high = self.data.High[-1]
        current_low = self.data.Low[-1]
        current_close = self.data.Close[-1]
        current_open = self.data.Open[-1]
        
        # Skip if indicators are not ready
        if np.isnan(self.ema9[-1]) or np.isnan(self.wma200[-1]) or np.isnan(self.ema50[-1]) or np.isnan(self.rsi[-1]):
            return
        
        # Trading Logic
        
        # BUY SIGNALS:
        # 1. EMA9 crosses above WMA200 (trend change)
        # 2. Price in demand zone (HTF Low + 5% range)
        # 3. RSI not overbought
        # 4. Bullish FVG formed
        
        buy_signal = False
        
        # Signal 1: EMA9 crosses above WMA200
        if crossover(self.ema9, self.wma200):
            buy_signal = True
        
        # Signal 2: EMA9 above WMA200 and price near VWAP from below
        if (self.ema9[-1] > self.wma200[-1] and 
            self.ema9[-2] <= self.wma200[-2] and 
            self.rsi[-1] < 70):
            buy_signal = True
        
        # Signal 3: Bullish FVG (low > high[2]) with bullish candle
        if (self.high_2bars_ago is not None and 
            current_low > self.high_2bars_ago and 
            self.close_1bar_ago is not None and 
            self.open_1bar_ago is not None and
            self.close_1bar_ago > self.open_1bar_ago):
            buy_signal = True
        
        # SELL SIGNALS:
        # 1. EMA9 crosses below WMA200
        # 2. Price in supply zone (HTF High - 5% range)
        # 3. RSI overbought
        # 4. Bearish FVG formed
        
        sell_signal = False
        
        # Signal 1: EMA9 crosses below WMA200
        if crossover(self.wma200, self.ema9):
            sell_signal = True
        
        # Signal 2: EMA9 below WMA200 and price near VWAP from above
        if (self.ema9[-1] < self.wma200[-1] and 
            self.ema9[-2] >= self.wma200[-2] and 
            self.rsi[-1] > 30):
            sell_signal = True
        
        # Signal 3: Bearish FVG (high < low[2]) with bearish candle
        if (self.low_2bars_ago is not None and 
            current_high < self.low_2bars_ago and 
            self.close_1bar_ago is not None and 
            self.open_1bar_ago is not None and
            self.close_1bar_ago < self.open_1bar_ago):
            sell_signal = True
        
        # Execute trades
        if buy_signal and not self.position:
            self.buy()
        elif sell_signal and self.position:
            self.sell()
        
        # Exit on reversal signals
        if self.position and self.position.is_long and self.rsi[-1] > 80:
            self.sell()
        elif self.position and self.position.is_long and crossover(self.wma200, self.ema9):
            self.sell()


if __name__ == "__main__":
    from datetime import datetime
    import yfinance as yf
    
    # Download sample data
    data = yf.download("BTC-USD", start="2023-01-01", end="2024-01-01", interval="1h")
    
    # Run backtest
    bt = Backtest(data, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()