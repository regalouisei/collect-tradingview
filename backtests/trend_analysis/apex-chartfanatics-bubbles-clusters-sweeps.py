"""
DS-TV Backtest Results: apex-chartfanatics-bubbles-clusters-sweeps
============================================================

--- SPY ---
  ERROR: object of type 'TvStrategy' has no len()

--- BTC ---
  ERROR: object of type 'TvStrategy' has no len()

--- QQQ ---
  ERROR: object of type 'TvStrategy' has no len()

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” apex-chartfanatics-bubbles-clusters-sweeps
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    bubble_quant = 10
    vol_lookback = 200
    cluster_min_vol = 200
    cluster_width = 4
    zone_lookback = 20
    atr_length = 14

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        self.atr = self.I(pta.atr, high, low, close, length=self.atr_length)
        
        self.vol_min = self.I(lambda: volume.rolling(self.vol_lookback).min())
        self.vol_max = self.I(lambda: volume.rolling(self.vol_lookback).max())
        
        self.ph = self.I(lambda: self._pivot_high(high, self.zone_lookback))
        self.pl = self.I(lambda: self._pivot_low(low, self.zone_lookback))
        
        self.in_demand_zone = False
        self.in_supply_zone = False

    def _pivot_high(self, high, period):
        result = pd.Series(index=high.index, dtype=float)
        for i in range(len(high)):
            if i < period or i >= len(high) - period:
                result.iloc[i] = np.nan
            else:
                window = high.iloc[i-period:i+period+1]
                if high.iloc[i] == window.max():
                    result.iloc[i] = high.iloc[i]
                else:
                    result.iloc[i] = np.nan
        return result

    def _pivot_low(self, low, period):
        result = pd.Series(index=low.index, dtype=float)
        for i in range(len(low)):
            if i < period or i >= len(low) - period:
                result.iloc[i] = np.nan
            else:
                window = low.iloc[i-period:i+period+1]
                if low.iloc[i] == window.min():
                    result.iloc[i] = low.iloc[i]
                else:
                    result.iloc[i] = np.nan
        return result

    def next(self):
        if len(self) < self.zone_lookback + 2:
            return

        current_high = self.data.High[-1]
        current_low = self.data.Low[-1]
        current_close = self.data.Close[-1]
        current_open = self.data.Open[-1]
        current_volume = self.data.Volume[-1]
        
        atr_val = self.atr[-1] if not np.isnan(self.atr[-1]) else 0
        vol_min = self.vol_min[-1] if not np.isnan(self.vol_min[-1]) else 0
        vol_max = self.vol_max[-1] if not np.isnan(self.vol_max[-1]) else 0
        
        is_green = current_close > current_open
        
        ph_val = self.ph[-1] if not np.isnan(self.ph[-1]) else None
        pl_val = self.pl[-1] if not np.isnan(self.pl[-1]) else None
        
        if ph_val is not None and not self.in_supply_zone:
            supply_top = ph_val
            supply_bottom = ph_val - atr_val * 2.0
            if supply_bottom <= current_close <= supply_top:
                self.in_supply_zone = True
                if self.position:
                    self.position.close()
        
        if pl_val is not None and not self.in_demand_zone:
            demand_bottom = pl_val
            demand_top = pl_val + atr_val * 2.0
            if demand_bottom <= current_close <= demand_top:
                self.in_demand_zone = True
                if not self.position:
                    self.buy()
        
        if current_high > self.data.High[-2] and current_close < self.data.High[-2] and current_close < current_open:
            if self.position:
                self.position.close()
        
        if current_low < self.data.Low[-2] and current_close > self.data.Low[-2] and current_close > current_open:
            if not self.position:
                self.buy()
        
        if current_volume >= self.cluster_min_vol:
            if is_green and not self.position:
                self.buy()
            elif not is_green and self.position:
                self.position.close()
        
        if self.in_supply_zone and current_low < (self.ph[-1] - atr_val * 2.0 if not np.isnan(self.ph[-1]) else current_low - atr_val):
            self.in_supply_zone = False
        
        if self.in_demand_zone and current_high > (self.pl[-1] + atr_val * 2.0 if not np.isnan(self.pl[-1]) else current_high + atr_val):
            self.in_demand_zone = False


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, commission=.002, exclusive_orders=True)
    results = bt.run()
    print(results)
    bt.plot()