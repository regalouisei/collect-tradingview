"""
DS-TV Backtest Results: fisher-transformator-index
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ,5)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "ema(λ,5)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ,5)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — fisher-transformator-index
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    len = 9
    mult = 2.2
    smooth = 0.80
    clip = 0.92
    trigger_lead = 0.65
    trigger_len = 5

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # hl2 calculation
        hl2 = (high + low) / 2
        
        # Highest and lowest over len period
        highest = self.I(lambda: hl2.rolling(window=self.len).max())
        lowest = self.I(lambda: hl2.rolling(window=self.len).min())
        
        # Price range
        price_range = self.I(lambda: highest_series(hl2, self.len) - lowest_series(hl2, self.len))
        
        # Safe range to avoid division by zero
        range_safe = self.I(lambda: (highest_series(hl2, self.len) - lowest_series(hl2, self.len)).apply(lambda x: max(x, 1e-10)))
        
        # Normalization
        raw = self.I(lambda: (hl2 - lowest_series(hl2, self.len)) / range_safe)
        centered = self.I(lambda: raw - 0.5)
        stretched = self.I(lambda: centered * self.mult)
        
        # Clipped and smoothed value
        self.value = self.I(lambda: compute_smoothed_value(stretched, self.smooth, self.clip))
        
        # Fisher transformation
        self.fish1 = self.I(lambda: compute_fisher(self.value))
        
        # EMA of fisher
        ema_slow = self.I(pta.ema, self.fish1, length=self.trigger_len)
        
        # Trigger: mixture of EMA and instant fish1
        self.trigger = self.I(lambda: (1 - self.trigger_lead) * ema_slow + self.trigger_lead * self.fish1)

    def next(self):
        if len(self.fish1) < 2 or len(self.trigger) < 2:
            return
        
        # Buy when Fisher crosses above Trigger
        if crossover(self.fish1, self.trigger):
            if not self.position:
                self.buy()
        
        # Sell when Fisher crosses below Trigger
        elif crossover(self.trigger, self.fish1):
            if self.position:
                self.position.close()


def highest_series(series, length):
    return series.rolling(window=length).max()


def lowest_series(series, length):
    return series.rolling(window=length).min()


def compute_smoothed_value(stretched, smooth, clip):
    stretched_arr = stretched.values if isinstance(stretched, pd.Series) else stretched
    result = np.zeros(len(stretched_arr))
    
    for i in range(len(stretched_arr)):
        clipped = np.clip(stretched_arr[i], -clip, clip)
        if i == 0:
            result[i] = smooth * clipped
        else:
            result[i] = smooth * clipped + (1 - smooth) * result[i - 1]
    
    return pd.Series(result, index=stretched.index if isinstance(stretched, pd.Series) else None)


def compute_fisher(value):
    value_arr = value.values if isinstance(value, pd.Series) else value
    result = np.zeros(len(value_arr))
    
    for i in range(len(value_arr)):
        v = np.clip(value_arr[i], -0.999, 0.999)
        fisher_val = 0.5 * np.log((1 + v) / (1 - v + 1e-10))
        if i == 0:
            result[i] = 0.5 * fisher_val
        else:
            result[i] = fisher_val + 0.5 * result[i - 1]
    
    return pd.Series(result, index=value.index if isinstance(value, pd.Series) else None)


if __name__ == "__main__":
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, commission=.002, exclusive_orders=True)
    stats = bt.run()
    print(stats)
    bt.plot()