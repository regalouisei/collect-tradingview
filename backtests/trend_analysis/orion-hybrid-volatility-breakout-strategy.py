"""
DS-TV Backtest Results: orion-hybrid-volatility-breakout-strategy
============================================================

--- SPY ---
  ERROR: size must be a positive fraction of equity, or a positive whole number of units

--- BTC ---
  Return                    0.00%
  Buy & Hold Return         23.18%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- QQQ ---
  ERROR: size must be a positive fraction of equity, or a positive whole number of units

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” orion-hybrid-volatility-breakout-strategy
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lookback = 15
    atr_mult = 2.5
    slope_thresh = 0.2
    cooldown_bars = 5
    max_box_life = 45
    use_ema = True
    ema_len = 150
    risk_per_trade = 0.8
    reward_ratio = 1.9
    use_gold = True
    std_len = 20
    squeeze_th = 0.6

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        self.ema_val = self.I(pta.ema, close, length=self.ema_len)
        self.atr_val = self.I(pta.atr, high, low, close, length=14)
        self.std_dev = self.I(pta.stdev, close, length=self.std_len)
        
        self.high_line = self.I(lambda: high.rolling(self.lookback).max())
        self.low_line = self.I(lambda: low.rolling(self.lookback).min())
        
        self.lrc = self.I(lambda: pd.Series(close).rolling(self.lookback).apply(
            lambda x: np.polyfit(np.arange(len(x)), x.values, 1)[0] if len(x) > 1 else 0, raw=False
        ))
        
        self.in_trade = False
        self.box_ready = False
        self.last_exit_bar = -999
        self.box_start_bar = 0
        self.t_entry = np.nan
        self.t_sl = np.nan
        self.t_tp = np.nan
        self.t_dir = 0
        self.t_qty = 0.0
        self.t_start_bar = 0
        self.z_high = np.nan
        self.z_low = np.nan

    def next(self):
        if len(self.data) < self.lookback + self.std_len:
            return
        
        close = self.data.Close[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        bar_idx = len(self.data) - 1
        
        ema_val = self.ema_val[-1] if not np.isnan(self.ema_val[-1]) else close
        atr_val = self.atr_val[-1] if not np.isnan(self.atr_val[-1]) else 0
        std_dev = self.std_dev[-1] if not np.isnan(self.std_dev[-1]) else 0
        
        high_line = self.high_line[-1] if not np.isnan(self.high_line[-1]) else high
        low_line = self.low_line[-1] if not np.isnan(self.low_line[-1]) else low
        
        lrc = self.lrc[-1] if not np.isnan(self.lrc[-1]) else 0
        lrc_prev = self.lrc[-2] if len(self.lrc) > 1 and not np.isnan(self.lrc[-2]) else lrc
        
        trend_long = close > ema_val if self.use_ema else True
        trend_short = close < ema_val if self.use_ema else True
        
        box_h = high_line - low_line
        slope = abs((lrc - lrc_prev) / close * 1000) if close != 0 else 0
        is_squeeze = std_dev < (atr_val * self.squeeze_th) if atr_val > 0 else False
        is_tight = box_h < (atr_val * self.atr_mult) if atr_val > 0 else False
        is_flat = slope < self.slope_thresh
        
        is_resting = (bar_idx - self.last_exit_bar) < self.cooldown_bars
        
        if self.in_trade:
            entry_sl_diff = abs(self.t_entry - self.t_sl)
            entry_tp_diff = abs(self.t_tp - self.t_entry)
            
            if self.t_dir == 1:
                if high >= self.t_tp:
                    self.position.close()
                    self.in_trade = False
                    self.last_exit_bar = bar_idx
                elif low <= self.t_sl:
                    self.position.close()
                    self.in_trade = False
                    self.last_exit_bar = bar_idx
            elif self.t_dir == -1:
                if low <= self.t_tp:
                    self.position.close()
                    self.in_trade = False
                    self.last_exit_bar = bar_idx
                elif high >= self.t_sl:
                    self.position.close()
                    self.in_trade = False
                    self.last_exit_bar = bar_idx
        
        if not self.in_trade:
            if self.box_ready:
                if (bar_idx - self.box_start_bar) > self.max_box_life:
                    self.box_ready = False
                else:
                    still_in_range = close <= self.z_high and close >= self.z_low
                    
                    if not still_in_range:
                        break_up = close > self.z_high
                        break_down = close < self.z_low
                        
                        if break_up and not trend_long:
                            break_up = False
                        if break_down and not trend_short:
                            break_down = False
                        
                        if break_up:
                            self.box_ready = False
                            self.last_exit_bar = bar_idx
                            self.in_trade = True
                            
                            self.t_entry = close
                            self.t_start_bar = bar_idx
                            self.t_dir = 1
                            self.t_sl = self.z_low
                            risk = abs(self.t_entry - self.t_sl)
                            self.t_tp = self.t_entry + (risk * self.reward_ratio)
                            
                            if risk > 0:
                                self.t_qty = (self.equity * self.risk_per_trade / 100) / risk
                                self.buy(size=self.t_qty)
                        
                        elif break_down:
                            self.box_ready = False
                            self.last_exit_bar = bar_idx
                            self.in_trade = True
                            
                            self.t_entry = close
                            self.t_start_bar = bar_idx
                            self.t_dir = -1
                            self.t_sl = self.z_high
                            risk = abs(self.t_sl - self.t_entry)
                            self.t_tp = self.t_entry - (risk * self.reward_ratio)
                            
                            if risk > 0:
                                self.t_qty = (self.equity * self.risk_per_trade / 100) / risk
                                self.sell(size=self.t_qty)
                        
                        else:
                            self.box_ready = False
            
            elif is_tight and is_flat and not is_resting:
                self.box_ready = True
                self.box_start_bar = bar_idx
                self.z_high = high_line
                self.z_low = low_line


if __name__ == "__main__":
    df = pd.read_csv("data.csv", index_col=0, parse_dates=True)
    
    bt = Backtest(df, TvStrategy, cash=200000, commission=0.0002, margin=1.0)
    stats = bt.run()
    print(stats)
    bt.plot()