"""
DS-TV Backtest Results: strategy-pack-by-cryptokazancev
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — strategy-pack-by-cryptokazancev
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Parameters from Pine Script
    swingLen = 2
    deep = 100
    ZIlookback = 10
    ZImultiplier_ATR = 1.0
    ZIminSwingCount = 5
    multiplier_ATR = 0.8
    multiplier_ENGULFING = 0.8
    
    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate ATR-based volatility
        percent_range = (high - low) / low * 100
        self.atr = self.I(lambda: pta.sma(percent_range, length=500) or pd.Series(1.0, index=close.index))
        
        # Calculate swing points using pivot highs/lows
        self.swing_high = self.I(lambda: self._calc_swing_high(high, self.swingLen))
        self.swing_low = self.I(lambda: self._calc_swing_low(low, self.swingLen))
        
        # Pinbar detection
        body = (np.abs(self.data.Close - self.data.Open) / self.data.Low * 100).replace([np.inf, -np.inf], 0)
        upper_wick = ((self.data.High - np.maximum(self.data.Open, self.data.Close)) / self.data.Low * 100).replace([np.inf, -np.inf], 0)
        lower_wick = ((np.minimum(self.data.Open, self.data.Close) - self.data.Low) / self.data.Low * 100).replace([np.inf, -np.inf], 0)
        
        self.body = self.I(lambda: body)
        self.upper_wick = self.I(lambda: upper_wick)
        self.lower_wick = self.I(lambda: lower_wick)
        
        # Track trend state
        self.trend = "NEUTRAL"
        self.key_high = None
        self.key_low = None
        self.last_signal = None
        
    def _calc_swing_high(self, series, length):
        result = pd.Series(np.nan, index=series.index)
        for i in range(length, len(series) - length):
            if series.iloc[i] == series.iloc[i-length:i+length+1].max():
                result.iloc[i] = series.iloc[i]
        return result
    
    def _calc_swing_low(self, series, length):
        result = pd.Series(np.nan, index=series.index)
        for i in range(length, len(series) - length):
            if series.iloc[i] == series.iloc[i-length:i+length+1].min():
                result.iloc[i] = series.iloc[i]
        return result
    
    def _is_bull_pinbar(self):
        if len(self.body) < 2:
            return False
        current_body = self.body[-1]
        current_lower_wick = self.lower_wick[-1]
        current_atr = self.atr[-1]
        
        return (current_lower_wick > current_body * 1.1 and 
                current_lower_wick > current_atr * self.multiplier_ATR and 
                current_lower_wick > 0.3 and
                self.data.Low[-1] < self.data.Low[-2])
    
    def _is_bear_pinbar(self):
        if len(self.body) < 2:
            return False
        current_body = self.body[-1]
        current_upper_wick = self.upper_wick[-1]
        current_atr = self.atr[-1]
        
        return (current_upper_wick > current_body * 1.1 and 
                current_upper_wick > current_atr * self.multiplier_ATR and 
                current_upper_wick > 0.3 and
                self.data.High[-1] > self.data.High[-2])
    
    def _is_bullish_engulfing(self):
        if len(self.data.Close) < 2:
            return False
        
        curr_close = self.data.Close[-1]
        curr_open = self.data.Open[-1]
        prev_close = self.data.Close[-2]
        prev_open = self.data.Open[-2]
        prev_low = self.data.Low[-2]
        prev_prev_low = self.data.Low[-3] if len(self.data.Close) > 2 else prev_low
        
        body_curr = np.abs(curr_close - curr_open) / curr_open if curr_open != 0 else 0
        current_atr = self.atr[-1] if len(self.atr) > 0 else 1.0
        
        return (curr_close > curr_open and 
                prev_close < prev_open and 
                curr_open <= prev_close and 
                curr_close >= prev_open and 
                body_curr * 100 > current_atr * self.multiplier_ENGULFING and
                prev_low < prev_prev_low)
    
    def _is_bearish_engulfing(self):
        if len(self.data.Close) < 2:
            return False
        
        curr_close = self.data.Close[-1]
        curr_open = self.data.Open[-1]
        prev_close = self.data.Close[-2]
        prev_open = self.data.Open[-2]
        prev_high = self.data.High[-2]
        prev_prev_high = self.data.High[-3] if len(self.data.Close) > 2 else prev_high
        
        body_curr = np.abs(curr_close - curr_open) / curr_open if curr_open != 0 else 0
        current_atr = self.atr[-1] if len(self.atr) > 0 else 1.0
        
        return (curr_close < curr_open and 
                prev_close > prev_open and 
                curr_open >= prev_close and 
                curr_close <= prev_open and 
                body_curr * 100 > current_atr * self.multiplier_ENGULFING and
                prev_high > prev_prev_high)
    
    def next(self):
        # Trading logic based on reversal patterns
        
        # Bullish signals: pinbar or engulfing at support
        if self._is_bull_pinbar() or self._is_bullish_engulfing():
            if not self.position:
                self.buy()
            self.last_signal = "BULL"
        
        # Bearish signals: pinbar or engulfing at resistance
        elif self._is_bear_pinbar() or self._is_bearish_engulfing():
            if self.position:
                self.position.close()
            self.last_signal = "BEAR"
        
        # Simple trend following exit
        if self.position and len(self.data.Close) > 20:
            sma_fast = self.I(lambda: pta.sma(pd.Series(self.data.Close), length=5) or pd.Series(self.data.Close[-1], index=pd.Series(self.data.Close).index))
            sma_slow = self.I(lambda: pta.sma(pd.Series(self.data.Close), length=20) or pd.Series(self.data.Close[-1], index=pd.Series(self.data.Close).index))
            
            if self.position.is_long and sma_fast[-1] < sma_slow[-1]:
                self.position.close()