"""
DS-TV Backtest Results: hb-directional-range
============================================================

--- SPY ---
  ERROR: object of type 'TvStrategy' has no len()

--- BTC ---
  ERROR: object of type 'TvStrategy' has no len()

--- QQQ ---
  ERROR: object of type 'TvStrategy' has no len()

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” hb-directional-range
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    def init(self):
        pass

    def next(self):
        close = self.data.Close
        open_ = self.data.Open
        high = self.data.High
        low = self.data.Low
        
        if len(self) < 2:
            return
        
        idx = len(self) - 1
        
        # Helper functions
        def body_top(o, c):
            return max(o, c)
        
        def body_bottom(o, c):
            return min(o, c)
        
        def is_within_range(src, bottom, top):
            return bottom <= src <= top
        
        def body_breaks_above(top, bottom, o, c, h):
            bt = body_top(o, c)
            return (top < bt) or (bottom < bt and bt < top and body_top(o, c) > top)
        
        def body_breaks_below(top, bottom, o, c, l):
            bb = body_bottom(o, c)
            return (bottom > body_top(o, c)) or (bottom < body_top(o, c) and body_top(o, c) < top and bb < bottom)
        
        # Initialize state on first bar
        if not hasattr(self, 'cons_high'):
            self.cons_high = high[idx]
            self.cons_low = low[idx]
            self.cons_started_up = close[idx] >= open_[idx]
            self.in_range = True
            return
        
        # Per-bar maintenance
        curr_open = open_[idx]
        curr_close = close[idx]
        curr_high = high[idx]
        curr_low = low[idx]
        
        # Check if body is within current range
        open_in = is_within_range(curr_open, self.cons_low, self.cons_high)
        close_in = is_within_range(curr_close, self.cons_low, self.cons_high)
        
        is_break_up = False
        is_break_down = False
        
        if not open_in or not close_in:
            # Body-based breakout detected
            is_break_up = body_breaks_above(self.cons_high, self.cons_low, curr_open, curr_close, curr_high)
            is_break_down = body_breaks_below(self.cons_high, self.cons_low, curr_open, curr_close, curr_low)
            
            # Start new range
            self.cons_high = curr_high
            self.cons_low = curr_low
            self.cons_started_up = curr_close >= curr_open
            self.in_range = True
            
            # Trading logic based on breakout
            if is_break_up and not self.cons_started_up:
                if self.position:
                    self.position.close()
                self.buy()
            elif is_break_down and self.cons_started_up:
                if self.position:
                    self.position.close()
                self.sell()
        
        else:
            # Body is inside range: extend and expand with wicks
            if curr_high > self.cons_high:
                self.cons_high = curr_high
            
            if curr_low < self.cons_low:
                self.cons_low = curr_low


def run_backtest():
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()


if __name__ == '__main__':
    run_backtest()