"""
DS-TV Backtest Results: ct-displacement-fvg-toolkit
============================================================

--- SPY ---
  ERROR: 'Position' object has no attribute 'open_price'

--- BTC ---
  ERROR: 'Position' object has no attribute 'open_price'

--- QQQ ---
  ERROR: 'Position' object has no attribute 'open_price'

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” ct-displacement-fvg-toolkit
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Displacement parameters
    disp_lookback = 5
    disp_factor = 1.5
    use_body_size = True
    
    # Structure break filter
    sb_lookback = 5
    require_struct_br = True
    struct_break_type = "Close"
    
    # FVG parameters
    show_fvg = True
    extend_fvg = True
    extend_bars = 250
    hide_mitigated = False
    max_fvgs = 60
    
    # Dealing range parameters
    show_dr = True
    dr_len = 50
    
    # BOS/CHOCH parameters
    show_ms = True
    ms_swing_len = 5
    ms_break_type = "Close"
    
    # CISD parameters
    cisd_enable = True
    tolerance = 0.7
    cisd_len = 12
    expiry_bars = 100
    liquidity_lookback = 10
    
    # HTF parameters
    show_htf = False
    htf_confirmed_only = True
    use_htf_trend = False
    
    # Candle coloring
    candle_color_mode = "Off"

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        open_ = pd.Series(self.data.Open)
        
        # Displacement calculation
        sz = np.where(self.use_body_size, 
                     np.abs(close - open_),
                     high - low)
        avg_s = pd.Series(sz).rolling(self.disp_lookback).mean()
        
        is_disp = (sz > avg_s * self.disp_factor).fillna(False)
        bull_disp = is_disp & (close > open_).values
        bear_disp = is_disp & (close < open_).values
        
        # Structure break
        sb_high = high.rolling(self.sb_lookback).max().shift(1)
        sb_low = low.rolling(self.sb_lookback).min().shift(1)
        
        if self.struct_break_type == "Close":
            bull_sb = close > sb_high
            bear_sb = close < sb_low
        else:
            bull_sb = high > sb_high
            bear_sb = low < sb_low
        
        if self.require_struct_br:
            self.bull_disp_ok = bull_disp & bull_sb
            self.bear_disp_ok = bear_disp & bear_sb
        else:
            self.bull_disp_ok = bull_disp
            self.bear_disp_ok = bear_disp
        
        # FVG detection (3-candle pattern)
        self.bull_fvg = (low > high.shift(2)).fillna(False) & self.bull_disp_ok
        self.bear_fvg = (high < low.shift(2)).fillna(False) & self.bear_disp_ok
        
        # Dealing range
        self.dr_high = high.rolling(self.dr_len).max()
        self.dr_low = low.rolling(self.dr_len).min()
        self.dr_mid = (self.dr_high + self.dr_low) * 0.5
        
        # BOS/CHOCH - pivot points
        self.pivot_high = self._pivot_high(high, self.ms_swing_len)
        self.pivot_low = self._pivot_low(low, self.ms_swing_len)
        
        self.last_swing_high = high.iloc[0]
        self.last_swing_low = low.iloc[0]
        
        # CISD - simple trend detection
        self.cisd_trend = 0
        self.bullish_sweep = False
        self.bearish_sweep = False
        
        # Initialize entry signal
        self.signal_buy = False
        self.signal_sell = False

    def _pivot_high(self, series, period):
        """Detect pivot highs"""
        result = pd.Series(False, index=series.index)
        for i in range(period, len(series) - period):
            if series.iloc[i] == series.iloc[i-period:i+period+1].max():
                result.iloc[i] = True
        return result

    def _pivot_low(self, series, period):
        """Detect pivot lows"""
        result = pd.Series(False, index=series.index)
        for i in range(period, len(series) - period):
            if series.iloc[i] == series.iloc[i-period:i+period+1].min():
                result.iloc[i] = True
        return result

    def next(self):
        close = self.data.Close[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        open_ = self.data.Open[-1]
        
        idx = len(self.data) - 1
        
        # Detect FVG signals
        if idx > 0:
            if self.bull_fvg.iloc[idx]:
                self.signal_buy = True
            if self.bear_fvg.iloc[idx]:
                self.signal_sell = True
        
        # Detect pivot breaks (BOS/CHOCH)
        if idx > self.ms_swing_len:
            if self.pivot_high.iloc[idx]:
                self.last_swing_high = high
            if self.pivot_low.iloc[idx]:
                self.last_swing_low = low
            
            # Check for break of structure
            if self.ms_break_type == "Close":
                if close > self.last_swing_high and not self.position:
                    self.signal_buy = True
                if close < self.last_swing_low and self.position:
                    self.signal_sell = True
            else:
                if high > self.last_swing_high and not self.position:
                    self.signal_buy = True
                if low < self.last_swing_low and self.position:
                    self.signal_sell = True
        
        # Simple CISD-based entry/exit
        if self.cisd_enable and idx > self.cisd_len:
            # Detect candle color reversals (basic CISD)
            if idx >= 1:
                prev_close = self.data.Close[-2]
                prev_open = self.data.Open[-2]
                
                # Bearish reversal (close > open after close < open)
                if prev_close < prev_open and close > open_ and not self.position:
                    self.signal_buy = True
                    self.cisd_trend = 1
                
                # Bullish reversal (close < open after close > open)
                if prev_close > prev_open and close < open_ and self.position:
                    self.signal_sell = True
                    self.cisd_trend = -1
        
        # Execute signals
        if self.signal_buy and not self.position:
            self.buy()
            self.signal_buy = False
        
        if self.signal_sell and self.position:
            self.sell()
            self.signal_sell = False
        
        # Risk management: exit on extreme moves
        if self.position:
            entry_price = self.position.open_price
            stop_loss = entry_price * 0.95  # 5% stop loss
            take_profit = entry_price * 1.10  # 10% take profit
            
            if close <= stop_loss or close >= take_profit:
                self.position.close()