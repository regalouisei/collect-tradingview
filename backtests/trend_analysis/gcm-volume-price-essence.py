"""
DS-TV Backtest Results: gcm-volume-price-essence
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ,8)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "ema(λ,8)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ,8)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — gcm-volume-price-essence
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lengthFast = 8
    lengthSlow = 21
    lengthVolume = 14
    volImpact = 1.5
    smoothing = 5
    finalSmoothing = 3
    signalPeriod = 12
    divLookback = 3

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)

        # Volume Ratio
        vol_sma_3 = self.I(pta.sma, volume, length=3)
        vol_sma_len = self.I(pta.sma, volume, length=self.lengthVolume)
        self.volumeRatio = self.I(lambda: vol_sma_3 / (vol_sma_len + 1e-10))

        # Price Change
        self.priceChange = self.I(lambda: close.diff())

        # Volume Weighted Momentum
        self.volumeWeightedMomentum = self.I(
            lambda: self.priceChange * np.log(1 + (self.volumeRatio * self.volImpact))
        )

        # Fast and Slow Flow
        self.fastFlow = self.I(pta.ema, self.volumeWeightedMomentum, length=self.lengthFast)
        self.slowFlow = self.I(pta.ema, self.volumeWeightedMomentum, length=self.lengthSlow)

        # Quantum Flow
        flow_diff = self.I(lambda: self.fastFlow - self.slowFlow)
        self.quantumFlow = self.I(pta.ema, flow_diff, length=self.smoothing)

        # Price Velocity and Acceleration
        self.priceVelocity = self.I(
            lambda: (close - close.shift(self.lengthFast)) / self.lengthFast
        )
        self.priceAcceleration = self.I(lambda: self.priceVelocity.diff())

        # Flow Strength
        flow_strength_calc = self.I(
            lambda: (self.priceVelocity * self.volumeRatio + self.priceAcceleration) * 100
        )
        self.flowStrength = self.I(pta.ema, flow_strength_calc, length=self.smoothing)

        # Trend Pressure
        rsi_val = self.I(pta.rsi, close, length=self.lengthFast)
        trend_pressure_calc = self.I(lambda: rsi_val - 50)
        self.trendPressure = self.I(pta.ema, trend_pressure_calc, length=self.smoothing)

        # Raw Composite and Composite Index
        raw_composite = self.I(
            lambda: (self.quantumFlow * 50 + self.flowStrength + self.trendPressure) / 3
        )
        self.compositeIndex = self.I(pta.wma, raw_composite, length=self.finalSmoothing)

        # Base Line
        self.baseLine = self.I(pta.ema, self.compositeIndex, length=self.signalPeriod)

        # Recent High and Low for Dynamic Zones
        self.recentHigh = self.I(
            lambda: self.compositeIndex.rolling(window=50).max().shift(1)
        )
        self.recentLow = self.I(
            lambda: self.compositeIndex.rolling(window=50).min().shift(1)
        )

        # Volatility Factor
        self.volatilityFactor = self.I(
            lambda: (self.recentHigh - self.recentLow) / 2
        )

        # Dynamic Zones
        self.upperZone = self.I(
            lambda: np.minimum(60, 30 + self.volatilityFactor * 0.3)
        )
        self.lowerZone = self.I(
            lambda: np.maximum(-60, -30 - self.volatilityFactor * 0.3)
        )

        # Anticipation and Continuation Logic
        self.flowCross = self.I(
            lambda: crossover(self.fastFlow, self.slowFlow)
        )

        self.momentumBuilding = self.I(
            lambda: (
                (self.compositeIndex > self.compositeIndex.shift(1)) &
                (self.compositeIndex < -20)
            ).astype(int)
        )

        self.momentumFading = self.I(
            lambda: (
                (self.compositeIndex < self.compositeIndex.shift(1)) &
                (self.compositeIndex > 20)
            ).astype(int)
        )

        self.bullishAnticipation = self.I(
            lambda: (
                self.flowCross &
                (self.fastFlow > self.slowFlow) &
                (self.compositeIndex < 0)
            ).astype(int)
        )

        self.bearishAnticipation = self.I(
            lambda: (
                self.flowCross &
                (self.fastFlow < self.slowFlow) &
                (self.compositeIndex > 0)
            ).astype(int)
        )

        self.bullishContinuation = self.I(
            lambda: (
                (self.momentumBuilding == 1) &
                (self.volumeRatio > 1.2)
            ).astype(int)
        )

        self.bearishContinuation = self.I(
            lambda: (
                (self.momentumFading == 1) &
                (self.volumeRatio > 1.2)
            ).astype(int)
        )

        # Divergence Logic
        self.pricePushingDown = self.I(
            lambda: (low < low.shift(self.divLookback - 1)).astype(int)
        )

        self.pricePushingUp = self.I(
            lambda: (high > high.shift(self.divLookback - 1)).astype(int)
        )

        self.indRising = self.I(
            lambda: (self.compositeIndex > self.compositeIndex.shift(1)).astype(int)
        )

        self.indFalling = self.I(
            lambda: (self.compositeIndex < self.compositeIndex.shift(1)).astype(int)
        )

        self.divBull = self.I(
            lambda: ((self.pricePushingDown == 1) & (self.indRising == 1)).astype(int)
        )

        self.divBear = self.I(
            lambda: ((self.pricePushingUp == 1) & (self.indFalling == 1)).astype(int)
        )

        # Crossovers with Base Line
        self.qfi_above_base = self.I(
            lambda: crossover(self.compositeIndex, self.baseLine)
        )

        self.qfi_below_base = self.I(
            lambda: crossover(self.baseLine, self.compositeIndex)
        )

    def next(self):
        if len(self.data) < max(self.lengthSlow, 50):
            return

        # Entry Conditions
        if (
            self.bullishAnticipation[-1] or
            self.bullishContinuation[-1] or
            self.divBull[-1] or
            self.qfi_above_base[-1]
        ):
            if not self.position:
                self.buy()

        # Exit Conditions
        if (
            self.bearishAnticipation[-1] or
            self.bearishContinuation[-1] or
            self.divBear[-1] or
            self.qfi_below_base[-1]
        ):
            if self.position:
                self.position.close()