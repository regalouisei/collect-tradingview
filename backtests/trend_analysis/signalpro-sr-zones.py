"""
DS-TV Backtest Results: signalpro-sr-zones
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — signalpro-sr-zones
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover

class TvStrategy(Strategy):
    param1 = 10
    param2 = 0.15
    param3 = 8
    param4 = 0.3
    param5 = 1
    param6 = 50
    param7 = 5.0
    param8 = 0.1

    def init(self):
        close = pd.Series(self.data.Close)
        self.pivot_high = self.I(lambda: pta.pivothigh(high, self.param1, self.param1))
        self.pivot_low = self.I(lambda: pta.pivotlow(low, self.param1, self.param1))
        self.zones = self.I(lambda: self.add_levels(close))
        self.zones.sort_values(ascending=False, inplace=True)
        self.zones = self.zones.head(self.param3)
        self.merged_levels = self.I(lambda: self.merge_levels(self.zones, self.param4))
        self.touch_count = self.I(lambda: self.touch_count_levels(self.zones, self.param5))
        self.extended_levels = self.I(lambda: self.extend_levels(self.merged_levels, self.param6))
        self.near_resistance = self.I(lambda: self.near_resistance_level(close, self.extended_levels, self.param7))
        self.near_support = self.I(lambda: self.near_support_level(close, self.extended_levels, self.param7))

    def next(self):
        if self.near_resistance:
            self.sell()
        elif self.near_support:
            self.buy()

    def add_levels(self, close):
        levels = pd.DataFrame()
        if not pd.isna(self.pivot_high):
            levels = levels.append(pd.Series([self.pivot_high]), ignore_index=True)
        if not pd.isna(self.pivot_low):
            levels = levels.append(pd.Series([self.pivot_low]), ignore_index=True)
        return levels

    def merge_levels(self, levels, merge_dist_pct):
        merged_levels = pd.DataFrame()
        merge_dist = merge_dist_pct / 100.0
        for i in range(len(levels)):
            idx = -1
            for j in range(len(merged_levels)):
                if abs(merged_levels.iloc[j] - levels.iloc[i]) <= merge_dist:
                    idx = j
                    break
            if idx >= 0:
                merged_levels.iloc[idx] = (merged_levels.iloc[idx] * self.touch_count.iloc[idx] + levels.iloc[i]) / (self.touch_count.iloc[idx] + 1)
                self.touch_count.iloc[idx] += 1
            else:
                merged_levels = merged_levels.append(pd.Series([levels.iloc[i]]), ignore_index=True)
                self.touch_count = self.touch_count.append(pd.Series([1]), ignore_index=True)
        return merged_levels

    def touch_count_levels(self, levels, min_touches):
        touch_count = pd.Series([0] * len(levels))
        for i in range(len(levels)):
            touch_count.iloc[i] = self.touch_count.iloc[i] + 1 if i < len(self.touch_count) else 1
        touch_count = touch_count[touch_count >= min_touches]
        return touch_count

    def extend_levels(self, levels, extend_bars):
        extended_levels = pd.DataFrame()
        for i in range(len(levels)):
            extended_levels = extended_levels.append(pd.Series([levels.iloc[i]]), ignore_index=True)
        extended_levels = extended_levels.append(pd.Series([self.data.Close[-extend_bars]]), ignore_index=True)
        return extended_levels

    def near_resistance_level(self, close, levels, alert_prox):
        near_resistance = False
        alert_dist = close * alert_prox / 100.0
        for i in range(len(levels) - 1):
            if abs(close - levels.iloc[i]) <= alert_dist:
                near_resistance = True
                break
        return near_resistance

    def near_support_level(self, close, levels, alert_prox):
        near_support = False
        alert_dist = close * alert_prox / 100.0
        for i in range(len(levels) - 1):
            if abs(close - levels.iloc[i]) <= alert_dist:
                near_support = True
                break
        return near_support