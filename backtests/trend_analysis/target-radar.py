"""
DS-TV Backtest Results: target-radar
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — target-radar
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Forecast Engine
    h = 3
    lookback = 100
    wTrend = 0.30
    wMom = 0.30
    wVol = 0.20
    wVpr = 0.20
    retScale = 1.0

    # Uncertainty Band
    targetCov = 0.80
    resLookback = 200
    minHW = 0.005
    uncertTh = 0.08
    dirEps = 0.001

    # Signal Mode
    sigMode = "Breakout"
    minScore = 0.65

    # Signal Filters
    useConfGate = True
    useUncertGate = True
    useRegimeGate = True
    adxLen = 14
    trendTh = 25.0
    chopLen = 14
    chaosTh = 62.0

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)

        # EMA for trend
        self.emaF = self.I(pta.ema, close, length=10)
        self.emaS = self.I(pta.ema, close, length=20)

        # RSI for momentum
        self.rsi = self.I(pta.rsi, close, length=14)

        # ATR for volatility
        self.atr = self.I(pta.atr, high, low, close, length=14)

        # Volume metrics
        self.vol_sma_20 = self.I(pta.sma, volume, length=20)

        # EMA for signals
        self.ema9 = self.I(pta.ema, close, length=9)
        self.ema21 = self.I(pta.ema, close, length=21)

        # Bollinger Bands for mean reversion
        self.bb = self.I(pta.sma, close, length=20)
        bb_result = self.I(lambda: pta.bbands(close, length=20, std=2) or pd.DataFrame(index=close.index))
        self.bb_upper = bb_result['BBU_20_2.0'] if isinstance(bb_result, pd.DataFrame) and 'BBU_20_2.0' in bb_result.columns else self.I(lambda: pd.Series(0, index=close.index))
        self.bb_lower = bb_result['BBL_20_2.0'] if isinstance(bb_result, pd.DataFrame) and 'BBL_20_2.0' in bb_result.columns else self.I(lambda: pd.Series(0, index=close.index))

        # ADX for regime
        adx_result = self.I(lambda: pta.adx(high, low, close, length=self.adxLen) or pd.DataFrame(index=close.index))
        self.adx = adx_result['ADX_14'] if isinstance(adx_result, pd.DataFrame) and 'ADX_14' in adx_result.columns else self.I(lambda: pd.Series(0, index=close.index))

        # Highest/Lowest for breakout
        self.highest_20 = self.I(lambda: pd.Series(high).rolling(window=20).max())
        self.lowest_20 = self.I(lambda: pd.Series(low).rolling(window=20).min())

    def next(self):
        if len(self) < self.h + max(self.lookback, self.resLookback):
            return

        # Current values
        close_val = self.data.Close[-1]
        high_val = self.data.High[-1]
        low_val = self.data.Low[-1]
        volume_val = self.data.Volume[-1]

        emaF_val = self.emaF[-1]
        emaS_val = self.emaS[-1]
        rsi_val = self.rsi[-1]
        atr_val = self.atr[-1]
        ema9_val = self.ema9[-1]
        ema21_val = self.ema21[-1]
        vol_sma_val = self.vol_sma_20[-1]
        highest_20_val = self.highest_20[-1]
        lowest_20_val = self.lowest_20[-1]
        adx_val = self.adx[-1] if not np.isnan(self.adx[-1]) else 0

        # Trend signal (Trend Pullback mode)
        trend_up = emaF_val > emaS_val
        trend_down = emaF_val < emaS_val
        rsi_oversold = rsi_val < 30
        rsi_overbought = rsi_val > 70

        tp_long = trend_up and rsi_oversold and close_val > emaF_val
        tp_short = trend_down and rsi_overbought and close_val < emaF_val

        # Breakout signal
        vol_ok = volume_val > vol_sma_val * 1.3
        bo_long = close_val > highest_20_val and vol_ok
        bo_short = close_val < lowest_20_val and vol_ok

        # Mean reversion signal
        bb_mid = self.bb[-1]
        bb_std = np.std(self.data.Close[-20:]) if len(self) >= 20 else 0
        if bb_std > 0:
            z_price = (close_val - bb_mid) / bb_std
        else:
            z_price = 0
        mr_long = z_price < -2.0 and crossover(pd.Series([z_price]), pd.Series([-2.0]))
        mr_short = z_price > 2.0 and crossover(pd.Series([2.0]), pd.Series([z_price]))

        # EMA Cross signal
        ema_long = crossover(self.ema9, self.ema21)
        ema_short = crossover(self.ema21, self.ema9)

        # Select signal based on mode
        if self.sigMode == "Trend Pullback":
            base_long = tp_long
            base_short = tp_short
        elif self.sigMode == "Breakout":
            base_long = bo_long
            base_short = bo_short
        elif self.sigMode == "Mean Reversion":
            base_long = mr_long
            base_short = mr_short
        else:  # EMA Cross
            base_long = ema_long
            base_short = ema_short

        # Regime filter (simplified)
        is_trending = adx_val > self.trendTh
        regime_ok = True
        if self.useRegimeGate:
            if self.sigMode == "Mean Reversion" and is_trending:
                regime_ok = False

        # Combined signal
        sig_long = base_long and regime_ok
        sig_short = base_short and regime_ok

        # Entry logic
        if sig_long and not self.position:
            self.buy()
        elif sig_short and self.position:
            self.sell()