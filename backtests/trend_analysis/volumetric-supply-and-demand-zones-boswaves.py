"""
DS-TV Backtest Results: volumetric-supply-and-demand-zones-boswaves
============================================================

--- SPY ---
  Return                    0.00%
  Buy & Hold Return         43.17%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- BTC ---
  Return                    0.00%
  Buy & Hold Return         -2.17%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- QQQ ---
  Return                    0.00%
  Buy & Hold Return         43.14%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” volumetric-supply-and-demand-zones-boswaves
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    swing_len = 8
    impulse_mult = 1.2
    base_lookback = 3
    atr_length = 14
    max_zone_atr = 4.0
    merge_gap_atr = 0.3

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        self.atr = self.I(pta.atr, high, low, close, length=self.atr_length)
        
        self.pivot_high = self.I(self._pivot_high, high, self.swing_len)
        self.pivot_low = self.I(self._pivot_low, low, self.swing_len)
        
        self.demand_zones = []
        self.supply_zones = []
        self.last_zone_bar = -1

    def _pivot_high(self, high, period):
        result = np.full(len(high), np.nan)
        for i in range(period, len(high) - period):
            if high.iloc[i] == high.iloc[i-period:i+period+1].max():
                result[i] = high.iloc[i]
        return pd.Series(result)

    def _pivot_low(self, low, period):
        result = np.full(len(low), np.nan)
        for i in range(period, len(low) - period):
            if low.iloc[i] == low.iloc[i-period:i+period+1].min():
                result[i] = low.iloc[i]
        return pd.Series(result)

    def _is_impulse_up(self, bar_offset):
        if len(self.data) <= bar_offset:
            return False
        current_close = self.data.Close[-1]
        past_close = self.data.Close[-1 - bar_offset]
        move = current_close - past_close
        atr_val = self.atr[-1] if not np.isnan(self.atr[-1]) else 1.0
        return move >= atr_val * self.impulse_mult

    def _is_impulse_down(self, bar_offset):
        if len(self.data) <= bar_offset:
            return False
        current_close = self.data.Close[-1]
        past_close = self.data.Close[-1 - bar_offset]
        move = past_close - current_close
        atr_val = self.atr[-1] if not np.isnan(self.atr[-1]) else 1.0
        return move >= atr_val * self.impulse_mult

    def _create_zone(self, is_demand, pivot_bar_offset):
        if len(self.data) < pivot_bar_offset + self.base_lookback:
            return None
        
        end_idx = len(self.data) - 1 - pivot_bar_offset
        start_idx = end_idx - self.base_lookback
        
        if end_idx < 0 or start_idx < 0:
            return None
        
        raw_top = self.data.High[end_idx]
        raw_bottom = self.data.Low[end_idx]
        
        for i in range(max(0, start_idx), min(len(self.data), end_idx + 1)):
            raw_top = max(raw_top, self.data.High[i])
            raw_bottom = min(raw_bottom, self.data.Low[i])
        
        zone_height = raw_top - raw_bottom
        atr_val = self.atr[-1] if not np.isnan(self.atr[-1]) else 1.0
        max_height = atr_val * self.max_zone_atr
        
        if zone_height > max_height:
            mid = (raw_top + raw_bottom) / 2
            raw_top = mid + (max_height / 2)
            raw_bottom = mid - (max_height / 2)
        
        return {
            'is_demand': is_demand,
            'top': raw_top,
            'bottom': raw_bottom,
            'bar_created': len(self.data) - 1,
            'touches': 0,
            'mitigated': False
        }

    def _zones_overlap(self, zone_a, zone_b, gap):
        exp_top_a = zone_a['top'] + gap
        exp_btm_a = zone_a['bottom'] - gap
        exp_top_b = zone_b['top'] + gap
        exp_btm_b = zone_b['bottom'] - gap
        return (exp_btm_a <= exp_top_b) and (exp_top_a >= exp_btm_b)

    def _merge_zones(self, new_zone, existing_zones):
        atr_val = self.atr[-1] if not np.isnan(self.atr[-1]) else 1.0
        gap = atr_val * self.merge_gap_atr
        
        for i in range(len(existing_zones) - 1, -1, -1):
            existing = existing_zones[i]
            if existing['is_demand'] == new_zone['is_demand']:
                if self._zones_overlap(existing, new_zone, gap):
                    existing['top'] = max(existing['top'], new_zone['top'])
                    existing['bottom'] = min(existing['bottom'], new_zone['bottom'])
                    existing['touches'] += 1
                    return True
        return False

    def next(self):
        if len(self.data) < self.swing_len + self.base_lookback:
            return
        
        atr_val = self.atr[-1] if not np.isnan(self.atr[-1]) else 1.0
        
        new_demand = not np.isnan(self.pivot_low[-1]) and self._is_impulse_up(self.swing_len)
        new_supply = not np.isnan(self.pivot_high[-1]) and self._is_impulse_down(self.swing_len)
        
        if new_demand:
            new_zone = self._create_zone(True, self.swing_len)
            if new_zone:
                if not self._merge_zones(new_zone, self.demand_zones):
                    self.demand_zones.append(new_zone)
        
        if new_supply:
            new_zone = self._create_zone(False, self.swing_len)
            if new_zone:
                if not self._merge_zones(new_zone, self.supply_zones):
                    self.supply_zones.append(new_zone)
        
        current_high = self.data.High[-1]
        current_low = self.data.Low[-1]
        current_close = self.data.Close[-1]
        
        for zone in self.demand_zones[:]:
            if not zone['mitigated']:
                in_zone = current_high >= zone['bottom'] and current_low <= zone['top']
                if in_zone:
                    zone['touches'] += 1
                
                if current_low < zone['bottom']:
                    zone['mitigated'] = True
                    if not self.position:
                        self.buy()
        
        for zone in self.supply_zones[:]:
            if not zone['mitigated']:
                in_zone = current_high >= zone['bottom'] and current_low <= zone['top']
                if in_zone:
                    zone['touches'] += 1
                
                if current_high > zone['top']:
                    zone['mitigated'] = True
                    if self.position:
                        self.sell()
        
        self.demand_zones = [z for z in self.demand_zones if not z['mitigated']]
        self.supply_zones = [z for z in self.supply_zones if not z['mitigated']]


if __name__ == '__main__':
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()