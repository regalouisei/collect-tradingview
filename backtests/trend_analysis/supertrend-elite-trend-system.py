"""
DS-TV Backtest Results: supertrend-elite-trend-system
============================================================

--- SPY ---
  ERROR: Indicator "calc_alma" error. See traceback above.

--- BTC ---
  ERROR: Indicator "calc_alma" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "calc_alma" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” supertrend-elite-trend-system
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Supertrend parameters
    atrPeriod = 10
    atrMultiplier = 3.0
    
    # ALMA parameters
    almaLength = 82
    almaOffset = 0.7
    almaSigma = 3.8
    
    # CTI parameters
    ctiLength = 45
    ctiThreshold = 0.3
    
    # STC parameters
    stcFastLength = 21
    stcSlowLength = 50
    
    # Gunxo parameters
    gunxoLength1 = 56
    gunxoLength2 = 56
    
    # DEMA DMI parameters
    demaLength = 50
    dmiLength1 = 14
    dmiLength2 = 14
    
    # MM parameters
    mmLength = 13
    mmThreshold = 70
    
    # DMI Loop parameters
    dmiLoopLength = 15
    dmiLoopEma = 15
    dmiLoopSlow = 44
    dmiLoopUpperThreshold = 0.25
    dmiLoopLowerThreshold = -0.25
    
    # Trend Oscillator parameters
    toLength = 12
    
    # Stoch parameters
    stochD = 5
    stochThreshold = 50
    stochEmaLength = 50
    stochLowerThreshold = -0.5
    stochNeutralThreshold = 0.1

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Supertrend calculation
        def calc_supertrend():
            atr = pta.atr(high, low, close, length=self.atrPeriod)
            hl2 = (high + low) / 2
            basic_ub = hl2 + self.atrMultiplier * atr
            basic_lb = hl2 - self.atrMultiplier * atr
            
            final_ub = pd.Series(index=close.index, dtype=float)
            final_lb = pd.Series(index=close.index, dtype=float)
            
            for i in range(len(close)):
                if i == 0:
                    final_ub.iloc[i] = basic_ub.iloc[i]
                    final_lb.iloc[i] = basic_lb.iloc[i]
                else:
                    final_ub.iloc[i] = basic_ub.iloc[i] if basic_ub.iloc[i] < final_ub.iloc[i-1] or close.iloc[i-1] > final_ub.iloc[i-1] else final_ub.iloc[i-1]
                    final_lb.iloc[i] = basic_lb.iloc[i] if basic_lb.iloc[i] > final_lb.iloc[i-1] or close.iloc[i-1] < final_lb.iloc[i-1] else final_lb.iloc[i-1]
            
            supertrend = pd.Series(index=close.index, dtype=float)
            direction = pd.Series(index=close.index, dtype=float)
            
            for i in range(len(close)):
                if i == 0:
                    supertrend.iloc[i] = final_ub.iloc[i]
                    direction.iloc[i] = -1
                else:
                    if supertrend.iloc[i-1] == final_ub.iloc[i-1]:
                        supertrend.iloc[i] = final_ub.iloc[i] if close.iloc[i] <= final_ub.iloc[i] else final_lb.iloc[i]
                        direction.iloc[i] = -1 if close.iloc[i] <= final_ub.iloc[i] else 1
                    else:
                        supertrend.iloc[i] = final_lb.iloc[i] if close.iloc[i] >= final_lb.iloc[i] else final_ub.iloc[i]
                        direction.iloc[i] = 1 if close.iloc[i] >= final_lb.iloc[i] else -1
            
            return supertrend, direction
        
        self.supertrend, self.direction = self.I(calc_supertrend)
        
        # ALMA calculation
        def calc_alma():
            return pta.alma(close, length=self.almaLength, offset=self.almaOffset, sigma=self.almaSigma) or pd.Series(0, index=close.index)
        self.alma = self.I(calc_alma)
        
        # CTI calculation
        def calc_cti():
            cti_values = pd.Series(index=close.index, dtype=float)
            std_close = close.rolling(window=self.ctiLength).std()
            for i in range(len(close)):
                if i < self.ctiLength - 1:
                    cti_values.iloc[i] = 0
                else:
                    cti_sum = sum(close.iloc[i-j] - close.iloc[i-self.ctiLength] for j in range(self.ctiLength))
                    if std_close.iloc[i] != 0:
                        cti_values.iloc[i] = cti_sum / (self.ctiLength * std_close.iloc[i])
                    else:
                        cti_values.iloc[i] = 0
            return cti_values
        self.cti = self.I(calc_cti)
        
        # STC calculation
        self.stc_fast = self.I(pta.ema, close, length=self.stcFastLength)
        self.stc_slow = self.I(pta.ema, close, length=self.stcSlowLength)
        
        # Gunxo calculation
        self.gunxo_ema1 = self.I(pta.ema, close, length=self.gunxoLength1)
        self.gunxo_ema2 = self.I(pta.ema, close, length=self.gunxoLength2)
        
        # DEMA calculation
        def calc_dema():
            ema1 = pta.ema(close, length=self.demaLength)
            ema2 = pta.ema(ema1, length=self.demaLength)
            return 2 * ema1 - ema2
        self.dema = self.I(calc_dema)
        
        # DMI calculation
        def calc_dmi():
            adx_result = pta.adx(high, low, close, length=self.dmiLength1)
            if adx_result is None:
                return pd.Series(0, index=close.index), pd.Series(0, index=close.index), pd.Series(0, index=close.index)
            di_plus = adx_result.iloc[:, 0]
            di_minus = adx_result.iloc[:, 1]
            adx = adx_result.iloc[:, 2]
            return di_plus, di_minus, adx
        self.di_plus, self.di_minus, self.adx = self.I(calc_dmi)
        
        # MM calculation
        def calc_mm():
            mm_ema = pta.ema(close, length=self.mmLength)
            mm_high = high.rolling(window=self.mmLength).max()
            mm_low = low.rolling(window=self.mmLength).min()
            mm_range = mm_high - mm_low
            mm_percent = ((close - mm_low) / (mm_range + 1e-10)) * 100
            return mm_ema, mm_percent
        self.mm_ema, self.mm_percent = self.I(calc_mm)
        
        # DMI Loop calculation
        def calc_dmi_loop():
            adx_result = pta.adx(high, low, close, length=self.dmiLoopLength)
            if adx_result is None:
                di_plus2 = pd.Series(0, index=close.index)
                di_minus2 = pd.Series(0, index=close.index)
            else:
                di_plus2 = adx_result.iloc[:, 0]
                di_minus2 = adx_result.iloc[:, 1]
            
            dmi_diff = (di_plus2 - di_minus2) / 100
            dmi_diff_ema = pta.ema(dmi_diff, length=self.dmiLoopEma)
            return dmi_diff_ema
        self.dmi_diff_ema = self.I(calc_dmi_loop)
        
        # Trend Oscillator calculation
        def calc_to():
            to_fast = pta.ema(close, length=self.toLength)
            to_slow = pta.ema(close, length=self.toLength * 2)
            to_osc = ((to_fast - to_slow) / (to_slow + 1e-10)) * 100
            return to_osc
        self.to_oscillator = self.I(calc_to)
        
        # Stoch calculation
        def calc_stoch():
            stoch_result = pta.stoch(high, low, close, k=self.stochD, d=self.stochD)
            if stoch_result is None or stoch_result.empty:
                return pd.Series(50, index=close.index)
            return stoch_result.iloc[:, 0]
        self.stoch_value = self.I(calc_stoch)
        
        self.trend_confirmation = 0
        self.final_trend = 0

    def next(self):
        # Calculate signals
        supertrend_signal = 1 if self.direction[-1] < 0 else (-1 if self.direction[-1] > 0 else 0)
        alma_signal = 1 if self.data.Close[-1] > self.alma[-1] else (-1 if self.data.Close[-1] < self.alma[-1] else 0)
        cti_signal = 1 if self.cti[-1] > self.ctiThreshold else (-1 if self.cti[-1] < -self.ctiThreshold else 0)
        stc_signal = 1 if self.stc_fast[-1] > self.stc_slow[-1] else (-1 if self.stc_fast[-1] < self.stc_slow[-1] else 0)
        gunxo_signal = 1 if (self.data.Close[-1] > self.gunxo_ema1[-1] and self.data.Close[-1] > self.gunxo_ema2[-1]) else (-1 if (self.data.Close[-1] < self.gunxo_ema1[-1] and self.data.Close[-1] < self.gunxo_ema2[-1]) else 0)
        dema_dmi_signal = 1 if (self.data.Close[-1] > self.dema[-1] and self.di_plus[-1] > self.di_minus[-1]) else (-1 if (self.data.Close[-1] < self.dema[-1] and self.di_minus[-1] > self.di_plus[-1]) else 0)
        mm_signal = 1 if (self.mm_percent[-1] > self.mmThreshold and self.data.Close[-1] > self.mm_ema[-1]) else (-1 if (self.mm_percent[-1] < (100 - self.mmThreshold) and self.data.Close[-1] < self.mm_ema[-1]) else 0)
        dmi_loop_signal = 1 if self.dmi_diff_ema[-1] > self.dmiLoopUpperThreshold else (-1 if self.dmi_diff_ema[-1] < self.dmiLoopLowerThreshold else 0)
        to_signal = 1 if self.to_oscillator[-1] > 0 else (-1 if self.to_oscillator[-1] < 0 else 0)
        stoch_normalized = (self.stoch_value[-1] - 50) / 50
        stoch_signal = 1 if (self.stoch_value[-1] > self.stochThreshold and stoch_normalized > self.stochNeutralThreshold) else (-1 if (self.stoch_value[-1] < self.stochThreshold and stoch_normalized < self.stochLowerThreshold) else 0)
        
        # Calculate scores
        bullish_score = (1 if supertrend_signal == 1 else 0) + (2 if alma_signal == 1 else 0) + (1 if cti_signal == 1 else 0) + (2 if stc_signal == 1 else 0) + (1 if gunxo_signal == 1 else 0) + (2 if dema_dmi_signal == 1 else 0) + (1 if mm_signal == 1 else 0) + (1 if dmi_loop_signal == 1 else 0) + (1 if to_signal == 1 else 0) + (1 if stoch_signal == 1 else 0)
        bearish_score = (1 if supertrend_signal == -1 else 0) + (2 if alma_signal == -1 else 0) + (1 if cti_signal == -1 else 0) + (2 if stc_signal == -1 else 0) + (1 if gunxo_signal == -1 else 0) + (2 if dema_dmi_signal == -1 else 0) + (1 if mm_signal == -1 else 0) + (1 if dmi_loop_signal == -1 else 0) + (1 if to_signal == -1 else 0) + (1 if stoch_signal == -1 else 0)
        
        score_diff = bullish_score - bearish_score
        
        # Determine raw trend
        if score_diff > 4:
            raw_trend = 2
        elif score_diff > 1:
            raw_trend = 1
        elif score_diff < -4:
            raw_trend = -2
        elif score_diff < -1:
            raw_trend = -1
        else:
            raw_trend = 0
        
        # Trend confirmation logic
        if raw_trend > 0:
            self.trend_confirmation = self.trend_confirmation + 1 if self.trend_confirmation >= 0 else 0
        elif raw_trend < 0:
            self.trend_confirmation = self.trend_confirmation - 1 if self.trend_confirmation <= 0 else 0
        else:
            self.trend_confirmation = 0
        
        confirmed_trend = raw_trend if abs(self.trend_confirmation) >= 2 else 0
        
        # Persist trend
        if confirmed_trend != 0:
            self.final_trend = confirmed_trend
        
        # Entry/Exit logic
        if self.final_trend == 2 or self.final_trend == 1:
            if not self.position:
                self.buy()
        elif self.final_trend == -2 or self.final_trend == -1:
            if self.position:
                self.position.close()