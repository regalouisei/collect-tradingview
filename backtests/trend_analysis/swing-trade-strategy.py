"""
DS-TV Backtest Results: swing-trade-strategy
============================================================

--- SPY ---
  ERROR: Indicator "dema_dmi_…" error. See traceback above.

--- BTC ---
  ERROR: Indicator "dema_dmi_…" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "dema_dmi_…" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — swing-trade-strategy
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # INDIKATOR 1: RMI TREND SNIPER
        rmiLength = 8
        change_close = close.diff()
        rmi_up = change_close.clip(lower=0).ewm(span=rmiLength, adjust=False).mean()
        rmi_down = (-change_close.clip(upper=0)).ewm(span=rmiLength, adjust=False).mean()
        rmi_value = 100 - (100 / (1 + rmi_up / (rmi_down + 1e-9)))
        ema5 = pta.ema(close, length=5)
        ema5_change = ema5.diff()
        
        def rmi_signal_calc():
            rmi_pos = (rmi_value > rmi_value.shift(1)) & (ema5_change > 0)
            rmi_neg = (rmi_value < rmi_value.shift(1)) & (ema5_change < 0)
            return np.where(rmi_pos, 1, np.where(rmi_neg, -1, 0))
        
        self.rmi_signal = self.I(rmi_signal_calc)
        
        # INDIKATOR 2: ALMA SMOOTH
        almaLength = 82
        almaOffset = 0.7
        almaSigma = 3.8
        alma_value = self.I(pta.alma, close, length=almaLength, phase=almaOffset, volatility=almaSigma)
        
        def alma_signal_calc():
            return np.where(close > alma_value, 1, np.where(close < alma_value, -1, 0))
        
        self.alma_signal = self.I(alma_signal_calc)
        
        # INDIKATOR 3: CTI
        ctiLength = 45
        ctiThreshold = 0.3
        
        def cti_calc():
            cti_values = []
            for i in range(len(close)):
                if i < ctiLength:
                    cti_values.append(0)
                else:
                    cti_sum = (close.iloc[i-ctiLength:i] - close.iloc[i-ctiLength]).sum()
                    cti_std = close.iloc[i-ctiLength:i].std()
                    cti_val = cti_sum / (ctiLength * (cti_std + 1e-9))
                    cti_values.append(cti_val)
            return np.array(cti_values)
        
        cti_value = self.I(cti_calc)
        
        def cti_signal_calc():
            return np.where(cti_value > ctiThreshold, 1, np.where(cti_value < -ctiThreshold, -1, 0))
        
        self.cti_signal = self.I(cti_signal_calc)
        
        # INDIKATOR 4: SEBASTINE TREND CATCHER
        stcFastLength = 21
        stcSlowLength = 50
        stc_fast_ema = pta.ema(close, length=stcFastLength)
        stc_slow_ema = pta.ema(close, length=stcSlowLength)
        
        def stc_signal_calc():
            return np.where(stc_fast_ema > stc_slow_ema, 1, np.where(stc_fast_ema < stc_slow_ema, -1, 0))
        
        self.stc_signal = self.I(stc_signal_calc)
        
        # INDIKATOR 5: GUNXO TREND SNIPER
        gunxoLength1 = 56
        gunxoLength2 = 56
        gunxo_ema1 = pta.ema(close, length=gunxoLength1)
        gunxo_ema2 = pta.ema(close, length=gunxoLength2)
        
        def gunxo_signal_calc():
            return np.where((close > gunxo_ema1) & (close > gunxo_ema2), 1, 
                           np.where((close < gunxo_ema1) & (close < gunxo_ema2), -1, 0))
        
        self.gunxo_signal = self.I(gunxo_signal_calc)
        
        # INDIKATOR 6: DEMA DMI
        demaLength = 50
        dmiLength1 = 14
        dmiLength2 = 14
        ema1_dema = pta.ema(close, length=demaLength)
        ema2_dema = pta.ema(ema1_dema, length=demaLength)
        dema_value = 2 * ema1_dema - ema2_dema
        
        dmi_result = self.I(pta.adx, high, low, close, length=dmiLength1)
        
        def dema_dmi_signal_calc():
            di_plus = dmi_result.iloc[:, 0] if dmi_result.shape[1] > 0 else pd.Series(0, index=close.index)
            di_minus = dmi_result.iloc[:, 1] if dmi_result.shape[1] > 1 else pd.Series(0, index=close.index)
            return np.where((close > dema_value) & (di_plus > di_minus), 1,
                           np.where((close < dema_value) & (di_minus > di_plus), -1, 0))
        
        self.dema_dmi_signal = self.I(dema_dmi_signal_calc)
        
        # INDIKATOR 7: MM FOR LOOP
        mmLength = 13
        mmThreshold = 70
        mm_ema = pta.ema(close, length=mmLength)
        mm_high = high.rolling(window=mmLength).max()
        mm_low = low.rolling(window=mmLength).min()
        mm_percent = ((close - mm_low) / (mm_high - mm_low + 1e-9)) * 100
        
        def mm_signal_calc():
            return np.where((mm_percent > mmThreshold) & (close > mm_ema), 1,
                           np.where((mm_percent < (100 - mmThreshold)) & (close < mm_ema), -1, 0))
        
        self.mm_signal = self.I(mm_signal_calc)
        
        # INDIKATOR 8: DMI FOR LOOP
        dmiLoopLength = 15
        dmiLoopEma = 15
        dmiLoopSlow = 44
        dmiLoopUpperThreshold = 0.25
        dmiLoopLowerThreshold = -0.25
        
        dmi_loop_result = self.I(pta.adx, high, low, close, length=dmiLoopLength)
        
        def dmi_loop_signal_calc():
            di_plus_loop = dmi_loop_result.iloc[:, 0] if dmi_loop_result.shape[1] > 0 else pd.Series(0, index=close.index)
            di_minus_loop = dmi_loop_result.iloc[:, 1] if dmi_loop_result.shape[1] > 1 else pd.Series(0, index=close.index)
            dmi_diff = (di_plus_loop - di_minus_loop) / 100
            dmi_diff_ema = pta.ema(dmi_diff, length=dmiLoopEma)
            return np.where(dmi_diff_ema > dmiLoopUpperThreshold, 1,
                           np.where(dmi_diff_ema < dmiLoopLowerThreshold, -1, 0))
        
        self.dmi_loop_signal = self.I(dmi_loop_signal_calc)
        
        # INDIKATOR 9: TREND OSCILLATOR
        toLength = 12
        to_fast = pta.ema(close, length=toLength)
        to_slow = pta.ema(close, length=toLength * 2)
        to_oscillator = ((to_fast - to_slow) / (to_slow + 1e-9)) * 100
        
        def to_signal_calc():
            return np.where(to_oscillator > 0, 1, np.where(to_oscillator < 0, -1, 0))
        
        self.to_signal = self.I(to_signal_calc)
        
        # INDIKATOR 10: STOCH FOR LOOP
        stochD = 5
        stochThreshold = 50
        stochEmaLength = 50
        stochLowerThreshold = -0.5
        stochNeutralThreshold = 0.1
        
        stoch_result = self.I(pta.stoch, high, low, close, k=stochD, d=stochD)
        
        def stoch_signal_calc():
            stoch_val = stoch_result.iloc[:, 0] if stoch_result.shape[1] > 0 else pd.Series(50, index=close.index)
            stoch_ema = pta.ema(stoch_val, length=stochEmaLength)
            stoch_normalized = (stoch_val - 50) / 50
            return np.where((stoch_val > stochThreshold) & (stoch_normalized > stochNeutralThreshold), 1,
                           np.where((stoch_val < stochThreshold) & (stoch_normalized < stochLowerThreshold), -1, 0))
        
        self.stoch_signal = self.I(stoch_signal_calc)
    
    def next(self):
        # Calculate scores
        bullish_score = (
            (1 if self.rmi_signal[-1] == 1 else 0) +
            (2 if self.alma_signal[-1] == 1 else 0) +
            (1 if self.cti_signal[-1] == 1 else 0) +
            (2 if self.stc_signal[-1] == 1 else 0) +
            (1 if self.gunxo_signal[-1] == 1 else 0) +
            (2 if self.dema_dmi_signal[-1] == 1 else 0) +
            (1 if self.mm_signal[-1] == 1 else 0) +
            (1 if self.dmi_loop_signal[-1] == 1 else 0) +
            (1 if self.to_signal[-1] == 1 else 0) +
            (1 if self.stoch_signal[-1] == 1 else 0)
        )
        
        bearish_score = (
            (1 if self.rmi_signal[-1] == -1 else 0) +
            (2 if self.alma_signal[-1] == -1 else 0) +
            (1 if self.cti_signal[-1] == -1 else 0) +
            (2 if self.stc_signal[-1] == -1 else 0) +
            (1 if self.gunxo_signal[-1] == -1 else 0) +
            (2 if self.dema_dmi_signal[-1] == -1 else 0) +
            (1 if self.mm_signal[-1] == -1 else 0) +
            (1 if self.dmi_loop_signal[-1] == -1 else 0) +
            (1 if self.to_signal[-1] == -1 else 0) +
            (1 if self.stoch_signal[-1] == -1 else 0)
        )
        
        score_diff = bullish_score - bearish_score
        
        raw_trend = (2 if score_diff > 4 else 1 if score_diff > 1 else 
                     -2 if score_diff < -4 else -1 if score_diff < -1 else 0)
        
        if not hasattr(self, 'trend_confirmation'):
            self.trend_confirmation = 0
            self.final_trend = 0
        
        if raw_trend > 0:
            self.trend_confirmation = self.trend_confirmation + 1 if self.trend_confirmation >= 0 else 0
        elif raw_trend < 0:
            self.trend_confirmation = self.trend_confirmation - 1 if self.trend_confirmation <= 0 else 0
        else:
            self.trend_confirmation = 0
        
        confirmed_trend = raw_trend if abs(self.trend_confirmation) >= 2 else 0
        
        if confirmed_trend != 0:
            self.final_trend = confirmed_trend
        
        prev_final_trend = getattr(self, 'prev_final_trend', 0)
        
        buy_signal = self.final_trend >= 1 and prev_final_trend <= 0
        sell_signal = self.final_trend <= 0 and prev_final_trend >= 1
        
        if buy_signal and not self.position:
            self.buy()
        
        if sell_signal and self.position:
            self.position.close()
        
        self.prev_final_trend = self.final_trend


if __name__ == '__main__':
    bt = Backtest(None, TvStrategy, cash=10000, commission=0.001)