"""
DS-TV Backtest Results: gcm-volume-price-essence
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — gcm-volume-price-essence
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lengthFast = 8
    lengthSlow = 21
    lengthVolume = 14
    volImpact = 1.5
    smoothing = 5
    finalSmoothing = 3
    signalPeriod = 12
    divLookback = 3

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # Volume Ratio
        sma_vol_3 = self.I(pta.sma, volume, length=3)
        sma_vol_len = self.I(pta.sma, volume, length=self.lengthVolume)
        self.volumeRatio = self.I(lambda: sma_vol_3 / sma_vol_len.replace(0, 1))
        
        # Price Change
        self.priceChange = self.I(lambda: close.diff())
        
        # Volume Weighted Momentum
        self.volumeWeightedMomentum = self.I(
            lambda: self.priceChange * np.log(1 + (self.volumeRatio * self.volImpact))
        )
        
        # Fast and Slow Flow
        self.fastFlow = self.I(pta.ema, self.volumeWeightedMomentum, length=self.lengthFast)
        self.slowFlow = self.I(pta.ema, self.volumeWeightedMomentum, length=self.lengthSlow)
        
        # Quantum Flow
        flowDiff = self.I(lambda: self.fastFlow - self.slowFlow)
        self.quantumFlow = self.I(pta.ema, flowDiff, length=self.smoothing)
        
        # Price Velocity and Acceleration
        self.priceVelocity = self.I(
            lambda: (close - close.shift(self.lengthFast)) / self.lengthFast
        )
        self.priceAcceleration = self.I(lambda: self.priceVelocity.diff())
        
        # Flow Strength
        flowStrengthRaw = self.I(
            lambda: (self.priceVelocity * self.volumeRatio + self.priceAcceleration) * 100
        )
        self.flowStrength = self.I(pta.ema, flowStrengthRaw, length=self.smoothing)
        
        # Trend Pressure
        rsi_fast = self.I(pta.rsi, close, length=self.lengthFast)
        trendPressureRaw = self.I(lambda: rsi_fast - 50)
        self.trendPressure = self.I(pta.ema, trendPressureRaw, length=self.smoothing)
        
        # Composite Index
        rawComposite = self.I(
            lambda: (self.quantumFlow * 50 + self.flowStrength + self.trendPressure) / 3
        )
        self.compositeIndex = self.I(pta.wma, rawComposite, length=self.finalSmoothing)
        
        # Base Line
        self.baseLine = self.I(pta.ema, self.compositeIndex, length=self.signalPeriod)
        
        # Dynamic Zones
        def calc_zones():
            highest_50 = self.compositeIndex.rolling(window=50).max().shift(1)
            lowest_50 = self.compositeIndex.rolling(window=50).min().shift(1)
            volatilityFactor = (highest_50 - lowest_50) / 2
            upperZone = np.minimum(60, 30 + volatilityFactor * 0.3)
            lowerZone = np.maximum(-60, -30 - volatilityFactor * 0.3)
            return upperZone, lowerZone
        
        self.upperZone = self.I(lambda: calc_zones()[0])
        self.lowerZone = self.I(lambda: calc_zones()[1])
        
        # Anticipation Signals
        self.flowCross = self.I(
            lambda: crossover(self.fastFlow, self.slowFlow)
        )
        
        self.momentumBuilding = self.I(
            lambda: (self.compositeIndex > self.compositeIndex.shift(1)) & 
                    (self.compositeIndex > self.compositeIndex.shift(2)) & 
                    (self.compositeIndex < -20)
        )
        
        self.momentumFading = self.I(
            lambda: (self.compositeIndex < self.compositeIndex.shift(1)) & 
                    (self.compositeIndex < self.compositeIndex.shift(2)) & 
                    (self.compositeIndex > 20)
        )
        
        self.bullishAnticipation = self.I(
            lambda: self.flowCross & (self.fastFlow > self.slowFlow) & (self.compositeIndex < 0)
        )
        
        self.bearishAnticipation = self.I(
            lambda: self.flowCross & (self.fastFlow < self.slowFlow) & (self.compositeIndex > 0)
        )
        
        self.bullishContinuation = self.I(
            lambda: self.momentumBuilding & (self.volumeRatio > 1.2)
        )
        
        self.bearishContinuation = self.I(
            lambda: self.momentumFading & (self.volumeRatio > 1.2)
        )
        
        # Divergence Logic
        def calc_divergence():
            pricePushingDown = (low < low.shift(1)) & (low.shift(1) < low.shift(2))
            pricePushingUp = (high > high.shift(1)) & (high.shift(1) > high.shift(2))
            
            indRising = self.compositeIndex > self.compositeIndex.shift(1)
            indFalling = self.compositeIndex < self.compositeIndex.shift(1)
            
            divBull = pricePushingDown & indRising
            divBear = pricePushingUp & indFalling
            
            return divBull, divBear
        
        self.divBull = self.I(lambda: calc_divergence()[0])
        self.divBear = self.I(lambda: calc_divergence()[1])
        
        # Crossover with Base Line
        self.compositeAboveBase = self.I(
            lambda: crossover(self.compositeIndex, self.baseLine)
        )
        
        self.compositeBelowBase = self.I(
            lambda: crossover(self.baseLine, self.compositeIndex)
        )

    def next(self):
        if len(self.data) < max(self.lengthFast, self.lengthSlow, self.signalPeriod) + 10:
            return
        
        bullish_signal = False
        bearish_signal = False
        
        # Check for bullish signals
        if self.bullishAnticipation[-1] or self.bullishContinuation[-1] or self.divBull[-1]:
            bullish_signal = True
        
        # Check for bearish signals
        if self.bearishAnticipation[-1] or self.bearishContinuation[-1] or self.divBear[-1]:
            bearish_signal = True
        
        # Entry logic
        if bullish_signal and not self.position:
            self.buy()
        elif bearish_signal and self.position:
            self.position.close()
        
        # Exit logic based on baseline crossover
        if self.position and self.compositeBelowBase[-1]:
            self.position.close()
        elif not self.position and self.compositeAboveBase[-1] and not bearish_signal:
            self.buy()