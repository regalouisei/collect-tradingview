"""
DS-TV Backtest Results: game-theory-ema-with-an-alternate-strategy
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — game-theory-ema-with-an-alternate-strategy
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # EMA Settings
    emaFast = 9
    emaSlow = 21
    emaTrend = 50
    
    # Game Theory Settings
    gtPeriod = 14
    nashFilter = True
    utilityFilter = True
    minUtilityGap = 0.15
    
    # Risk Management
    riskRewardRatio = 1.5
    atrPeriod = 14
    atrMultiplier = 1.2
    maxDailyLoss = 2.0
    
    # Trade Filters
    useADXFilter = True
    adxThreshold = 20
    useVolumeFilter = True
    volumeThreshold = 1.2
    useRSIFilter = True
    
    # Trade Management
    maxTradesPerDay = 5
    useTimeFilter = False
    startHour = 9
    endHour = 20

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # EMAs
        self.ema_fast = self.I(pta.ema, close, length=self.emaFast)
        self.ema_slow = self.I(pta.ema, close, length=self.emaSlow)
        self.ema_trend = self.I(pta.ema, close, length=self.emaTrend)
        
        # ATR
        self.atr = self.I(pta.atr, high, low, close, length=self.atrPeriod)
        
        # ADX
        adx_result = self.I(lambda: pta.adx(high, low, close, length=14) or pd.DataFrame(index=close.index))
        self.adx = self.I(lambda: adx_result['ADX_14'] if isinstance(adx_result, pd.DataFrame) and 'ADX_14' in adx_result else pd.Series(20, index=close.index))
        
        # RSI
        self.rsi = self.I(pta.rsi, close, length=14)
        
        # Volume MA
        self.volMA = self.I(pta.sma, volume, length=20)
        
        # GT RSI for expected utility
        self.rsi_gt = self.I(pta.rsi, close, length=self.gtPeriod)
        
        # Tracking variables
        self.trades_today = 0
        self.last_trade_bar = 0
        self.last_day = None

    def next(self):
        # Reset daily counters
        current_day = len(self.data)
        if self.last_day is None or current_day != self.last_day:
            self.trades_today = 0
            self.last_day = current_day
        
        # Current values
        close = self.data.Close[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        volume = self.data.Volume[-1]
        
        ema_fast = self.ema_fast[-1]
        ema_slow = self.ema_slow[-1]
        ema_trend = self.ema_trend[-1]
        atr = self.atr[-1]
        adx = self.adx[-1]
        rsi = self.rsi[-1]
        volMA = self.volMA[-1]
        rsi_gt = self.rsi_gt[-1]
        
        if np.isnan(ema_fast) or np.isnan(ema_slow) or np.isnan(ema_trend) or np.isnan(atr) or np.isnan(adx) or np.isnan(rsi) or np.isnan(volMA) or np.isnan(rsi_gt):
            return
        
        # Calculate Game Theory metrics
        buyer_momentum = max((rsi_gt - 50) / 50, 0.0) if rsi_gt > 50 else 0.0
        seller_momentum = max((50 - rsi_gt) / 50, 0.0) if rsi_gt < 50 else 0.0
        
        vol_weight = min(volume / volMA, 2.0)
        vol_probability = max(0.5, min(vol_weight, 1.5))
        
        bull_trend = 1.0 if close > ema_trend else 0.5
        bear_trend = 1.0 if close < ema_trend else 0.5
        
        eu_buyer = buyer_momentum * vol_probability * bull_trend
        eu_seller = seller_momentum * vol_probability * bear_trend
        
        utility_gap = abs(eu_buyer - eu_seller)
        
        nash_diff = abs(eu_buyer - eu_seller)
        is_nash = nash_diff < 0.1
        
        # EMA Crossover Signals
        ema_cross_up = crossover(self.ema_fast, self.ema_slow)
        ema_cross_down = crossover(self.ema_slow, self.ema_fast)
        
        # Trend confirmation
        uptrend = close > ema_trend
        downtrend = close < ema_trend
        
        # Trend strength
        strong_trend = adx > self.adxThreshold
        medium_trend = adx > (self.adxThreshold - 5)
        
        # Game Theory conditions
        buyer_has_edge = eu_buyer > eu_seller
        seller_has_edge = eu_seller > eu_buyer
        sufficient_utility = utility_gap > self.minUtilityGap
        not_equilibrium = not is_nash
        
        # RSI Filter
        rsi_ok = (rsi > 20 and rsi < 80)
        
        # Volume Filter
        volume_up = volume > volMA * self.volumeThreshold
        
        # Long entry condition
        long_condition = (
            ema_cross_up and
            uptrend and
            (not self.useADXFilter or medium_trend) and
            (not self.useVolumeFilter or volume_up) and
            (not self.useRSIFilter or rsi_ok) and
            (not self.nashFilter or not_equilibrium) and
            (not self.utilityFilter or (buyer_has_edge and sufficient_utility)) and
            self.trades_today < self.maxTradesPerDay
        )
        
        # Short entry condition
        short_condition = (
            ema_cross_down and
            downtrend and
            (not self.useADXFilter or medium_trend) and
            (not self.useVolumeFilter or volume_up) and
            (not self.useRSIFilter or rsi_ok) and
            (not self.nashFilter or not_equilibrium) and
            (not self.utilityFilter or (seller_has_edge and sufficient_utility)) and
            self.trades_today < self.maxTradesPerDay
        )
        
        # Entry logic
        if long_condition and not self.position:
            self.buy()
            self.long_stop = close - (atr * self.atrMultiplier)
            self.long_target = close + (atr * self.atrMultiplier * self.riskRewardRatio)
            self.trades_today += 1
            self.last_trade_bar = len(self.data)
        
        if short_condition and not self.position:
            self.sell()
            self.short_stop = close + (atr * self.atrMultiplier)
            self.short_target = close - (atr * self.atrMultiplier * self.riskRewardRatio)
            self.trades_today += 1
            self.last_trade_bar = len(self.data)
        
        # Exit logic for long positions
        if self.position.size > 0:
            # Target and stop
            if close >= self.long_target:
                self.position.close()
            elif close <= self.long_stop:
                self.position.close()
            # Trend break
            elif close < ema_slow:
                self.position.close()
            # Nash equilibrium exit
            elif self.nashFilter and is_nash and (len(self.data) - self.last_trade_bar) > 5:
                self.position.close()
            # Time exit
            elif (len(self.data) - self.last_trade_bar) > 50:
                self.position.close()
        
        # Exit logic for short positions
        if self.position.size < 0:
            # Target and stop
            if close <= self.short_target:
                self.position.close()
            elif close >= self.short_stop:
                self.position.close()
            # Trend break
            elif close > ema_slow:
                self.position.close()
            # Nash equilibrium exit
            elif self.nashFilter and is_nash and (len(self.data) - self.last_trade_bar) > 5:
                self.position.close()
            # Time exit
            elif (len(self.data) - self.last_trade_bar) > 50:
                self.position.close()


if __name__ == "__main__":
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, 
                  cash=10000, 
                  commission=0.001,
                  exclusive_orders=True)
    
    stats = bt.run()
    print(stats)
    bt.plot()