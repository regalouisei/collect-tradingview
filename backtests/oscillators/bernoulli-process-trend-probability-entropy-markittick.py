"""
DS-TV Backtest Results: bernoulli-process-trend-probability-entropy-markittick
============================================================

--- SPY ---
  ERROR: Indicator "_calc_p_h…" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_calc_p_h…" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_calc_p_h…" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — bernoulli-process-trend-probability-entropy-markittick
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    length = 20
    mode = "Price Action (Close > Open)"
    risk_reward = 2.0
    stop_atr = 1.5

    def init(self):
        close = pd.Series(self.data.Close)
        open_ = pd.Series(self.data.Open)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)

        # Calculate trial outcome based on mode
        if self.mode == "Price Action (Close > Open)":
            self.trial_outcome = self.I(lambda: (close > open_).astype(float))
        elif self.mode == "Momentum (RSI > 50)":
            rsi = self.I(pta.rsi, close, length=14)
            self.trial_outcome = self.I(lambda: (rsi > 50).astype(float))
        else:  # Trend (Close > MA)
            sma = self.I(pta.sma, close, length=self.length)
            self.trial_outcome = self.I(lambda: (close > sma).astype(float))

        # Calculate probability p_hat
        self.p_hat = self.I(self._calc_p_hat)

        # Calculate entropy
        self.entropy = self.I(self._calc_entropy)

        # Calculate ATR for stop loss
        self.atr_val = self.I(pta.atr, high, low, close, length=14)

    def _calc_p_hat(self):
        if len(self.trial_outcome) < self.length:
            return pd.Series(0.5, index=self.trial_outcome.index)
        return self.trial_outcome.rolling(window=self.length).sum() / self.length

    def _calc_entropy(self):
        def entropy_calc(p):
            if p <= 0.0 or p >= 1.0:
                return 0.0
            return -1.0 * (p * (np.log(p) / np.log(2)) + (1.0 - p) * (np.log(1.0 - p) / np.log(2)))

        return self.p_hat.apply(entropy_calc)

    def next(self):
        if len(self.data) < self.length + 1:
            return

        p_hat_current = self.p_hat[-1]
        p_hat_prev = self.p_hat[-2] if len(self.p_hat) > 1 else 0.5
        entropy_current = self.entropy[-1]
        atr_current = self.atr_val[-1]

        # Signal conditions
        signal_long = crossover(self.p_hat, 0.5) and entropy_current < 0.95
        signal_short = crossover(0.5, self.p_hat) and entropy_current < 0.95

        if signal_long and not self.position:
            entry_price = self.data.Close[-1]
            sl_long = entry_price - (atr_current * self.stop_atr)
            tp_long = entry_price + ((entry_price - sl_long) * self.risk_reward)
            self.buy()

        elif signal_short and not self.position:
            entry_price = self.data.Close[-1]
            sl_short = entry_price + (atr_current * self.stop_atr)
            tp_short = entry_price - ((sl_short - entry_price) * self.risk_reward)
            self.sell()

        elif self.position and p_hat_current < 0.3:
            self.position.close()

        elif self.position and p_hat_current > 0.7:
            self.position.close()