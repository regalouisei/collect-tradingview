"""
DS-TV Backtest Results: mizan-trinity-oscillator
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "wma(calc_raw_…,3)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "wma(calc_raw_…,3)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "wma(calc_raw_…,3)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — mizan-trinity-oscillator
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    w_cci = 0.35
    w_cmf = 0.45
    w_obv = 0.20
    len_main = 14
    smooth = 3
    use_turb = True

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)

        # A. VELOCITY (CCI)
        cci_raw = self.I(pta.cci, high, low, close, length=self.len_main)
        norm_cci = self.I(lambda: (np.clip(cci_raw, -200, 200) + 200) / 400 * 100)

        # B. MONEY (CMF) - Manual Calculation
        def calc_cmf():
            mfm = np.where(
                high != low,
                ((close - low) - (high - close)) / (high - low),
                0.0
            )
            cmf_num = pd.Series(mfm * volume).rolling(20).sum()
            cmf_den = volume.rolling(20).sum()
            cmf_val = np.where(cmf_den != 0, cmf_num / cmf_den, 0)
            norm_cmf = (np.clip(cmf_val, -0.5, 0.5) + 0.5) * 100
            return pd.Series(norm_cmf, index=close.index)

        norm_cmf = self.I(calc_cmf)

        # C. MASS (OBV Momentum)
        obv_raw = self.I(pta.obv, close, volume)
        
        def calc_obv_norm():
            obv_roc = pta.roc(obv_raw, length=10)
            if obv_roc is None:
                obv_roc = pd.Series(0, index=close.index)
            obv_roc = obv_roc / 10
            obv_highest = obv_roc.rolling(100).max()
            obv_lowest = obv_roc.rolling(100).min()
            denominator = np.maximum(obv_highest - obv_lowest, 1e-10)
            norm_obv = (obv_roc - obv_lowest) / denominator * 100
            return pd.Series(norm_obv, index=close.index)

        norm_obv = self.I(calc_obv_norm)

        # TRINITY ENGINE (L-SCORE SYNTHESIS)
        def calc_raw_score():
            raw = (norm_cci * self.w_cci) + (norm_cmf * self.w_cmf) + (norm_obv * self.w_obv)
            return pd.Series(raw, index=close.index)

        raw_score = self.I(calc_raw_score)

        # Mizan Effect (Smoothing)
        self.mto_val = self.I(pta.wma, raw_score, length=self.smooth)

        # QUALITY CONTROL (TURBULENCE & SILENCE)
        def calc_turbulence():
            osc_noise = np.abs(self.mto_val.diff())
            avg_noise = osc_noise.rolling(20).mean()
            is_turb = self.use_turb & (osc_noise > (avg_noise * 2.0))
            vol_check = volume < (volume.rolling(50).mean() * 0.7)
            is_silent = is_turb | vol_check
            return pd.Series(is_silent, index=close.index)

        self.is_silent = self.I(calc_turbulence)

    def next(self):
        # Only trade when not in silent mode
        if len(self.data) < 2:
            return

        current_mto = self.mto_val[-1]
        prev_mto = self.mto_val[-2]
        is_silent = self.is_silent[-1]

        if is_silent:
            return

        # Buy when crossing above 20 (oversold) and moving up
        if current_mto > 20 and prev_mto <= 20:
            if not self.position:
                self.buy()
        # Sell when crossing below 80 (overbought) and moving down
        elif current_mto < 80 and prev_mto >= 80:
            if self.position:
                self.position.close()
        # Also sell when crossing below 50 and was in uptrend
        elif crossover(50, self.mto_val):
            if self.position:
                self.position.close()
        # Buy when crossing above 50 from below
        elif crossover(self.mto_val, 50):
            if not self.position:
                self.buy()


if __name__ == "__main__":
    from backtesting.test import GOOG

    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()