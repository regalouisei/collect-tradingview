"""
DS-TV Backtest Results: volume-conviction-index-v10
============================================================

--- SPY ---
  Return                    -3.80%
  Buy & Hold Return         28.14%
  Max Drawdown              -14.81%
  Sharpe Ratio              -0.15
  Sortino Ratio             -0.22
  Calmar Ratio              -0.13
  Profit Factor             0.92
  Expectancy                -0.03%
  SQN                       -0.39
  # Trades                  101
  Win Rate                  54.46%
  Best Trade                2.44%
  Worst Trade               -3.74%
  Avg Trade                 -0.04%
  Exposure Time             61.80%
  Equity Final              96204.13$
  Equity Peak               100023.06$
  Avg Drawdown              -5.88%
  Max Drawdown Duration     558 days 00:00:00
  Max Trade Duration        18 days 00:00:00
  Avg Trade Duration        4 days 00:00:00
  Ann. Return               -1.93%
  Ann. Volatility           13.27%

--- BTC ---
  Return                    -15.71%
  Buy & Hold Return         4.35%
  Max Drawdown              -42.57%
  Sharpe Ratio              -0.34
  Sortino Ratio             -0.46
  Calmar Ratio              -0.19
  Profit Factor             0.99
  Expectancy                -0.01%
  SQN                       -0.43
  # Trades                  144
  Win Rate                  50.69%
  Best Trade                12.32%
  Worst Trade               -13.87%
  Avg Trade                 -0.08%
  Exposure Time             60.60%
  Equity Final              84292.91$
  Equity Peak               135434.72$
  Avg Drawdown              -4.66%
  Max Drawdown Duration     413 days 00:00:00
  Max Trade Duration        10 days 00:00:00
  Avg Trade Duration        3 days 00:00:00
  Ann. Return               -8.18%
  Ann. Volatility           23.74%

--- QQQ ---
  Return                    -4.54%
  Buy & Hold Return         26.12%
  Max Drawdown              -21.48%
  Sharpe Ratio              -0.15
  Sortino Ratio             -0.21
  Calmar Ratio              -0.11
  Profit Factor             0.93
  Expectancy                -0.04%
  SQN                       -0.35
  # Trades                  99
  Win Rate                  51.52%
  Best Trade                1.88%
  Worst Trade               -5.40%
  Avg Trade                 -0.05%
  Exposure Time             62.40%
  Equity Final              95455.90$
  Equity Peak               100820.51$
  Avg Drawdown              -21.48%
  Max Drawdown Duration     579 days 00:00:00
  Max Trade Duration        21 days 00:00:00
  Avg Trade Duration        4 days 00:00:00
  Ann. Return               -2.32%
  Ann. Volatility           15.90%

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” volume-conviction-index-v10
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    vol_len = 50
    z_thresh = 1.5
    weight_recent = 0.7
    median_len = 7

    def init(self):
        close = pd.Series(self.data.Close)
        volume = pd.Series(self.data.Volume)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate median volume using rolling median
        def calc_med_vol():
            return volume.rolling(window=self.vol_len).median()
        
        self.med_vol = self.I(calc_med_vol)
        
        # Calculate MAD (Mean Absolute Deviation)
        def calc_mad():
            med_vol_series = volume.rolling(window=self.vol_len).median()
            deviations = (volume - med_vol_series).abs()
            mad = deviations.rolling(window=self.vol_len).median()
            return mad
        
        self.mad_vol = self.I(calc_mad)
        
        # Calculate robust Z-score for volume
        def calc_robust_z():
            med_vol_series = volume.rolling(window=self.vol_len).median()
            mad_series = (volume - med_vol_series).abs().rolling(window=self.vol_len).median()
            result = pd.Series(index=volume.index, dtype=float)
            for i in range(len(volume)):
                if pd.isna(mad_series.iloc[i]) or mad_series.iloc[i] == 0:
                    result.iloc[i] = np.nan
                else:
                    result.iloc[i] = 0.6745 * (volume.iloc[i] - med_vol_series.iloc[i]) / mad_series.iloc[i]
            return result
        
        self.robust_z_vol = self.I(calc_robust_z)
        
        # Apply outlier filter (Winsorize)
        def calc_filtered_z():
            z_series = pd.Series(index=volume.index, dtype=float)
            med_vol_series = volume.rolling(window=self.vol_len).median()
            mad_series = (volume - med_vol_series).abs().rolling(window=self.vol_len).median()
            for i in range(len(volume)):
                if pd.isna(mad_series.iloc[i]) or mad_series.iloc[i] == 0:
                    z_series.iloc[i] = np.nan
                else:
                    z = 0.6745 * (volume.iloc[i] - med_vol_series.iloc[i]) / mad_series.iloc[i]
                    if abs(z) > self.z_thresh:
                        z_series.iloc[i] = np.sign(z) * self.z_thresh
                    else:
                        z_series.iloc[i] = z
            return z_series
        
        self.filtered_z = self.I(calc_filtered_z)
        
        # Calculate volume change percentage
        def calc_vol_change_pct():
            result = pd.Series(index=volume.index, dtype=float)
            for i in range(len(volume)):
                if i == 0 or volume.iloc[i] <= 0 or volume.iloc[i-1] <= 0:
                    result.iloc[i] = 0
                else:
                    result.iloc[i] = (volume.iloc[i] / volume.iloc[i-1] - 1) * 100
            return result
        
        self.vol_change_pct = self.I(calc_vol_change_pct)
        
        # Calculate RVOL percentage
        def calc_rvol_pct():
            med_vol_series = volume.rolling(window=self.vol_len).median()
            result = pd.Series(index=volume.index, dtype=float)
            for i in range(len(volume)):
                if pd.isna(med_vol_series.iloc[i]) or med_vol_series.iloc[i] == 0:
                    result.iloc[i] = 0
                else:
                    result.iloc[i] = (volume.iloc[i] / med_vol_series.iloc[i] - 1) * 100
            return result
        
        self.rvol_pct = self.I(calc_rvol_pct)
        
        # Calculate weighted conviction
        def calc_weighted_conv():
            result = pd.Series(index=volume.index, dtype=float)
            med_vol_series = volume.rolling(window=self.vol_len).median()
            for i in range(len(volume)):
                if i == 0 or volume.iloc[i] <= 0 or volume.iloc[i-1] <= 0:
                    vol_chg = 0
                else:
                    vol_chg = (volume.iloc[i] / volume.iloc[i-1] - 1) * 100
                
                if pd.isna(med_vol_series.iloc[i]) or med_vol_series.iloc[i] == 0:
                    rvol = 0
                else:
                    rvol = (volume.iloc[i] / med_vol_series.iloc[i] - 1) * 100
                
                result.iloc[i] = self.weight_recent * vol_chg + (1 - self.weight_recent) * rvol
            return result
        
        self.weighted_conv = self.I(calc_weighted_conv)
        
        # Calculate raw VCI
        def calc_vpi_raw():
            result = pd.Series(index=volume.index, dtype=float)
            med_vol_series = volume.rolling(window=self.vol_len).median()
            mad_series = (volume - med_vol_series).abs().rolling(window=self.vol_len).median()
            for i in range(len(volume)):
                if pd.isna(mad_series.iloc[i]) or mad_series.iloc[i] == 0:
                    filtered = 0
                else:
                    z = 0.6745 * (volume.iloc[i] - med_vol_series.iloc[i]) / mad_series.iloc[i]
                    filtered = np.sign(z) * self.z_thresh if abs(z) > self.z_thresh else z
                
                if i == 0 or volume.iloc[i] <= 0 or volume.iloc[i-1] <= 0:
                    vol_chg = 0
                else:
                    vol_chg = (volume.iloc[i] / volume.iloc[i-1] - 1) * 100
                
                if pd.isna(med_vol_series.iloc[i]) or med_vol_series.iloc[i] == 0:
                    rvol = 0
                else:
                    rvol = (volume.iloc[i] / med_vol_series.iloc[i] - 1) * 100
                
                weighted = self.weight_recent * vol_chg + (1 - self.weight_recent) * rvol
                result.iloc[i] = 0.6 * filtered + 0.4 * (weighted / 10)
            return result
        
        self.vpi_raw = self.I(calc_vpi_raw)
        
        # Calculate median line
        def calc_vci_median():
            result = pd.Series(index=volume.index, dtype=float)
            med_vol_series = volume.rolling(window=self.vol_len).median()
            mad_series = (volume - med_vol_series).abs().rolling(window=self.vol_len).median()
            vpi_raw_series = pd.Series(index=volume.index, dtype=float)
            for i in range(len(volume)):
                if pd.isna(mad_series.iloc[i]) or mad_series.iloc[i] == 0:
                    filtered = 0
                else:
                    z = 0.6745 * (volume.iloc[i] - med_vol_series.iloc[i]) / mad_series.iloc[i]
                    filtered = np.sign(z) * self.z_thresh if abs(z) > self.z_thresh else z
                
                if i == 0 or volume.iloc[i] <= 0 or volume.iloc[i-1] <= 0:
                    vol_chg = 0
                else:
                    vol_chg = (volume.iloc[i] / volume.iloc[i-1] - 1) * 100
                
                if pd.isna(med_vol_series.iloc[i]) or med_vol_series.iloc[i] == 0:
                    rvol = 0
                else:
                    rvol = (volume.iloc[i] / med_vol_series.iloc[i] - 1) * 100
                
                weighted = self.weight_recent * vol_chg + (1 - self.weight_recent) * rvol
                vpi_raw_series.iloc[i] = 0.6 * filtered + 0.4 * (weighted / 10)
            
            result = vpi_raw_series.rolling(window=self.median_len).median()
            return result
        
        self.vci_median = self.I(calc_vci_median)

    def next(self):
        if len(self.data) < self.median_len + self.vol_len:
            return
        
        vci_current = self.vpi_raw[-1]
        vci_prev = self.vpi_raw[-2] if len(self.vpi_raw) > 1 else vci_current
        vci_median_current = self.vci_median[-1]
        vci_median_prev = self.vci_median[-2] if len(self.vci_median) > 1 else vci_median_current
        
        # Buy signal: VCI crosses above 0 (volume conviction turns positive)
        if vci_prev <= 0 and vci_current > 0:
            if not self.position:
                self.buy()
        
        # Sell signal: VCI crosses below 0 (volume conviction turns negative)
        elif vci_prev >= 0 and vci_current < 0:
            if self.position:
                self.position.close()