"""
DS-TV Backtest Results: game-theory-ema-strategy-high-accuracy
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — game-theory-ema-strategy-high-accuracy
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    emaFast = 9
    emaSlow = 21
    emaTrend = 50
    gtPeriod = 14
    nashFilter = True
    utilityFilter = True
    riskRewardRatio = 2.0
    atrPeriod = 14
    atrMultiplier = 1.5
    useADXFilter = True
    adxThreshold = 25
    useVolumeFilter = True

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        self.ema_fast = self.I(pta.ema, close, length=self.emaFast)
        self.ema_slow = self.I(pta.ema, close, length=self.emaSlow)
        self.ema_trend = self.I(pta.ema, close, length=self.emaTrend)
        
        self.atr = self.I(pta.atr, high, low, close, length=self.atrPeriod)
        
        adx_result = self.I(lambda: pta.adx(high, low, close, length=14) or pd.DataFrame(0, index=close.index, columns=['ADX_14']))
        self.adx = self.I(lambda: adx_result['ADX_14'] if isinstance(adx_result, pd.DataFrame) else adx_result)
        
        self.volMA = self.I(pta.sma, volume, length=20)
        
        rsi = self.I(pta.rsi, close, length=self.gtPeriod)
        self.rsi = rsi
        
        self.long_stop = None
        self.long_target = None
        self.short_stop = None
        self.short_target = None

    def next(self):
        if len(self.data.Close) < max(self.emaTrend, self.atrPeriod, 20) + 5:
            return
        
        close = self.data.Close[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        volume = self.data.Volume[-1]
        
        ema_fast_val = self.ema_fast[-1]
        ema_slow_val = self.ema_slow[-1]
        ema_trend_val = self.ema_trend[-1]
        atr_val = self.atr[-1]
        adx_val = self.adx[-1]
        volMA_val = self.volMA[-1]
        rsi_val = self.rsi[-1]
        
        uptrend = close > ema_trend_val
        downtrend = close < ema_trend_val
        
        strongTrend = adx_val > self.adxThreshold
        volumeUp = volume > volMA_val * 1.2
        
        buyer_momentum = (rsi_val - 50) / 20 if (rsi_val > 50 and rsi_val < 70) else (0.5 if rsi_val >= 70 else (rsi_val - 50) / 50)
        seller_momentum = (50 - rsi_val) / 20 if (rsi_val < 50 and rsi_val > 30) else (0.5 if rsi_val <= 30 else (50 - rsi_val) / 50)
        
        vol_weight = min(volume / volMA_val, 2.0) if volume > volMA_val else 0.5
        
        eu_buyer = buyer_momentum * vol_weight
        eu_seller = seller_momentum * vol_weight
        
        diff = abs(eu_buyer - eu_seller)
        total = eu_buyer + eu_seller
        is_nash = (diff / total) < 0.2 if total > 0 else True
        
        buyer_has_edge = eu_buyer > eu_seller
        seller_has_edge = eu_seller > eu_buyer
        not_equilibrium = not is_nash
        
        ema_cross_up = crossover(self.ema_fast, self.ema_slow)
        ema_cross_down = crossover(self.ema_slow, self.ema_fast)
        
        long_condition = (ema_cross_up and uptrend and 
                         (not self.useADXFilter or strongTrend) and 
                         (not self.useVolumeFilter or volumeUp) and 
                         (not self.nashFilter or not_equilibrium) and 
                         (not self.utilityFilter or buyer_has_edge))
        
        short_condition = (ema_cross_down and downtrend and 
                          (not self.useADXFilter or strongTrend) and 
                          (not self.useVolumeFilter or volumeUp) and 
                          (not self.nashFilter or not_equilibrium) and 
                          (not self.utilityFilter or seller_has_edge))
        
        if long_condition and not self.position:
            self.buy()
            self.long_stop = close - (atr_val * self.atrMultiplier)
            self.long_target = close + (atr_val * self.atrMultiplier * self.riskRewardRatio)
        
        if short_condition and not self.position:
            self.sell()
            self.short_stop = close + (atr_val * self.atrMultiplier)
            self.short_target = close - (atr_val * self.atrMultiplier * self.riskRewardRatio)
        
        if self.position.size > 0:
            if self.long_stop is not None and low <= self.long_stop:
                self.position.close()
            elif self.long_target is not None and high >= self.long_target:
                self.position.close()
            elif ema_cross_down:
                self.position.close()
            elif self.nashFilter and is_nash:
                self.position.close()
        
        if self.position.size < 0:
            if self.short_stop is not None and high >= self.short_stop:
                self.position.close()
            elif self.short_target is not None and low <= self.short_target:
                self.position.close()
            elif ema_cross_up:
                self.position.close()
            elif self.nashFilter and is_nash:
                self.position.close()


if __name__ == '__main__':
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.001)
    stats = bt.run()
    print(stats)
    bt.plot()