"""
DS-TV Backtest Results: btc-cycle-rsi-linreg-bands-dca-strategy-v2
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "wma(rsi(50),5)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "wma(rsi(50),5)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "wma(rsi(50),5)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” btc-cycle-rsi-linreg-bands-dca-strategy-v2
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover
from datetime import datetime


class TvStrategy(Strategy):
    # RSI + LinReg Bands parameters
    rsi_length = 50
    linreg_period = 200
    deviations = 2.0
    ob_level = 65
    os_level = 35
    
    # DCA parameters
    base_dca = 100
    
    # Logic toggles
    use_false_filter = True
    enable_dca = True
    enable_sells = True
    
    # Yield model parameters
    yield_apr = 11.0
    starting_yield_balance = 0.0
    yield_dca_enabled = True
    deep_bear_target_frac = 20.0
    
    # Hybrid deploy parameters
    hybrid_max_pct_pool = 4.0
    hybrid_deploy_pct = 25.0
    hybrid_ramp_weeks = 25.0
    hybrid_start_capacity = 10.0
    hybrid_drawdown_power = 3.0
    
    # Start date parameters
    use_start_date = True
    start_year = 2013
    start_month = 1
    start_day = 1

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate RSI with WMA smoothing
        rsi_raw = self.I(pta.rsi, close, length=self.rsi_length)
        self.rsi = self.I(pta.wma, rsi_raw, length=5)
        
        # Calculate linear regression bands
        self.lower_curve = self.I(self._calc_lower_curve, self.rsi)
        self.mid_curve = self.I(self._calc_mid_curve, self.rsi)
        self.upper_curve = self.I(self._calc_upper_curve, self.rsi)
        
        # State variables
        self.post_peak = False
        self.phase = "UNKNOWN"
        self.dca_mult = 0.0
        self.overbought_armed = False
        self.sell_count = 0
        self.prev_above_mid = False
        self.sell_paused_by_plunge = False
        self.dca_enabled_state = True
        self.sell_signal_text = "NONE"
        
        # Yield variables
        self.yield_balance = self.starting_yield_balance
        self.yield_seeded = False
        self.deep_bear_start_yield = None
        self.in_deep_bear_for_yield = False
        self.weeks_in_bear = 0
        self.cycle_high = None

    def _calc_lower_curve(self, rsi):
        if len(rsi) < self.linreg_period:
            return np.nan
        return self._compute_linreg_band(rsi, -1)

    def _calc_mid_curve(self, rsi):
        if len(rsi) < self.linreg_period:
            return np.nan
        return self._compute_linreg_band(rsi, 0)

    def _calc_upper_curve(self, rsi):
        if len(rsi) < self.linreg_period:
            return np.nan
        return self._compute_linreg_band(rsi, 1)

    def _compute_linreg_band(self, rsi, band_type):
        try:
            period = self.linreg_period
            if len(rsi) < period:
                return np.nan
            
            rsi_window = rsi[-period:]
            
            # Linear regression calculation
            ex = sum(range(period))
            ey = rsi_window.sum()
            ex2 = sum(i*i for i in range(period))
            exy = sum(i * rsi_window.iloc[i] for i in range(period))
            exex = ex * ex
            
            if ex2 == exex:
                return np.nan
            
            slope = (period * exy - ex * ey) / (period * ex2 - exex)
            ilinear_regression = (ey - slope * ex) / period
            
            # Compute deviation
            deviation = 0.0
            for i in range(period):
                deviation += rsi_window.iloc[i] ** 2
            
            deviation_new = self.deviations * np.sqrt(deviation / period)
            starting_point_y = ilinear_regression
            
            if band_type == 0:
                return starting_point_y
            elif band_type == -1:
                return starting_point_y - deviation_new
            else:
                return starting_point_y + deviation_new
        except:
            return np.nan

    def _is_live(self):
        if not self.use_start_date:
            return True
        start_time = pd.Timestamp(self.start_year, self.start_month, self.start_day)
        current_time = pd.Timestamp(self.data.index[-1])
        return current_time >= start_time

    def _detect_phases(self):
        rsi_val = self.rsi[-1]
        mid = self.mid_curve[-1]
        lower = self.lower_curve[-1]
        upper = self.upper_curve[-1]
        
        is_deep_bear = rsi_val <= 50 and rsi_val <= lower
        is_bear_recovery = rsi_val <= 50 and rsi_val > lower and rsi_val <= mid
        is_early_bull = rsi_val > mid and rsi_val < 50
        is_bull_confirmed = rsi_val > 50 and rsi_val > upper
        is_mature_bull = rsi_val > self.ob_level
        is_bull_building = rsi_val > 50 and not is_bull_confirmed and not is_mature_bull
        
        if is_mature_bull:
            self.post_peak = True
        if is_deep_bear:
            self.post_peak = False
        
        if is_mature_bull:
            self.phase = "MATURE_BULL"
            self.dca_mult = 0
        elif is_bull_confirmed and not self.post_peak:
            self.phase = "BULL_CONFIRMED"
            self.dca_mult = 1
        elif is_bull_confirmed and self.post_peak:
            self.phase = "DISTRIBUTION"
            self.dca_mult = 0.5
        elif is_bull_building and not self.post_peak:
            self.phase = "BULL_BUILDING"
            self.dca_mult = 1
        elif is_bull_building and self.post_peak:
            self.phase = "WEAKENING"
            self.dca_mult = 0.25
        elif is_early_bull:
            self.phase = "EARLY_BULL"
            self.dca_mult = 2
        elif is_bear_recovery:
            self.phase = "BEAR_RECOVERY"
            self.dca_mult = 3
        elif is_deep_bear:
            self.phase = "DEEP_BEAR"
            self.dca_mult = 5
        else:
            self.phase = "UNKNOWN"
            self.dca_mult = 1
        
        return is_deep_bear, is_bull_confirmed, is_mature_bull

    def next(self):
        if not self._is_live():
            return
        
        is_deep_bear, is_bull_confirmed, is_mature_bull = self._detect_phases()
        
        # Update cycle high
        close_price = self.data.Close[-1]
        if is_bull_confirmed or is_mature_bull:
            if self.cycle_high is None or close_price > self.cycle_high:
                self.cycle_high = close_price
        
        # Seed yield balance
        if not self.yield_seeded:
            self.yield_seeded = True
        
        # Apply weekly yield
        weekly_rate = (self.yield_apr / 100.0) / 52.0
        self.yield_balance *= (1 + weekly_rate)
        
        # Deep bear tracking
        if is_deep_bear and not self.in_deep_bear_for_yield:
            self.in_deep_bear_for_yield = True
            self.deep_bear_start_yield = self.yield_balance
            self.weeks_in_bear = 0
        
        if is_deep_bear:
            self.weeks_in_bear += 1
        else:
            self.in_deep_bear_for_yield = False
            self.deep_bear_start_yield = None
            self.weeks_in_bear = 0
        
        # RSI filters
        rsi_val = self.rsi[-1]
        mid = self.mid_curve[-1]
        lower = self.lower_curve[-1]
        
        rsi_above_mid = rsi_val > mid
        rsi_below_mid = rsi_val < mid
        
        if rsi_val > self.ob_level:
            self.overbought_armed = True
        if rsi_val < 50 and rsi_val < mid:
            self.overbought_armed = False
        
        sell_filter_ok = (not self.use_false_filter) or self.overbought_armed
        
        # Sell detection
        prev_above_mid = self.prev_above_mid
        self.prev_above_mid = rsi_above_mid
        
        midline_breakdown = prev_above_mid and rsi_below_mid
        
        if sell_filter_ok and midline_breakdown and not self.sell_paused_by_plunge:
            self.sell_count += 1
            if self.sell_count == 1:
                self.sell_signal_text = "FIRST_SELL"
            elif self.sell_count == 2:
                self.sell_signal_text = "SECOND_SELL"
                self.dca_enabled_state = False
            else:
                self.sell_signal_text = "SELLS_DONE"
        else:
            self.sell_signal_text = "NONE"
        
        # Plunge guard
        if self.sell_count == 1 and rsi_val <= lower:
            self.sell_paused_by_plunge = True
        
        # Reset on new bull confirmation
        if is_bull_confirmed:
            self.sell_count = 0
            self.sell_paused_by_plunge = False
        
        # Re-arm DCA on deep bear
        if is_deep_bear:
            self.dca_enabled_state = True
        
        # 1) BASE DCA
        if self.enable_dca and self.dca_enabled_state:
            dca_cash = self.base_dca * self.dca_mult
            if dca_cash > 0:
                qty = dca_cash / close_price
                self.buy(size=qty)
        
        # 2) YIELD-FUNDED DCA (HYBRID)
        if self.yield_dca_enabled and self.dca_enabled_state and is_deep_bear and self.deep_bear_start_yield is not None:
            target_frac = self.deep_bear_target_frac / 100.0
            target_balance = self.deep_bear_start_yield * target_frac
            remaining_pool = max(0.0, self.yield_balance - target_balance)
            
            start_cap = self.hybrid_start_capacity / 100.0
            time_factor = min(1.0, start_cap + (1.0 - start_cap) * self.weeks_in_bear / self.hybrid_ramp_weeks)
            
            drawdown_fraction = 0.0
            if self.cycle_high is not None and self.cycle_high > 0:
                drawdown_fraction = max(0.0, (self.cycle_high - close_price) / self.cycle_high)
            drawdown_scale = (0.5 + drawdown_fraction) ** self.hybrid_drawdown_power
            
            max_per_week = remaining_pool * (self.hybrid_max_pct_pool / 100.0)
            desired = min(remaining_pool * (self.hybrid_deploy_pct / 100.0), max_per_week * time_factor)
            yield_dca_cash = desired * drawdown_scale
            yield_dca_cash = min(yield_dca_cash, self.yield_balance)
            yield_dca_cash = max(yield_dca_cash, 0.0)
            
            if yield_dca_cash > 0:
                qty = yield_dca_cash / close_price
                self.yield_balance -= yield_dca_cash
                self.buy(size=qty)
        
        # 3) SELLS
        if self.enable_sells and len(self.position) > 0:
            if self.sell_signal_text == "FIRST_SELL":
                qty_to_close = self.position.size * 0.20
                cash_proceeds = qty_to_close * close_price
                self.yield_balance += cash_proceeds
                self.sell(size=qty_to_close)
            
            elif self.sell_signal_text == "SECOND_SELL":
                qty_to_close = self.position.size * 0.40
                cash_proceeds = qty_to_close * close_price
                self.yield_balance += cash_proceeds
                self.sell(size=qty_to_close)