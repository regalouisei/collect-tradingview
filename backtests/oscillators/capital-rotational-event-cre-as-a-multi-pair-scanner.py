"""
DS-TV Backtest Results: capital-rotational-event-cre-as-a-multi-pair-scanner
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "λ" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — capital-rotational-event-cre-as-a-multi-pair-scanner
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lenRS = 14
    lenMom = 9

    def init(self):
        close = pd.Series(self.data.Close)
        
        # Calculate RS (Relative Strength between price and itself - simplified)
        # Since we can't access external symbols, we'll use a momentum-based approach
        # RS = SMA(price change ratio over itself)
        price_change = close.diff()
        
        rs_ratio = self.I(lambda: close / close.shift(1))
        self.rs = self.I(lambda: pta.sma(rs_ratio, length=self.lenRS))
        
        # Calculate momentum of RS
        rs_change = self.I(lambda: self.rs.diff())
        self.mom = self.I(lambda: pta.sma(rs_change, length=self.lenMom))
        
        # Calculate RS moving average for comparison
        self.rs_ma = self.I(lambda: pta.sma(self.rs, length=self.lenRS))
        
        # Create signal: 1 for bullish, -1 for bearish, 0 for neutral
        self.signal = self.I(self._calc_signal)

    def _calc_signal(self):
        """Calculate CRE signal based on RS and momentum conditions"""
        signals = pd.Series(0, index=self.data.Close.index)
        
        for i in range(len(self.data.Close)):
            if i < self.lenRS + self.lenMom:
                signals.iloc[i] = 0
                continue
            
            rs_val = self.rs.iloc[i]
            mom_val = self.mom.iloc[i]
            rs_ma_val = self.rs_ma.iloc[i]
            
            if pd.notna(rs_val) and pd.notna(mom_val) and pd.notna(rs_ma_val):
                if rs_val > rs_ma_val and mom_val > 0:
                    signals.iloc[i] = 1
                elif rs_val < rs_ma_val and mom_val < 0:
                    signals.iloc[i] = -1
                else:
                    signals.iloc[i] = 0
        
        return signals

    def next(self):
        # Buy when signal transitions from 0/negative to 1 (bullish CRE)
        if len(self.data) > self.lenRS + self.lenMom:
            current_signal = self.signal[-1]
            prev_signal = self.signal[-2] if len(self.signal) > 1 else 0
            
            # Enter long on bullish rotation signal
            if current_signal == 1 and prev_signal != 1:
                if not self.position:
                    self.buy()
            
            # Exit long on bearish rotation signal
            elif current_signal == -1 and self.position:
                self.position.close()
            
            # Exit on neutral signal after being in position
            elif current_signal == 0 and self.position and prev_signal == 1:
                self.position.close()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    results = bt.run()
    print(results)
    bt.plot()