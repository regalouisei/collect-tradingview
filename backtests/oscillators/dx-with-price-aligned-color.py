"""
DS-TV Backtest Results: dx-with-price-aligned-color
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "λ" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — dx-with-price-aligned-color
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    dxLength = 14
    smaLength = 5

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate True Range
        tr_values = pta.true_range(high, low, close)
        
        # Calculate RMA (EMA with different smoothing) for TR
        tr_rma = self.I(lambda: pta.ema(tr_values, length=self.dxLength, adjust=False) if tr_values is not None else pd.Series(0, index=close.index))
        
        # Calculate Directional Movements
        def calc_plus_dm():
            up_move = high.diff()
            down_move = -low.diff()
            plus_dm = ((up_move > down_move) & (up_move > 0)) * up_move
            return plus_dm
        
        def calc_minus_dm():
            up_move = high.diff()
            down_move = -low.diff()
            minus_dm = ((down_move > up_move) & (down_move > 0)) * down_move
            return minus_dm
        
        plus_dm_series = self.I(calc_plus_dm)
        minus_dm_series = self.I(calc_minus_dm)
        
        # Calculate RMA of DM
        plus_dm_rma = self.I(lambda: pta.ema(plus_dm_series, length=self.dxLength, adjust=False) if plus_dm_series is not None else pd.Series(0, index=close.index))
        minus_dm_rma = self.I(lambda: pta.ema(minus_dm_series, length=self.dxLength, adjust=False) if minus_dm_series is not None else pd.Series(0, index=close.index))
        
        # Calculate DI values
        def calc_plus_di():
            return (100 * plus_dm_rma / tr_rma).fillna(0)
        
        def calc_minus_di():
            return (100 * minus_dm_rma / tr_rma).fillna(0)
        
        self.plus_di = self.I(calc_plus_di)
        self.minus_di = self.I(calc_minus_di)
        
        # Calculate DX
        def calc_dx():
            di_sum = self.plus_di + self.minus_di
            di_sum = di_sum.replace(0, np.nan)
            dx = 100 * np.abs(self.plus_di - self.minus_di) / di_sum
            return dx.fillna(0)
        
        self.dx = self.I(calc_dx)
        
        # Calculate DX SMA
        self.dx_sma = self.I(pta.sma, self.dx, length=self.smaLength)

    def next(self):
        if len(self.data) < 2:
            return
        
        # Price direction
        price_up = self.data.Close[-1] > self.data.Close[-2]
        price_down = self.data.Close[-1] < self.data.Close[-2]
        
        # DX slope
        dx_rising = self.dx[-1] > self.dx[-2]
        dx_falling = self.dx[-1] < self.dx[-2]
        
        # Trading logic based on DX color logic
        # Buy when DX is rising and price is up (bullish strength)
        if dx_rising and price_up and self.dx[-1] > 25:
            if not self.position:
                self.buy()
        
        # Sell when DX is falling or (DX is rising but price is down)
        if dx_falling or (dx_rising and price_down):
            if self.position:
                self.sell()