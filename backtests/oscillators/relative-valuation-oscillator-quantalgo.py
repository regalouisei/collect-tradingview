"""
DS-TV Backtest Results: relative-valuation-oscillator-quantalgo
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "λ" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — relative-valuation-oscillator-quantalgo
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lookback_period = 34
    threshold_mult = 2.0

    def init(self):
        close = pd.Series(self.data.Close)
        
        # Calculate log price
        log_price = self.I(lambda: np.log(close))
        
        # Calculate mean log price (SMA of log price)
        mean_log_price = self.I(lambda: pta.sma(log_price, length=self.lookback_period))
        
        # Calculate standard deviation of log price
        std_dev = self.I(lambda: pta.stdev(log_price, length=self.lookback_period))
        
        # Calculate valuation score: (log_price - mean) / std_dev
        self.valuation_score = self.I(
            lambda: (log_price - mean_log_price) / std_dev.replace(0, np.nan)
        )
        
        # Store threshold values
        self.upper_threshold = self.threshold_mult
        self.lower_threshold = -self.threshold_mult

    def next(self):
        if len(self.data) < self.lookback_period + 1:
            return
        
        current_score = self.valuation_score[-1]
        prev_score = self.valuation_score[-2] if len(self.valuation_score) > 1 else current_score
        
        # Check for crossovers
        crosses_above_upper = prev_score <= self.upper_threshold and current_score > self.upper_threshold
        crosses_below_lower = prev_score >= self.lower_threshold and current_score < self.lower_threshold
        crosses_above_zero = prev_score <= 0 and current_score > 0
        crosses_below_zero = prev_score >= 0 and current_score < 0
        
        is_overvalued = current_score > self.upper_threshold
        is_undervalued = current_score < self.lower_threshold
        
        # Buy when undervalued (crosses below lower threshold) or crosses above zero from below
        if crosses_below_lower or (crosses_above_zero and not is_overvalued):
            if not self.position:
                self.buy()
        
        # Sell when overvalued (crosses above upper threshold) or crosses below zero from above
        if crosses_above_upper or (crosses_below_zero and not is_undervalued):
            if self.position:
                self.sell()


if __name__ == '__main__':
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, commission=.002, exclusive_orders=True)
    stats = bt.run()
    print(stats)
    bt.plot()