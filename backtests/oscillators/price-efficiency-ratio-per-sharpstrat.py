"""
DS-TV Backtest Results: price-efficiency-ratio-per-sharpstrat
============================================================

--- SPY ---
  ERROR: Indicator "_calculat…(_calculat…)" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_calculat…(_calculat…)" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_calculat…(_calculat…)" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — price-efficiency-ratio-per-sharpstrat
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    length = 30
    smoothing = 20
    use_volume_weight = False
    zone_type = "Dynamic"
    threshold = 25.0
    threshold_lookback = 252
    dynamic_percentile = 40

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # Calculate PER
        self.per = self.I(self._calculate_per, close, volume)
        
        # Calculate threshold
        self.threshold_final = self.I(self._calculate_threshold, self.per, close)

    def _calculate_per(self, close, volume):
        per_values = []
        
        for i in range(len(close)):
            if i < self.length:
                per_values.append(0)
                continue
            
            # Net distance
            net_distance = abs(close.iloc[i] - close.iloc[i - self.length])
            
            # Total distance
            total_distance = 0.0
            for j in range(1, self.length + 1):
                price_move = abs(close.iloc[i - j + 1] - close.iloc[i - j])
                weight = volume.iloc[i - j] if self.use_volume_weight else 1.0
                total_distance += price_move * weight
            
            # Weighted net distance
            weighted_net_distance = net_distance
            if self.use_volume_weight:
                total_vol = volume.iloc[i - self.length + 1:i + 1].sum()
                avg_volume = total_vol / self.length
                weighted_net_distance = net_distance * avg_volume
            
            # PER calculation
            per = ((weighted_net_distance if self.use_volume_weight else net_distance) / total_distance * 100) if total_distance > 0 else 0
            per_values.append(per)
        
        per_series = pd.Series(per_values, index=close.index)
        
        # Apply smoothing
        if self.smoothing > 0:
            per_smoothed = per_series.rolling(window=self.smoothing).mean()
            return per_smoothed
        
        return per_series

    def _calculate_threshold(self, per, close):
        threshold_values = []
        
        for i in range(len(per)):
            if i < self.threshold_lookback:
                threshold_values.append(self.threshold)
                continue
            
            if self.zone_type == "Dynamic":
                # Calculate percentile
                window = per.iloc[i - self.threshold_lookback:i + 1]
                sorted_vals = window.dropna().sort_values()
                
                if len(sorted_vals) > 0:
                    percentile_idx = int(len(sorted_vals) * self.dynamic_percentile / 100)
                    percentile_idx = min(percentile_idx, len(sorted_vals) - 1)
                    threshold_val = sorted_vals.iloc[percentile_idx]
                else:
                    threshold_val = self.threshold
            else:
                threshold_val = self.threshold
            
            threshold_values.append(threshold_val)
        
        return pd.Series(threshold_values, index=per.index)

    def next(self):
        # Get current values
        per_current = self.per[-1]
        threshold_current = self.threshold_final[-1]
        
        # Ensure we have valid values
        if per_current is None or threshold_current is None:
            return
        
        # Skip if not enough data
        if len(self.data) < self.length + self.smoothing:
            return
        
        # Trading logic based on PER
        # Buy when PER crosses above threshold (trending)
        if len(self.per) > 1 and len(self.threshold_final) > 1:
            per_prev = self.per[-2]
            threshold_prev = self.threshold_final[-2]
            
            if per_prev is not None and threshold_prev is not None:
                # Crossover above threshold - enter trend following
                if per_prev <= threshold_prev and per_current > threshold_current:
                    if not self.position:
                        self.buy()
                
                # Crossover below threshold - exit trend following, enter mean reversion
                elif per_prev >= threshold_prev and per_current < threshold_current:
                    if self.position:
                        self.sell()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    results = bt.run()
    print(results)
    bt.plot()