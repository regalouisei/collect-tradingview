"""
DS-TV Backtest Results: chaos-weighted-rsi-luxalgo
============================================================

--- SPY ---
  ERROR: Indicator "calc_chaos(20)" error. See traceback above.

--- BTC ---
  ERROR: Indicator "calc_chaos(20)" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "calc_chaos(20)" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” chaos-weighted-rsi-luxalgo
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    rsi_length = 14
    disorder_length = 20
    sensitivity = 1.0
    div_strength = 20

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)

        # Calculate chaos/fractal dimension index
        def calc_chaos(src, length):
            result = []
            for i in range(len(src)):
                if i < length - 1:
                    result.append(np.nan)
                    continue
                window = src.iloc[i - length + 1:i + 1]
                max_val = window.max()
                min_val = window.min()
                price_range = max_val - min_val

                L = 0.0
                for j in range(length - 1):
                    if price_range > 0:
                        y1 = (window.iloc[j + 1] - min_val) / price_range
                        y2 = (window.iloc[j] - min_val) / price_range
                    else:
                        y1 = y2 = 0.5
                    L += np.sqrt((y1 - y2) ** 2 + (1.0 / (length - 1)) ** 2)

                fdi = 1.0 + np.log(L) / np.log(2.0 * (length - 1))
                chaos_val = np.max(0.0, np.min(1.0, (fdi - 1.0) / 0.5))
                result.append(chaos_val)
            return pd.Series(result)

        self.chaos = self.I(calc_chaos, close, self.disorder_length)

        # Calculate weighted RSI with adaptive smoothing
        def calc_weighted_rsi(src, length, chaos_series, sensitivity):
            result = []
            avg_gain = 0
            avg_loss = 0

            for i in range(len(src)):
                if i == 0:
                    result.append(np.nan)
                    continue

                change = src.iloc[i] - src.iloc[i - 1]
                gain = max(change, 0)
                loss = max(-change, 0)

                if i == 1:
                    avg_gain = gain
                    avg_loss = loss
                else:
                    chaos_val = chaos_series.iloc[i] if not np.isnan(chaos_series.iloc[i]) else 0.5
                    base_alpha = 1.0 / length
                    adjusted_alpha = base_alpha * ((1.0 - chaos_val) ** sensitivity)
                    adjusted_alpha = max(0.001, min(1.0, adjusted_alpha))

                    avg_gain = avg_gain + adjusted_alpha * (gain - avg_gain)
                    avg_loss = avg_loss + adjusted_alpha * (loss - avg_loss)

                if avg_loss == 0:
                    wrsi = 100 if avg_gain > 0 else 50
                else:
                    rs = avg_gain / avg_loss
                    wrsi = 100 - (100 / (1 + rs))

                result.append(wrsi)

            return pd.Series(result)

        self.wrsi = self.I(calc_weighted_rsi, close, self.rsi_length, self.chaos, self.sensitivity)

        # Detect pivot highs and lows for divergence
        def find_pivot_highs(wrsi_series, strength):
            result = [np.nan] * len(wrsi_series)
            for i in range(strength, len(wrsi_series) - strength):
                is_pivot = True
                center_val = wrsi_series.iloc[i]
                for j in range(1, strength + 1):
                    if wrsi_series.iloc[i - j] >= center_val or wrsi_series.iloc[i + j] >= center_val:
                        is_pivot = False
                        break
                if is_pivot:
                    result[i] = center_val
            return pd.Series(result)

        def find_pivot_lows(wrsi_series, strength):
            result = [np.nan] * len(wrsi_series)
            for i in range(strength, len(wrsi_series) - strength):
                is_pivot = True
                center_val = wrsi_series.iloc[i]
                for j in range(1, strength + 1):
                    if wrsi_series.iloc[i - j] <= center_val or wrsi_series.iloc[i + j] <= center_val:
                        is_pivot = False
                        break
                if is_pivot:
                    result[i] = center_val
            return pd.Series(result)

        self.pivot_high = self.I(find_pivot_highs, self.wrsi, self.div_strength)
        self.pivot_low = self.I(find_pivot_lows, self.wrsi, self.div_strength)

        self.last_wrsi_lo = None
        self.last_price_lo = None
        self.last_wrsi_hi = None
        self.last_price_hi = None
        self.bull_div_active = False
        self.bear_div_active = False

    def next(self):
        # Check for bullish divergence signal
        if not np.isnan(self.pivot_low[-1]):
            current_wrsi_lo = self.wrsi[-self.div_strength]
            current_price_lo = self.data.Low[-self.div_strength]

            if self.last_wrsi_lo is not None:
                if current_wrsi_lo > self.last_wrsi_lo and current_price_lo < self.last_price_lo:
                    self.bull_div_active = True

            self.last_wrsi_lo = current_wrsi_lo
            self.last_price_lo = current_price_lo

        # Check for bearish divergence signal
        if not np.isnan(self.pivot_high[-1]):
            current_wrsi_hi = self.wrsi[-self.div_strength]
            current_price_hi = self.data.High[-self.div_strength]

            if self.last_wrsi_hi is not None:
                if current_wrsi_hi < self.last_wrsi_hi and current_price_hi > self.last_price_hi:
                    self.bear_div_active = True

            self.last_wrsi_hi = current_wrsi_hi
            self.last_price_hi = current_price_hi

        # Trading logic
        if self.bull_div_active and self.wrsi[-1] < 30:
            self.buy()
            self.bull_div_active = False

        if self.bear_div_active and self.wrsi[-1] > 70:
            self.sell()
            self.bear_div_active = False

        # Alternative: RSI oversold/overbought with trend confirmation
        if crossover(30, self.wrsi) and self.wrsi[-1] < 35:
            if not self.position:
                self.buy()

        if crossover(self.wrsi, 70) and self.wrsi[-1] > 65:
            if self.position:
                self.position.close()


if __name__ == "__main__":
    from backtesting.test import GOOG

    bt = Backtest(GOOG, TvStrategy, commission=.002, exclusive_orders=True)
    results = bt.run()
    print(results)
    bt.plot()