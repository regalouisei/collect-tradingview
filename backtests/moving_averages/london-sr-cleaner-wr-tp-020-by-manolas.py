"""
DS-TV Backtest Results: london-sr-cleaner-wr-tp-020-by-manolas
============================================================

--- SPY ---
  ERROR: unsupported operand type(s) for +: 'NoneType' and 'float'

--- BTC ---
  ERROR: unsupported operand type(s) for +: 'NoneType' and 'float'

--- QQQ ---
  ERROR: unsupported operand type(s) for +: 'NoneType' and 'float'

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” london-sr-cleaner-wr-tp-020-by-manolas
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Input parameters
    retest_bars = 2
    wick_body_mult = 1.5
    tp_pct = 0.20
    sl_buffer = 0.3
    max_trades_per_day = 2
    ema_len = 200
    atr_len = 14
    atr_break_mult = 0.06
    atr_close_away_mult = 0.12

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        self.ema200 = self.I(pta.ema, close, length=self.ema_len)
        self.atr = self.I(pta.atr, high, low, close, length=self.atr_len)
        
        # Session tracking
        self.in_session = True
        self.sess_high = None
        self.sess_low = None
        self.prev_high = None
        self.prev_low = None
        
        # Daily tracking
        self.trades_today = 0
        self.used_high_today = False
        self.used_low_today = False
        self.last_day = None
        
        # Retest tracking
        self.wait_retest_up = False
        self.break_up_bar = None
        self.wait_retest_dn = False
        self.break_dn_bar = None

    def next(self):
        # Reset daily counters at new day
        current_date = self.data.index[len(self.data) - 1].date()
        if self.last_day is None or current_date != self.last_day:
            self.trades_today = 0
            self.used_high_today = False
            self.used_low_today = False
            self.last_day = current_date
        
        # Initialize session levels on first bar
        if self.sess_high is None:
            self.sess_high = self.data.High[-1]
            self.sess_low = self.data.Low[-1]
            return
        
        # Update session levels
        self.sess_high = max(self.sess_high, self.data.High[-1])
        self.sess_low = min(self.sess_low, self.data.Low[-1])
        
        close = self.data.Close[-1]
        open_ = self.data.Open[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        close_prev = self.data.Close[-2] if len(self.data) > 1 else close
        high_prev = self.data.High[-2] if len(self.data) > 1 else high
        low_prev = self.data.Low[-2] if len(self.data) > 1 else low
        
        atr_val = self.atr[-1] if self.atr[-1] is not None else 0
        ema_val = self.ema200[-1] if self.ema200[-1] is not None else close
        
        # Break conditions
        break_up = (self.prev_high is not None and 
                   close > (self.prev_high + atr_val * self.atr_break_mult) and 
                   close_prev <= self.prev_high)
        
        break_dn = (self.prev_low is not None and 
                   close < (self.prev_low - atr_val * self.atr_break_mult) and 
                   close_prev >= self.prev_low)
        
        # Set retest wait flags
        if break_up and not self.used_high_today:
            self.wait_retest_up = True
            self.break_up_bar = len(self.data) - 1
        
        if break_dn and not self.used_low_today:
            self.wait_retest_dn = True
            self.break_dn_bar = len(self.data) - 1
        
        # Clear retest wait if timeout
        if self.wait_retest_up and self.break_up_bar is not None:
            if len(self.data) - 1 - self.break_up_bar > self.retest_bars:
                self.wait_retest_up = False
                self.break_up_bar = None
        
        if self.wait_retest_dn and self.break_dn_bar is not None:
            if len(self.data) - 1 - self.break_dn_bar > self.retest_bars:
                self.wait_retest_dn = False
                self.break_dn_bar = None
        
        # Retest touch detection
        retest_touch_up = self.wait_retest_up and low <= self.prev_high
        retest_touch_dn = self.wait_retest_dn and high >= self.prev_low
        
        # Wick rejection checks
        upper_wick = high - max(open_, close)
        lower_wick = min(open_, close) - low
        body_size = abs(close - open_)
        
        # Close-away confirmation
        close_away_up = close > (self.prev_high + atr_val * self.atr_close_away_mult)
        close_away_dn = close < (self.prev_low - atr_val * self.atr_close_away_mult)
        
        # Trading conditions
        can_trade = self.trades_today < self.max_trades_per_day
        flat = len(self.position) == 0
        
        # Buy signal
        buy_signal = (can_trade and flat and not self.used_high_today and
                     retest_touch_up and
                     close > open_ and
                     (lower_wick > body_size * self.wick_body_mult) and
                     close_away_up and
                     close > ema_val)
        
        # Sell signal
        sell_signal = (can_trade and flat and not self.used_low_today and
                      retest_touch_dn and
                      close < open_ and
                      (upper_wick > body_size * self.wick_body_mult) and
                      close_away_dn and
                      close < ema_val)
        
        # Entry execution
        if buy_signal:
            self.trades_today += 1
            self.used_high_today = True
            self.wait_retest_up = False
            self.break_up_bar = None
            
            buy_sl = low - self.sl_buffer
            buy_tp = close * (1.0 + self.tp_pct / 100.0)
            
            self.buy()
            self.position.exit(limit=buy_tp, stop=buy_sl)
        
        if sell_signal:
            self.trades_today += 1
            self.used_low_today = True
            self.wait_retest_dn = False
            self.break_dn_bar = None
            
            sell_sl = high + self.sl_buffer
            sell_tp = close * (1.0 - self.tp_pct / 100.0)
            
            self.sell()
            self.position.exit(limit=sell_tp, stop=sell_sl)
        
        # Update previous session levels at session change (simplified)
        if len(self.data) > 1:
            self.prev_high = self.sess_high
            self.prev_low = self.sess_low


if __name__ == '__main__':
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=0.0)
    stats = bt.run()
    print(stats)
    bt.plot()