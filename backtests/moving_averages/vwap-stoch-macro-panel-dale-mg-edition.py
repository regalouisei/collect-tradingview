"""
DS-TV Backtest Results: vwap-stoch-macro-panel-dale-mg-edition
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — vwap-stoch-macro-panel-dale-mg-edition
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        open_ = pd.Series(self.data.Open)
        volume = pd.Series(self.data.Volume)
        
        # VWAP calculation
        hlc3 = (high + low + close) / 3
        self.vwap = self.I(lambda: pta.vwap(close, high, low, volume) or pd.Series(close.mean(), index=close.index))
        
        # Stochastic parameters
        period_k = 14
        period_d = 3
        smooth_k = 3
        
        # Local Stochastic (5-15 min equivalent)
        stoch_raw = self.I(lambda: pta.stoch(high, low, close, k=period_k, d=period_d, smooth_k=smooth_k))
        
        # Extract K line from stochastic
        self.k = self.I(lambda: pta.sma(pta.stoch(high, low, close, k=period_k)['STOCHk_14_3_3'] if pta.stoch(high, low, close, k=period_k) is not None else pd.Series(50, index=close.index), length=smooth_k) or pd.Series(50, index=close.index))
        
        # SMA 200 for macro filter (simulated with available data)
        self.sma_200 = self.I(pta.sma, close, length=200)
        
        # Store raw OHLC for rejection calculation
        self.open = open_
        self.high = high
        self.low = low
        self.close = close
        
    def next(self):
        if len(self.data) < 200:
            return
        
        current_close = self.data.Close[-1]
        current_open = self.data.Open[-1]
        current_low = self.data.Low[-1]
        current_high = self.data.High[-1]
        current_vwap = self.vwap[-1]
        current_k = self.k[-1]
        current_sma_200 = self.sma_200[-1]
        
        # nearVWAP: price is near VWAP (within 0.15%)
        near_vwap = current_low <= current_vwap * 1.0015
        
        # stochOversold: K < 30
        stoch_oversold = current_k < 30
        
        # stochBought: K > 70
        stoch_bought = current_k > 70
        
        # rejection: (min(open, close) - low) > (abs(close - open) * 1.2)
        rejection = (min(current_open, current_close) - current_low) > (abs(current_close - current_open) * 1.2)
        
        # longSignal: close > VWAP AND nearVWAP AND stochOversold AND rejection AND close > SMA200
        long_signal = (current_close > current_vwap and 
                      near_vwap and 
                      stoch_oversold and 
                      rejection and 
                      current_close > current_sma_200)
        
        # shortSignal: close < VWAP AND nearVWAP AND stochBought AND rejection AND close < SMA200
        short_signal = (current_close < current_vwap and 
                       near_vwap and 
                       stoch_bought and 
                       rejection and 
                       current_close < current_sma_200)
        
        # Execute trades
        if long_signal:
            if not self.position:
                self.buy()
        elif short_signal:
            if self.position:
                self.position.close()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, commission=.002, exclusive_orders=True)
    stats = bt.run()
    print(stats)
    bt.plot()