"""
DS-TV Backtest Results: long-short-ma-band-breakout-with-fixed-stop
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — long-short-ma-band-breakout-with-fixed-stop
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover

class TvStrategy(Strategy):
    param1 = 200  # MA Length
    param2 = 3.0  # Upper Band %
    param3 = 2.0  # Lower Band %
    param4 = 2.0  # Fixed Stop-Loss (%)
    param5 = 'EMA'  # Moving Average Type

    def init(self):
        close = pd.Series(self.data.Close)
        ma_type = self.param5
        ma_len = self.param1
        band_up_perc = self.param2
        band_down_perc = self.param3
        stop_loss_perc = self.param4
        
        # Calculate Moving Average
        if ma_type == 'EMA':
            self.ma = self.I(pta.ema, close, length=ma_len)
        elif ma_type == 'TEMA':
            self.ma = self.I(pta.tema, close, length=ma_len)
        elif ma_type == 'SMA':
            self.ma = self.I(pta.sma, close, length=ma_len)
        elif ma_type == 'ALMA':
            self.ma = self.I(pta.alma, close, length=ma_len, offset=0.85, sigma=6)
        elif ma_type == 'HMA':
            self.ma = self.I(pta.hma, close, length=ma_len)
        
        # Calculate Bands
        self.upper_band = self.ma * (1 + band_up_perc / 100)
        self.lower_band = self.ma * (1 - band_down_perc / 100)

    def next(self):
        in_date_range = self.I(lambda: self.data.time >= self.I(timestamp, '2018-01-01'))
        mode = self.I(lambda: self.data.mode == 'Long Only' or self.data.mode == 'Long & Short')
        long_entry = self.I(lambda: self.data.close > self.upper_band) & self.I(lambda: self.data.position_size == 0)
        long_exit = self.I(lambda: self.data.close < self.lower_band) & self.I(lambda: self.data.position_size > 0) & self.I(lambda: self.data.position_avg_price > 0)
        short_entry = self.I(lambda: self.data.close < self.lower_band) & self.I(lambda: self.data.position_size == 0)
        short_exit = self.I(lambda: self.data.close > self.upper_band) & self.I(lambda: self.data.position_size < 0)
        stop_loss_price = self.I(lambda: self.data.close * (1 - self.param4 / 100))
        entry_price = self.I(lambda: self.data.close * (1 + self.param4 / 100))

        if in_date_range & mode:
            if long_entry:
                self.buy()
                self.exit('Exit Long', 'Long', stop=stop_loss_price)
            if long_exit:
                self.close('Long')
            if short_entry:
                self.short()
                self.exit('Exit Short', 'Short', stop=entry_price)
            if short_exit:
                self.close('Short')