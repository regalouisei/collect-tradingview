"""
DS-TV Backtest Results: rtr-70-30
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (502,); indicator "sma(V,10)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (732,); indicator "sma(V,10)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (502,); indicator "sma(V,10)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” rtr-70-30
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    param1 = 20
    param2 = 50
    param3 = 200
    volLookback = 10
    volMultiplier = 2.0
    useHighestFilter = False
    touchBufferPct = 0.0
    showBounce50 = True
    showBounce200 = True

    def init(self):
        close = pd.Series(self.data.Close)
        self.ema20 = self.I(pta.ema, close, length=self.param1)
        self.ema50 = self.I(pta.ema, close, length=self.param2)
        self.ema200 = self.I(pta.ema, close, length=self.param3)
        self.volSMA = self.I(pta.sma, self.data.Volume, length=self.volLookback)
        self.highVol = self.I(lambda: self.data.Volume > self.volSMA * self.volMultiplier,
                               self.data, columns=['Volume'])
        self.highVolByHighest = self.I(lambda: self.data.Volume > self.I(lambda: self.I(pta.highest, self.data.Volume, self.volLookback), self.data)[self.data.index[-1]],
                                       self.data, columns=['Volume'])
        self.highVolFiltered = self.I(lambda: self.useHighestFilter and self.highVol and self.highVolByHighest,
                                       self.data, columns=['Volume'])

    def next(self):
        bullCross = crossover(self.ema20, self.ema200) or crossover(self.ema50, self.ema200)
        bearCross = crossover(self.ema20, self.ema200) or crossover(self.ema50, self.ema200)
        bullCrossSignal = self.highVolFiltered and (bullCross or self.highVol)
        bearCrossSignal = self.highVolFiltered and (bearCross or self.highVol)

        buf50 = self.ema50 * (self.touchBufferPct / 100.0)
        buf200 = self.ema200 * (self.touchBufferPct / 100.0)

        touch50 = (self.data.Low <= self.ema50 + buf50) and (self.data.High >= self.ema50 - buf50)
        touch200 = (self.data.Low <= self.ema200 + buf200) and (self.data.High >= self.ema200 - buf200)

        bullBounce50 = self.showBounce50 and touch50 and self.data.Close > self.ema50
        bearBounce50 = self.showBounce50 and touch50 and self.data.Close < self.ema50
        bullBounce200 = self.showBounce200 and touch200 and self.data.Close > self.ema200
        bearBounce200 = self.showBounce200 and touch200 and self.data.Close < self.ema200

        bullBounce50Signal = self.highVolFiltered and (bullBounce50 or self.highVol)
        bearBounce50Signal = self.highVolFiltered and (bearBounce50 or self.highVol)
        bullBounce200Signal = self.highVolFiltered and (bullBounce200 or self.highVol)
        bearBounce200Signal = self.highVolFiltered and (bearBounce200 or self.highVol)

        if bullCrossSignal:
            self.buy()
        elif bearCrossSignal:
            self.sell()

        if bullBounce50Signal:
            self.buy()
        elif bearBounce50Signal:
            self.sell()

        if bullBounce200Signal:
            self.buy()
        elif bearBounce200Signal:
            self.sell()