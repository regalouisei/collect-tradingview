"""
DS-TV Backtest Results: top-score-scalping-3-signal-dashboard-v2
============================================================

--- SPY ---
  ERROR: Indicator "_calculat…" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_calculat…" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_calculat…" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — top-score-scalping-3-signal-dashboard-v2
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # EMA Settings
    emaFastL = 9
    emaSlowL = 21
    
    # RSI Settings
    rsiLen = 14
    rsiBuyLv = 50
    rsiSellLv = 50
    
    # VFI Settings
    vfiLen = 130
    vfiCoef = 0.2
    vfiSmooth = 3
    
    # Weight Settings
    wEMA = 40
    wRSI = 35
    wVFI = 25
    
    # Dashboard Settings
    minProb = 60

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # EMA
        self.emaFast = self.I(pta.ema, close, length=self.emaFastL)
        self.emaSlow = self.I(pta.ema, close, length=self.emaSlowL)
        
        # RSI
        self.rsiVal = self.I(pta.rsi, close, length=self.rsiLen)
        
        # VFI (Volume Flow Indicator)
        self.vfiVal = self.I(self._calculate_vfi, close, high, low, volume)
        
        # Buy/Sell Scores
        self.buyScore = self.I(self._calculate_buy_score)
        self.sellScore = self.I(self._calculate_sell_score)

    def _calculate_vfi(self, close, high, low, volume):
        """Calculate Volume Flow Indicator"""
        df = pd.DataFrame({
            'close': close,
            'high': high,
            'low': low,
            'volume': volume
        })
        
        # Calculate HLC3
        hlc3 = (df['high'] + df['low'] + df['close']) / 3
        
        # Calculate inter and vInter
        inter = np.log(hlc3) - np.log(hlc3.shift(1))
        vInter = inter.rolling(window=30).std()
        
        # Calculate cutOff
        cutOff = self.vfiCoef * vInter * df['close']
        
        # Calculate vave and vMax
        vave = df['volume'].rolling(window=self.vfiLen).mean().shift(1)
        vMax = vave * 2.5
        
        # Calculate vc (capped volume)
        vc = df['volume'].copy()
        vc[df['volume'] > vMax] = vMax[df['volume'] > vMax]
        
        # Calculate mf (money flow)
        mf = hlc3 - hlc3.shift(1)
        
        # Calculate vcp
        vcp = pd.Series(0.0, index=df.index)
        vcp[mf > cutOff] = vc[mf > cutOff]
        vcp[mf < -cutOff] = -vc[mf < -cutOff]
        
        # Calculate rawVFI
        rawVFI = vcp.rolling(window=self.vfiLen).sum() / vave
        
        # Smooth with EMA
        vfiVal = rawVFI.ewm(span=self.vfiSmooth, adjust=False).mean()
        
        return vfiVal

    def _calculate_buy_score(self):
        """Calculate buy probability score"""
        total_w = self.wEMA + self.wRSI + self.wVFI
        
        if total_w == 0:
            norm_ema = norm_rsi = norm_vfi = 33.33
        else:
            norm_ema = (self.wEMA * 1.0) / total_w * 100.0
            norm_rsi = (self.wRSI * 1.0) / total_w * 100.0
            norm_vfi = (self.wVFI * 1.0) / total_w * 100.0
        
        ema_bullish = self.emaFast[-1] > self.emaSlow[-1]
        rsi_bullish = self.rsiVal[-1] > self.rsiBuyLv
        vfi_bullish = self.vfiVal[-1] > 0
        
        buy_score = (norm_ema if ema_bullish else 0.0) + \
                    (norm_rsi if rsi_bullish else 0.0) + \
                    (norm_vfi if vfi_bullish else 0.0)
        
        return buy_score

    def _calculate_sell_score(self):
        """Calculate sell probability score"""
        total_w = self.wEMA + self.wRSI + self.wVFI
        
        if total_w == 0:
            norm_ema = norm_rsi = norm_vfi = 33.33
        else:
            norm_ema = (self.wEMA * 1.0) / total_w * 100.0
            norm_rsi = (self.wRSI * 1.0) / total_w * 100.0
            norm_vfi = (self.wVFI * 1.0) / total_w * 100.0
        
        ema_bearish = self.emaFast[-1] < self.emaSlow[-1]
        rsi_bearish = self.rsiVal[-1] < self.rsiSellLv
        vfi_bearish = self.vfiVal[-1] < 0
        
        sell_score = (norm_ema if ema_bearish else 0.0) + \
                     (norm_rsi if rsi_bearish else 0.0) + \
                     (norm_vfi if vfi_bearish else 0.0)
        
        return sell_score

    def next(self):
        # Get current scores
        buy_score = self.buyScore[-1] if len(self.buyScore) > 0 else 0
        sell_score = self.sellScore[-1] if len(self.sellScore) > 0 else 0
        
        # Get previous scores for crossover detection
        prev_buy_score = self.buyScore[-2] if len(self.buyScore) > 1 else 0
        prev_sell_score = self.sellScore[-2] if len(self.sellScore) > 1 else 0
        
        # Buy signal: buy_score just crossed above minProb and > sell_score
        buy_signal = buy_score >= self.minProb and buy_score > sell_score
        buy_trigger = buy_signal and not (prev_buy_score >= self.minProb and prev_buy_score > prev_sell_score)
        
        # Sell signal: sell_score just crossed above minProb and > buy_score
        sell_signal = sell_score >= self.minProb and sell_score > buy_score
        sell_trigger = sell_signal and not (prev_sell_score >= self.minProb and prev_sell_score > prev_buy_score)
        
        if buy_trigger and not self.position:
            self.buy()
        elif sell_trigger and self.position:
            self.position.close()