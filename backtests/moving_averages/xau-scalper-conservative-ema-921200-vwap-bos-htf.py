"""
DS-TV Backtest Results: xau-scalper-conservative-ema-921200-vwap-bos-htf
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "calc_slope(ema(21))" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "calc_slope(ema(21))" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "calc_slope(ema(21))" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” xau-scalper-conservative-ema-921200-vwap-bos-htf
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # EMA parameters
    emaFastLen = 9
    emaSlowLen = 21
    emaTrendLen = 200
    useVWAPFilter = True
    
    # Volume parameters
    useVolFilter = True
    volLen = 50
    volFactor = 1.4
    minAdx = 15.0
    
    # Session filter
    useSessionFilter = True
    
    # Structure & BOS
    useStructure = True
    bosLookback = 40
    
    # HTF filter
    useHTF = True
    htfFastLen = 50
    htfSlowLen = 200
    
    # Conservative confirmations
    requireTouch21 = True
    reclaimCandle = "prevHighBreak"
    slopeLen = 6
    slopeMinPct = 0.03
    minDist200Pct = 0.06

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # Core MAs
        self.emaFast = self.I(pta.ema, close, length=self.emaFastLen)
        self.emaSlow = self.I(pta.ema, close, length=self.emaSlowLen)
        self.emaTrend = self.I(pta.ema, close, length=self.emaTrendLen)
        
        # VWAP (simplified - just use SMA of HLC3 as proxy)
        hlc3 = (high + low + close) / 3
        self.vwap = self.I(pta.sma, hlc3, length=20)
        
        # Volume MA
        self.volMA = self.I(pta.sma, volume, length=self.volLen)
        
        # ADX calculation (manual Wilder's smoothing)
        def calc_adx(high_s, low_s, close_s):
            tr1 = high_s - low_s
            tr2 = (high_s - close_s.shift(1)).abs()
            tr3 = (low_s - close_s.shift(1)).abs()
            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            
            upMove = high_s - high_s.shift(1)
            downMove = low_s.shift(1) - low_s
            
            plusDM = pd.Series(0.0, index=high_s.index)
            minusDM = pd.Series(0.0, index=high_s.index)
            
            for i in range(1, len(high_s)):
                if upMove.iloc[i] > 0 and upMove.iloc[i] > downMove.iloc[i]:
                    plusDM.iloc[i] = upMove.iloc[i]
                if downMove.iloc[i] > 0 and downMove.iloc[i] >= upMove.iloc[i]:
                    minusDM.iloc[i] = downMove.iloc[i]
            
            # Wilder's RMA
            atr = pta.rma(tr, length=14)
            plusDI = pd.Series(0.0, index=close_s.index)
            minusDI = pd.Series(0.0, index=close_s.index)
            
            atr_rma = pta.rma(tr, length=14)
            plusDM_rma = pta.rma(plusDM, length=14)
            minusDM_rma = pta.rma(minusDM, length=14)
            
            for i in range(len(atr_rma)):
                if atr_rma.iloc[i] != 0:
                    plusDI.iloc[i] = 100.0 * plusDM_rma.iloc[i] / atr_rma.iloc[i]
                    minusDI.iloc[i] = 100.0 * minusDM_rma.iloc[i] / atr_rma.iloc[i]
            
            diSum = plusDI + minusDI
            dx = pd.Series(0.0, index=close_s.index)
            for i in range(len(diSum)):
                if diSum.iloc[i] != 0:
                    dx.iloc[i] = abs(plusDI.iloc[i] - minusDI.iloc[i]) / diSum.iloc[i] * 100.0
            
            adx_result = pta.rma(dx, length=14)
            return adx_result if adx_result is not None else pd.Series(50, index=close_s.index)
        
        self.adx = self.I(calc_adx, high, low, close)
        
        # EMA21 slope
        def calc_slope(ema21):
            return pta.roc(ema21, length=self.slopeLen)
        
        self.slopePct = self.I(calc_slope, self.emaSlow)
        
        # Pivot highs and lows for structure
        def calc_pivot_high(high_s):
            result = pd.Series(np.nan, index=high_s.index)
            for i in range(2, len(high_s) - 2):
                if high_s.iloc[i] > high_s.iloc[i-1] and high_s.iloc[i] > high_s.iloc[i-2] and \
                   high_s.iloc[i] > high_s.iloc[i+1] and high_s.iloc[i] > high_s.iloc[i+2]:
                    result.iloc[i] = high_s.iloc[i]
            return result
        
        def calc_pivot_low(low_s):
            result = pd.Series(np.nan, index=low_s.index)
            for i in range(2, len(low_s) - 2):
                if low_s.iloc[i] < low_s.iloc[i-1] and low_s.iloc[i] < low_s.iloc[i-2] and \
                   low_s.iloc[i] < low_s.iloc[i+1] and low_s.iloc[i] < low_s.iloc[i+2]:
                    result.iloc[i] = low_s.iloc[i]
            return result
        
        self.ph = self.I(calc_pivot_high, high)
        self.pl = self.I(calc_pivot_low, low)
        
        # Distance from EMA200
        def calc_dist_200(close_s, ema200):
            return (np.abs(close_s - ema200) / close_s * 100.0)
        
        self.pctDist200 = self.I(calc_dist_200, close, self.emaTrend)
        
        # Tracking variables for BOS
        self.lastPH = None
        self.lastPL = None
        self.lastBosUpBar = None
        self.lastBosDnBar = None

    def next(self):
        close = self.data.Close[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        volume = self.data.Volume[-1]
        idx = len(self.data) - 1
        
        if idx < self.emaTrendLen + 5:
            return
        
        # Update pivot tracking
        if not np.isnan(self.ph[-1]):
            self.lastPH = self.ph[-1]
        if not np.isnan(self.pl[-1]):
            self.lastPL = self.pl[-1]
        
        # Core bias
        longBiasMA = close > self.emaTrend[-1] and self.emaFast[-1] > self.emaSlow[-1]
        shortBiasMA = close < self.emaTrend[-1] and self.emaFast[-1] < self.emaSlow[-1]
        
        # Filters
        farFrom200 = self.pctDist200[-1] >= self.minDist200Pct
        volOkay = not self.useVolFilter or (volume > self.volMA[-1] * self.volFactor)
        vwapLongOkay = not self.useVWAPFilter or (close >= self.vwap[-1])
        vwapShortOkay = not self.useVWAPFilter or (close <= self.vwap[-1])
        adxOkay = self.adx[-1] >= self.minAdx if not np.isnan(self.adx[-1]) else True
        slopeUp = self.slopePct[-1] >= self.slopeMinPct if not np.isnan(self.slopePct[-1]) else False
        slopeDown = self.slopePct[-1] <= -self.slopeMinPct if not np.isnan(self.slopePct[-1]) else False
        
        # BOS logic
        bosUp = self.useStructure and self.lastPH is not None and high > self.lastPH
        bosDown = self.useStructure and self.lastPL is not None and low < self.lastPL
        
        if bosUp:
            self.lastBosUpBar = idx
        if bosDown:
            self.lastBosDnBar = idx
        
        bosUpActive = self.useStructure and self.lastBosUpBar is not None and \
                      (idx - self.lastBosUpBar) <= self.bosLookback and \
                      (self.lastBosDnBar is None or self.lastBosUpBar > self.lastBosDnBar)
        bosDownActive = self.useStructure and self.lastBosDnBar is not None and \
                        (idx - self.lastBosDnBar) <= self.bosLookback and \
                        (self.lastBosUpBar is None or self.lastBosDnBar > self.lastBosUpBar)
        
        # Pullback logic
        touched21Long = low <= self.emaSlow[-1]
        touched21Short = high >= self.emaSlow[-1]
        pullbackOKLong = touched21Long if self.requireTouch21 else True
        pullbackOKShort = touched21Short if self.requireTouch21 else True
        
        # Candle confirmations
        prevHighBreakLong = close > self.data.High[-2]
        prevHighBreakShort = close < self.data.Low[-2]
        confirmLong = prevHighBreakLong if self.reclaimCandle == "prevHighBreak" else False
        confirmShort = prevHighBreakShort if self.reclaimCandle == "prevHighBreak" else False
        
        # Reclaim EMA9
        reclaim9Long = close > self.emaFast[-1]
        reclaim9Short = close < self.emaFast[-1]
        
        # Final signals
        signalLongCons = (longBiasMA and bosUpActive and pullbackOKLong and reclaim9Long and 
                         confirmLong and vwapLongOkay and volOkay and slopeUp and farFrom200 and adxOkay)
        signalShortCons = (shortBiasMA and bosDownActive and pullbackOKShort and reclaim9Short and 
                          confirmShort and vwapShortOkay and volOkay and slopeDown and farFrom200 and adxOkay)
        
        # Trading logic
        if signalLongCons and not self.position:
            self.buy()
        elif signalShortCons and self.position:
            self.sell()