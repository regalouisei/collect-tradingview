"""
DS-TV Backtest Results: 200-bar-en-uzun-bar-15x-volume-nokta
============================================================

--- SPY ---
  ERROR: object of type 'TvStrategy' has no len()

--- BTC ---
  ERROR: object of type 'TvStrategy' has no len()

--- QQQ ---
  ERROR: object of type 'TvStrategy' has no len()

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” 200-bar-en-uzun-bar-15x-volume-nokta
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lookback = 200
    vol_length = 20
    strong_lookback = 20

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # Calculate bar size
        self.bar_size = self.I(lambda: high - low)
        
        # Calculate max bar size over lookback period
        self.max_bar_size = self.I(lambda: (high - low).rolling(self.lookback).max())
        
        # Calculate average volume
        self.avg_volume = self.I(pta.sma, volume, length=self.vol_length)
        
        # Determine longer bar condition
        self.longer_bar = self.I(lambda: (high - low) > (high - low).rolling(self.lookback).max().shift(1))
        
        # Determine high volume condition
        self.high_volume = self.I(lambda: volume >= self.avg_volume[-1] * 1.5 if len(self.avg_volume) > 0 and self.avg_volume[-1] is not None else False)
        
        # Signal count over last 20 bars
        self.signal_count = self.I(lambda: ((high - low) > (high - low).rolling(self.lookback).max().shift(1)).astype(int).rolling(self.strong_lookback).sum())
        
        # Strong signal condition
        self.strong_signal = self.I(lambda: ((high - low) > (high - low).rolling(self.lookback).max().shift(1)) & (((high - low) > (high - low).rolling(self.lookback).max().shift(1)).astype(int).rolling(self.strong_lookback).sum() >= 2))

    def next(self):
        # Check if we have valid signal
        if len(self) < self.lookback + 1:
            return
        
        # Blue bar: longer bar without high volume
        blue_bar = self.longer_bar[-1] and not self.high_volume[-1]
        
        # Red bar: longer bar with high volume
        red_bar = self.longer_bar[-1] and self.high_volume[-1]
        
        # Strong signal
        strong_signal = self.strong_signal[-1] if isinstance(self.strong_signal[-1], (bool, np.bool_)) else False
        
        # Trading logic: Buy on blue bar signal, sell on red bar signal
        if blue_bar and not self.position:
            self.buy()
        elif red_bar and self.position:
            self.sell()
        
        # Strong signal confirmation - can be used as additional entry
        if strong_signal and not self.position:
            self.buy()


if __name__ == "__main__":
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()