"""
DS-TV Backtest Results: 1-min-gold-taylor-technique
============================================================

--- SPY ---
  Return                    0.00%
  Buy & Hold Return         39.08%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- BTC ---
  Return                    0.00%
  Buy & Hold Return         14.14%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

--- QQQ ---
  Return                    0.00%
  Buy & Hold Return         42.00%
  Max Drawdown              -0.00%
  Sharpe Ratio              nan
  Sortino Ratio             nan
  Calmar Ratio              nan
  Profit Factor             nan
  Expectancy                nan%
  SQN                       nan
  # Trades                  0
  Win Rate                  nan%
  Best Trade                nan%
  Worst Trade               nan%
  Avg Trade                 nan%
  Exposure Time             0.00%
  Equity Final              100000.00$
  Equity Peak               100000.00$
  Avg Drawdown              nan%
  Max Drawdown Duration     nan
  Max Trade Duration        nan
  Avg Trade Duration        nan
  Ann. Return               0.00%
  Ann. Volatility           0.00%

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” 1-min-gold-taylor-technique
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover
from datetime import datetime


class TvStrategy(Strategy):
    # Risk Management
    riskRewardRatio = 3.0
    stopLossPoints = 6.0
    useTrailingStop = False
    
    # Session Times (GMT)
    asianStart = 0
    asianEnd = 5
    londonStart = 6
    nyStart = 13
    nyEnd = 17
    
    # Indicator Settings
    atrLength = 14
    atrMultiplier = 2.0
    emaLength = 20
    sweepBufferPoints = 2.0
    
    def init(self):
        self.mintick = 0.01
        
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # VWAP
        self.vwap = self.I(self._calculate_vwap, close, high, low, volume)
        
        # 20 EMA
        self.ema20 = self.I(pta.ema, close, length=self.emaLength)
        
        # ATR for SuperTrend
        self.atr = self.I(pta.atr, high, low, close, length=self.atrLength)
        
        # SuperTrend calculation
        self.supertrend = self.I(self._calculate_supertrend, high, low, close)
        
        # Asian Range tracking
        self.asian_high = None
        self.asian_low = None
        self.asian_mid = None
        self.prev_day_high = None
        self.prev_day_low = None
        self.last_day = None
        
        # Position tracking
        self.long_stop_loss = None
        self.short_stop_loss = None
        self.entry_price = None
        self.in_long = False
        self.in_short = False
    
    def _calculate_vwap(self, close, high, low, volume):
        typical_price = (high + low + close) / 3
        cumulative_tp_volume = (typical_price * volume).cumsum()
        cumulative_volume = volume.cumsum()
        vwap = cumulative_tp_volume / cumulative_volume
        return vwap
    
    def _calculate_supertrend(self, high, low, close):
        hl2 = (high + low) / 2
        atr_values = pta.atr(high, low, close, length=self.atrLength)
        
        upper_band = hl2 + (self.atrMultiplier * atr_values)
        lower_band = hl2 - (self.atrMultiplier * atr_values)
        
        supertrend = pd.Series(index=close.index, dtype=float)
        direction = pd.Series(index=close.index, dtype=int)
        
        supertrend.iloc[0] = lower_band.iloc[0]
        direction.iloc[0] = 1
        
        for i in range(1, len(close)):
            if direction.iloc[i-1] == 1:
                supertrend.iloc[i] = upper_band.iloc[i] if close.iloc[i] < supertrend.iloc[i-1] else max(lower_band.iloc[i], supertrend.iloc[i-1])
            else:
                supertrend.iloc[i] = lower_band.iloc[i] if close.iloc[i] > supertrend.iloc[i-1] else min(upper_band.iloc[i], supertrend.iloc[i-1])
            
            direction.iloc[i] = 1 if close.iloc[i] > supertrend.iloc[i] else -1
        
        return supertrend
    
    def _get_current_hour(self):
        if len(self.data) == 0:
            return 0
        bar_time = pd.Timestamp(self.data.index[-1])
        return bar_time.hour
    
    def _is_new_day(self):
        if len(self.data) < 2:
            return False
        current_day = pd.Timestamp(self.data.index[-1]).date()
        prev_day = pd.Timestamp(self.data.index[-2]).date()
        return current_day != prev_day
    
    def _update_asian_range(self):
        current_hour = self._get_current_hour()
        is_asian = current_hour >= self.asianStart and current_hour < self.asianEnd
        is_new_day = self._is_new_day()
        
        if is_new_day:
            self.asian_high = None
            self.asian_low = None
            self.asian_mid = None
            self.prev_day_high = self.data.High[-2] if len(self.data) >= 2 else None
            self.prev_day_low = self.data.Low[-2] if len(self.data) >= 2 else None
        
        if is_asian:
            if self.asian_high is None:
                self.asian_high = self.data.High[-1]
                self.asian_low = self.data.Low[-1]
            else:
                self.asian_high = max(self.asian_high, self.data.High[-1])
                self.asian_low = min(self.asian_low, self.data.Low[-1])
            self.asian_mid = (self.asian_high + self.asian_low) / 2
    
    def _check_session(self):
        current_hour = self._get_current_hour()
        is_london = current_hour >= self.londonStart and current_hour < self.nyStart
        is_ny = current_hour >= self.nyStart and current_hour < self.nyEnd
        return is_london or is_ny
    
    def _check_sweep(self):
        sweep_buffer = self.sweepBufferPoints * self.mintick
        
        bullish_sweep = False
        bearish_sweep = False
        
        if self.asian_low is not None:
            if self.data.Low[-1] <= (self.asian_low - sweep_buffer) and self.data.Close[-1] > self.asian_low:
                bullish_sweep = True
        
        if self.asian_high is not None:
            if self.data.High[-1] >= (self.asian_high + sweep_buffer) and self.data.Close[-1] < self.asian_high:
                bearish_sweep = True
        
        if self.prev_day_low is not None:
            if self.data.Low[-1] <= (self.prev_day_low - sweep_buffer) and self.data.Close[-1] > self.prev_day_low:
                bullish_sweep = True
        
        if self.prev_day_high is not None:
            if self.data.High[-1] >= (self.prev_day_high + sweep_buffer) and self.data.Close[-1] < self.prev_day_high:
                bearish_sweep = True
        
        return bullish_sweep, bearish_sweep
    
    def next(self):
        self._update_asian_range()
        current_hour = self._get_current_hour()
        is_trading_hours = self._check_session()
        bullish_sweep, bearish_sweep = self._check_sweep()
        
        if len(self.data) < 2 or self.supertrend[-1] is None or self.ema20[-1] is None or self.vwap[-1] is None:
            return
        
        # SuperTrend signals
        supertrend_bullish = self.data.Close[-1] > self.supertrend[-1]
        supertrend_bearish = self.data.Close[-1] <= self.supertrend[-1]
        
        supertrend_flip_bullish = supertrend_bullish and (len(self.data) < 2 or self.data.Close[-2] <= self.supertrend[-2])
        supertrend_flip_bearish = supertrend_bearish and (len(self.data) < 2 or self.data.Close[-2] > self.supertrend[-2])
        
        # Reversal checks
        long_reversal = len(self.data) >= 2 and self.data.Low[-1] < self.data.Low[-2] and self.data.Close[-1] > self.data.Low[-2]
        short_reversal = len(self.data) >= 2 and self.data.High[-1] > self.data.High[-2] and self.data.Close[-1] < self.data.High[-2]
        
        # Entry conditions
        long_entry = (bullish_sweep and long_reversal and 
                     (supertrend_flip_bullish or supertrend_bullish) and 
                     (self.data.Close[-1] > self.vwap[-1] or self.data.Close[-1] > self.ema20[-1]) and 
                     is_trading_hours and self.position.size == 0)
        
        short_entry = (bearish_sweep and short_reversal and 
                      (supertrend_flip_bearish or supertrend_bearish) and 
                      (self.data.Close[-1] < self.vwap[-1] or self.data.Close[-1] < self.ema20[-1]) and 
                      is_trading_hours and self.position.size == 0)
        
        # Close positions at end of day
        if current_hour >= self.nyEnd and self.position.size != 0:
            self.position.close()
        
        # Long Entry
        if long_entry:
            self.long_stop_loss = self.data.Low[-1] - (self.stopLossPoints * self.mintick)
            risk_distance = self.data.Close[-1] - self.long_stop_loss
            
            tp1 = self.data.Close[-1] + (risk_distance * self.riskRewardRatio * 0.33)
            tp2 = self.data.Close[-1] + (risk_distance * self.riskRewardRatio * 0.66)
            tp3 = self.data.Close[-1] + (risk_distance * self.riskRewardRatio)
            
            self.buy()
            self.entry_price = self.data.Close[-1]
            self.in_long = True
        
        # Short Entry
        elif short_entry:
            self.short_stop_loss = self.data.High[-1] + (self.stopLossPoints * self.mintick)
            risk_distance = self.short_stop_loss - self.data.Close[-1]
            
            tp1 = self.data.Close[-1] - (risk_distance * self.riskRewardRatio * 0.33)
            tp2 = self.data.Close[-1] - (risk_distance * self.riskRewardRatio * 0.66)
            tp3 = self.data.Close[-1] - (risk_distance * self.riskRewardRatio)
            
            self.sell()
            self.entry_price = self.data.Close[-1]
            self.in_short = True
        
        # Stop loss management
        if self.position.size > 0 and self.long_stop_loss is not None:
            if self.data.Low[-1] <= self.long_stop_loss:
                self.position.close()
        
        if self.position.size < 0 and self.short_stop_loss is not None:
            if self.data.High[-1] >= self.short_stop_loss:
                self.position.close()


if __name__ == '__main__':
    import yfinance as yf
    
    data = yf.download('XAUUSD=X', start='2023-01-01', end='2024-01-01', interval='1m')
    
    bt = Backtest(data, TvStrategy, cash=10000, commission=0.0002, exclusive_orders=True)
    results = bt.run()
    print(results)
    bt.plot()