"""
DS-TV Backtest Results: pulse-mean-accelerator
============================================================

--- SPY ---
  ERROR: Indicator "_calculat…" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_calculat…" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_calculat…" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — pulse-mean-accelerator
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    matype = "RMA"
    len = 20
    palen = 32
    max_ = 0.2
    vtype = "Standard Deviation"
    smooth = "Double Moving Average"
    con = True

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        self.ma = self.I(self._calculate_ma, close, self.len, self.matype)
        self.pma = self.I(self._calculate_pma, close, high, low)
        self.trend = 0

    def _calculate_ma(self, source, length, matype):
        if matype == "RMA":
            return pta.rma(source, length=length)
        elif matype == "SMA":
            return pta.sma(source, length=length)
        elif matype == "EMA":
            return pta.ema(source, length=length)
        elif matype == "WMA":
            return pta.wma(source, length=length)
        elif matype == "DEMA":
            return pta.dema(source, length=length)
        elif matype == "TEMA":
            return pta.tema(source, length=length)
        elif matype == "HMA":
            return pta.hma(source, length=length)
        return pta.sma(source, length=length)

    def _calculate_pma(self, source, high, low):
        close = pd.Series(self.data.Close)
        
        ma = self._calculate_ma(source, self.len, self.matype)
        if ma is None:
            return pd.Series(0, index=source.index)
        
        roc_ma = ma.diff()
        roc_src = source.diff()
        
        step = self.max_ / self.palen
        acc = np.zeros(len(source))
        
        for i in range(len(source)):
            if i == 0:
                acc[i] = 0
            else:
                acc[i] = acc[i-1]
                if np.abs(roc_src.iloc[i]) > np.abs(roc_ma.iloc[i]):
                    acc[i] += step
                if np.abs(roc_ma.iloc[i]) > np.abs(roc_src.iloc[i]):
                    acc[i] -= step
        
        tr = high - low
        atr = self._calculate_ma(tr, self.palen, self.matype)
        if atr is None:
            atr = pd.Series(0, index=source.index)
        
        mad = self._calculate_ma((ma - source).abs(), self.palen, self.matype)
        if mad is None:
            mad = pd.Series(0, index=source.index)
        
        sd = source.rolling(window=self.palen).std()
        
        if self.vtype == "ATR":
            vol = atr
        elif self.vtype == "MAD":
            vol = mad
        else:
            vol = sd
        
        vol = vol.fillna(method='bfill').fillna(1)
        
        avgr = self._calculate_ma(roc_ma, self.palen, self.matype)
        if avgr is None:
            avgr = pd.Series(0, index=source.index)
        
        absr = avgr.abs()
        direction = np.where(absr != 0, avgr / absr, 0)
        
        pma_ = ma + (pd.Series(acc) * vol * direction)
        
        sqrt = int(np.round(np.sqrt(self.len)))
        sqrt = max(2, sqrt)
        
        pma_ma = self._calculate_ma(pma_, sqrt, self.matype)
        if pma_ma is None:
            pma_ma = pma_
        
        a = 2 / (1 + self.len)
        pma_e = pma_ * (1 - a) + ma * a
        
        pma_d = self._calculate_ma(pma_ma, sqrt, self.matype)
        if pma_d is None:
            pma_d = pma_ma
        
        if self.smooth == "NONE":
            pma = pma_
        elif self.smooth == "Exponential":
            pma = pma_e
        elif self.smooth == "Extra Moving Average":
            pma = pma_ma
        else:
            pma = pma_d
        
        return pma

    def next(self):
        if len(self.data) < self.palen + 5:
            return
        
        close = self.data.Close[-1]
        ma = self.ma[-1]
        pma = self.pma[-1]
        
        if np.isnan(ma) or np.isnan(pma):
            return
        
        ma_prev = self.ma[-2] if len(self.ma) > 1 else ma
        pma_prev = self.pma[-2] if len(self.pma) > 1 else pma
        
        cl_condition = (pma - pma_prev) + (ma - ma_prev) > 0 if self.con else True
        cs_condition = (pma - pma_prev) + (ma - ma_prev) < 0 if self.con else True
        
        L = close > pma and cl_condition
        S = close < pma and cs_condition
        
        if L:
            self.trend = 1
        if S:
            self.trend = -1
        
        if self.trend == 1 and not self.position:
            self.buy()
        elif self.trend == -1 and self.position:
            self.sell()