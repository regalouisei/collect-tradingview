"""
DS-TV Backtest Results: macd-cmf-mtf-signals
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ,9)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "ema(λ,9)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ema(λ,9)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — macd-cmf-mtf-signals
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    fastLen = 12
    slowLen = 26
    sigLen = 9
    cmfLen = 21

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # MACD calculation
        fastMA = self.I(pta.ema, close, length=self.fastLen)
        slowMA = self.I(pta.ema, close, length=self.slowLen)
        
        self.macd = self.I(lambda: fastMA - slowMA if len(fastMA) == len(slowMA) else pd.Series(0, index=close.index))
        self.signal = self.I(pta.ema, self.macd, length=self.sigLen)
        self.hist = self.I(lambda: self.macd - self.signal if len(self.macd) == len(self.signal) else pd.Series(0, index=close.index))
        
        # CMF calculation
        priceRange = self.I(lambda: high - low)
        
        def calc_mfm():
            pr = high - low
            mfm_val = pd.Series(0.0, index=close.index)
            for i in range(len(close)):
                if pr.iloc[i] != 0.0:
                    mfm_val.iloc[i] = ((close.iloc[i] - low.iloc[i]) - (high.iloc[i] - close.iloc[i])) / pr.iloc[i]
                else:
                    mfm_val.iloc[i] = 0.0
            return mfm_val
        
        mfm = self.I(calc_mfm)
        mfv = self.I(lambda: mfm * volume)
        
        cmf_num = self.I(pta.sma, mfv, length=self.cmfLen)
        cmf_den = self.I(pta.sma, volume, length=self.cmfLen)
        
        self.cmf_raw = self.I(lambda: cmf_num / cmf_den if (cmf_den != 0).all() else pd.Series(0, index=close.index))
        
        # Auto-scaling calculations
        def calc_macd_high():
            return self.macd.rolling(window=200).max()
        
        def calc_macd_low():
            return self.macd.rolling(window=200).min()
        
        def calc_cmf_high():
            return self.cmf_raw.rolling(window=200).max()
        
        def calc_cmf_low():
            return self.cmf_raw.rolling(window=200).min()
        
        macdHigh = self.I(calc_macd_high)
        macdLow = self.I(calc_macd_low)
        cmfHigh = self.I(calc_cmf_high)
        cmfLow = self.I(calc_cmf_low)
        
        self.macdRange = self.I(lambda: pd.Series([max(abs(macdHigh.iloc[i]) if pd.notna(macdHigh.iloc[i]) else 0, 
                                                         abs(macdLow.iloc[i]) if pd.notna(macdLow.iloc[i]) else 0) 
                                                    for i in range(len(macdHigh))], index=close.index))
        
        self.cmfRange = self.I(lambda: pd.Series([max(abs(cmfHigh.iloc[i]) if pd.notna(cmfHigh.iloc[i]) else 0, 
                                                       abs(cmfLow.iloc[i]) if pd.notna(cmfLow.iloc[i]) else 0) 
                                                  for i in range(len(cmfHigh))], index=close.index))

    def next(self):
        if len(self.data) < 50:
            return
        
        macd_curr = self.macd[-1]
        signal_curr = self.signal[-1]
        macd_prev = self.macd[-2] if len(self.macd) >= 2 else macd_curr
        signal_prev = self.signal[-2] if len(self.signal) >= 2 else signal_curr
        cmf_curr = self.cmf_raw[-1]
        
        bullCross = macd_prev <= signal_prev and macd_curr > signal_curr
        bearCross = macd_prev >= signal_prev and macd_curr < signal_curr
        
        buyCond = bullCross and cmf_curr > 0
        sellCond = bearCross and cmf_curr < 0
        
        if buyCond:
            if not self.position:
                self.buy()
        elif sellCond:
            if self.position:
                self.sell()