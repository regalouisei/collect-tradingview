"""
DS-TV Backtest Results: decycler-momentum-regime-filter-charonquant
============================================================

--- SPY ---
  ERROR: Indicator "calculate…" error. See traceback above.

--- BTC ---
  ERROR: Indicator "calculate…" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "calculate…" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — decycler-momentum-regime-filter-charonquant
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    highpassLength = 8
    firstLength = 23
    secondLength = 17
    signalLength = 10

    def init(self):
        close = pd.Series(self.data.Close)
        
        # Ehlers Highpass Filter (Decycler Core)
        def calculate_decycler():
            PI = 2 * np.arcsin(1)
            alphaArg = 2 * PI / (self.highpassLength * np.sqrt(2))
            
            alpha_vals = np.zeros(len(close))
            hp_vals = np.zeros(len(close))
            
            for i in range(len(close)):
                if i == 0:
                    alpha_vals[i] = 0
                    hp_vals[i] = 0
                elif i == 1:
                    cos_arg = np.cos(alphaArg)
                    if cos_arg != 0:
                        alpha_vals[i] = (np.cos(alphaArg) + np.sin(alphaArg) - 1) / cos_arg
                    else:
                        alpha_vals[i] = alpha_vals[i-1]
                    hp_vals[i] = 0
                else:
                    cos_arg = np.cos(alphaArg)
                    if cos_arg != 0:
                        alpha = (np.cos(alphaArg) + np.sin(alphaArg) - 1) / cos_arg
                    else:
                        alpha = alpha_vals[i-1]
                    alpha_vals[i] = alpha
                    
                    hp_vals[i] = (np.power(1 - (alpha / 2), 2) * (close.iloc[i] - 2 * close.iloc[i-1] + close.iloc[i-2]) +
                                 2 * (1 - alpha) * hp_vals[i-1] -
                                 np.power(1 - alpha, 2) * hp_vals[i-2])
            
            decycler = close.values - hp_vals
            return pd.Series(decycler, index=close.index)
        
        self.decycler = self.I(calculate_decycler)
        
        # ROC calculation
        def calculate_roc():
            roc_vals = np.zeros(len(close))
            for i in range(1, len(close)):
                roc_vals[i] = close.iloc[i] - close.iloc[i-1]
            return pd.Series(roc_vals, index=close.index)
        
        roc1 = self.I(calculate_roc)
        
        # PMO Calculation
        def calculate_pmo():
            roc_filled = roc1.fillna(0)
            ema1 = pta.ema(10 * roc_filled, length=self.firstLength)
            if ema1 is None:
                ema1 = pd.Series(0, index=close.index)
            pmo_vals = pta.ema(ema1, length=self.secondLength)
            if pmo_vals is None:
                pmo_vals = pd.Series(0, index=close.index)
            return pmo_vals
        
        self.pmo = self.I(calculate_pmo)
        
        # Signal line
        def calculate_signal():
            if self.pmo is None:
                return pd.Series(0, index=close.index)
            signal_vals = pta.ema(self.pmo, length=self.signalLength)
            if signal_vals is None:
                signal_vals = pd.Series(0, index=close.index)
            return signal_vals
        
        self.signal = self.I(calculate_signal)
        
        # State variable
        self.regime = 0

    def next(self):
        if len(self.data) < 2:
            return
        
        # Calculate signals
        decycler_up = self.decycler[-1] > self.decycler[-2]
        decycler_down = self.decycler[-1] < self.decycler[-2]
        
        pmo_bull = (self.pmo[-1] > self.signal[-1]) and (self.pmo[-1] > 0)
        pmo_bear = (self.pmo[-1] < self.signal[-1]) and (self.pmo[-1] < 0)
        
        long_signal = decycler_up and pmo_bull
        short_signal = decycler_down and pmo_bear
        
        # Update regime
        if long_signal and not short_signal:
            self.regime = 1
        elif short_signal:
            self.regime = -1
        
        # Trading logic
        if long_signal and self.regime == 1 and not self.position:
            self.buy()
        elif short_signal and self.regime == -1 and self.position:
            self.sell()