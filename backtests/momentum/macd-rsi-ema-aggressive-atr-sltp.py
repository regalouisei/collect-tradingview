"""
DS-TV Backtest Results: macd-rsi-ema-aggressive-atr-sltp
============================================================

--- SPY ---
  ERROR: Invalid value '9.290309816862361' for dtype 'int64'

--- BTC ---
  ERROR: Invalid value '389.765625' for dtype 'int64'

--- QQQ ---
  ERROR: Invalid value '9.218151614864894' for dtype 'int64'

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” macd-rsi-ema-aggressive-atr-sltp
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    fastLen = 12
    slowLen = 26
    signalLen = 9
    rsiLen = 14
    rsiBuy = 52
    rsiSell = 48
    emaLen = 21
    volLen = 20
    volFactor = 1.05
    adxLen = 14
    adxMin = 14
    atrLen = 14
    slATR = 0.8
    tpATR = 1.2

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # MACD
        macd_result = self.I(lambda: pta.macd(close, fast=self.fastLen, slow=self.slowLen, signal=self.signalLen))
        self.macd_line = self.I(lambda: pta.macd(close, fast=self.fastLen, slow=self.slowLen, signal=self.signalLen)['MACD_12_26_9'] if pta.macd(close, fast=self.fastLen, slow=self.slowLen, signal=self.signalLen) is not None else pd.Series(0, index=close.index))
        self.signal_line = self.I(lambda: pta.macd(close, fast=self.fastLen, slow=self.slowLen, signal=self.signalLen)['MACDh_12_26_9'] if pta.macd(close, fast=self.fastLen, slow=self.slowLen, signal=self.signalLen) is not None else pd.Series(0, index=close.index))
        
        # RSI
        self.rsi_val = self.I(pta.rsi, close, length=self.rsiLen)
        
        # EMA
        self.ema_val = self.I(pta.ema, close, length=self.emaLen)
        
        # Volume
        vol_sma = self.I(pta.sma, volume, length=self.volLen)
        self.vol_ok = self.I(lambda: volume > vol_sma * self.volFactor)
        
        # ADX Manual
        up_move = high - high.shift(1)
        down_move = low.shift(1) - low
        
        plus_dm = pd.Series(0, index=close.index)
        minus_dm = pd.Series(0, index=close.index)
        
        for i in range(1, len(close)):
            if up_move.iloc[i] > down_move.iloc[i] and up_move.iloc[i] > 0:
                plus_dm.iloc[i] = up_move.iloc[i]
            if down_move.iloc[i] > up_move.iloc[i] and down_move.iloc[i] > 0:
                minus_dm.iloc[i] = down_move.iloc[i]
        
        self.plus_dm = self.I(lambda: plus_dm)
        self.minus_dm = self.I(lambda: minus_dm)
        
        atr_result = self.I(pta.atr, high, low, close, length=self.atrLen)
        self.atr_val = self.I(lambda: pta.atr(high, low, close, length=self.atrLen) if pta.atr(high, low, close, length=self.atrLen) is not None else pd.Series(0, index=close.index))
        
        # RMA calculation for ADX
        self.tr = self.I(lambda: pta.atr(high, low, close, length=1) if pta.atr(high, low, close, length=1) is not None else pd.Series(0, index=close.index))
        
        self.plus_di = self.I(lambda: self._calc_plus_di(plus_dm, self.atr_val))
        self.minus_di = self.I(lambda: self._calc_minus_di(minus_dm, self.atr_val))
        self.adx_val = self.I(lambda: self._calc_adx(self.plus_di, self.minus_di))
        
        self.trend_ok = self.I(lambda: self.adx_val >= self.adxMin)

    def _calc_plus_di(self, plus_dm, atr_val):
        rma_plus = plus_dm.ewm(span=self.adxLen, adjust=False).mean()
        return 100 * rma_plus / (atr_val + 1e-10)

    def _calc_minus_di(self, minus_dm, atr_val):
        rma_minus = minus_dm.ewm(span=self.adxLen, adjust=False).mean()
        return 100 * rma_minus / (atr_val + 1e-10)

    def _calc_adx(self, plus_di, minus_di):
        dx = 100 * np.abs(plus_di - minus_di) / (plus_di + minus_di + 1e-10)
        adx = dx.ewm(span=self.adxLen, adjust=False).mean()
        return adx

    def next(self):
        if len(self.data) < self.slowLen + 5:
            return
        
        # Buy condition
        if (crossover(self.macd_line, self.signal_line) and 
            self.rsi_val[-1] > self.rsiBuy and 
            self.data.Close[-1] > self.ema_val[-1] and 
            self.vol_ok[-1] and 
            self.adx_val[-1] > self.adxMin):
            
            if not self.position:
                self.buy()
        
        # Sell condition
        elif (crossover(self.signal_line, self.macd_line) and 
              self.rsi_val[-1] < self.rsiSell and 
              self.data.Close[-1] < self.ema_val[-1] and 
              self.vol_ok[-1] and 
              self.adx_val[-1] > self.adxMin):
            
            if self.position:
                self.position.close()


if __name__ == "__main__":
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)