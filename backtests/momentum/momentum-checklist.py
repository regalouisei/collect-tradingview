"""
DS-TV Backtest Results: momentum-checklist
============================================================

--- SPY ---
  ERROR: object of type 'TvStrategy' has no len()

--- BTC ---
  ERROR: object of type 'TvStrategy' has no len()

--- QQQ ---
  ERROR: object of type 'TvStrategy' has no len()

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” momentum-checklist
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lensig = 14
    len_di = 14
    mfi_length = 14

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)
        
        # Calculate DMI/ADX components
        def calc_dmi_adx():
            up = high.diff()
            down = -low.diff()
            
            plus_dm = pd.Series(0.0, index=high.index)
            minus_dm = pd.Series(0.0, index=high.index)
            
            for i in range(1, len(high)):
                if up.iloc[i] > down.iloc[i] and up.iloc[i] > 0:
                    plus_dm.iloc[i] = up.iloc[i]
                if down.iloc[i] > up.iloc[i] and down.iloc[i] > 0:
                    minus_dm.iloc[i] = down.iloc[i]
            
            tr = pta.true_range(high, low, close)
            trur = pta.rma(tr, length=self.len_di)
            
            plus_di = 100 * pta.rma(plus_dm, length=self.len_di) / trur.replace(0, 1)
            minus_di = 100 * pta.rma(minus_dm, length=self.len_di) / trur.replace(0, 1)
            
            di_sum = plus_di + minus_di
            di_sum = di_sum.replace(0, 1)
            adx_raw = 100 * pta.rma((plus_di - minus_di).abs() / di_sum, length=self.lensig)
            
            return plus_di, minus_di, adx_raw
        
        self.plus_di, self.minus_di, self.adx = self.I(calc_dmi_adx)
        
        # Calculate MFI
        def calc_mfi():
            hlc3 = (high + low + close) / 3
            mfi_change = hlc3.diff()
            
            mfi_upper = (volume * hlc3.where(mfi_change > 0, 0)).rolling(self.mfi_length).sum()
            mfi_lower = (volume * hlc3.where(mfi_change < 0, 0)).rolling(self.mfi_length).sum()
            
            mfi_lower = mfi_lower.replace(0, 1)
            mfi = 100.0 - (100.0 / (1.0 + mfi_upper / mfi_lower))
            
            return mfi
        
        self.mfi = self.I(calc_mfi)
        
        # Track previous states for signal detection
        self.prev_adx_above_20 = False
        self.prev_mfi_above_50 = False
        self.prev_bias_long = False
        self.prev_bias_short = False

    def next(self):
        if len(self) < 2:
            return
        
        # Current indicator values
        current_adx = self.adx[-1]
        current_plus_di = self.plus_di[-1]
        current_minus_di = self.minus_di[-1]
        current_mfi = self.mfi[-1]
        
        # Determine current bias
        current_bias_long = (current_plus_di > 25) and (current_minus_di < 20)
        current_bias_short = (current_minus_di > 25) and (current_plus_di < 20)
        current_bias_neutral = not current_bias_long and not current_bias_short
        
        # Check ADX momentum strength
        adx_strong = current_adx >= 20
        mfi_bullish = current_mfi > 50
        
        # Entry signals: Buy when LONG bias emerges with strong momentum confirmation
        if current_bias_long and adx_strong and mfi_bullish and not self.position:
            self.buy()
        
        # Entry signals: Sell when SHORT bias emerges with strong momentum confirmation
        elif current_bias_short and adx_strong and not mfi_bullish and not self.position:
            self.sell()
        
        # Exit signals: Close LONG when bias turns NEUTRAL or SHORT
        if self.position and not current_bias_long:
            self.position.close()
        
        # Exit signals: Close SHORT when bias turns NEUTRAL or LONG
        if self.position and self.position.is_short and not current_bias_short:
            self.position.close()


if __name__ == '__main__':
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()