"""
DS-TV Backtest Results: ehlers-adaptive-trend-filter
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — ehlers-adaptive-trend-filter
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # Calibration parameters
    auto_mode = True
    baseline_mult = 1.0
    filter_config = "3p+2p (Hybrid)"
    
    # Volatility parameters
    enable_adaptive = True
    auto_vol_lb = True
    manual_vol_lb = 252
    vol_percentile = 0.75
    
    # Momentum parameters
    momentum_lb = 5
    
    # Reversal parameters
    bull_momentum_threshold = 0.0
    bull_momentum_lookback = 5
    bull_require_slope = False
    bear_momentum_threshold = 0.0
    bear_momentum_lookback = 5
    bear_require_slope = False
    
    # Plot styling
    p_smooth = 5

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Determine dynamic lookback
        vol_lookback = self.manual_vol_lb
        if self.auto_vol_lb:
            vol_lookback = 252
        
        # Volatility calculation
        def calc_volatility(close_series):
            daily_returns = close_series.pct_change() * 100
            rolling_vol = daily_returns.rolling(window=min(vol_lookback, len(close_series))).std()
            return rolling_vol
        
        self.rolling_vol = self.I(calc_volatility, close)
        
        # Get volatility baseline
        def calc_vol_baseline(vol_series):
            effective_lb = min(vol_lookback, len(vol_series))
            if effective_lb >= 50:
                sorted_vol = np.sort(vol_series.dropna().values)
                idx = int(len(sorted_vol) * self.vol_percentile)
                return sorted_vol[min(idx, len(sorted_vol) - 1)]
            return vol_series.mean()
        
        self.vol_baseline = self.I(lambda: pd.Series(
            [calc_vol_baseline(self.rolling_vol[:i+1]) if i >= 0 else 0 
             for i in range(len(self.rolling_vol))],
            index=close.index
        ))
        
        # Adaptive thresholds
        def calc_adaptive_extended(vol_base):
            return vol_base * 1.5 if self.enable_adaptive else 25.0
        
        def calc_adaptive_expanding(vol_base):
            return vol_base * 0.75 if self.enable_adaptive else 5.0
        
        self.adaptive_extended = self.I(lambda: self.vol_baseline * (1.5 if self.enable_adaptive else 25.0 / (self.vol_baseline if self.vol_baseline > 0 else 1)))
        
        # Dynamic anchor and detox
        m_detox = 90
        m_anchor = 181
        
        # SuperSmoother 2-pole filter
        def ss2_filter(price_series, freq):
            result = pd.Series(index=price_series.index, dtype=float)
            PI = 2 * np.arcsin(1.0)
            filt = price_series.iloc[0]
            result.iloc[0] = filt
            
            if len(price_series) < 2:
                return result
            
            result.iloc[1] = price_series.iloc[1]
            
            a1 = np.exp(-PI * np.sqrt(2) / freq)
            c2 = 2 * a1 * np.cos(np.sqrt(2) * PI / freq)
            c3 = -a1 ** 2
            c1 = 1 - c2 - c3
            
            for i in range(2, len(price_series)):
                filt = c1 * (price_series.iloc[i] + price_series.iloc[i-1]) / 2 + c2 * result.iloc[i-1] + c3 * result.iloc[i-2]
                result.iloc[i] = filt
            
            return result
        
        # SuperSmoother 3-pole filter
        def ss3_filter(price_series, freq):
            result = pd.Series(index=price_series.index, dtype=float)
            PI = 2 * np.arcsin(1.0)
            filt = price_series.iloc[0]
            result.iloc[0] = filt
            
            if len(price_series) < 3:
                for i in range(1, len(price_series)):
                    result.iloc[i] = price_series.iloc[i]
                return result
            
            result.iloc[1] = price_series.iloc[1]
            result.iloc[2] = price_series.iloc[2]
            
            r3 = np.sqrt(3)
            arg = PI / freq
            a1 = np.exp(-arg)
            b1 = 2 * a1 * np.cos(r3 * arg)
            c1 = a1 ** 2
            coef2 = b1 + c1
            coef3 = -(c1 + b1 * c1)
            coef4 = c1 ** 2
            coef1 = 1 - coef2 - coef3 - coef4
            
            for i in range(3, len(price_series)):
                filt = coef1 * price_series.iloc[i] + coef2 * result.iloc[i-1] + coef3 * result.iloc[i-2] + coef4 * result.iloc[i-3]
                result.iloc[i] = filt
            
            return result
        
        # Apply filter based on configuration
        if self.filter_config == "2p+2p (Fast)":
            self.l_path = self.I(ss2_filter, close, m_detox)
            self.s_floor = self.I(ss2_filter, self.I(ss2_filter, close, m_detox), m_anchor)
        elif self.filter_config == "3p+2p (Hybrid)":
            self.l_path = self.I(ss3_filter, close, m_detox)
            self.s_floor = self.I(ss2_filter, self.I(ss3_filter, close, m_detox), m_anchor)
        else:  # 3p+3p (Smooth)
            self.l_path = self.I(ss3_filter, close, m_detox)
            self.s_floor = self.I(ss3_filter, self.I(ss3_filter, close, m_detox), m_anchor)
        
        # Apply baseline multiplier
        def apply_baseline_mult(floor_series):
            return floor_series * self.baseline_mult
        
        self.s_floor = self.I(apply_baseline_mult, self.s_floor)
        
        # Smoothed price line
        self.p_draw = self.I(pta.ema, close, length=self.p_smooth)
        
        # Momentum calculation
        def calc_momentum(path_series):
            effective_mom_lb = self.momentum_lb
            if self.filter_config == "3p+2p (Hybrid)":
                effective_mom_lb = max(int(np.ceil(self.momentum_lb * 1.15)), 4)
            elif self.filter_config == "3p+3p (Smooth)":
                effective_mom_lb = max(int(np.ceil(self.momentum_lb * 1.45)), 6)
            
            result = pd.Series(index=path_series.index, dtype=float)
            for i in range(len(path_series)):
                if i >= effective_mom_lb and path_series.iloc[i - effective_mom_lb] != 0:
                    result.iloc[i] = (path_series.iloc[i] - path_series.iloc[i - effective_mom_lb]) / path_series.iloc[i - effective_mom_lb] * 100
                else:
                    result.iloc[i] = np.nan
            return result
        
        self.w_force_val = self.I(calc_momentum, self.l_path)
        
        # Support slope
        def calc_slope(floor_series):
            result = pd.Series(index=floor_series.index, dtype=float)
            for i in range(len(floor_series)):
                if i > 0 and floor_series.iloc[i-1] != 0:
                    result.iloc[i] = (floor_series.iloc[i] - floor_series.iloc[i-1]) / floor_series.iloc[i-1] * 100
                else:
                    result.iloc[i] = 0
            return result
        
        self.c_slope = self.I(calc_slope, self.s_floor)
        
        # Bull and bear momentum divergence
        def calc_bull_momentum(path_series):
            result = pd.Series(index=path_series.index, dtype=float)
            for i in range(len(path_series)):
                if i >= self.bull_momentum_lookback and path_series.iloc[i - self.bull_momentum_lookback] != 0:
                    result.iloc[i] = (path_series.iloc[i] - path_series.iloc[i - self.bull_momentum_lookback]) / path_series.iloc[i - self.bull_momentum_lookback] * 100
                else:
                    result.iloc[i] = 0
            return result
        
        def calc_bear_momentum(path_series):
            result = pd.Series(index=path_series.index, dtype=float)
            for i in range(len(path_series)):
                if i >= self.bear_momentum_lookback and path_series.iloc[i - self.bear_momentum_lookback] != 0:
                    result.iloc[i] = (path_series.iloc[i] - path_series.iloc[i - self.bear_momentum_lookback]) / path_series.iloc[i - self.bear_momentum_lookback] * 100
                else:
                    result.iloc[i] = 0
            return result
        
        self.bull_momentum = self.I(calc_bull_momentum, self.l_path)
        self.bear_momentum = self.I(calc_bear_momentum, self.l_path)
        
        # Trend status
        def calc_trend_status(path_series, floor_series):
            result = pd.Series(index=path_series.index, dtype=bool)
            for i in range(len(path_series)):
                result.iloc[i] = path_series.iloc[i] > floor_series.iloc[i]
            return result
        
        self.is_good = self.I(calc_trend_status, self.l_path, self.s_floor)
        
        # Divergence tracking
        def calc_bars_up(path_series):
            result = pd.Series(index=path_series.index, dtype=int)
            bars = 0
            for i in range(len(path_series)):
                if i > 0 and path_series.iloc[i] > path_series.iloc[i-1]:
                    bars += 1
                else:
                    bars = 0
                result.iloc[i] = bars
            return result
        
        def calc_bars_down(path_series):
            result = pd.Series(index=path_series.index, dtype=int)
            bars = 0
            for i in range(len(path_series)):
                if i > 0 and path_series.iloc[i] < path_series.iloc[i-1]:
                    bars += 1
                else:
                    bars = 0
                result.iloc[i] = bars
            return result
        
        self.bars_up = self.I(calc_bars_up, self.l_path)
        self.bars_down = self.I(calc_bars_down, self.l_path)
        
        # Safety margin
        def calc_safety_margin(path_series, floor_series):
            result = pd.Series(index=path_series.index, dtype=float)
            for i in range(len(path_series)):
                if floor_series.iloc[i] != 0:
                    result.iloc[i] = (path_series.iloc[i] - floor_series.iloc[i]) / floor_series.iloc[i] * 100
                else:
                    result.iloc[i] = 0
            return result
        
        self.h_clear = self.I(calc_safety_margin, self.l_path, self.s_floor)

    def next(self):
        # Get current values
        path = self.l_path[-1]
        floor = self.s_floor[-1]
        bull_mom = self.bull_momentum[-1]
        bear_mom = self.bear_momentum[-1]
        slope = self.c_slope[-1]
        bars_up = int(self.bars_up[-1])
        bars_down = int(self.bars_down[-1])
        is_good = self.is_good[-1]
        
        # Bull divergence signal
        is_bull_divergence = (
            bars_up >= 2 and
            bull_mom < self.bull_momentum_threshold and
            (not self.bull_require_slope or slope > 0)
        )
        
        # Bear divergence signal
        is_bear_divergence = (
            bars_down >= 2 and
            bear_mom > self.bear_momentum_threshold and
            (not self.bear_require_slope or slope < 0)
        )
        
        # Entry and exit logic
        if not self.position:
            # Buy signal: bull divergence and price above floor
            if is_bull_divergence and is_good:
                self.buy()
        else:
            # Sell signal: bear divergence or price below floor
            if is_bear_divergence or not is_good:
                self.sell()