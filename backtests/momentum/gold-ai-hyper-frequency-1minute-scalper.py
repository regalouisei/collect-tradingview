"""
DS-TV Backtest Results: gold-ai-hyper-frequency-1minute-scalper
============================================================

--- SPY ---
  ERROR: '>=' not supported between instances of 'float' and 'NoneType'

--- BTC ---
  ERROR: '>=' not supported between instances of 'float' and 'NoneType'

--- QQQ ---
  ERROR: '>=' not supported between instances of 'float' and 'NoneType'

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” gold-ai-hyper-frequency-1minute-scalper
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    neighbor_count = 8
    sensitivity = 10.0
    ai_window = 30
    rsi_len = 7
    mfi_len = 7
    roc_len = 3
    use_trend_filt = False
    vol_threshold = 0.8
    ema_trend_len = 200
    tp_step_1 = 1.0
    tp_step_2 = 2.2
    tp_step_3 = 4.5
    sl_atr_mult = 1.5

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        volume = pd.Series(self.data.Volume)

        self.rsi = self.I(pta.rsi, close, length=self.rsi_len)
        self.mfi = self.I(pta.mfi, high, low, close, volume, length=self.mfi_len)
        self.roc = self.I(pta.roc, close, length=self.roc_len)
        self.atr = self.I(pta.atr, high, low, close, length=14)
        self.ema_200 = self.I(pta.ema, close, length=self.ema_trend_len)
        self.vol_ma = self.I(pta.sma, volume, length=20)

        self.target_p = None
        self.stop_p = None
        self.tp_stage = 0
        self.position_type = None

    def get_prediction(self):
        buy_votes = 0
        sell_votes = 0

        idx = len(self.data) - 1
        if idx < self.ai_window + 1:
            return 0, 0, 0

        f1_current = self.rsi[-1]
        f2_current = self.mfi[-1]
        f3_current = self.roc[-1]

        if f1_current is None or f2_current is None or f3_current is None:
            return 0, 0, 0

        for i in range(1, self.ai_window + 1):
            if idx - i < 0 or idx - i - 1 < 0:
                break

            f1_past = self.rsi[-1 - i] if idx - i < len(self.rsi) else None
            f2_past = self.mfi[-1 - i] if idx - i < len(self.mfi) else None
            f3_past = self.roc[-1 - i] if idx - i < len(self.roc) else None

            if f1_past is None or f2_past is None or f3_past is None:
                continue

            d = (np.log(1 + abs(f1_current - f1_past)) +
                 np.log(1 + abs(f2_current - f2_past)) +
                 np.log(1 + abs(f3_current - f3_past)))

            if d < self.sensitivity:
                close_current = self.data.Close[-1]
                close_past = self.data.Close[-1 - i]
                close_past_next = self.data.Close[-i] if i > 0 else close_current

                if close_past > close_past_next:
                    buy_votes += 1
                else:
                    sell_votes += 1

        signal = 1 if buy_votes > sell_votes else -1
        return signal, buy_votes, sell_votes

    def next(self):
        ai_sig, buys, sells = self.get_prediction()

        if self.atr[-1] is None or self.vol_ma[-1] is None:
            return

        is_vol_ok = self.data.Volume[-1] > self.vol_ma[-1] * self.vol_threshold

        long_entry = (ai_sig == 1 and
                      (not self.use_trend_filt or self.data.Close[-1] > self.ema_200[-1]) and
                      is_vol_ok)

        short_entry = (ai_sig == -1 and
                       (not self.use_trend_filt or self.data.Close[-1] < self.ema_200[-1]) and
                       is_vol_ok)

        if (long_entry or short_entry) and self.target_p is None:
            self.tp_stage = 1
            if long_entry:
                self.stop_p = self.data.Low[-1] - (self.atr[-1] * self.sl_atr_mult)
                self.target_p = self.data.Close[-1] + (self.atr[-1] * self.tp_step_1)
                self.position_type = 1
            else:
                self.stop_p = self.data.High[-1] + (self.atr[-1] * self.sl_atr_mult)
                self.target_p = self.data.Close[-1] - (self.atr[-1] * self.tp_step_1)
                self.position_type = -1

        if self.target_p is not None:
            is_long = self.position_type == 1

            if (is_long and self.data.High[-1] >= self.target_p) or \
               (not is_long and self.data.Low[-1] <= self.target_p):
                if self.tp_stage == 1:
                    self.tp_stage = 2
                    if is_long:
                        self.target_p = self.target_p + (self.atr[-1] * self.tp_step_2)
                    else:
                        self.target_p = self.target_p - (self.atr[-1] * self.tp_step_2)
                    self.stop_p = self.data.Close[-1]
                elif self.tp_stage == 2:
                    self.tp_stage = 3
                    if is_long:
                        self.target_p = self.target_p + (self.atr[-1] * self.tp_step_3)
                        self.stop_p = self.data.Low[-2] if len(self.data) > 1 else self.stop_p
                    else:
                        self.target_p = self.target_p - (self.atr[-1] * self.tp_step_3)
                        self.stop_p = self.data.High[-2] if len(self.data) > 1 else self.stop_p

        if self.target_p is not None:
            is_long = self.position_type == 1
            if (is_long and self.data.Low[-1] <= self.stop_p) or \
               (not is_long and self.data.High[-1] >= self.stop_p):
                self.target_p = None
                self.stop_p = None
                self.tp_stage = 0
                self.position_type = None

        if long_entry and not self.position:
            self.buy()
        elif short_entry and not self.position:
            self.sell()

        if self.position:
            is_long = self.position_type == 1
            if (is_long and self.data.Low[-1] <= self.stop_p) or \
               (not is_long and self.data.High[-1] >= self.stop_p):
                self.position.close()
            elif is_long and self.data.High[-1] >= self.target_p:
                if self.tp_stage >= 3:
                    self.position.close()
            elif not is_long and self.data.Low[-1] <= self.target_p:
                if self.tp_stage >= 3:
                    self.position.close()


if __name__ == "__main__":
    from backtesting.test import GOOG

    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)