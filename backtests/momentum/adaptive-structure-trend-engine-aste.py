"""
DS-TV Backtest Results: adaptive-structure-trend-engine-aste
============================================================

--- SPY ---
  ERROR: Indicator "_calc_fra…(100)" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_calc_fra…(100)" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_calc_fra…(100)" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — adaptive-structure-trend-engine-aste
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lenSwing = 100
    kamaLen = 30
    jmaLen = 20
    jmaPhase = 2
    emaFastLen = 21
    emaMidLen = 50
    ema100Len = 100
    ema150Len = 150
    ema200Len = 200

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)

        # EMA indicators
        self.ema21 = self.I(pta.ema, close, length=self.emaFastLen)
        self.ema50 = self.I(pta.ema, close, length=self.emaMidLen)
        self.ema100 = self.I(pta.ema, close, length=self.ema100Len)
        self.ema150 = self.I(pta.ema, close, length=self.ema150Len)
        self.ema200 = self.I(pta.ema, close, length=self.ema200Len)

        # FRAMA calculation
        self.frMid = self.I(self._calc_frama, high, low, self.lenSwing)

        # KAMA calculation
        self.kama = self.I(self._calc_kama, close, self.kamaLen)

        # JMA calculation
        self.jma = self.I(self._calc_jma, close, self.jmaLen, self.jmaPhase)

        # Signal states
        self.s1 = 0
        self.s2 = 0
        self.last_s1 = 0
        self.last_s2 = 0

    def _calc_frama(self, high, low, length):
        n = max(length, 2)
        half = round(n / 2)

        hi1 = high.rolling(n).max()
        lo1 = low.rolling(n).min()
        hi2 = high.rolling(half).max()
        lo2 = low.rolling(half).min()

        hi3_vals = []
        lo3_vals = []
        for i in range(len(high)):
            if i >= half:
                hi3_vals.append(high.iloc[i-half:i].max())
                lo3_vals.append(low.iloc[i-half:i].min())
            else:
                hi3_vals.append(np.nan)
                lo3_vals.append(np.nan)

        hi3 = pd.Series(hi3_vals, index=high.index)
        lo3 = pd.Series(lo3_vals, index=low.index)

        dim = np.log((hi2 - lo2 + hi3 - lo3) / (hi1 - lo1 + 1e-10)) / np.log(2)
        dim = dim.fillna(0)
        alpha = np.maximum(0.01, np.minimum(np.exp(-4.6 * (dim - 1)), 1))

        fr = pd.Series(0.0, index=high.index)
        fr.iloc[0] = high.iloc[0]

        for i in range(1, len(high)):
            if pd.notna(alpha.iloc[i]):
                fr.iloc[i] = alpha.iloc[i] * (high.iloc[i] + low.iloc[i]) / 2 + (1 - alpha.iloc[i]) * fr.iloc[i-1]
            else:
                fr.iloc[i] = fr.iloc[i-1]

        return fr

    def _calc_kama(self, src, length):
        change = (src - src.shift(length)).abs()
        vol = src.diff().abs().rolling(length).sum()
        vol = vol.replace(0, 1e-10)
        er = change / vol
        sc = np.power(er * (2.0/3 - 2.0/31) + 2.0/31, 2)

        kama = pd.Series(0.0, index=src.index)
        kama.iloc[0] = src.iloc[0]

        for i in range(1, len(src)):
            if pd.notna(sc.iloc[i]):
                kama.iloc[i] = kama.iloc[i-1] + sc.iloc[i] * (src.iloc[i] - kama.iloc[i-1])
            else:
                kama.iloc[i] = kama.iloc[i-1]

        return kama

    def _calc_jma(self, src, length, phase):
        beta = 0.45 * (length - 1) / (0.45 * (length - 1) + 2)
        alpha = np.power(beta, phase)

        jma = pd.Series(0.0, index=src.index)
        jma.iloc[0] = src.iloc[0]

        for i in range(1, len(src)):
            jma.iloc[i] = (1 - alpha) * src.iloc[i] + alpha * jma.iloc[i-1]

        return jma

    def next(self):
        if len(self.data) < max(self.lenSwing, self.kamaLen, self.jmaLen, self.ema200Len):
            return

        # EMA Base conditions
        ema_bull_base = self.ema21[-1] > self.ema50[-1] and self.ema21[-1] > self.ema21[-2]
        ema_bear_base = self.ema21[-1] < self.ema50[-1] and self.ema21[-1] < self.ema21[-2]

        # EMA Strong conditions
        ema_bull_strong = (self.ema50[-1] > self.ema100[-1] and 
                          self.ema100[-1] > self.ema150[-1] and 
                          self.ema150[-1] > self.ema200[-1])
        ema_bear_strong = (self.ema50[-1] < self.ema100[-1] and 
                          self.ema100[-1] < self.ema150[-1] and 
                          self.ema150[-1] < self.ema200[-1])

        # FRAMA conditions
        fr_up = self.frMid[-1] > self.frMid[-2]
        fr_down = self.frMid[-1] < self.frMid[-2]

        # KAMA conditions
        kama_up = self.kama[-1] > self.kama[-2]
        kama_down = self.kama[-1] < self.kama[-2]

        # JMA conditions
        jma_up = self.jma[-1] > self.jma[-2]
        jma_down = self.jma[-1] < self.jma[-2]

        # Base signal logic
        bull_base = fr_up and kama_up and jma_up and ema_bull_base
        bear_base = fr_down and kama_down and jma_down and ema_bear_base

        # Strong signal logic
        bull_strong = bull_base and ema_bull_strong
        bear_strong = bear_base and ema_bear_strong

        # State machine for base signals
        if bull_base and self.s1 != 1:
            self.s1 = 1
            if not self.position:
                self.buy()
        elif bear_base and self.s1 != -1:
            self.s1 = -1
            if self.position:
                self.position.close()

        # State machine for strong signals (optional: could override base)
        if bull_strong and self.s2 != 1:
            self.s2 = 1
            if not self.position:
                self.buy()
        elif bear_strong and self.s2 != -1:
            self.s2 = -1
            if self.position:
                self.position.close()


if __name__ == "__main__":
    bt = Backtest(
        pd.read_csv("data.csv", index_col=0, parse_dates=True),
        TvStrategy,
        cash=10000,
        commission=0.002
    )
    stats = bt.run()
    print(stats)
    bt.plot()