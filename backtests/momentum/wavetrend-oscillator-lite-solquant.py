"""
DS-TV Backtest Results: wavetrend-oscillator-lite-solquant
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "λ" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — wavetrend-oscillator-lite-solquant
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    n1 = 10
    n2 = 21
    obLevel1 = 60
    obLevel2 = 53
    osLevel1 = -60
    osLevel2 = -53

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        ap = (high + low + close) / 3
        
        esa = self.I(lambda: pta.ema(ap, length=self.n1))
        d = self.I(lambda: pta.ema(np.abs(ap - esa), length=self.n1))
        
        ci = self.I(lambda: (ap - esa) / (0.015 * d))
        
        tci = self.I(lambda: pta.ema(ci, length=self.n2))
        
        self.wt1 = tci
        self.wt2 = self.I(lambda: pta.sma(self.wt1, length=4))

    def next(self):
        if len(self.data) < 2:
            return
        
        wt1_current = self.wt1[-1]
        wt2_current = self.wt2[-1]
        wt1_prev = self.wt1[-2]
        wt2_prev = self.wt2[-2]
        
        if wt1_current is None or wt2_current is None:
            return
        
        if not self.position:
            if wt1_prev < self.osLevel1 and wt1_current > self.osLevel1:
                self.buy()
            elif wt1_prev > self.obLevel1 and wt1_current < self.obLevel1:
                self.sell()
        else:
            if self.position.is_long:
                if wt1_current > self.obLevel1 or wt2_current > self.obLevel1:
                    self.position.close()
            elif self.position.is_short:
                if wt1_current < self.osLevel1 or wt2_current < self.osLevel1:
                    self.position.close()


if __name__ == '__main__':
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()