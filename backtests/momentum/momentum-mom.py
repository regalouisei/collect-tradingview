"""
DS-TV Backtest Results: momentum-mom
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ma_func(λ)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "ma_func(λ)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "ma_func(λ)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — momentum-mom
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    Length_MOM = 14
    Length_MA_MOM = 365
    Source_MA_MOM = 'EMA'

    def init(self):
        close = pd.Series(self.data.Close)
        
        # Calculate MOM (Momentum)
        self.mom = self.I(lambda x: pta.mom(x, length=self.Length_MOM), close)
        
        # Calculate MA of MOM based on selected type
        def ma_func(mom_series):
            if self.Source_MA_MOM == 'EMA':
                return pta.ema(mom_series, length=self.Length_MA_MOM)
            elif self.Source_MA_MOM == 'SMA':
                return pta.sma(mom_series, length=self.Length_MA_MOM)
            elif self.Source_MA_MOM == 'RMA':
                return pta.ema(mom_series, length=self.Length_MA_MOM)
            elif self.Source_MA_MOM == 'WMA':
                return pta.wma(mom_series, length=self.Length_MA_MOM)
            elif self.Source_MA_MOM == 'VWMA':
                return pta.vwma(close, pd.Series(self.data.Volume), length=self.Length_MA_MOM)
            elif self.Source_MA_MOM == 'HMA':
                return pta.hma(mom_series, length=self.Length_MA_MOM)
            else:
                return pta.ema(mom_series, length=self.Length_MA_MOM)
        
        self.mom_ma = self.I(ma_func, self.mom)

    def next(self):
        # Buy when MOM crosses above MOM_MA (Bullish signal)
        if crossover(self.mom, self.mom_ma):
            if not self.position:
                self.buy()
        
        # Sell when MOM crosses below MOM_MA (Bearish signal)
        elif crossover(self.mom_ma, self.mom):
            if self.position:
                self.position.close()


if __name__ == '__main__':
    from backtesting.test import SMA, GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()