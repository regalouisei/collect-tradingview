"""
DS-TV Backtest Results: relative-valuation-oscillator-quantalgo
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (731,); indicator "λ" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (500,); indicator "λ" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — relative-valuation-oscillator-quantalgo
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    lookback_period = 34
    threshold_mult = 2.0

    def init(self):
        close = pd.Series(self.data.Close)
        
        # Calculate log price
        log_price = self.I(lambda: np.log(close))
        
        # Calculate mean log price (SMA of log price)
        mean_log_price = self.I(lambda: pta.sma(log_price, length=self.lookback_period))
        
        # Calculate standard deviation of log price
        std_dev = self.I(lambda: pta.stdev(log_price, length=self.lookback_period))
        
        # Calculate valuation score
        self.valuation_score = self.I(
            lambda: (log_price - mean_log_price) / std_dev.replace(0, np.nan)
        )
        
        # Store thresholds
        self.upper_threshold = self.threshold_mult
        self.lower_threshold = -self.threshold_mult

    def next(self):
        if len(self.data) < self.lookback_period + 1:
            return
        
        current_score = self.valuation_score[-1]
        
        # Avoid NaN values
        if pd.isna(current_score):
            return
        
        prev_score = self.valuation_score[-2] if len(self.valuation_score) > 1 else current_score
        
        # Buy signal: undervalued crossover (score crosses above -threshold_mult)
        if prev_score <= self.lower_threshold and current_score > self.lower_threshold:
            if not self.position:
                self.buy()
        
        # Sell signal: overvalued crossover (score crosses above threshold_mult)
        if prev_score <= self.upper_threshold and current_score > self.upper_threshold:
            if self.position:
                self.position.close()
        
        # Alternative exit: fair value crossover (score crosses below 0)
        if prev_score >= 0 and current_score < 0:
            if self.position:
                self.position.close()


if __name__ == '__main__':
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()