"""
DS-TV Backtest Results: market-structure-dashboard-flux-charts
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — market-structure-dashboard-flux-charts
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    # EMA parameters
    emaLength = 9
    swingLength = 5
    atrLength = 14
    atrAvgLength = 20
    obLookback = 6
    fvgLookback = 6

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate EMA
        self.ema = self.I(pta.ema, close, length=self.emaLength)
        
        # Calculate pivot highs and lows using rolling windows
        self.pivot_high = self.I(
            lambda: high.rolling(window=self.swingLength * 2 + 1, center=True).max()
        )
        self.pivot_low = self.I(
            lambda: low.rolling(window=self.swingLength * 2 + 1, center=True).min()
        )
        
        # Calculate ATR for volatility
        self.atr = self.I(pta.atr, high, low, close, length=self.atrLength)
        self.avg_atr = self.I(
            lambda: self.atr.rolling(window=self.atrAvgLength).mean() if self.atr is not None else pd.Series(0, index=close.index)
        )
        
        # Volume calculations
        volume = pd.Series(self.data.Volume)
        self.avg_volume = self.I(pta.sma, volume, length=20)
        
        # Track swing states
        self.swing_high = None
        self.swing_low = None
        self.prev_swing_high = None
        self.prev_swing_low = None
        self.high_broken = False
        self.low_broken = False
        
        # Order Block and FVG detection flags
        self.bull_ob_active = False
        self.bear_ob_active = False
        self.bull_fvg_active = False
        self.bear_fvg_active = False

    def next(self):
        if len(self) < self.swingLength * 2 + 2:
            return
        
        close = self.data.Close[-1]
        high = self.data.High[-1]
        low = self.data.Low[-1]
        
        # Get current values
        ema_val = self.ema[-1]
        
        # Detect swing highs and lows
        if not np.isnan(self.pivot_high[-1]):
            self.prev_swing_high = self.swing_high
            self.swing_high = self.pivot_high[-1]
            self.high_broken = False
        
        if not np.isnan(self.pivot_low[-1]):
            self.prev_swing_low = self.swing_low
            self.swing_low = self.pivot_low[-1]
            self.low_broken = False
        
        # Track breaks
        if self.swing_high is not None and high > self.swing_high:
            self.high_broken = True
        
        if self.swing_low is not None and low < self.swing_low:
            self.low_broken = True
        
        # Detect Fair Value Gaps (FVGs)
        if len(self) >= 4:
            green_candle = self.data.Close[-2] > self.data.Open[-2] or self.data.Close[-2] > self.data.Close[-3]
            red_candle = self.data.Close[-2] < self.data.Open[-2] or self.data.Close[-2] < self.data.Close[-3]
            
            # Bullish FVG: low[1] > high[3]
            if green_candle and self.data.Low[-1] > self.data.High[-3] and self.data.Low[-1] < self.data.High[-2] and self.data.Low[-2] < self.data.High[-3]:
                self.bull_fvg_active = True
                self.bear_fvg_active = False
            
            # Bearish FVG: high[1] < low[3]
            if red_candle and self.data.High[-1] < self.data.Low[-3] and self.data.High[-1] > self.data.Low[-2] and self.data.High[-2] > self.data.Low[-3]:
                self.bear_fvg_active = True
                self.bull_fvg_active = False
        
        # Mitigate FVGs when price reaches them
        if self.bull_fvg_active and low < self.swing_low:
            self.bull_fvg_active = False
        
        if self.bear_fvg_active and high > self.swing_high:
            self.bear_fvg_active = False
        
        # Trading logic based on market structure
        if ema_val is not None and not np.isnan(ema_val):
            # Trend direction
            trend_bullish = close > ema_val
            trend_bearish = close < ema_val
            
            # Structure bias (based on swing progression)
            structure_bullish = False
            structure_bearish = False
            
            if self.swing_high is not None and self.prev_swing_high is not None:
                if self.swing_high > self.prev_swing_high:
                    structure_bullish = True
                else:
                    structure_bearish = True
            
            if self.swing_low is not None and self.prev_swing_low is not None:
                if self.swing_low > self.prev_swing_low:
                    structure_bullish = True
                else:
                    structure_bearish = True
            
            # BUY signals: Confluence of bullish bias
            buy_signal = (
                (trend_bullish or structure_bullish) and
                (self.bull_fvg_active or (self.swing_low is not None and close > self.swing_low)) and
                not self.position
            )
            
            # SELL signals: Confluence of bearish bias
            sell_signal = (
                (trend_bearish or structure_bearish) and
                (self.bear_fvg_active or (self.swing_high is not None and close < self.swing_high)) and
                self.position
            )
            
            # Execute trades
            if buy_signal:
                self.buy()
            elif sell_signal:
                self.sell()
            
            # Stop loss: Break of swing level in opposite direction
            if self.position:
                if self.position.is_long and self.swing_low is not None and low < self.swing_low:
                    self.position.close()
                elif self.position.is_short and self.swing_high is not None and high > self.swing_high:
                    self.position.close()


if __name__ == '__main__':
    # Example backtest setup
    bt = Backtest(
        pd.read_csv('data.csv', index_col=0, parse_dates=True),
        TvStrategy,
        cash=10000,
        commission=.002,
        exclusive_orders=True
    )
    
    results = bt.run()
    print(results)
    bt.plot()