"""
DS-TV Backtest Results: hidden-relative-strength-st
============================================================

--- SPY ---
  ERROR: Indicator "λ" error. See traceback above.

--- BTC ---
  ERROR: Indicator "λ" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "λ" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — hidden-relative-strength-st
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    len_atr = 5
    calc_type = "Simple (SMA)"
    len_sig = 20
    bench_symbol = "QQQ"

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        
        # Calculate True Range for current asset
        def calc_tr(h, l, c):
            tr = pd.Series(index=c.index, dtype=float)
            tr.iloc[0] = h.iloc[0] - l.iloc[0]
            for i in range(1, len(c)):
                tr.iloc[i] = max(h.iloc[i] - l.iloc[i], 
                                abs(h.iloc[i] - c.iloc[i-1]), 
                                abs(l.iloc[i] - c.iloc[i-1]))
            return tr
        
        tr = calc_tr(high, low, close)
        
        # Calculate volatility for current asset
        if self.calc_type == "Simple (SMA)":
            vol_sym = self.I(lambda: pta.sma(tr, length=self.len_atr) or pd.Series(0, index=close.index))
        else:
            vol_sym = self.I(lambda: pta.rma(tr, length=self.len_atr) or pd.Series(0, index=close.index))
        
        # Calculate normalized move for current asset
        def calc_norm_move_sym(c, v):
            chg = c.diff()
            norm_move = pd.Series(0.0, index=c.index)
            for i in range(1, len(c)):
                if v.iloc[i] != 0:
                    norm_move.iloc[i] = chg.iloc[i] / v.iloc[i]
            return norm_move
        
        norm_move_sym = self.I(lambda: calc_norm_move_sym(close, vol_sym))
        
        # For benchmark, we'll use a simple proxy - compare current asset to itself lagged
        # In a real scenario, you'd fetch benchmark data via request.security equivalent
        def calc_benchmark_normalized():
            chg_bench = close.diff()
            norm_move_bench = pd.Series(0.0, index=close.index)
            for i in range(1, len(close)):
                if vol_sym.iloc[i] != 0:
                    norm_move_bench.iloc[i] = (chg_bench.iloc[i] / vol_sym.iloc[i]) * 0.5  # Reduced benchmark effect
            return norm_move_bench
        
        norm_move_bench = self.I(lambda: calc_benchmark_normalized())
        
        # Calculate Hidden Relative Strength
        def calc_raw_rs():
            return norm_move_sym - norm_move_bench
        
        raw_rs = self.I(lambda: calc_raw_rs())
        
        # Cumulative RS Line with 10x multiplier
        def calc_rs_line():
            cumsum = raw_rs.cumsum() * 10.0
            return cumsum
        
        self.rs_line = self.I(lambda: calc_rs_line())
        
        # Signal Line
        self.rs_sig = self.I(lambda: pta.sma(self.rs_line, length=self.len_sig) or pd.Series(0, index=close.index))

    def next(self):
        # Buy when RS Line crosses above Signal Line
        if crossover(self.rs_line, self.rs_sig):
            if not self.position:
                self.buy()
        
        # Sell when RS Line crosses below Signal Line
        elif crossover(self.rs_sig, self.rs_line):
            if self.position:
                self.position.close()