"""
DS-TV Backtest Results: all-in-one-smc-pro
============================================================

--- SPY ---
  ERROR: Indicator "_pivot_hi…(5)" error. See traceback above.

--- BTC ---
  ERROR: Indicator "_pivot_hi…(5)" error. See traceback above.

--- QQQ ---
  ERROR: Indicator "_pivot_hi…(5)" error. See traceback above.

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script — all-in-one-smc-pro
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover


class TvStrategy(Strategy):
    swingLen = 5
    fvgSens = 0.08
    obLookback = 25
    liqThreshold = 3

    def init(self):
        close = pd.Series(self.data.Close)
        high = pd.Series(self.data.High)
        low = pd.Series(self.data.Low)
        open_ = pd.Series(self.data.Open)
        
        # Calculate ATR for FVG sensitivity
        self.atr = self.I(pta.atr, high, low, close, length=14)
        
        # Pivot points for swing detection
        self.ph = self.I(self._pivot_high, high, self.swingLen)
        self.pl = self.I(self._pivot_low, low, self.swingLen)
        
        # Track last confirmed swing points
        self.lastPH = np.nan
        self.lastPL = np.nan
        
        # Fair value gaps
        self.bullFVG = self.I(self._bull_fvg, high, low, close, open_, self.atr)
        self.bearFVG = self.I(self._bear_fvg, high, low, close, open_, self.atr)
        
        # Liquidity grabs
        self.liqGrabHigh = self.I(self._liq_grab_high, high, low, close, open_, self.liqThreshold)
        self.liqGrabLow = self.I(self._liq_grab_low, high, low, close, open_, self.liqThreshold)
        
        # Discount/Premium zones
        self.discount = self.I(self._discount, high, low, close)
        self.premium = self.I(self._premium, high, low, close)
        
        self.in_position = False

    def _pivot_high(self, high):
        result = pd.Series(np.nan, index=high.index)
        for i in range(self.swingLen, len(high) - self.swingLen):
            if high.iloc[i] == high.iloc[i-self.swingLen:i+self.swingLen+1].max():
                result.iloc[i] = high.iloc[i]
        return result

    def _pivot_low(self, low):
        result = pd.Series(np.nan, index=low.index)
        for i in range(self.swingLen, len(low) - self.swingLen):
            if low.iloc[i] == low.iloc[i-self.swingLen:i+self.swingLen+1].min():
                result.iloc[i] = low.iloc[i]
        return result

    def _bull_fvg(self, high, low, close, open_, atr):
        result = pd.Series(False, index=high.index)
        minGap = atr * self.fvgSens
        for i in range(2, len(high)):
            if not pd.isna(minGap.iloc[i]):
                if (low.iloc[i] > high.iloc[i-2] + minGap.iloc[i] and 
                    close.iloc[i-1] < open_.iloc[i-1]):
                    result.iloc[i] = True
        return result

    def _bear_fvg(self, high, low, close, open_, atr):
        result = pd.Series(False, index=high.index)
        minGap = atr * self.fvgSens
        for i in range(2, len(high)):
            if not pd.isna(minGap.iloc[i]):
                if (high.iloc[i] < low.iloc[i-2] - minGap.iloc[i] and 
                    close.iloc[i-1] > open_.iloc[i-1]):
                    result.iloc[i] = True
        return result

    def _liq_grab_high(self, high, low, close, open_, threshold):
        result = pd.Series(False, index=high.index)
        tolerance = 0.0001
        for i in range(threshold, len(high)):
            eq_high = True
            for j in range(1, threshold + 1):
                if abs(high.iloc[i] - high.iloc[i-j]) > tolerance:
                    eq_high = False
                    break
            if eq_high and close.iloc[i] < open_.iloc[i]:
                result.iloc[i] = True
        return result

    def _liq_grab_low(self, high, low, close, open_, threshold):
        result = pd.Series(False, index=high.index)
        tolerance = 0.0001
        for i in range(threshold, len(low)):
            eq_low = True
            for j in range(1, threshold + 1):
                if abs(low.iloc[i] - low.iloc[i-j]) > tolerance:
                    eq_low = False
                    break
            if eq_low and close.iloc[i] > open_.iloc[i]:
                result.iloc[i] = True
        return result

    def _discount(self, high, low, close):
        result = pd.Series(False, index=close.index)
        eq = (high + low + close) / 3
        result = close < eq * 0.992
        return result

    def _premium(self, high, low, close):
        result = pd.Series(False, index=close.index)
        eq = (high + low + close) / 3
        result = close > eq * 1.008
        return result

    def next(self):
        high = self.data.High[-1]
        low = self.data.Low[-1]
        close = self.data.Close[-1]
        open_ = self.data.Open[-1]
        
        # Update last swing points
        if not pd.isna(self.ph[-1]):
            self.lastPH = self.ph[-1]
        if not pd.isna(self.pl[-1]):
            self.lastPL = self.pl[-1]
        
        # Detect Break of Structure and CHOCH
        bullBOS = (not pd.isna(self.lastPH) and close > self.lastPH and 
                   self.data.Close[-2] <= self.lastPH)
        bearBOS = (not pd.isna(self.lastPL) and close < self.lastPL and 
                   self.data.Close[-2] >= self.lastPL)
        
        bullCHOCH = (not pd.isna(self.lastPL) and low < self.lastPL and 
                     close > self.lastPH)
        bearCHOCH = (not pd.isna(self.lastPH) and high > self.lastPH and 
                     close < self.lastPL)
        
        # Trading logic based on SMC signals
        if not self.position:
            # Buy signals
            if bullBOS or bullCHOCH or self.liqGrabLow[-1] or (self.bullFVG[-1] and self.discount[-1]):
                self.buy()
                self.in_position = True
            
            # Sell signals
            if bearBOS or bearCHOCH or self.liqGrabHigh[-1] or (self.bearFVG[-1] and self.premium[-1]):
                self.sell()
                self.in_position = True
        
        else:
            # Exit logic
            if self.position.is_long:
                if bearBOS or bearCHOCH or self.liqGrabHigh[-1] or self.premium[-1]:
                    self.position.close()
            elif self.position.is_short:
                if bullBOS or bullCHOCH or self.liqGrabLow[-1] or self.discount[-1]:
                    self.position.close()


if __name__ == '__main__':
    from backtesting.test import GOOG
    
    bt = Backtest(GOOG, TvStrategy, cash=10000, commission=.002)
    stats = bt.run()
    print(stats)
    bt.plot()