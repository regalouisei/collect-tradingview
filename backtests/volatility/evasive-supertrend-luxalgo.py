"""
DS-TV Backtest Results: evasive-supertrend-luxalgo
============================================================

--- SPY ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (502,); indicator "atr(H,L,10)" shape: , returned value: None)

--- BTC ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (732,); indicator "atr(H,L,10)" shape: , returned value: None)

--- QQQ ---
  ERROR: Indicators must return (optionally a tuple of) numpy.arrays of same length as `data` (data shape: (502,); indicator "atr(H,L,10)" shape: , returned value: None)

============================================================
Unoptimized run. No parameter tuning applied.

Source: TradingView Community Script â€” evasive-supertrend-luxalgo
Generated by DeepStack TradingView Pipeline
"""

import numpy as np
import pandas as pd
import pandas_ta as pta
from backtesting import Backtest, Strategy
from backtesting.lib import crossover

class TvStrategy(Strategy):
    # Default parameters from Pine Script
    param1 = 10  # ATR Length
    param2 = 3.0  # Base Multiplier
    param3 = 1.0  # Noise Threshold (xATR)
    param4 = 0.5  # Expansion Alpha (xATR)

    def init(self):
        close = pd.Series(self.data.Close)
        atr = self.I(pta.atr, high=self.data.High, low=self.data.Low, close=close, length=self.param1)
        self.upper_band = self.I(lambda: close + self.param2 * atr, close=close)
        self.lower_band = self.I(lambda: close - self.param2 * atr, close=close)
        self.prev_upper_band = self.I(lambda: self.upper_band[1], upper_band=self.upper_band)
        self.prev_lower_band = self.I(lambda: self.lower_band[1], lower_band=self.lower_band)
        self.trend = 1  # 1 for Bull, -1 for Bear
        self.noisy = False

    def next(self):
        close = self.data.Close[-1]
        atr = self.I(pta.atr, high=self.data.High, low=self.data.Low, close=self.data.Close, length=self.param1)
        current_upper_band = self.I(lambda: close + self.param2 * atr, close=close)
        current_lower_band = self.I(lambda: close - self.param2 * atr, close=close)

        # Noise Avoidance Condition
        noise_threshold = self.param3 * atr
        self.noisy = abs(close - self.prev_upper_band) < noise_threshold

        # Band Calculation with Adaptive Expansion
        if self.trend == 1:
            if self.noisy:
                self.upper_band[-1] = self.prev_upper_band - (self.param4 * atr)
            else:
                self.upper_band[-1] = max(self.lower_band[-1], self.prev_upper_band)
            if close < self.upper_band[-1]:
                self.trend = -1
                self.upper_band[-1] = self.lower_band[-1]
        else:
            if self.noisy:
                self.lower_band[-1] = self.prev_lower_band + (self.param4 * atr)
            else:
                self.lower_band[-1] = min(self.upper_band[-1], self.prev_lower_band)
            if close > self.lower_band[-1]:
                self.trend = 1
                self.lower_band[-1] = self.upper_band[-1]

        # Check for Trend Flip
        trend_changed = self.trend != self.trend[1]

        # Buy and Sell Logic
        if self.trend == 1 and close < self.upper_band[-1]:
            self.sell()
        elif self.trend == -1 and close > self.lower_band[-1]:
            self.buy()

        # Update previous bands
        self.prev_upper_band[-1] = self.upper_band[-1]
        self.prev_lower_band[-1] = self.lower_band[-1]